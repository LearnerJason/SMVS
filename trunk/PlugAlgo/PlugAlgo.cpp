#include "stdafx.h"
#include "resource.h"
#include "PlugAlgo_i.h"
#include "dllmain.h"
#include "PlugAlgo.h"
#include "cpp/HalconCpp.h"
#include <string>
#include "../ImageProcessLib/ImageProcessLib.h"
using namespace EoeShell;
using namespace ColorImage;

#ifndef   DLLEXPT
#define DLLEXPT __declspec (dllexport )
#endif

using namespace std;

STDAPI DllCanUnloadNow(void)
{
	return _AtlModule.DllCanUnloadNow();
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _AtlModule.DllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{
	HRESULT hr = _AtlModule.DllRegisterServer();
	return hr;
}

STDAPI DllUnregisterServer(void)
{
	HRESULT hr = _AtlModule.DllUnregisterServer();
	return hr;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
	HRESULT hr = E_FAIL;
	static const wchar_t szUserSwitch[] = L"user";

	if (pszCmdLine != NULL)
	{
		if (_wcsnicmp(pszCmdLine, szUserSwitch, _countof(szUserSwitch)) == 0)
		{
			ATL::AtlSetPerUserRegistration(true);
		}
	}

	if (bInstall)
	{	
		hr = DllRegisterServer();
		if (FAILED(hr))
		{
			DllUnregisterServer();
		}
	}
	else
	{
		hr = DllUnregisterServer();
	}

	return hr;
}

STDMETHODIMP CPlugAlgo::GetCurrentLocationXY(BSTR* bstrLocationXY)
{
	CString cstrXY;
	for (int i =0 ;i <m_modelAngleTmp.Num();i++ )
	{
		if (i!=0)
		{
			cstrXY+=_T("$");
		}
		CString cstrXYtmp;
		cstrXYtmp.Format(_T("%.2f,%.2f,%.4f"),m_vPos[0].m_x,m_vPos[0].m_y,m_modelAngleTmp[i].D());	
		cstrXY += cstrXYtmp;	
	}

	CComBSTR strLocationXY = cstrXY.AllocSysString();
	HRESULT hr = strLocationXY.CopyTo(bstrLocationXY);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;

}

// CanAlgo.cpp : CCanAlgo  Implementation
STDMETHODIMP CPlugAlgo::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* const arr[] = 
	{
		&IID_IPlugAlgo
	};

	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
//STDMETHODIMP CPlugAlgo::SetCurrentImage(LONG* pImg)
//{
//	Hobject* pObj = (Hobject*)pImg;
//	m_crtImg      = *pObj;
//	m_crtcolorImg = *pObj;
//
//	//HTuple Width,Height;
//	//get_image_size (m_crtImg, &Width, &Height);
//	//ResizeImage(m_crtImg,&m_crtImg,12000,Width,Height);
//	m_bDebugImg   = ImageProcessAlg.IsDebugImage(m_crtImg);	
//	m_bPilotImg   = ImageProcessAlg.IsPilotImage(m_crtImg);
//
//	HTuple Channels;
//	Hobject MedianCrtImage;
//	count_channels(m_crtImg,&Channels);
//
//	//黑白图片
//	if(Channels[0].I()==3)
//	{
//		rgb1_to_gray(m_crtImg,&m_crtImg);
//	}
//	else if(Channels[0].I()==1)
//	{
//		m_crtImg  = *pObj;
//	}
//	else
//	{
//		mean_n(m_crtImg, &m_crtImg);
//	}
//	if(m_bFileUpdated)
//	{
//		m_dictCrtPathModelID.clear();
//		m_dictCrtPathModelID = m_dictNewPathModelID;
//		m_dictCrtPathRgn.clear();
//		m_dictCrtPathRgn = m_dictNewPathRgn;
//		m_bFileUpdated=false;
//	}
//
//	return S_OK;
//}

STDMETHODIMP CPlugAlgo::SetCurrentImage(LONG* pImg)
{
	m_modelAngleTmp = HTuple();
	Hobject* pObj = (Hobject*)pImg;
	m_crtImgMult      = *pObj;// 原始图片，可能是多通道图片（彩色图片）

	m_bDebugImg   = ImageProcessAlg.IsDebugImage(m_crtImgMult);	
	m_bPilotImg   = ImageProcessAlg.IsPilotImage(m_crtImgMult);

	HTuple Channels;
	Hobject MedianCrtImage;
	count_channels(m_crtImgMult,&Channels);

	//黑白图片
	if(Channels[0].I()==3)
	{
		rgb1_to_gray(m_crtImgMult,&m_crtImg);
	}
	else if(Channels[0].I()==1)
	{
		m_crtImg  = *pObj;
	}
	else
	{
		mean_n(m_crtImgMult, &m_crtImg);
	}
	if(m_bFileUpdated)
	{
		m_dictCrtPathModelID.clear();
		m_dictCrtPathModelID = m_dictNewPathModelID;
		m_dictCrtPathRgn.clear();
		m_dictCrtPathRgn = m_dictNewPathRgn;
		m_bFileUpdated=false;
	}

	scale_image_max(m_crtImg, &m_ImageScaleMax);

	return S_OK;
}
STDMETHODIMP CPlugAlgo:: GetWhiteErrorRegion(BYTE rgnID,  LONG* pWhiteErrorRgn)
{
	Hobject* pObj = (Hobject*)pWhiteErrorRgn;
	*pObj = m_vWhiteErrorRgn[rgnID];
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetInterImgs(BYTE rgnID, LONG* pInterImgs)
{
	Hobject* pObj = (Hobject*)pInterImgs;
	*pObj = m_vInterImgs[rgnID];
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetRegion(BYTE rgnID, LONG* pRgn)
{
	Hobject* pObj = (Hobject*)pRgn;
	*pObj = m_vRgn[rgnID];
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetSelfLearningRegion(LONG* pRgn)
{
	//Hobject* pObj = (Hobject*)pRgn;
	//*pObj = m_regLearning;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetErrorRegion(BYTE rgnID, LONG* pErrorRgn)
{
	Hobject* pObj = (Hobject*)pErrorRgn;
	*pObj = m_vErrorRgn[rgnID];
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetInternalStats(BYTE rgnID, LONG nMaxLen, FLOAT* pStatsArray, LONG* nActualLen)
{
	if(m_dictSpecialData.find(rgnID) == m_dictSpecialData.end())
		return S_FALSE;

	std::vector<float> vStats = m_dictSpecialData[rgnID];
	int sz = (int)vStats.size();
	if(sz == 0)
		return S_FALSE;

	long count = min(sz, nMaxLen);
	*nActualLen = count;
	for(long i = 0; i < count; i++)
	{
		pStatsArray[i] = vStats[i];
	}
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ReloadExternalFile(BSTR* bstrPath)
{
	CString sFilePath = *bstrPath;
	string strFile    = CT2A(sFilePath);
	if(strFile.find(".shm") != string::npos)
	{
		if (!_access(strFile.c_str(),0))
		{
			HTuple newModelID;
			read_shape_model(strFile.c_str(), &newModelID);
			m_dictNewPathModelID[strFile] = newModelID;
		}
		else
		{
			if(m_isChineseLanguage)
			{
				MessageBox(NULL,_T("模板损坏或路径错误！"),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			}
			else
			{
				MessageBox(NULL,_T("Please check the validity of the model path."),_T("Reading model file failed!"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			}
			return S_FALSE;
		}
	}

	if(strFile.find(".reg") != string::npos)
	{
		if(!_access(strFile.c_str(),0))
		{
			Hobject retRgn;
			read_region(&retRgn,strFile.c_str());
			m_dictNewPathRgn[strFile] = retRgn;
		}
		else
		{
			if(m_isChineseLanguage)
			{
				MessageBox(NULL,_T("区域损坏或路径设置错误。"),_T("区域读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			}
			else
			{
				MessageBox(NULL,_T("Please check the validity of the region path."),_T("Reading region failed!"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			}
			return S_FALSE;
		}
	}
	m_bFileUpdated = true;

	return S_OK;
}
//
STDMETHODIMP CPlugAlgo::SetSelfLearningParam(DWORD sampleSz, BSTR* bstrParam)
{

	return S_OK;
}
STDMETHODIMP CPlugAlgo::SelectModelImage(LONG* pCrtImg, BYTE productID)
{

	return S_FALSE;
}
STDMETHODIMP CPlugAlgo::AddModelImage(LONG* pImg, BSTR* strFolder, BYTE productID)
{
	return S_FALSE;
}
STDMETHODIMP CPlugAlgo::DeleteModelImage(BYTE nIndex, BYTE productID)
{
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SaveResult(BSTR* strModelName,BYTE productID)
{

	return S_OK;
}
STDMETHODIMP CPlugAlgo::ResetSelfLearningRegion(BSTR* strRegionExtractPara)
{

	return S_OK;
}
STDMETHODIMP CPlugAlgo::GetSelfLearningResult(LONG*  multiModelImag, long* cMax, float* vImgScore, BYTE productID)
{

	return S_OK;
}

STDMETHODIMP CPlugAlgo::ResetSelfLearningProcedure(void)
{
	// TODO: 在此添加实现代码

	return S_OK;
}

STDMETHODIMP CPlugAlgo::CenterLocationAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pMinScore)
{
	/*利用边缘轮廓来定位圆*/
	int id = (int)rgnId->fltVal;
	double Radius = (double)pRadius->fltVal;
	int MinScore = (int)pMinScore->fltVal;
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	Hlong Width, Height;
	HTuple Class, Area1, Row3, Column3;
	Hobject  ModelImages1, ModelRegions1,RegionDilation1,ConnectedRegions,RegionFillUp,RegionErosion,SelectedRegions,RegionUnion;
	Hobject  Ellipse, ImageReduced,Circle;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		Hobject Image = m_crtImg;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		if (Radius<10)
		{
			gen_circle (&Circle,  Height/2.0, Width/2.0, Radius);
			m_vPos[0].m_x = (float)(m_imgWidth/2.0);
			m_vPos[0].m_y = (float)(m_imgHeight/2.0);
			m_vRgn[id] = Circle;
			return S_OK;
		}
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/2.2, Height/1.6);   //默认图片的大小有要求

		double Pt_X, Pt_Y;
		BOOL Result = H_LocateCircleUseProfile(Image, Ellipse, &Circle, Radius, MinScore,  &Pt_X, &Pt_Y);
		m_vPos[0].m_x = (float)Pt_X;
		m_vPos[0].m_y = (float)Pt_Y;
		m_vRgn[id] = Circle;

		m_OutCircleRow=(float)Pt_Y;
		m_OutCircleCol=(float)Pt_X;

		if (!Result)
		{
			gen_circle(&Circle, Height/2.0, Width/2.0, Radius);
			m_vPos[0].m_x = 0.0;
			m_vPos[0].m_y = 0.0;
			m_vRgn[id] = Circle;
			return S_FALSE;
		}
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("621$\
					 381;B$\
					 374;LP;4;2000;1;220$\
					 390;LP;1;255;1;40");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ImageCenterLocationAlgo(VARIANT* rgnId )
{
	int id = (int)rgnId->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	HTuple Width,Height;
	Hobject Circle;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		Hobject Image = m_crtImg;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width[0].L();
		m_imgHeight = (long)Height[0].L();
		gen_circle (&Circle,  m_imgHeight/2.0, m_imgWidth/2.0, 2);
		m_vPos[0].m_x = (float)(m_imgWidth/2.0);
		m_vPos[0].m_y = (float)(m_imgHeight/2.0);
		m_vRgn[id] = Circle;
		return S_OK;

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ImageCenterLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("753$\
					 381;B");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ModelCreate(double Radius, HTuple * ModelID1)
{
	//产生一个标准圆创建一个形状模板
	if (Radius <= 0) 
	{
		return S_FALSE;
	}
	else
	{
		Hobject ContCircle, EmptyImage, SyntheticModelImage;
		HTuple  SizeSynthImage = 2* Radius + 10;

		gen_circle_contour_xld(&ContCircle, SizeSynthImage/2, SizeSynthImage/2, Radius, 0, 6.28318, "positive", 1);
		gen_image_const(&EmptyImage, "byte", SizeSynthImage, SizeSynthImage);
		paint_xld(ContCircle, EmptyImage, &SyntheticModelImage, 128);
		create_scaled_shape_model(SyntheticModelImage, "auto", 0, 0, 0, 0.95, 1.05, "auto","auto", "use_polarity", 40, "auto", ModelID1);
		return S_OK;
	}
}
STDMETHODIMP CPlugAlgo::CenterLocationAlgo1(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pMinScore)
{
	/*利用形状模板来定位圆*/
	int id = (int)rgnId->fltVal;
	double Radius = (double)pRadius->fltVal;
	float MinScore = (float)pMinScore->fltVal;
	Hobject newRgn;
	m_vRgn[id] = newRgn;

	double Row, Column, Radius1;
	Hlong Width, Height;
	HTuple CenterRow, CenterColumn, Angle, Scale, Score, CenterRadius, MovementOfObject, MoveAndScaleOfObject;
	Hobject  ContCircle, EmptyImage, SyntheticModelImage;
	Hobject  ShapeModelImage, ShapeModelRegion, ShapeModel, SearchImage;
	Hobject  Ellipse, ImageReduced, ModelAtNewPosition, Region, Circle1;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		//
		Hobject Image = m_ImageScaleMax;
		//scale_image_max(Image,&Image);

		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/5.0, Height/5.0);   //默认图片的大小有要求
		reduce_domain (Image, Ellipse, &ImageReduced);
		if(m_isFirst)
		{
			ModelCreate (Radius, &m_modelId);
			m_isFirst = false;
		}
		if(m_oldRadius != Radius)
		{
			clear_shape_model(m_modelId);
			ModelCreate (Radius, &m_modelId);
			m_oldRadius = Radius;
		}
		get_shape_model_contours (&ShapeModel, m_modelId, 1);
		find_scaled_shape_model (ImageReduced, m_modelId, 0, 0, 0.95, 1.05, MinScore, 1, 0.5, "least_squares", (HTuple(5).Append(-2)), 0.7, &CenterRow, &CenterColumn, &Angle, &Scale, &Score);
		if (0 != ((Score.Num())>0))
		{
			vector_angle_to_rigid(0, 0, 0, CenterRow[0].D(), CenterColumn[0].D(), Angle[0].D(), &MovementOfObject);
			hom_mat2d_scale(MovementOfObject, Scale[0].D(), Scale[0].D(),CenterRow[0].D(), CenterColumn[0].D(), &MoveAndScaleOfObject);
			affine_trans_contour_xld(ShapeModel, &ModelAtNewPosition, MoveAndScaleOfObject);
			gen_region_contour_xld(ModelAtNewPosition, &Region, "filled");
			smallest_circle(Region, &Row, &Column, &Radius1);
			Hobject Circle, RegionDifference;
			gen_circle(&Circle, Row, Column, Radius1);
			gen_circle(&Circle1, Row, Column, Radius);
			m_vPos[0].m_y = (float)Row;
			m_vPos[0].m_x = (float)Column;
			if(Circle.Id() != H_EMPTY_REGION) 
			{
				if(Radius1 >= Radius)
				{
					if(Radius1-Radius < 1)
					{
						gen_circle(&Circle, Row, Column, Radius1+1);
					}
					else
					{
						gen_circle(&Circle, Row, Column, Radius1);
					}
					difference (Circle, Circle1, &RegionDifference);
				}
				else
				{
					if(Radius - Radius1 < 1)
					{
						gen_circle(&Circle, Row, Column, Radius1-1);
					}
					else
					{
						gen_circle(&Circle, Row, Column, Radius1);
					}
					difference (Circle1, Circle, &RegionDifference);
				}
				m_vRgn[id] = RegionDifference;
			}
		}
		else
		{
			gen_circle(&Circle1, Height/2.0, Width/2.0, Radius);
			m_vPos[0].m_x = 0.0;
			m_vPos[0].m_y = 0.0;
			m_vRgn[id] = Circle1;
			return S_FALSE;
		}
#ifdef NDEBUG
	}

	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("372$\
					 381;B$\
					 374;LP;10;2000;1;192$\
					 377;FP;0.5;1.0;0.05;0.85");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CenterLocationAlgoHS(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pThresholdLow,VARIANT* pOutlierRemoverSize)
{
	/*利用边缘轮廓来定位圆*/
	int id = (int)rgnId->fltVal;
	double Radius = (double)pRadius->fltVal;
	int ThresholdLow = (int)pThresholdLow->fltVal;
	int OutlierRemoverSize = (int)pOutlierRemoverSize->fltVal;
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	Hlong Width, Height;
	HTuple hv_Class, CenterRadius, hv_Row3, hv_Column3;
	Hobject threshed,RegionFillUp,RegionUnion,RegionOpening;
	Hobject  Ellipse, ImageReduced,Circle;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		Hobject Image = m_crtImg;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/2.2, Height/1.6);   //默认图片的大小有要求
		reduce_domain (Image, Ellipse, &ImageReduced);
		//threshold(ImageReduced, &threshed,ThresholdLow, 255);

		threshold(ImageReduced, &threshed,0, ThresholdLow);
		fill_up(threshed, &RegionFillUp);
		union1(RegionFillUp, &RegionUnion);
		opening_circle(RegionUnion, &RegionOpening,OutlierRemoverSize+0.5);
		get_obj_class(RegionOpening, &hv_Class);
		if (0 != (hv_Class==HTuple("region")))
		{	
			smallest_circle(RegionOpening, &hv_Row3, &hv_Column3, &CenterRadius);
			m_locationRadius=CenterRadius;
			if((CenterRadius<Radius*1.4)&(CenterRadius>Radius*0.6))
			{
				gen_circle(&Circle, hv_Row3, hv_Column3, CenterRadius);
				m_vPos[0].m_y = (float)hv_Row3[0].D();
				m_vPos[0].m_x = (float)hv_Column3[0].D();
				m_vRgn[id] = Circle;

				m_OutCircleRow=m_vPos[0].m_y;
				m_OutCircleCol=m_vPos[0].m_x;

				m_InnerCircleRow=m_vPos[0].m_y;
				m_InnerCircleCol=m_vPos[0].m_x;

			}
			else
			{
				gen_circle(&Circle, Height/2.0, Width/2.0, Radius);
				m_vPos[0].m_x = 0.0;
				m_vPos[0].m_y = 0.0;
				m_vRgn[id] = Circle;
				return S_FALSE;
			}
		}
		else
		{
			gen_circle(&Circle, Height/2.0, Width/2.0, Radius);
			m_vPos[0].m_x = 0.0;
			m_vPos[0].m_y = 0.0;
			m_vRgn[id] = Circle;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterLocationAlgoHSHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("639$\
					 381;B$\
					 374;LP;10;2000;1;200$\
					 1141;LP;1;255;1;50$\
					 641;LP;1;800;1;70");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CenterLocationAlgoM(VARIANT* rgnId, VARIANT* pRowStart,VARIANT* pColStart,VARIANT* pRegWidth,VARIANT* pRegHeight, VARIANT* pThresholdUp)
{
	/*胶塞测量工位的中心定位，获取胶塞的列坐标*/
	int id = (int)rgnId->fltVal;

	int RowStart=(int)pRowStart->fltVal;
	int ColStart=(int)pColStart->fltVal;
	int RegWidth = (int)pRegWidth->fltVal; 
	int RegHeight=(int)pRegHeight->fltVal;

	int ThresholdUp = (int)pThresholdUp->fltVal;
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		Hobject Image = m_crtImg;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		//

		if (RowStart>m_imgHeight/2)
		{
			RowStart=10;
		}
		if (ColStart>m_imgWidth/2)
		{
			ColStart=10;
		}
		if ((RegWidth+ColStart)>m_imgWidth-1)
		{
			RegWidth=10;
		}
		if ((RegHeight+RowStart)>m_imgHeight-1)
		{
			RegHeight=10;
		}

		Hobject SearchRgn,ImageReduced;
		gen_rectangle2(&SearchRgn,RowStart+RegHeight/2,ColStart+RegWidth/2,0,RegWidth/2,RegHeight/2);
		reduce_domain (Image, SearchRgn, &ImageReduced);

		Hobject SelectedRegions,threshed,RegionFillUp;
		threshold(ImageReduced, &threshed,0, ThresholdUp);
		fill_up(threshed, &RegionFillUp);
		select_shape_std(RegionFillUp, &SelectedRegions, "max_area", 70);

		Hobject Circle;
		HTuple CenterArea, CenterRow, CenterColumn;
		area_center(SelectedRegions, &CenterArea, &CenterRow, &CenterColumn);
		if ((CenterArea!=0)&& (CenterArea.Num()!=0))
		{	
			gen_circle(&Circle, CenterRow,CenterColumn,10);

			m_vPos[0].m_y = (float)(m_imgHeight/2.0);
			m_vPos[0].m_x = (float)CenterColumn[0].D();

		}
		else
		{
			//gen_circle(&Circle, Height/2.0, Width/2.0, 100);
			gen_empty_region(&Circle);
			m_vPos[0].m_x = (float)(m_imgWidth/2.0);
			m_vPos[0].m_y = (float)(m_imgHeight/2.0);

		}

		if (m_bDebugImg)
		{
			concat_obj(m_vRgn[id],SearchRgn,&m_vRgn[id]);
			concat_obj(m_vRgn[id],SelectedRegions,&m_vRgn[id]);
			concat_obj(m_vRgn[id],Circle,&m_vRgn[id]);
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterLocationAlgoMHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1140$\
					 381;B$\
					 939;LP;20;500;1;100$\
					 938;LP;34;600;1;100$\
					 940;LP;1;1300;1;1000$\
					 941;LP;1;1000;1;600$\
					 1141;LP;1;255;1;50");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::MatchingParaAlgo(VARIANT* rgnId, VARIANT* pGreediness, VARIANT* pRingOrOCR, BSTR* bstrShm1File, BSTR* bstrShm2File, VARIANT* pMatchingResult)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn      = m_vRgn[rId];
	float greediness = (float)pGreediness->fltVal;
	int ringOrOCR    = (int)pRingOrOCR->fltVal;
	CComVariant retValue;
#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			CString sModelPath1  = *bstrShm1File;
			string strModelPath1 = CT2A(sModelPath1);
			if(!_access(strModelPath1.c_str(),0))
			{
				HTuple modelID;
				read_shape_model(strModelPath1.c_str(), &modelID);
				m_dictCrtPathModelID[strModelPath1] = modelID;
				m_dictNewPathModelID[strModelPath1] = modelID;
			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}

			if(ringOrOCR==2)
			{
				CString sModelPath2   = *bstrShm2File;
				string strModelPath2  = CT2A(sModelPath2);
				if (!_access(strModelPath2.c_str(),0))
				{
					HTuple modelID;
					read_shape_model(strModelPath2.c_str(), &modelID);
					m_dictCrtPathModelID[strModelPath2] = modelID;
					m_dictNewPathModelID[strModelPath2] = modelID;
				}
				else
				{
					if(m_isChineseLanguage)
					{
						MessageBox(NULL,_T("请检查模板2初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					else
					{
						MessageBox(NULL,_T("Please check whether the second initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pMatchingResult);
					m_modelMatchingPARA[0]=0.0;
					m_modelMatchingPARA[1]=0.0;
					m_modelMatchingPARA[2]=0.0;
					m_modelMatchingPARA[3]=0.0;
					m_modelMatchingPARA[4]=0.0;
					m_modelMatchingPARA[5]=0.0;
					m_modelMatchingPARA[6]=0.0;
					return S_FALSE;
				}
			}
		}
		//
		Hobject ImageReduced,Circle;
		HTuple Row_M,Column_M,Angle_M,Score_M,Model_M;
		m_modelMatchingPARA[0] = m_imageRadius;

		if(rgn.Id() == H_EMPTY_REGION)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pMatchingResult);
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			return S_FALSE;
		}
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		bool b_isOK = true;
		Hobject Image=m_crtImg;
		//

		HTuple ClassRegion;
		get_obj_class(rgn,&ClassRegion);
		if(ClassRegion=="region")
		{
			Circle=rgn;
		}
		else
		{
			gen_circle (&Circle, m_imgHeight/2.0, m_imgWidth/2.0,m_ringPara[rId].m_Radius);   //默认图片的大小有要求
		}
		//

		reduce_domain(Image, Circle, &ImageReduced);

		CString sModelPath1  = *bstrShm1File;
		string strModelPath1 = CT2A(sModelPath1);
		if(m_dictCrtPathModelID.find(strModelPath1) == m_dictCrtPathModelID.end())
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pMatchingResult);
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			return S_FALSE;
		}
		HTuple modelID = m_dictCrtPathModelID[strModelPath1];
		HTuple dataLength1;
		tuple_length (modelID, &dataLength1);

		if(ringOrOCR == 1)
		{
			if(dataLength1 < 1)
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			//匹配计算时，搜索范围与建模板的角度范围一致！
			HTuple NumLevels,AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, ScaleStep, Metric, MinContrast,Scale1;//Scale1,
			get_shape_model_params (modelID, &NumLevels, &AngleStart, &AngleExtent, &AngleStep, &ScaleMin, &ScaleMax, &ScaleStep, &Metric, &MinContrast);
			if (AngleExtent<3.14)
			{
				find_scaled_shape_model (ImageReduced,modelID, HTuple(-10).Rad(), HTuple(20).Rad(), 0.9, 1.1, 0.5, 1, 0.5, "least_squares", 0, greediness, &Row_M, &Column_M, &Angle_M,&Scale1,&Score_M);
				//find_shape_model(ImageReduced,modelID, HTuple(-10).Rad(), HTuple(20).Rad(), 0.5, 1,0.5, "least_squares",0,greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			}
			else
			{
				find_shape_model(ImageReduced,modelID, HTuple(0).Rad(), HTuple(360).Rad(), 0.5, 1,0.5, "least_squares",0,greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			}			
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[1]=Row_M;
				m_modelMatchingPARA[2]=Column_M;
				m_modelMatchingPARA[3]=Angle_M;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				retValue = Score_M[0].D();
			}
			else
			{
				b_isOK = false;
			}
		}
		else if(ringOrOCR==2)
		{
			CString sModelPath2  = *bstrShm2File;
			string strModelPath2 = CT2A(sModelPath2);
			if(m_dictCrtPathModelID.find(strModelPath2) == m_dictCrtPathModelID.end())
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			HTuple modelID2 = m_dictCrtPathModelID[strModelPath2];
			HTuple dataLength2;

			tuple_length (modelID2, &dataLength2);
			if((dataLength1 < 1)||(dataLength2 < 1))
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确,是否存在拉环与图案两个模板."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not.Tab model and OCR model whether or not exist."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			find_shape_model(ImageReduced,modelID, HTuple(0).Rad(), HTuple(360).Rad(), 0.5, 1,0.5, "least_squares",0,greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[1]=Row_M;
				m_modelMatchingPARA[2]=Column_M;
				m_modelMatchingPARA[3]=Angle_M;
				retValue =Score_M[0].D();
			}
			else
				b_isOK=false;

			find_shape_model(ImageReduced,modelID2, HTuple(0).Rad(), HTuple(360).Rad(), 0.5, 1,0.5, "least_squares",(HTuple(4).Append(-2)),greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[4]=Row_M;
				m_modelMatchingPARA[5]=Column_M;
				m_modelMatchingPARA[6]=Angle_M;
				retValue =Score_M[0].D();
			}
			else
				b_isOK=false;
		}
		if(!b_isOK)
		{
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			retValue = 0.0;	
			retValue.Detach(pMatchingResult);
			m_vErrorRgn[rId] = Circle;
			return S_FALSE;
		}
		else
		{
			retValue.Detach(pMatchingResult);
		}
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_modelMatchingPARA[0]=0.0;
		m_modelMatchingPARA[1]=0.0;
		m_modelMatchingPARA[2]=0.0;
		m_modelMatchingPARA[3]=0.0;
		m_modelMatchingPARA[4]=0.0;
		m_modelMatchingPARA[5]=0.0;
		m_modelMatchingPARA[6]=0.0;
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pMatchingResult);
		return S_FALSE;
	}
#endif

	return S_OK;
}
STDMETHODIMP CPlugAlgo::MatchingParaAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("439$\
					 440;R;FP;0.0;1.0;0.01$\
					 167;B$\
					 322;FP;0.2;1.0;0.05;0.85$\
					 441;LP;1;2;1;1$\
					 535;SPM$\
					 629;SPM");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::MatchingParaMinScoreAlgo(VARIANT* rgnId, VARIANT* pMinScore, VARIANT* pNumLevels, VARIANT* pGreediness, VARIANT* pRingOrOCR, BSTR* bstrShm1File, BSTR* bstrShm2File, VARIANT* pMatchingResult)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn      = m_vRgn[rId];
	float greediness = (float)pGreediness->fltVal;
	int ringOrOCR    = (int)pRingOrOCR->fltVal;
	double MinScore=(double)pMinScore->fltVal;
	int NumLevels=(int)pNumLevels->fltVal;
	CComVariant retValue;
#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			CString sModelPath1  = *bstrShm1File;
			string strModelPath1 = CT2A(sModelPath1);
			if(!_access(strModelPath1.c_str(),0))
			{
				HTuple modelID;
				read_shape_model(strModelPath1.c_str(), &modelID);
				m_dictCrtPathModelID[strModelPath1] = modelID;
				m_dictNewPathModelID[strModelPath1] = modelID;
			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}

			if(ringOrOCR==2)
			{
				CString sModelPath2   = *bstrShm2File;
				string strModelPath2  = CT2A(sModelPath2);
				if (!_access(strModelPath2.c_str(),0))
				{
					HTuple modelID;
					read_shape_model(strModelPath2.c_str(), &modelID);
					m_dictCrtPathModelID[strModelPath2] = modelID;
					m_dictNewPathModelID[strModelPath2] = modelID;
				}
				else
				{
					if(m_isChineseLanguage)
					{
						MessageBox(NULL,_T("请检查模板2初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					else
					{
						MessageBox(NULL,_T("Please check whether the second initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pMatchingResult);
					m_modelMatchingPARA[0]=0.0;
					m_modelMatchingPARA[1]=0.0;
					m_modelMatchingPARA[2]=0.0;
					m_modelMatchingPARA[3]=0.0;
					m_modelMatchingPARA[4]=0.0;
					m_modelMatchingPARA[5]=0.0;
					m_modelMatchingPARA[6]=0.0;
					return S_FALSE;
				}
			}
		}
		//
		Hobject ImageReduced,Circle;
		HTuple Row_M,Column_M,Angle_M,Score_M,Model_M;
		m_modelMatchingPARA[0] = m_imageRadius;

		if(rgn.Id() == H_EMPTY_REGION)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pMatchingResult);
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			return S_FALSE;
		}
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		bool b_isOK = true;
		Hobject Image=m_crtImg;
		//
		Hobject ImageEnhance,EnhanceRegion,ImageReduced1,DiffOfGauss,ImageSub,ImageConverted;
		gen_circle (&EnhanceRegion, m_imgHeight/2.0, m_imgWidth/2.0, m_imgHeight/2.1);
		reduce_domain (Image, EnhanceRegion, &ImageReduced1);
		diff_of_gauss (ImageReduced1, &DiffOfGauss, 1.0, 20);
		convert_image_type (DiffOfGauss, &ImageConverted, "byte");
		sub_image (Image, ImageConverted, &ImageSub, 1, 0);
		//
		Circle=rgn;
		reduce_domain(ImageSub, Circle, &ImageReduced);
		Hobject ImageReducedOcr;
		reduce_domain(Image, Circle, &ImageReducedOcr);
		CString sModelPath1  = *bstrShm1File;
		string strModelPath1 = CT2A(sModelPath1);
		if(m_dictCrtPathModelID.find(strModelPath1) == m_dictCrtPathModelID.end())
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pMatchingResult);
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			return S_FALSE;
		}
		HTuple modelID = m_dictCrtPathModelID[strModelPath1];
		HTuple dataLength1;
		tuple_length (modelID, &dataLength1);

		if(ringOrOCR == 1)
		{
			if(dataLength1 < 1)
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			//
			find_shape_model(ImageReduced,modelID, HTuple(0).Rad(), HTuple(360).Rad(), MinScore, 1,0.5, "least_squares",NumLevels,greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[1]=Row_M;
				m_modelMatchingPARA[2]=Column_M;
				m_modelMatchingPARA[3]=Angle_M;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				retValue = Score_M[0].D();
			}
			else
			{
				b_isOK = false;
			}
		}
		else if(ringOrOCR==2)
		{
			CString sModelPath2  = *bstrShm2File;
			string strModelPath2 = CT2A(sModelPath2);
			if(m_dictCrtPathModelID.find(strModelPath2) == m_dictCrtPathModelID.end())
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			HTuple modelID2 = m_dictCrtPathModelID[strModelPath2];
			HTuple dataLength2;

			tuple_length (modelID2, &dataLength2);
			if((dataLength1 < 1)||(dataLength2 < 1))
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("请检查模板初始化路径是否正确,是否存在拉环与图案两个模板."),_T("模板读取错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Please check whether the initial model path is correct or not.Tab model and OCR model whether or not exist."),_T("Reading model goes wrong:"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pMatchingResult);
				m_modelMatchingPARA[0]=0.0;
				m_modelMatchingPARA[1]=0.0;
				m_modelMatchingPARA[2]=0.0;
				m_modelMatchingPARA[3]=0.0;
				m_modelMatchingPARA[4]=0.0;
				m_modelMatchingPARA[5]=0.0;
				m_modelMatchingPARA[6]=0.0;
				return S_FALSE;
			}
			find_shape_model(ImageReduced,modelID, HTuple(0).Rad(), HTuple(360).Rad(),MinScore , 1,0.5, "least_squares",NumLevels,greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[1]=Row_M;
				m_modelMatchingPARA[2]=Column_M;
				m_modelMatchingPARA[3]=Angle_M;
				retValue =Score_M[0].D();
			}
			else
				b_isOK=false;
			//判断搜索区域形状
			Hobject SearchRegionFillUp,SearchNew,CenterRegion;
			HTuple RowCenter,ColCenter,AreaCenter;
			fill_up(Circle,&SearchRegionFillUp);
			difference(SearchRegionFillUp,Circle,&CenterRegion);
			area_center(CenterRegion,&AreaCenter,&RowCenter,&ColCenter);
			if (AreaCenter>100)
			{
				float fCenterX = 0.0;
				float fCenterY = 0.0;
				fCenterX = m_vPos[0].m_x;
				fCenterY = m_vPos[0].m_y;
				Hobject SearchNew;
				gen_circle (&SearchNew, fCenterY, fCenterX,40.0);
				reduce_domain(Image, SearchNew, &ImageReducedOcr);
			} 
			find_shape_model(ImageReducedOcr,modelID2, HTuple(0).Rad(), HTuple(360).Rad(), 0.4, 1,0.5, "least_squares",(HTuple(4).Append(-2)),greediness, &Row_M, &Column_M, &Angle_M, &Score_M);
			if (0 != (Score_M>0.05))
			{
				m_modelMatchingPARA[4]=Row_M;
				m_modelMatchingPARA[5]=Column_M;
				m_modelMatchingPARA[6]=Angle_M;
				retValue =Score_M[0].D();
			}
			else
				b_isOK=false;
		}
		if(!b_isOK)
		{
			m_modelMatchingPARA[0]=0.0;
			m_modelMatchingPARA[1]=0.0;
			m_modelMatchingPARA[2]=0.0;
			m_modelMatchingPARA[3]=0.0;
			m_modelMatchingPARA[4]=0.0;
			m_modelMatchingPARA[5]=0.0;
			m_modelMatchingPARA[6]=0.0;
			retValue = 0.0;	
			retValue.Detach(pMatchingResult);
			m_vErrorRgn[rId] = Circle;
			return S_FALSE;
		}
		else
		{
			retValue.Detach(pMatchingResult);
		}
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_modelMatchingPARA[0]=0.0;
		m_modelMatchingPARA[1]=0.0;
		m_modelMatchingPARA[2]=0.0;
		m_modelMatchingPARA[3]=0.0;
		m_modelMatchingPARA[4]=0.0;
		m_modelMatchingPARA[5]=0.0;
		m_modelMatchingPARA[6]=0.0;
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pMatchingResult);
		return S_FALSE;
	}
#endif

	return S_OK;
}
STDMETHODIMP CPlugAlgo::MatchingParaMinScoreAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("439$\
					 440;R;FP;0.0;1.0;0.01$\
					 167;B$\
					 654;FP;0.1;1.0;0.05;0.5$\
					 670;LP;0;4;1;3$\
					 322;FP;0.2;1.0;0.05;0.85$\
					 441;LP;1;2;1;1$\
					 535;SPM$\
					 629;SPM");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CircleRegionLocationAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pRoiWidth)
{
	//得到环形区域
	int id = (int)rgnId->fltVal;
	float RoiWidth = (float)pRoiWidth->fltVal;
	m_ringPara[id].m_Radius = (float)pRadius->fltVal;
	m_ringPara[id].m_RoiWidth = (float)pRoiWidth->fltVal;
	float Radius =(float)pRadius->fltVal;
	float m_RadiusExt = Radius - RoiWidth;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, Radius);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, Radius+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, Radius);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, Radius);
			}
		}
		m_vRgn[id] = RegionDetect ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CircleRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("307$\
					 167;B$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CircleRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pRadius, VARIANT* pRoiWidth)
{
	//依据胶塞的中心的定位结果，得到匹配搜索区域，专门用于模板匹配
	int id = (int)rgnId->fltVal;
	float RoiWidth = (float)pRoiWidth->fltVal;
	m_ringPara[id].m_Radius = (float)pRadius->fltVal;
	m_ringPara[id].m_RoiWidth = (float)pRoiWidth->fltVal;
	float Radius =(float)pRadius->fltVal;
	float m_RadiusExt = Radius - RoiWidth;

	int MoveSize = (int)pMoveSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y+MoveSize;

	if (fCenterY>=m_imgHeight-1)
	{
		fCenterY = m_vPos[0].m_y;
	}

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, Radius);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, Radius+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, Radius);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, Radius);
			}
		}
		m_vRgn[id] = RegionDetect ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CircleRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1145$\
					 167;B$\
					 1124;LP;-150;150;1;100$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::DetectRegionLocationAlgo(VARIANT* rgnId,VARIANT* pErosionSize, VARIANT* pRingOrOCR, BSTR* bstrRgnFile, BSTR* bstrExtractRgnFile)
{
	int id = (int)rgnId->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	int RingOrOCR     = (int)pRingOrOCR->fltVal;
	//
	Hobject newRgn;
	HTuple tmp;
	tmp[0]=0.0;tmp[1]=0.0;tmp[2]=0.0;tmp[3]=0.0;
	tmp[4]=0.0;tmp[5]=0.0;tmp[6]=0.0;
	m_vRgnReadData[id] = tmp;
	//
	if(m_bDebugImg)
	{
		m_dictSpecialData[id].clear();
	}
	if(RingOrOCR < 1 || RingOrOCR > 2)
	{
		m_vRgn[id].Reset();
		return S_FALSE;
	}

	CString sRgnPath1  = *bstrRgnFile;
	string strRgnPath1 = CT2A(sRgnPath1);
	CString sRgnPath2  = *bstrExtractRgnFile;
	string strRgnPath2 = CT2A(sRgnPath2);
#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			if(!_access(strRgnPath1.c_str(),0))
			{
				Hobject retRgn;
				read_region(&retRgn,strRgnPath1.c_str());
				m_dictCrtPathRgn[strRgnPath1] = retRgn;
				m_dictNewPathRgn[strRgnPath1] = retRgn;
			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("初始化参数,检测区域路径设置错误。"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );	
				}
				else
				{
					MessageBox(NULL, _T("Initialization parameter（detect region path）setting is wrong!"),_T("Initial configuration is wrong："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				m_vRgn[id].Reset();
				return S_FALSE;
			}
			HTuple tmp;
			tmp[0]=0.0;tmp[1]=0.0;tmp[2]=0.0;tmp[3]=0.0;
			tmp[4]=0.0;tmp[5]=0.0;tmp[6]=0.0;
			m_vRgnReadData[id] = tmp;

			if(RingOrOCR==2)
			{
				if(!_access(strRgnPath2.c_str(),0))
				{
					Hobject retRgn;
					read_region(&retRgn,strRgnPath2.c_str());
					m_dictCrtPathRgn[strRgnPath2] = retRgn;
					m_dictNewPathRgn[strRgnPath2] = retRgn;
				}
				else
				{
					if(m_isChineseLanguage)
					{
						MessageBox(NULL,_T("初始化参数,剔除区域路径设置错误。"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					else
					{
						MessageBox(NULL, _T("Initialization parameter（deducts region path）setting is wrong!"),_T("Initial configuration is wrong："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
					}
					m_vRgn[id].Reset();
					return S_FALSE;
				}
				HTuple tmp;
				tmp[0]=0.0;tmp[1]=0.0;tmp[2]=0.0;tmp[3]=0.0;
				tmp[4]=0.0;tmp[5]=0.0;tmp[6]=0.0;
				m_vRgnReadData[id] = tmp;
			}
		}

		m_vRgn[id] = newRgn;
		//
		HTuple dataLength;
		tuple_length (m_modelMatchingPARA, &dataLength);
		if(dataLength < 3)
		{
			if(m_isFirstMatchingErrorMessage)
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("调用函数('DetectRegionLocationAlgo')前需先调用匹配函数('MatchingParaAlgo')."),_T("函数调用次序错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				else
				{
					MessageBox(NULL,_T("Call matching function('MatchingParaAlgo')before calling location function('DetectRegionLocationAlgo')."), _T("Calling function order is wrong!"), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				m_isFirstMatchingErrorMessage=false;
			}
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		if(m_modelMatchingPARA[0].D() < 1.0)
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		Hobject RegionDetect;

		HTuple modelPARAID = m_vRgnReadData[id];
		if(RingOrOCR==1)
		{	
			if(m_dictCrtPathRgn.find(strRgnPath1) == m_dictCrtPathRgn.end())
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}
			Hobject roiRgn = m_dictCrtPathRgn[strRgnPath1];
			//
			//HTuple modelPARAIDLength;
			//tuple_length(modelPARAID,&modelPARAIDLength);
			//if(modelPARAIDLength[0].I()<6)
			//{
			//	MessageBox(NULL,_T("初始化参数（模板路径与检测区域路径）或区域编号设置错误"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			//	m_vRgn[id] = newRgn ;
			//	return S_FALSE;
			//}
			m_modelPARA = modelPARAID;
			//
			Hobject  RegionAffineTrans;
			//HTuple ringHomMat2D;
			//vector_angle_to_rigid(m_modelPARA[1].D(),m_modelPARA[2].D(),m_modelPARA[3].D(),m_modelMatchingPARA[1].D(),m_modelMatchingPARA[2].D(),m_modelMatchingPARA[3].D(),&ringHomMat2D);
			//affine_trans_region(roiRgn,&RegionAffineTrans,ringHomMat2D,"false");
			//
			HTuple HomMat2DRate,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(0, 0, m_modelPARA[3].D(), 0, 0, m_modelMatchingPARA[3].D(), &HomMat2DRate);
			hom_mat2d_translate(HomMat2DRate, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);

			Hobject rotatedRgn,RegionMoved1;
			HTuple RowModelData,ColModelData;
			RowModelData=m_modelPARA[1];
			ColModelData=m_modelPARA[2];
			move_region (roiRgn, &RegionMoved1,-RowModelData, -ColModelData);        
			projective_trans_region (RegionMoved1, &rotatedRgn, HomMat2DAdapted, "bilinear");
			RowModelData=m_modelMatchingPARA[1];
			ColModelData=m_modelMatchingPARA[2];
			move_region (rotatedRgn,&RegionAffineTrans,RowModelData,ColModelData) ;
			//
			if(ErosionSize>=0.5)
			{
				erosion_circle (RegionAffineTrans, &RegionDetect,ErosionSize);
			}
			else if(ErosionSize<-0.5)
			{
				dilation_circle(RegionAffineTrans, &RegionDetect,abs(ErosionSize));
			}
			else
			{
				RegionDetect = RegionAffineTrans;
			}
		}
		else if(RingOrOCR==2)
		{
			if(m_dictCrtPathRgn.find(strRgnPath1) == m_dictCrtPathRgn.end())
			{
				m_vRgn[id] = newRgn;
				return S_FALSE;
			}
			Hobject roiRgn = m_dictCrtPathRgn[strRgnPath1];
			HTuple modelPARAID = m_vRgnReadData[id];

			//HTuple modelPARAIDLength;
			//tuple_length(modelPARAID,&modelPARAIDLength);
			//if(modelPARAIDLength[0].I()<6)
			//{
			//	MessageBox(NULL,_T("仅同时存在图案与拉环两个模板时‘盖面图案’参数可选择('2')"),_T("参数设置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
			//	m_vRgn[id] = newRgn;
			//	return S_FALSE;
			//}
			m_modelPARA[0] = modelPARAID[0];
			m_modelPARA[1] = modelPARAID[1];
			m_modelPARA[2] = modelPARAID[2];
			m_modelPARA[3] = modelPARAID[3];
			m_modelPARA[4] = modelPARAID[4];
			m_modelPARA[5] = modelPARAID[5];
			m_modelPARA[6] = modelPARAID[6];
			//
			Hobject  RegionAffineTrans,OCRRegionAffineTrans,RegionDiff;
			//HTuple ringHomMat2D,OCRHomMat2D;
			//vector_angle_to_rigid(m_modelPARA[1].D(),m_modelPARA[2].D(),m_modelPARA[3].D(),m_modelMatchingPARA[1].D(),m_modelMatchingPARA[2].D(),m_modelMatchingPARA[3].D(),&ringHomMat2D);
			//affine_trans_region(roiRgn,&RegionAffineTrans,ringHomMat2D,"false");
			//
			HTuple HomMat2DRate,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(0, 0, m_modelPARA[3].D(), 0, 0, m_modelMatchingPARA[3].D(), &HomMat2DRate);
			hom_mat2d_translate(HomMat2DRate, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);

			Hobject rotatedRgn,RegionMoved1;	
			HTuple RowModelData,ColModelData;
			RowModelData=m_modelPARA[1];
			ColModelData=m_modelPARA[2];
			move_region (roiRgn, &RegionMoved1,-RowModelData, -ColModelData);        
			projective_trans_region (RegionMoved1, &rotatedRgn, HomMat2DAdapted, "bilinear");
			RowModelData=m_modelMatchingPARA[1];
			ColModelData=m_modelMatchingPARA[2];
			move_region (rotatedRgn,&RegionAffineTrans,RowModelData,ColModelData) ;
			//
			//vector_angle_to_rigid(m_modelPARA[4].D(),m_modelPARA[5].D(),m_modelPARA[6].D(),m_modelMatchingPARA[4].D(),m_modelMatchingPARA[5].D(),m_modelMatchingPARA[6].D(),&OCRHomMat2D);

			if(m_dictCrtPathRgn.find(strRgnPath2) == m_dictCrtPathRgn.end())
			{
				m_vRgn[id] = newRgn;
				return S_FALSE;
			}
			Hobject rgnExtract = m_dictCrtPathRgn[strRgnPath2];
			//affine_trans_region(rgnExtract,&OCRRegionAffineTrans,OCRHomMat2D,"false");
			//
			vector_angle_to_rigid(0, 0, m_modelPARA[6].D(), 0, 0, m_modelMatchingPARA[6].D(), &HomMat2DRate);
			hom_mat2d_translate(HomMat2DRate, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			RowModelData=m_modelPARA[4];
			ColModelData=m_modelPARA[5];
			move_region (rgnExtract, &RegionMoved1,-RowModelData, -ColModelData);        
			projective_trans_region (RegionMoved1, &rotatedRgn, HomMat2DAdapted, "bilinear");
			RowModelData=m_modelMatchingPARA[4];
			ColModelData=m_modelMatchingPARA[5];
			move_region (rotatedRgn,&OCRRegionAffineTrans,RowModelData,ColModelData) ;
			//
			difference (RegionAffineTrans, OCRRegionAffineTrans, &RegionDiff);
			RegionAffineTrans = RegionDiff;
			if(ErosionSize>=0.5)
			{
				erosion_circle (RegionAffineTrans, &RegionDetect,ErosionSize);
			}
			else if(ErosionSize<-0.5)
			{
				dilation_circle(RegionAffineTrans, &RegionDetect,abs(ErosionSize));
			}
			else
			{
				RegionDetect=RegionAffineTrans;
			}
		}
		m_vRgn[id] = RegionDetect ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DetectRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("442$\
					 167;B$\
					 443;FP;-10.5;10.5;0.5;1.0$\
					 441;LP;1;2;1;1$\
					 267;SP$\
					 232;SP" );

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CurlOptimizeAlgo(VARIANT* rgnId, VARIANT* pFreqStart, VARIANT* pFreqCutoff, VARIANT* pDefectType, VARIANT* pWaveThreshold, VARIANT* pMinArea, VARIANT* pDetectNumber)
{
	//利用带通滤波器的卷边优化算法
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	float RoiWidth = m_ringPara[rId].m_RoiWidth;
	float Radius = m_ringPara[rId].m_Radius;
	m_dictSpecialData[rId].clear();
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectNumber);
		return S_FALSE;
	}
	double FreqStart = (double)pFreqStart->fltVal;
	FreqStart = FreqStart/100;
	double FreqCutoff = (double)pFreqCutoff->fltVal;
	FreqCutoff = FreqCutoff/100;
	int DefectType = (int)pDefectType->fltVal;
	float WaveThreshold = (float)pWaveThreshold->fltVal;
	int MinArea = (int)pMinArea->fltVal;
	float fCenterX;
	float fCenterY;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		Hobject DetectRegion;
		int DetectNumber;
		std::vector<float>DictSpecialData;
		if(H_CurlOptimizeAlgo(Image,rgn,&DetectRegion,fCenterX,fCenterY,RoiWidth, Radius ,FreqStart,FreqCutoff,DefectType, WaveThreshold,MinArea, &DetectNumber,DictSpecialData))
		{
			retValue = DetectNumber; 
			m_vErrorRgn[rId] = DetectRegion;
			if(m_bDebugImg)//显示数据
			{
				bool isSector;
				isSector=true;
				if(m_sectorAngle[rId].m_angelEnd-m_sectorAngle[rId].m_angelStart>359.99)
				{
					isSector=false;
				}
				std::vector<float>DictSpecialDataRota;
				std::vector<float>DictSpecialDataRotaDetectAngle;
				int DataLength=(int)(DictSpecialData.size()-2);
				int angleO=(int)(DataLength*(85.6/360.0));//起始角度不是90度。
				DictSpecialDataRota.push_back(DictSpecialData[0]);
				DictSpecialDataRota.push_back(DictSpecialData[1]);
				for(int i = angleO+1; i >= 2; i--)
				{
					DictSpecialDataRota.push_back(DictSpecialData[i]);
				}
				for(int i =DataLength+1; i >angleO+1; i--)
				{
					DictSpecialDataRota.push_back(DictSpecialData[i]);
				}
				//
				if(isSector)
				{
					if((m_angleDetect>=0)&&(m_angleDetect<6.28))
					{
						angleO=(int)(DataLength*(m_angleDetect/6.283));
					}
					else if((m_angleDetect>=-6.28)&&(m_angleDetect<0))
					{
						angleO=(int)(DataLength*(1+m_angleDetect/6.283));
					}
					else
					{
						angleO=2;
					}

					DictSpecialDataRotaDetectAngle.push_back(DictSpecialData[0]);
					DictSpecialDataRotaDetectAngle.push_back(DictSpecialData[1]);

					for(int i =angleO+1; i <=DataLength+1; i++)
					{
						DictSpecialDataRotaDetectAngle.push_back(DictSpecialDataRota[i]);
					}
					for(int i =2; i<angleO+1; i++)
					{
						DictSpecialDataRotaDetectAngle.push_back(DictSpecialDataRota[i]);
					}

					int startData=(int)((m_sectorAngle[rId].m_angelStart/360.0)*DataLength);
					int endData=(int)((m_sectorAngle[rId].m_angelEnd/360.0)*DataLength);
					if(startData<0)
						startData=0;
					if(startData>=DataLength)
						startData=2;
					if(endData<=startData)
						endData=DataLength;
					if(endData>=DataLength)
						endData=DataLength;
					std::vector<float>DictSpecialSector;
					DictSpecialSector.push_back(DictSpecialData[0]);
					DictSpecialSector.push_back(DictSpecialData[1]);
					for(int i =startData+2; i<endData+2; i++)
					{
						DictSpecialSector.push_back(DictSpecialDataRotaDetectAngle[i]);
					}
					m_dictSpecialData[rId]=DictSpecialSector;
				}
				else
					m_dictSpecialData[rId]=DictSpecialDataRota;//DictSpecialData;
				//


			}
		}
		else
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectNumber);
			return S_FALSE;
		}		
		retValue.Detach(pDetectNumber);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectNumber);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectNumber);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CurlOptimizeAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("380$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 382;FP;1;50;1;2$\
					 383;FP;2;50;1;10$\
					 385;LP;-1;1;1;0$\
					 386;FP;0.1;100.0;0.1;22$\
					 387;LP;1;100;1;2");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::DynThresholdAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("411$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************
***函数名： DynThresholdAlgo1
***功  能： 动态阈值
***修  改：（1）将expand_domain_gray的尺寸变成可控制的，而不是写定值的
****************************************************************************************/
STDMETHODIMP CPlugAlgo::DynThresholdAlgo1(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, BlackMaskSize+5);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, WhiteMaskSize+5);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DynThresholdAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6116$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_FilmBigErrorDetectAlgo(VARIANT* rgnId, VARIANT* pMeanSizeWidth,VARIANT* pMeanSizeHeight, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pClosingSize1, VARIANT* pClosingSize2, VARIANT* pAreaLimit,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int MeanSizeWidth                = (int)pMeanSizeWidth->fltVal;
	int MeanSizeHeight              = (int)pMeanSizeHeight->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize        = (int) pSeriousBlackPointSize->fltVal;
	int ClosingSize1                 = (int) pClosingSize1->fltVal;
	int ClosingSize2                 = (int) pClosingSize2->fltVal;
	int AreaLimit                    = (int)pAreaLimit->fltVal;


#ifdef NDEBUG
	try
	{
#endif
		//
		/*if(m_bDebugImg)
		{
		m_dictSpecialData[rId].clear();
		}*/
		//获得区域信息
		HTuple  Radius      =  m_ringPara[rId].m_Radius;
		HTuple  ROiWidth    =  m_ringPara[rId].m_RoiWidth ;
		HTuple  RadiusStart = Radius - ROiWidth;
		HTuple  RadiusEnd   = Radius;
		HTuple  PolarWidth  = (Radius - ROiWidth/2.0)*2*3.1415926 ;
		HTuple  PolarHeight = RadiusEnd-RadiusStart;
		HTuple fCenterX = 0.0;
		HTuple fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;

		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew,ImageScaleMax;
		Hobject ImageOpening, ImageMean,RegionDynThresh,PolarTransImage;
		HTuple  Width,Height;

		get_image_size(Image,&Width,&Height);
		//
		reduce_domain (Image, rgn, &ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		// 6.28319+
		polar_trans_image_ext (ImageScaleMax, &PolarTransImage, fCenterY,fCenterX,0.0, 7.5, RadiusStart, RadiusEnd, PolarWidth, PolarHeight, "nearest_neighbor");
		//scale_image_max(ImageReduced, &ImageScaleMax);
		gray_opening_rect(PolarTransImage, &ImageOpening, 1, 11);
		mean_image(ImageOpening, &ImageMean, MeanSizeWidth, MeanSizeHeight);
		dyn_threshold(ImageOpening, ImageMean, &RegionDynThresh, SeriousBlackPointDynThresh,"light");

		Hobject ConnectedRegions,SelectedRegions,RegionUnion,RegionClosing1,RegionClosing2;
		Hobject RegionDifference,RegionOpening,RegionOpening2,RegionDilation,ConnectedRegions2,SelectedRegions2,XYTransRegion;
		HTuple  ErrorArea,ErrorRow,ErrorCol;

		connection(RegionDynThresh, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, 9999999);
		union1(SelectedRegions, &RegionUnion);

		closing_rectangle1(RegionUnion, &RegionClosing1, ClosingSize1, 2);
		closing_rectangle1(RegionClosing1, &RegionClosing2, ClosingSize2, 1);
		difference(RegionClosing2, RegionClosing1, &RegionDifference);
		opening_circle(RegionDifference, &RegionOpening2, 1.5);
		connection(RegionOpening2,&ConnectedRegions2);
		select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and", AreaLimit, 9999999);

		// 6.28319+
		polar_trans_region_inv (SelectedRegions2, &XYTransRegion, fCenterY, fCenterX, 0.0, 7.5, RadiusStart, RadiusEnd, PolarWidth, PolarHeight, Width, Height, "nearest_neighbor");

		//my_disp_obj(RegionOpening2);

		dilation_rectangle1(XYTransRegion, &RegionDilation, 3, 5);

		area_center(RegionDilation, &ErrorArea, &ErrorRow, &ErrorCol);

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union1(RegionDilation, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_FilmBigErrorDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6001$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6002;LP;1;101;1;11$\
					 6003;LP;1;250;1;60$\
					 415;LP;1;200;1;48$\
					 416;LP;3;201;2;50$\
					 6004;LP;1;250;1;10$\
					 6006;LP;1;350;1;150$\
					 6005;LP;1;450;1;200");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::N_DynThresholdAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		//
		emphasize(Image, &Image, 10, 10, 1.3);
		//
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageDetectNew,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageDetectNew, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::N_DynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1094$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************************
** 函数名：InWallDynThresholdAlgo
** 功  能：动态阈值变形（只有纵向平滑尺寸）
*************************************************************************************/
STDMETHODIMP CPlugAlgo::InWallDynThresholdAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	//侧面内壁区域的动态灰度算法检测、纵向平滑
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, 1, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, 1, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::InWallDynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1192$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::InWallDynThresholdAlgo1(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pUpEdgeExclude,VARIANT* pDownEdgeExclude,VARIANT* pDetectArea)
{
	//侧面内壁区域的动态灰度算法检测、纵向平滑
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	float UpEdgeExclude       = (float)pUpEdgeExclude->fltVal;
	float DownEdgeExclude       = (float)pDownEdgeExclude->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, 1, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, 1, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		// 筛出上下边缘干扰
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		Hobject rgnUp,rgnDown,rgnIntersect;
		move_region(rgn,&rgnUp,(int)UpEdgeExclude,0 );
		move_region(rgn,&rgnDown,(int)-DownEdgeExclude,0 );

		intersection(rgnUp,rgnDown,&rgnIntersect);
		intersection(rgnIntersect,DefectRegs,&DefectRegs );
		union1( DefectRegs,&DefectRegs);

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::InWallDynThresholdAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6148$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10$\
					 6126;FP;0;50;1;0$\
					 6127;FP;0;50;1;0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::N_BubbleDetectProfileAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::N_BubbleDetectProfileAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1144$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：BubbleDetectProfileAlgo
***功  能：破膜、大缺陷检测
***原  理：动态阈值（参数设置的较大一些）
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BubbleDetectProfileAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BubbleDetectProfileAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1144$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：BubbleDetectProfileForAnnulusAlgo
***功  能：破膜、大缺陷检测（用于环形区域或者扇形区域）
***说  明：（1）增加了滤波方向筛选（径向、切向）
***        （2）增加了形状筛选  
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForAnnulusAlgo(VARIANT* rgnId,VARIANT* pMaskDirection, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDefectShape,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	// get the center of region 
	HTuple dCenterRow, dCenterColumn;
	dCenterRow = m_vPos[0].m_y;
	dCenterColumn = m_vPos[0].m_x;

	// get the annulus messsage
	HTuple dRadius,dRoiWidth;
	HTuple dMinDist,dMaxDist;
	distance_pr(rgn,dCenterRow,dCenterColumn,&dMinDist,&dMaxDist );
	dRadius = dMaxDist;
	dRoiWidth = dMaxDist - dMinDist;

	int MaskDirection = (int)pMaskDirection->fltVal;
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	float DefectShape = (float)pDefectShape->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple Width,Height;
		Hobject Image = m_crtImg;
		get_image_size(Image,&Width,&Height);

		//change to polar coordinate
		HTuple dRadiusInner,dExtendHeight,dExtendWidth;
		Hobject PolarTransImage,rgnPolarTransImage;

		dRadiusInner = dRadius - dRoiWidth;
		dExtendHeight = dRoiWidth;
		dExtendWidth = (dRadius + dRadiusInner)/2.0 * 2*PI;
		polar_trans_image_ext(Image, &PolarTransImage, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, "nearest_neighbor");
		
		//HTuple dWidth,dHeight;
		//get_image_size(PolarTransImage,&dWidth,&dHeight );
		//zoom_image_size(PolarTransImage,&PolarTransImage,dWidth+20,dHeight+20,"bilinear" );
		
		get_domain(PolarTransImage,&rgnPolarTransImage );
		clip_region_rel(rgnPolarTransImage,&rgnPolarTransImage,1,1,1,1);

		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		//ImageProcessAlg.MeanImageReduced(PolarTransImage,rgnPolarTransImage, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		reduce_domain(PolarTransImage,rgnPolarTransImage,&ImageReduced );
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgnPolarTransImage, &ImageDetectNew); 

		if ( MaskDirection == 0)
		{
			// 水平滤波
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		}
		else if ( MaskDirection == 1)
		{
			// 垂直
			mean_image(ImageDetectNew, &ImageReduceMean,1, BlackMaskSize);
		}
		else
		{
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		}

		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgnPolarTransImage, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			//ImageProcessAlg.MeanImageReduced(PolarTransImage,rgnPolarTransImage, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			reduce_domain(PolarTransImage,rgnPolarTransImage,&ImageReduced );
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgnPolarTransImage, &ImageDetectNew); 
			if ( MaskDirection == 0)
			{
				// 水平滤波
				mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
			}
			else if ( MaskDirection == 1)
			{
				// 垂直
				mean_image(ImageDetectNew, &ImageReduceMean,1, WhiteMaskSize);
			}
			else
			{
				mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
			}
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		polar_trans_region_inv(DefectRegs, &DefectRegs, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, Width, Height, "nearest_neighbor");
		intersection(DefectRegs,rgn ,&DefectRegs );
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}

		// 形状筛选
		Hobject defectRgnCon,rgnFin;
		HTuple  iNum;
		gen_empty_obj(&rgnFin );
		connection(DefectRegs, &defectRgnCon);
		count_obj(defectRgnCon,&iNum);
		for ( int i = 1; i <= iNum;i++)
		{
			Hobject objSel;
			HTuple dRow,dCol,dPhi,dLen1,dLen2,dRate;
			select_obj(defectRgnCon,&objSel, i);
			smallest_rectangle2(objSel, &dRow,&dCol,&dPhi,&dLen1,&dLen2);
			dRate = dLen1/(dLen2*1.0);
			if (dRate >= DefectShape )
			{
				concat_obj(rgnFin, objSel,&rgnFin);
			}
		}
		union1(rgnFin,&rgnFin);
		DefectRegs = rgnFin;
        //////

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForAnnulusAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6142$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6141;LP;0;2;1;0$\
					 412;LP;3;100;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;100;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10$\
					 6110;FP;1;100;0.1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/*********************************************************************************************
** 函数名：SmallCircleDefectDetectAlgo
** 功  能：检测小圆缺失类缺陷
** 时  间：2019年12月22日
**********************************************************************************************/
STDMETHODIMP CPlugAlgo::SmallCircleDefectDetectAlgo(VARIANT* rgnId,VARIANT* pMaskDirection, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDefectShape,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	// get the center of region 
	HTuple dCenterRow, dCenterColumn;
	dCenterRow = m_vPos[0].m_y;
	dCenterColumn = m_vPos[0].m_x;

	// get the annulus messsage
	HTuple dRadius,dRoiWidth;
	HTuple dMinDist,dMaxDist;
	distance_pr(rgn,dCenterRow,dCenterColumn,&dMinDist,&dMaxDist );
	dRadius = dMaxDist;
	dRoiWidth = dMaxDist - dMinDist;

	int MaskDirection = (int)pMaskDirection->fltVal;
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	float DefectShape = (float)pDefectShape->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple Width,Height;
		Hobject Image = m_crtImg;
		get_image_size(Image,&Width,&Height);

		//change to polar coordinate
		HTuple dRadiusInner,dExtendHeight,dExtendWidth;
		Hobject PolarTransImage,rgnPolarTransImage;

		dRadiusInner = dRadius - dRoiWidth;
		dExtendHeight = dRoiWidth;
		dExtendWidth = (dRadius + dRadiusInner)/2.0 * 2*PI;
		polar_trans_image_ext(Image, &PolarTransImage, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, "nearest_neighbor");

		//HTuple dWidth,dHeight;
		//get_image_size(PolarTransImage,&dWidth,&dHeight );
		//zoom_image_size(PolarTransImage,&PolarTransImage,dWidth+20,dHeight+20,"bilinear" );

		get_domain(PolarTransImage,&rgnPolarTransImage );
		clip_region_rel(rgnPolarTransImage,&rgnPolarTransImage,1,1,1,1);

		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		//ImageProcessAlg.MeanImageReduced(PolarTransImage,rgnPolarTransImage, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		reduce_domain(PolarTransImage,rgnPolarTransImage,&ImageReduced );
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgnPolarTransImage, &ImageDetectNew); 

		if ( MaskDirection == 0)
		{
			// 水平滤波
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		}
		else if ( MaskDirection == 1)
		{
			// 垂直
			mean_image(ImageDetectNew, &ImageReduceMean,1, BlackMaskSize);
		}
		else
		{
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		}

		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgnPolarTransImage, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			//ImageProcessAlg.MeanImageReduced(PolarTransImage,rgnPolarTransImage, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			reduce_domain(PolarTransImage,rgnPolarTransImage,&ImageReduced );
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgnPolarTransImage, &ImageDetectNew); 
			if ( MaskDirection == 0)
			{
				// 水平滤波
				mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
			}
			else if ( MaskDirection == 1)
			{
				// 垂直
				mean_image(ImageDetectNew, &ImageReduceMean,1, WhiteMaskSize);
			}
			else
			{
				mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
			}
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		polar_trans_region_inv(DefectRegs, &DefectRegs, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, Width, Height, "nearest_neighbor");
		intersection(DefectRegs,rgn ,&DefectRegs );
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}

		// 形状筛选
		Hobject defectRgnCon,rgnFin;
		HTuple  iNum;
		gen_empty_obj(&rgnFin );
		connection(DefectRegs, &defectRgnCon);
		count_obj(defectRgnCon,&iNum);
		for ( int i = 1; i <= iNum;i++)
		{
			Hobject objSel;
			HTuple dRow,dCol,dPhi,dLen1,dLen2,dRate;
			select_obj(defectRgnCon,&objSel, i);
			smallest_rectangle2(objSel, &dRow,&dCol,&dPhi,&dLen1,&dLen2);
			dRate = dLen1/(dLen2*1.0);
			if (dRate >= DefectShape )
			{
				concat_obj(rgnFin, objSel,&rgnFin);
			}
		}
		union1(rgnFin,&rgnFin);
		
		// 计算与小圆区域交集最大和最小的区域
		Hobject rgnCircleCon,rgnCircleIntsct;
		HTuple Num,dAreaS,dRowS,dColS,dAreaMax,dAreaMin;
		connection(rgn,&rgnCircleCon);
		intersection(rgnCircleCon,rgnFin,&rgnCircleIntsct);

		area_center(rgnCircleIntsct, &dAreaS,&dRowS,&dColS);
		//tuple_max(dAreaS, );
		if ( dAreaS.Num()  <= 0  )
		{
			// 如果交集为空不报错
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
			return S_OK;
		}

		tuple_max(dAreaS,&dAreaMax);
		tuple_min(dAreaS,&dAreaMin);

		Hobject  rgnCirLess;
		if ((dAreaMax - dAreaMin).Abs() > 0  )
		{
			HTuple iIndex;
			tuple_find(dAreaS,dAreaMin,&iIndex );
			select_obj(rgnCircleCon,&rgnCirLess,iIndex + 1 );
		}
		else
		{
			gen_empty_obj(&rgnCirLess );
		}

		DefectRegs = rgnCirLess;
		union1(DefectRegs,&DefectRegs );

		//////

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			Area = dAreaMax - dAreaMin;
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SmallCircleDefectDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6243$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6141;LP;0;2;1;0$\
					 412;LP;3;100;2;45$\
					 415;LP;1;250;1;20$\
					 416;LP;1;200;1;10$\
					 417;LP;3;100;2;45$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10$\
					 6110;FP;1;100;0.1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：BubbleDetectProfileForColorAlgo
***功  能：破膜、大缺陷检测（针对彩色缺陷）
***原  理：动态阈值（参数设置的较大一些，滤波方向可选择）
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForColorAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect,VARIANT* pMaskDirction,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	int ChannelSelect    = (int) pChannelSelect->fltVal;
	int ColorTransType   = (int) pColorTransType->fltVal;
	int MaskDirction    = (int) pMaskDirction ->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		if ( MaskDirction == 0)
		{
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		}
		else
			mean_image(ImageDetectNew, &ImageReduceMean,1 , BlackMaskSize);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			if ( MaskDirction == 0)
			{
				mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
			}
			else
				mean_image(ImageDetectNew, &ImageReduceMean,1 , BlackMaskSize);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForColorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5521$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 5522;LP;0;1;1;0$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************
***函数名：BubbleDetectProfileForColorFilmAlgo
***功  能：破膜、大缺陷检测（针对彩色缺陷），并增加覆膜边缘剔除
***原  理：动态阈值（参数设置的较大一些，滤波方向可选择）
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForColorFilmAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect,VARIANT* pMaskDirction,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pMoveSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	int ChannelSelect    = (int) pChannelSelect->fltVal;
	int ColorTransType   = (int) pColorTransType->fltVal;
	int MaskDirction    = (int) pMaskDirction ->fltVal;   
    int MoveSize    = (int) pMoveSize ->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		if ( MaskDirction == 0)
		{
			mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		}
		else
			mean_image(ImageDetectNew, &ImageReduceMean,1 , BlackMaskSize);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			if ( MaskDirction == 0)
			{
				mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
			}
			else
				mean_image(ImageDetectNew, &ImageReduceMean,1 , BlackMaskSize);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//

		//m_FMpoints  m_ABEdgeM ，剔除覆膜边缘干扰
		HTuple Area7, Row5, Column3,Area8, Row6, Column5;
		Hobject RegionMoved,RegionDilation;
		area_center(m_FMpoints, &Area7, &Row5, &Column3);
		area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
		move_region(m_ABEdgeM, &RegionMoved, -(Row6-Row5), 0);
		dilation_rectangle1(RegionMoved, &RegionDilation, 1, 20);

		Hobject RemovedReg,DefectRegs;
		move_region(RegionDilation,&RemovedReg,MoveSize,0);
		//
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		union1(DefectRegs,&DefectRegs);
		Hobject DefectRegs1;
		difference(DefectRegs,RemovedReg,&DefectRegs1);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs1, &Area, &Row_test, &Column_test);

		/*Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);*/
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs1, &DefectRegs1, 2.5);
			m_vErrorRgn[rId] = DefectRegs1;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BubbleDetectProfileForColorFilmAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6114$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 5522;LP;0;1;1;0$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10$\
					 1227;LP;-50;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************
***函数名：BlackDetectExcludeEdgesAlgo
***功  能：黑缺陷检测并筛除边缘干扰
***原  理：动态阈值 + 阈值分割 + 边缘剔除
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BlackDetectExcludeEdgesAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pBlackThresh,VARIANT* pSeriousBlackPointSize, VARIANT* pThresholdLow,  VARIANT* pMinEdgeSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	int SeriousBlackPointDynThresh = (int)pSeriousBlackPointDynThresh->fltVal;
	int BlackThresh = (int)pBlackThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int ThresholdLow = (int) pThresholdLow->fltVal;
	int ThresholdHigh=ThresholdLow*2;
	if (ThresholdHigh>255)
	{
		ThresholdHigh=255;
	}
	int MinEdgeSize = (int) pMinEdgeSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean;
		//
		Hobject  ModelImages, ModelRegions;
		Hobject  RegionDilation, RegionDynThresh, RegionDifference;
		Hobject  RegionBlack, RegionUnion, ConnectedRegions;
		Hobject  SelectedRegions;

		reduce_domain(Image, rgn, &ImageReduced);
		if(BlackMaskSize>=0.5)
			median_image(ImageReduced, &ImageReduceMean, "circle", BlackMaskSize, "mirrored");
		else
			ImageReduceMean=ImageReduced;

		inspect_shape_model(ImageReduced, &ModelImages, &ModelRegions, 1, ((HTuple(ThresholdLow).Append(ThresholdHigh)).Append(MinEdgeSize)));
		dilation_circle(ModelRegions, &RegionDilation, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &RegionDynThresh, SeriousBlackPointDynThresh, "dark");
		H_SelectRegionExcludeLinear (RegionDynThresh,&RegionDynThresh, 0.5,18);
		difference(RegionDynThresh, RegionDilation, &RegionDifference);

		threshold(ModelImages, &RegionBlack, 0, BlackThresh);
		union2(RegionDifference, RegionBlack, &RegionUnion);
		connection(RegionUnion, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, 9999);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			sub_image (ImageReduceMean,ImageReduced,  &ImageSub, 1, 0);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;	
		union1(SelectedRegions, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BlackDetectExcludeEdgesAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("635$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;3$\
					 415;LP;1;250;1;40$\
					 198;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 579;LP;1;250;1;10$\
					 581;LP;1;800;1;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：BlackDetectAlgo
***功  能：黑缺陷检测
***原  理：动态阈值 + 阈值分割
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::BlackDetectAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pBlackThresh,VARIANT* pSeriousBlackPointSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	int SeriousBlackPointDynThresh = (int)pSeriousBlackPointDynThresh->fltVal;
	int BlackThresh = (int)pBlackThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean;
		//
		Hobject  ImageOpening;
		Hobject  RegionDynThresh;
		Hobject  RegionBlack, RegionUnion, ConnectedRegions,SelectedRegions;
		reduce_domain(Image, rgn, &ImageReduced);
		gray_opening_rect(ImageReduced,&ImageOpening,7,7);
		if(BlackMaskSize>=0.5)
			median_image(ImageOpening, &ImageReduceMean, "circle", BlackMaskSize, "mirrored");
		else
			ImageReduceMean=ImageOpening;

		dyn_threshold(ImageReduced, ImageReduceMean, &RegionDynThresh, SeriousBlackPointDynThresh, "dark");
		threshold(ImageReduced, &RegionBlack, 0, BlackThresh);
		union2(RegionDynThresh, RegionBlack, &RegionUnion);
		connection(RegionUnion, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, 9999999);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			sub_image (ImageReduceMean,ImageReduced,  &ImageSub, 1, 0);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;	
		union1(SelectedRegions, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BlackDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("492$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;1;101;2;3$\
					 415;LP;1;250;1;40$\
					 198;LP;1;250;1;60$\
					 416;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：WhiteDetectAlgo
***功  能：白缺陷检测
***原  理：动态阈值 + 阈值分割
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::WhiteDetectAlgo(VARIANT* rgnId, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pWhiteThresh,VARIANT* pSeriousWhitePointSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pWhiteMaskSize->fltVal;
	int SeriousBlackPointDynThresh = (int)pSeriousWhitePointDynThresh->fltVal;
	int BlackThresh = (int)pWhiteThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousWhitePointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean;
		//
		Hobject  ImageOpening;
		Hobject  RegionDynThresh;
		Hobject  RegionBlack, RegionUnion, ConnectedRegions,SelectedRegions;
		reduce_domain(Image, rgn, &ImageReduced);
		gray_opening_rect(ImageReduced,&ImageOpening,7,7);
		if(BlackMaskSize>=0.5)
			median_image(ImageOpening, &ImageReduceMean, "circle", BlackMaskSize, "mirrored");
		else
			ImageReduceMean=ImageOpening;

		dyn_threshold(ImageReduced, ImageReduceMean, &RegionDynThresh, SeriousBlackPointDynThresh, "light");
		threshold(ImageReduced, &RegionBlack,BlackThresh,255);
		union2(RegionDynThresh, RegionBlack, &RegionUnion);
		connection(RegionUnion, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, 9999999);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			sub_image (ImageReduceMean,ImageReduced,  &ImageSub, 1, 0);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;	
		union1(SelectedRegions, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WhiteDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("493$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 842;LP;1;255;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::MinMaxGrayDetectAlgo(VARIANT* rgnId, VARIANT* pBlackThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteThresh,VARIANT* pSeriousWhitePointSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackThresh = (int)pBlackThresh->fltVal;
	int SeriousBlackPointSize = (int)pSeriousBlackPointSize->fltVal;
	int WhiteThresh = (int)pWhiteThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean;
		//
		Hobject  RegionBlack, RegionUnion, ConnectedRegions,SelectedRegions;
		reduce_domain(Image, rgn, &ImageReduced);
		Hobject ExpandedImage,ImageDetectNew;
		expand_domain_gray (ImageReduced, &ExpandedImage, 5);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, 3, 3);
		if (BlackThresh>255)
		{
			BlackThresh=255;
		}
		if (BlackThresh<0)
		{
			BlackThresh=0;
		}
		threshold(ImageReduceMean, &RegionBlack,0,BlackThresh);
		connection(RegionBlack, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, 9999999);
		Hobject UnionBlack;
		union1(SelectedRegions,&UnionBlack);
		//
		if (WhiteThresh>255)
		{
			WhiteThresh=255;
		}
		if (WhiteThresh<0)
		{
			WhiteThresh=0;
		}
		Hobject RegionWhite;
		threshold(ImageReduceMean, &RegionWhite,WhiteThresh,255);
		connection(RegionWhite, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousWhitePointSize, 9999999);
		Hobject UnionWhite;
		union1(SelectedRegions,&UnionWhite);
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(WhiteThresh));
			m_dictSpecialData[rId].push_back(float(BlackThresh));

			HTuple AbsoluteHisto, RelativeHisto, Length, maxValue = 0;
			gray_histo (rgn, ImageReduceMean, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(AbsoluteHisto, &maxValue);

			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i = 0; i < histoLength; i ++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;	
		//
		union2(UnionWhite, RegionBlack, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::MinMaxGrayDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1260$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 198;LP;1;255;1;60$\
					 416;LP;1;600;1;10$\
					 842;LP;1;255;1;160$\
					 421;LP;1;600;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CurlNoCompoundAlgo(VARIANT* rgnId,VARIANT*pGrayValueMean )
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
	HTuple MeanGray, Deviation;//pDetectArea

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		intensity (rgn, Image, &MeanGray, &Deviation);

		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(MeanGray[0].D()));
			m_dictSpecialData[rId].push_back(-999999.0f);

			HTuple AbsoluteHisto, RelativeHisto, Length, maxValue = 0;
			gray_histo (rgn, Image, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(AbsoluteHisto, &maxValue);

			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i = 0; i < histoLength; i ++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		retValue = MeanGray[0].I();
		m_vErrorRgn[rId] = rgn;
		retValue.Detach(pGrayValueMean);
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CurlNoCompoundAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("436$\
					 200;R;LP;1;255;1$\
					 167;B");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************
** 函数名：CenterLocationRightOrNotAlgo
** 功  能：判断中心定位是否失败（判断中心定位是不是在圆点）
*******************************************************************************/
STDMETHODIMP CPlugAlgo::CenterLocationRightOrNotAlgo(VARIANT* rgnId,VARIANT*pGrayValueMean )
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
	HTuple MeanGray, Deviation;//pDetectArea

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		//intensity (rgn, Image, &MeanGray, &Deviation);

		HTuple dCenRow;
		dCenRow = m_vPos[0].m_y;

		retValue = dCenRow[0].I();
		m_vErrorRgn[rId] = rgn;
		retValue.Detach(pGrayValueMean);

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterLocationRightOrNotAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6158$\
					 200;R;LP;1;500;1$\
					 167;B");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::UVCurlAlgo(VARIANT* rgnId, VARIANT* pNumPart, VARIANT* pThresholdValue, VARIANT* pGrayValue,VARIANT* pMeanGrayValue,VARIANT* pDetectArea)
{
	//UVCurlAlgo  对应第三版UVCurlDLL2.1
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue =0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	HTuple Row6, Column6, RadiusOut,Row8, Column8, HalfRoiWidth;
	smallest_circle (rgn, &Row6, &Column6, &RadiusOut);
	inner_circle (rgn, &Row8, &Column8, &HalfRoiWidth);

	float RoiWidth =(float)(2.0*HalfRoiWidth[0].D());
	float Radius =(float)RadiusOut[0].D();
	if((Radius<RoiWidth*2.1)||(RoiWidth<1.2))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	if((Radius<RoiWidth*2.1)||(RoiWidth<1.6))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int NumPart = (int)pNumPart->fltVal;
	float ThresholdValue = (float)pThresholdValue->fltVal;
	int GrayValue = (int)pGrayValue->fltVal;
	int MeanGrayValue=(int)pMeanGrayValue->fltVal;
	float fCenterX;
	float fCenterY;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	double RegionalOut, RegionalIn;
	if(Radius - RoiWidth > 0)
	{
		if(RoiWidth > 0)
		{
			RegionalOut = Radius;
			RegionalIn = Radius - RoiWidth;
		}
		else
		{
			RegionalOut = Radius - RoiWidth;
			RegionalIn = Radius;
		}
	}
	else
	{
		RegionalOut = Radius;
		RegionalIn = 0;
	}
	HTuple WidthOri, HeightOri;
	Hobject Image = m_crtImg;
	get_image_size (m_crtImg, &WidthOri, &HeightOri);
	Hobject PolarTransImage, ImageScaleMax, JuanYuanPartitioned, ResultDefect;
	HTuple PolarTransImageWidth, PolarTransImageHeight, Mean, Deviation, MeanLength, Exp, MeanDeviation;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		int angleCirle=370;//重复一定角度，避免起始角度位置缺陷被忽略。
		polar_trans_image_ext(Image, &PolarTransImage, fCenterY, fCenterX, 0, HTuple(angleCirle).Rad(), HTuple(RegionalOut), HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), "nearest_neighbor");
		get_image_size(PolarTransImage, &PolarTransImageWidth, &PolarTransImageHeight);
		partition_rectangle(PolarTransImage, &JuanYuanPartitioned, PolarTransImageWidth/NumPart, PolarTransImageHeight);
		intensity(JuanYuanPartitioned, PolarTransImage, &Mean, &Deviation);
		tuple_length(Mean, &MeanLength);
		MeanDeviation = HTuple();
		for (int i=0; i<=MeanLength-2; i+=1)
		{
			tuple_deviation(HTuple(Mean[i]).Concat(HTuple(Mean[i+1])), &Exp);
			MeanDeviation[i] = Exp; 
		}

		HTuple Abs, AbsSorted, LocationId, Length, errorValue, ResultID;
		tuple_abs(MeanDeviation, &Abs);
		tuple_sort(Abs, &AbsSorted);
		tuple_sort_index(Abs, &LocationId);
		tuple_length(Abs, &Length);
		for (int i=Length[0].I()-1; i>=0; i+=-1)
		{
			if (0 != (HTuple(AbsSorted[i])<ThresholdValue))
			{
				if (0 != (i==(Length-1)))
				{
					ResultID = HTuple();
					break;
				}
				else
				{
					tuple_last_n(LocationId, i+1, &ResultID);
					break;
				}
			}
		}
		ResultID += 1;

		HTuple MeanSorted, LocationId2, Length1, ResultID2, ResultID3, Sorted, Uniq;
		tuple_sort(Mean, &MeanSorted);
		tuple_sort_index(Mean, &LocationId2);
		tuple_length(Mean, &Length1);
		ResultID2 = HTuple();
		for (int i=0; i<=Length1-1; i+=1)
		{
			if (0 != (HTuple(MeanSorted[i]) < GrayValue))
			{
				ResultID2[i] = HTuple(LocationId2[i]);
			}
			else
			{
				break;
			}
		}
		ResultID2 += 1;

		tuple_concat(ResultID, ResultID2, &ResultID3);
		tuple_sort(ResultID3, &Sorted);
		tuple_uniq(Sorted, &Uniq);
		Hobject BackTransRegion, DefectRegs;
		select_obj(JuanYuanPartitioned, &ResultDefect, Uniq);
		polar_trans_region_inv(ResultDefect, &BackTransRegion, fCenterY, fCenterX, 0, HTuple(angleCirle).Rad(), HTuple(RegionalOut), HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), WidthOri, HeightOri, "nearest_neighbor");
		union1 (BackTransRegion, &DefectRegs);
		intersection(DefectRegs,rgn,&DefectRegs);
		//
		HTuple Mean1, Deviation1;
		intensity(rgn, Image, &Mean1, &Deviation1);
		if (Mean1<MeanGrayValue)
		{
			union2 (rgn,DefectRegs, &DefectRegs);
		}
		//
		HTuple Area, Row_test, Column_test;
		area_center (DefectRegs, &Area, &Row_test, &Column_test);
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn;
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;	
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::UVCurlAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("607$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 403;LP;5;500;1;300$\
					 404;FP;1;100;0.1;30$\
					 405;LP;1;255;1;50$\
					 608;LP;1;255;1;60");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdAlgo(VARIANT* rgnId,VARIANT* pRotaAngle,VARIANT* pDynThresh, VARIANT* pDefectSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int ThresholdValue = (int)pDynThresh->fltVal;
	int DefectSize = (int) pDefectSize->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		reduce_domain (Image, rgn, &ImageReduced);
		vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY, fCenterX, HTuple(RotaAngle).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "bilinear", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThresholdValue, "not_equal");
		connection(RegionDynThresh, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions4, "area", "and", DefectSize, 9999999);
		Hobject DefectRegs;
		union1(SelectedRegions4, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("609$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 610;FP;0.5;350;0.5;3.5$\
					 630;LP;1;250;1;60$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/********************************************************************************
*函数名：AnnularRotaDynThresholdAlgo1
*功  能：在原始的旋转对比算法下加入了均值判断，通过灰度均值来二次筛选检测出来的缺陷
*参  数：pLowValue：灰度均值下限
         pHighValue：灰度均值上限
*********************************************************************************/
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdAlgo1(VARIANT* rgnId,VARIANT* pRotaAngle,VARIANT* pDynThresh, VARIANT* pDefectSize, VARIANT* pLowValue,VARIANT* pHighValue,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int ThresholdValue = (int)pDynThresh->fltVal;
	int DefectSize = (int) pDefectSize->fltVal;
	int LowValue = (int) pLowValue->fltVal;
	int HighValue = (int) pHighValue->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//
		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		reduce_domain (Image, rgn, &ImageReduced);
		vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY, fCenterX, HTuple(RotaAngle).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "bilinear", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThresholdValue, "not_equal");
		connection(RegionDynThresh, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions4, "area", "and", DefectSize, 9999999);

		HTuple Num,dMean,dDeviation;
		Hobject objSel,objConcat ;

		gen_empty_obj(&objConcat);
		count_obj(SelectedRegions4,&Num);
		if ( Num > 0)
		{
			for (int i=1;i<=Num;i++)
			{
				select_obj(SelectedRegions4,&objSel,i);
				intensity(objSel,Image,&dMean,&dDeviation);
				if((dMean[0].I()> LowValue) && (dMean[0].I()< HighValue))
				{
					concat_obj(objConcat,objSel,&objConcat);
				}
			}
		}

		Hobject DefectRegs;
		union1(objConcat, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("609$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 610;FP;0.5;350;0.5;3.5$\
					 630;LP;1;250;1;60$\
					 387;LP;1;200;1;10$\
					 1305;LP;1;250;1;1$\
					 1307;LP;1;255;1;128");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/********************************************************************************
*函数名：EdgeAlgo
*功  能：对产品表面灰度突变区域进行检测
*思  路：对图像进行滤波然后获得边缘，再使用阈值分割得到突变区域
*参  数：pEdgeThred：灰度均值上限
         pDefectSize：缺陷面积阈值
*********************************************************************************/
STDMETHODIMP CPlugAlgo::EdgeAlgo(VARIANT* rgnId, VARIANT* pEdgeThred, VARIANT* pDefectSize, VARIANT* pDetectArea)
{
	//盖面边沿算法
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int EdgeThred = (int)pEdgeThred->fltVal;
	int DefectSize = (int)pDefectSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ExpandedImage, DerivGauss;
		reduce_domain (Image, rgn, &ImageReduced);
		expand_domain_gray(ImageReduced, &ExpandedImage, 2);

		Hobject ImageMean, ImageExpandedReduced;
		HTuple MaskSize;
		MaskSize = 3;
		mean_image(ExpandedImage, &ImageMean, MaskSize, MaskSize);
		reduce_domain(ImageMean, rgn, &ImageExpandedReduced);

		Hobject ImageEdgeRobinson, ThresholdRegion, ConnectedThresholdRegion, SelectedRegion;
		robinson_amp(ImageExpandedReduced, &ImageEdgeRobinson);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(EdgeThred));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple AbsoluteHisto, RelativeHisto, Length;
			gray_histo (rgn, ImageEdgeRobinson, &AbsoluteHisto, &RelativeHisto);
			HTuple  maxValue = 0;
			tuple_max (AbsoluteHisto, &maxValue);
			tuple_length (AbsoluteHisto, &Length);
			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i=0; i< histoLength; i++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		threshold(ImageEdgeRobinson, &ThresholdRegion, EdgeThred, 255);
		connection(ThresholdRegion, &ConnectedThresholdRegion);
		select_shape(ConnectedThresholdRegion, &SelectedRegion, "area", "and", DefectSize, 99999);
		Hobject DefectRegs;
		union1(SelectedRegion, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::EdgeAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("432$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 433;LP;1;255;1;30$\
					 434;LP;1;250;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：LineDetectionAlgo
***功  能：通过Lines_gauss 算子进行线条的检测
***参  数：pDefectType ： 控制检测的类型：1--白线；-1--黑线；0--黑白线
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::LineDetectionAlgo(VARIANT* rgnId, VARIANT* pMaskSize, VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectType,VARIANT* pDefectSize,VARIANT* pDefectArea)
{
	int rId           = (int)rgnId->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	double thredLow   = (double)pThredLow->fltVal;
	double thredUpper = (double)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+0.5;
	}
	int detectModel   = (int)pDefectType->fltVal;
	int detectSize   = (int)pDefectSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced, defectRgn;
		HTuple Length, maxLength;
		reduce_domain(crtImg, rgn, &imgReduced);
		//
		Hobject Lines, UnionContours, selectedContours,rgnErosion;
		if(detectModel==1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==-1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==0)
		{
			Hobject UnionContoursLight,UnionContoursDark;
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursLight, 10, 1, "attr_keep");

			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursDark, 10, 1, "attr_keep");

			concat_obj(UnionContoursLight,UnionContoursDark,&UnionContours);
		}
		erosion_circle(rgn, &rgnErosion, 2.5);
		ImageProcessAlg.LinesToRegion(UnionContours, detectSize, 99999, defectRgn);
		intersection (rgnErosion, defectRgn, &defectRgn);
		HTuple Area, Row_test, Column_test;
		area_center(defectRgn, &Area, &Row_test, &Column_test);
		//
		if(Area > 0)
		{
			retValue = Area[0].I();
			dilation_circle(defectRgn, &defectRgn, 2.5);
			m_vErrorRgn[rId] = defectRgn;
		}
		else
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::LineDetectionAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("425$\
					 397;R;FP;0;1000;4$\
					 381;B$\
					 643;FP;0.1;20;0.1;1.0$\
					 644;FP;0.1;20;0.1;3$\
					 645;FP;0.1;30;0.1;8$\
					 385;LP;-1;1;1;0$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：LineDetectionAlgo2
***功  能：通过Lines_gauss 算子进行线条的检测
***参  数：pDefectType ： 控制检测的类型：1--白线；-1--黑线；0--黑白线
***说  明：根据算子LineDetectionAlgo进行修改，加入了对缺陷形状的长宽比进行筛选
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::LineDetectionAlgo2(VARIANT* rgnId, VARIANT* pMaskSize, VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectType,VARIANT* pDefectShape,VARIANT* pDefectSize,VARIANT* pDefectArea)
{
	int rId           = (int)rgnId->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	double thredLow   = (double)pThredLow->fltVal;
	double thredUpper = (double)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+0.5;
	}
	int detectModel   = (int)pDefectType->fltVal;
	int detectSize   = (int)pDefectSize->fltVal;
	float defectShape   = (float)pDefectShape->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced, defectRgn;
		HTuple Length, maxLength;
		reduce_domain(crtImg, rgn, &imgReduced);
		//
		Hobject Lines, UnionContours, selectedContours,rgnErosion;
		if(detectModel==1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==-1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==0)
		{
			Hobject UnionContoursLight,UnionContoursDark;
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursLight, 10, 1, "attr_keep");

			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursDark, 10, 1, "attr_keep");

			concat_obj(UnionContoursLight,UnionContoursDark,&UnionContours);
		}
		erosion_circle(rgn, &rgnErosion, 2.5);
		ImageProcessAlg.LinesToRegion(UnionContours, detectSize, 99999, defectRgn);
		intersection (rgnErosion, defectRgn, &defectRgn);

		// 通过区域的长宽比对缺陷进行筛选
		HTuple dArea, dRow_test, dColumn_test;
		area_center(defectRgn, &dArea, &dRow_test, &dColumn_test);
		if ( dArea <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}

		Hobject defectRgnCon,rgnFin;
		HTuple  iNum;
		gen_empty_obj(&rgnFin );
		connection(defectRgn, &defectRgnCon);
		count_obj(defectRgnCon,&iNum);
		for ( int i = 1; i <= iNum;i++)
		{
			Hobject objSel;
			HTuple dRow,dCol,dPhi,dLen1,dLen2,dRate;
			select_obj(defectRgnCon,&objSel, i);
			smallest_rectangle2(objSel, &dRow,&dCol,&dPhi,&dLen1,&dLen2);
			dRate = dLen1/(dLen2*1.0);
			if (dRate >= defectShape )
			{
				concat_obj(rgnFin, objSel,&rgnFin);
			}
		}

		union1(rgnFin,&rgnFin);
		defectRgn = rgnFin;

		HTuple Area, Row_test, Column_test;
		area_center(defectRgn, &Area, &Row_test, &Column_test);
		//
		if(Area > 0)
		{
			retValue = Area[0].I();
			dilation_circle(defectRgn, &defectRgn, 2.5);
			m_vErrorRgn[rId] = defectRgn;
		}
		else
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::LineDetectionAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6111$\
					 397;R;FP;0;1000;4$\
					 381;B$\
					 643;FP;0.1;20;0.1;1.0$\
					 644;FP;0.1;20;0.1;3$\
					 645;FP;0.1;30;0.1;8$\
					 385;LP;-1;1;1;0$\
					 6110;FP;1;100;0.1;1$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：LineDetectionAlgo1
***功  能：通过Lines_gauss 算子进行线条的检测
***修  改：（1）在LineDetectionAlgo算子的基础上加上了加入了预处理操作（Scale_Image_Max）
***参  数：pDefectType ： 控制检测的类型：1--白线；-1--黑线；0--黑白线
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::LineDetectionAlgo1(VARIANT* rgnId, VARIANT* pMaskSize, VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectType,VARIANT* pDefectSize,VARIANT* pDefectArea)
{
	int rId           = (int)rgnId->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	double thredLow   = (double)pThredLow->fltVal;
	double thredUpper = (double)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+0.5;
	}
	int detectModel   = (int)pDefectType->fltVal;
	int detectSize   = (int)pDefectSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced, defectRgn,imgReducedScaled;
		HTuple Length, maxLength;
		reduce_domain(crtImg, rgn, &imgReduced);
		scale_image_max(imgReduced,&imgReducedScaled);
		//
		Hobject Lines, UnionContours, selectedContours,rgnErosion;
		if(detectModel==1)
		{
			lines_gauss (imgReducedScaled, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==-1)
		{
			lines_gauss (imgReducedScaled, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==0)
		{
			Hobject UnionContoursLight,UnionContoursDark;
			lines_gauss (imgReducedScaled, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursLight, 10, 1, "attr_keep");

			lines_gauss (imgReducedScaled, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursDark, 10, 1, "attr_keep");

			concat_obj(UnionContoursLight,UnionContoursDark,&UnionContours);
		}
		erosion_circle(rgn, &rgnErosion, 2.5);
		ImageProcessAlg.LinesToRegion(UnionContours, detectSize, 99999, defectRgn);
		intersection (rgnErosion, defectRgn, &defectRgn);
		HTuple Area, Row_test, Column_test;
		area_center(defectRgn, &Area, &Row_test, &Column_test);
		//
		if(Area > 0)
		{
			retValue = Area[0].I();
			dilation_circle(defectRgn, &defectRgn, 2.5);
			m_vErrorRgn[rId] = defectRgn;
		}
		else
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::LineDetectionAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6112$\
					 397;R;FP;0;1000;4$\
					 381;B$\
					 643;FP;0.1;20;0.1;1.0$\
					 644;FP;0.1;20;0.1;3$\
					 645;FP;0.1;30;0.1;8$\
					 385;LP;-1;1;1;0$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::GLineAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pBlackThredLow, VARIANT* pBlackDefectSize, VARIANT* pWhiteMaskSize, VARIANT* pWhiteThredLow, VARIANT* pWhiteDefectSize, VARIANT* pDetectArea)
{
	//盖面找线算法
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	m_vWhiteErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue         = -1;
		m_vErrorRgn[rId].Reset();
		m_vWhiteErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float BlackMaskSize = (float)pBlackMaskSize->fltVal;
	double BlackThredLow = (double)pBlackThredLow->fltVal;
	int BlackDefectSize = (int)pBlackDefectSize->fltVal;
	float WhiteMaskSize = (float)pWhiteMaskSize->fltVal;
	double WhiteThredLow = (double)pWhiteThredLow->fltVal;
	int WhiteDefectSize = (int)pWhiteDefectSize->fltVal;
	int BlackThredUpper = 8;
	int WhiteThredUpper = 8;
	int BlackDefectSizeUpper = 200;
	int WhiteDefectSizeUpper = 200;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ExpandedImage, DerivGauss, rgnErosion;
		reduce_domain (Image, rgn, &ImageReduced);
		expand_domain_gray(ImageReduced, &ExpandedImage, 2);
		//*===================================================================
		Hobject BlackLines, BlackUnion, WhiteLines, WhiteUnion;	
		reduce_domain(ExpandedImage, rgn, &ImageReduced);
		erosion_circle(rgn, &rgnErosion, 2.5);
		lines_gauss(ImageReduced, &BlackLines, BlackMaskSize, BlackThredLow, BlackThredUpper, "dark", "true", "bar-shaped", "true");
		ImageProcessAlg.LinesToRegion(BlackLines, BlackDefectSize, BlackDefectSizeUpper, BlackUnion);
		intersection (rgnErosion, BlackUnion, &BlackUnion);

		lines_gauss(ImageReduced, &WhiteLines, WhiteMaskSize, WhiteThredLow, WhiteThredUpper, "light", "true", "bar-shaped", "true");
		ImageProcessAlg.LinesToRegion(WhiteLines, WhiteDefectSize, WhiteDefectSizeUpper, WhiteUnion);
		intersection (rgnErosion, WhiteUnion, &WhiteUnion);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		m_vWhiteErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif

	return S_OK;
}
STDMETHODIMP CPlugAlgo::GLineAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("425$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 426;FP;0.1;20;0.1;1.1$\
					 427;FP;0;8;0.5;3$\
					 428;LP;1;200;1;10$\
					 429;FP;0.1;20;0.1;1.0$\
					 430;FP;0;8;0.5;3$\
					 431;LP;1;200;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::N_LineDetectionAlgo(VARIANT* rgnId, VARIANT* pMaskSize, VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectType,VARIANT* pDefectSize,VARIANT* pDefectArea)
{
	int rId           = (int)rgnId->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	double thredLow   = (double)pThredLow->fltVal;
	double thredUpper = (double)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+0.5;
	}
	int detectModel   = (int)pDefectType->fltVal;
	int detectSize   = (int)pDefectSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//区域为空，不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced, defectRgn;
		HTuple Length, maxLength;
		reduce_domain(crtImg, rgn, &imgReduced);
		//
		Hobject Lines, UnionContours, selectedContours,rgnErosion;
		if(detectModel==1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==-1)
		{
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContours, 10, 1, "attr_keep");
		}
		else if(detectModel==0)
		{
			Hobject UnionContoursLight,UnionContoursDark;
			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "light", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursLight, 10, 1, "attr_keep");

			lines_gauss (imgReduced, &Lines, maskSize, thredLow, thredUpper, "dark", "true", "bar-shaped", "true");
			union_adjacent_contours_xld (Lines, &UnionContoursDark, 10, 1, "attr_keep");

			concat_obj(UnionContoursLight,UnionContoursDark,&UnionContours);
		}
		erosion_circle(rgn, &rgnErosion, 2.5);
		ImageProcessAlg.LinesToRegion(UnionContours, detectSize, 99999, defectRgn);
		intersection (rgnErosion, defectRgn, &defectRgn);
		HTuple Area, Row_test, Column_test;
		area_center(defectRgn, &Area, &Row_test, &Column_test);
		//
		if(Area > 0)
		{
			retValue = Area[0].I();
			dilation_circle(defectRgn, &defectRgn, 2.5);
			m_vErrorRgn[rId] = defectRgn;
		}
		else
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::N_LineDetectionAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1221$\
					 397;R;FP;0;1000;4$\
					 381;B$\
					 643;FP;0.1;20;0.1;1.0$\
					 644;FP;0.1;20;0.1;3$\
					 645;FP;0.1;30;0.1;8$\
					 385;LP;-1;1;1;0$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::BlackDetectUseUpSizeAlgo(VARIANT* rgnId, VARIANT* pBlackThresh,VARIANT* pThredForeground,VARIANT* pWhiteSize,VARIANT* pSeriousBlackPointSize,VARIANT* pBlackPointUpSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int BlackThresh = (int)pBlackThresh->fltVal;
	int ThredForeground = (int) pThredForeground->fltVal;
	int WhiteSize = (int)pWhiteSize->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int BlackPointUpSize = (int)pBlackPointUpSize->fltVal;
	if (BlackPointUpSize<=SeriousBlackPointSize)
	{
		BlackPointUpSize=SeriousBlackPointSize+10;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean;
		//
		Hobject  ImageOpening;
		Hobject  RegionDynThresh;
		Hobject  RegionBlack, RegionUnion, ConnectedRegions,SelectedRegions;
		mean_image(Image,&Image,5,5);
		reduce_domain(Image, rgn, &ImageReduced);

		threshold(ImageReduced, &RegionBlack, 0, BlackThresh);
		connection(RegionBlack, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, BlackPointUpSize);
		union1(SelectedRegions, &RegionBlack);
		//排除拉环过低干扰
		Hobject RegionWhite,RegionFillUp,RegionErosion,RegionDilation;
		threshold (ImageReduced, &RegionWhite, ThredForeground,255)  ;   
		fill_up (RegionWhite, &RegionFillUp);
		erosion_rectangle1 (RegionFillUp, &RegionErosion, WhiteSize, 3);
		dilation_rectangle1 (RegionErosion, &RegionDilation,WhiteSize, 3);
		difference (RegionBlack, RegionDilation, &RegionBlack);
		//	
		connection(RegionBlack, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", SeriousBlackPointSize, BlackPointUpSize);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(BlackThresh));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple AbsoluteHisto, RelativeHisto, Length;
			gray_histo (rgn, Image, &AbsoluteHisto, &RelativeHisto);
			HTuple  maxValue = 0;
			tuple_max (AbsoluteHisto, &maxValue);
			tuple_length (AbsoluteHisto, &Length);
			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i=0; i< histoLength; i++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;	
		union1(SelectedRegions, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BlackDetectUseUpSizeAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("676$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 198;LP;1;250;1;60$\
					 649;LP;5;255;1;80$\
					 668;LP;5;360;1;170$\
					 416;LP;1;400;1;10$\
					 677;LP;1;8000;1;600");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************
***函数名：DerivateGaussDetectAlgo
***功  能：检测极黑极白点
***思  路：将输入图像与高斯导数进行卷积；对新得到的卷积图像进行阈值处理
**********************************************************************/
STDMETHODIMP CPlugAlgo::DerivateGaussDetectAlgo(VARIANT* rgnId,  VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		derivate_gauss(ImageReduced, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		//if (m_bDebugImg)
		//{
		//	m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
		//	m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
		//	HTuple AbsoluteHisto, RelativeHisto, Length;
		//	gray_histo (rgn, DerivGauss1, &AbsoluteHisto, &RelativeHisto);
		//	HTuple  maxValue = 0;
		//	tuple_max (AbsoluteHisto, &maxValue);
		//	tuple_length (AbsoluteHisto, &Length);
		//	float YRange = 100;
		//	float YScaleFactor = float(YRange/maxValue[0].D());
		//	int histoLength = Length[0].I();
		//	for (int i=0; i< histoLength; i++)
		//	{
		//		m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
		//	}
		//}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateGaussDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("678$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************
***函数名：DerivateGaussDetectAlgo1
***功  能：检测极白点
***思  路：将输入图像与高斯导数进行卷积；对新得到的卷积图像进行阈值处理
***修  改：（1）在原算子的基础上（DerivateGaussDetectAlgo）改变了高斯卷积的核函数并加入了腐蚀与膨胀操作
**********************************************************************/
STDMETHODIMP CPlugAlgo::DerivateGaussDetectAlgo1(VARIANT* rgnId, VARIANT* pMaskSize,VARIANT* pSmoothSize,VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	//int DefectType = (int)pDefectType->fltVal;
	//float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	//int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1,ImageResult,ImageClosing;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		derivate_gauss(ImageReduced, &DerivGauss, MaskSize, "xx");
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "gradient");

		gray_range_rect(DerivGauss1,&ImageResult,5,5);
		gray_closing_rect(ImageResult,&ImageClosing,7,7);

		//
		Hobject DefectRegs,rgnEro,rgnIntesct;
		HTuple Area, Row_test, Column_test;

		//*极白点
		threshold(ImageClosing, &WhiteRegion, SeriousWhitePointDynThresh,100);
		connection(WhiteRegion, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
		erosion_circle(rgn,&rgnEro,3.5);
		intersection(SelectedRegions2,rgnEro,&rgnIntesct);
		union1(rgnIntesct,&DefectRegs);

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateGaussDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("678$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************
***函数名：DerivateGaussDetectForAnnulusAlgo
***功  能：针对环形区域的检测极黑极白点
***思  路：将输入图像展开到极坐标下与高斯导数进行卷积；对新得到的卷积图像进行阈值处理
***时  间：2019年5月14日
***作  者：WuYifeng
**********************************************************************/
STDMETHODIMP CPlugAlgo::DerivateGaussDetectForAnnulusAlgo(VARIANT* rgnId, VARIANT* pFeatureToConv, VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	// get the annulus messsage
	HTuple dRadius,dRoiWidth;
	dRadius = m_ringPara[rId].m_Radius ;
	dRoiWidth = m_ringPara[rId].m_RoiWidth;

	// get the center of region 
	HTuple dCenterRow, dCenterColumn;
	dCenterRow = m_vPos[0].m_y;
	dCenterColumn = m_vPos[0].m_x;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if((rgn.Id() == H_EMPTY_REGION)||(area.Num()==0)||(area==0) || (dRoiWidth <= 0) || (dRadius <= 0))
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int FeatureToConv = (int) pFeatureToConv->fltVal;
	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		
		HTuple Width,Height;
		Hobject Image = m_crtImg;
		get_image_size(Image,&Width,&Height);

		//change to polar coordinate
		HTuple dRadiusInner,dExtendHeight,dExtendWidth;
		Hobject PolarTransImage;

		dRadiusInner = dRadius - dRoiWidth;
		dExtendHeight = dRoiWidth;
		dExtendWidth = (dRadius + dRadiusInner)/2.0 * 2*PI;
		polar_trans_image_ext(Image, &PolarTransImage, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, "nearest_neighbor");

		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		
		if ( FeatureToConv == 1)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "x");
		}
		else if (FeatureToConv == 2)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "y");
		}
		else if (FeatureToConv == 3)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "xx");
		}
		else if (FeatureToConv == 4)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "xy");
		}
		else if (FeatureToConv == 5)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "yy");
		}
		else
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		}
		
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}

		polar_trans_region_inv(DefectRegs, &DefectRegs, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, Width, Height, "nearest_neighbor");
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateGaussDetectForAnnulusAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5506$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 5507;LP;0;5;1;1$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************
***函数名：DerivateGaussDetectForAnnulusAlgo
***功  能：针对环形区域的检测极黑极白点
***思  路：将输入图像展开到极坐标下与高斯导数进行卷积；对新得到的卷积图像进行阈值处理
***说  明：根据算子DerivateGaussDetectForAnnulusAlgo进行修改，加入了缺陷的长宽比对形状进行筛选
***时  间：2019年8月9日
**********************************************************************/
STDMETHODIMP CPlugAlgo::DerivateGaussDetectForAnnulusAlgo1(VARIANT* rgnId, VARIANT* pFeatureToConv, VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pDefectShape, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	// get the center of region 
	HTuple dCenterRow, dCenterColumn;
	dCenterRow = m_vPos[0].m_y;
	dCenterColumn = m_vPos[0].m_x;

	// get the annulus messsage
	HTuple dRadius,dRoiWidth;
	dRadius = m_ringPara[rId].m_Radius ;
	dRoiWidth = m_ringPara[rId].m_RoiWidth;

	HTuple dMinDist,dMaxDist;
	distance_pr(rgn,dCenterRow,dCenterColumn,&dMinDist,&dMaxDist );
	dRadius = dMaxDist;
	dRoiWidth = dMaxDist - dMinDist;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if((rgn.Id() == H_EMPTY_REGION)||(area.Num()==0)||(area==0) || (dRoiWidth <= 0) || (dRadius <= 0))
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int FeatureToConv = (int) pFeatureToConv->fltVal;
	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	float defectShape   = (float) pDefectShape->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		
		HTuple Width,Height;
		Hobject Image = m_crtImg;
		get_image_size(Image,&Width,&Height);

		//change to polar coordinate
		HTuple dRadiusInner,dExtendHeight,dExtendWidth;
		Hobject PolarTransImage;

		dRadiusInner = dRadius - dRoiWidth;
		dExtendHeight = dRoiWidth;
		dExtendWidth = (dRadius + dRadiusInner)/2.0 * 2*PI;
		polar_trans_image_ext(Image, &PolarTransImage, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, "nearest_neighbor");

		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		
		if ( FeatureToConv == 1)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "x");
		}
		else if (FeatureToConv == 2)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "y");
		}
		else if (FeatureToConv == 3)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "xx");
		}
		else if (FeatureToConv == 4)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "xy");
		}
		else if (FeatureToConv == 5)
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "yy");
		}
		else
		{
			derivate_gauss(PolarTransImage, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		}
		
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}

		polar_trans_region_inv(DefectRegs, &DefectRegs, dCenterRow, dCenterColumn, 0, 6.5, dRadiusInner, dRadius, dExtendWidth, dExtendHeight, Width, Height, "nearest_neighbor");
		
		// 通过区域的长宽比对缺陷进行筛选
		HTuple dArea, dRow_test, dColumn_test;
		area_center(DefectRegs, &dArea, &dRow_test, &dColumn_test);
		if ( dArea <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}

		Hobject defectRgnCon,rgnFin;
		HTuple  iNum;
		gen_empty_obj(&rgnFin );
		connection(DefectRegs, &defectRgnCon);
		count_obj(defectRgnCon,&iNum);
		for ( int i = 1; i <= iNum;i++)
		{
			Hobject objSel;
			HTuple dRow,dCol,dPhi,dLen1,dLen2,dRate;
			select_obj(defectRgnCon,&objSel, i);
			smallest_rectangle2(objSel, &dRow,&dCol,&dPhi,&dLen1,&dLen2);
			dRate = dLen1/(dLen2*1.0);
			if (dRate >= defectShape )
			{
				concat_obj(rgnFin, objSel,&rgnFin);
			}
		}
		union1(rgnFin,&rgnFin);
		
		intersection(rgn,rgnFin,&DefectRegs );

		//DefectRegs = rgnFin;
		
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateGaussDetectForAnnulusAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6113$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 5507;LP;0;5;1;1$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10$\
					 6110;FP;1;100;0.1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void  CPlugAlgo:: GaussConvolution(Hobject imgSrc,Hobject& imgOut,HTuple iConvolWay,HTuple dConvolSize)
{
	if ( iConvolWay == 1)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "x");
	}
	else if (iConvolWay == 2)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "y");
	}
	else if (iConvolWay == 3)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "xx");
	}
	else if (iConvolWay == 4)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "xy");
	}
	else if (iConvolWay == 5)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "yy");
	}
	else if (iConvolWay == 6)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "kitchen_rosenfeld");
	}
	else if (iConvolWay == 7)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "gradient");
	}
	else if (iConvolWay == 0)
	{
		derivate_gauss(imgSrc, &imgOut, dConvolSize, "none");
	}
		
}
/*********************************************************************************
***函数名：DerivateGaussDetectFreeModelAlgo（高斯检测之自由模式）
***功  能：针对非环形区域的检测具有一定特征（弱特征），背景一致性高的区域进行检测
***思  路：将输入图像与高斯导数（自由选择）进行卷积；对新得到的卷积图像进行阈值处理
***时  间：2019年5月20日
***作  者：WuYifeng
*********************************************************************************/
STDMETHODIMP CPlugAlgo::DerivateGaussDetectFreeModelAlgo(VARIANT* rgnId, VARIANT* pFeatureToConv1, VARIANT* pMaskSize,VARIANT* pFeatureToConv2,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pMoveSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if((rgn.Id() == H_EMPTY_REGION)||(area.Num()==0)||(area==0))
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int MoveSize =(int)pMoveSize->fltVal;
	int FeatureToConv1 = (int) pFeatureToConv1->fltVal;
	int FeatureToConv2 = (int) pFeatureToConv2->fltVal;
	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(-pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		
		HTuple Width,Height;
		Hobject Image = m_crtImg;
		get_image_size(Image,&Width,&Height);
	
		Hobject ImageReduced, ImageReduceMean,imgExpand,ImageReduced1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);
		expand_domain_gray(ImageReduced,&imgExpand,15);
		reduce_domain(imgExpand,rgn,&ImageReduced1);
		
		Hobject imgResultGauss1,imgResultGauss2;
		GaussConvolution(ImageReduced1,imgResultGauss1,FeatureToConv1,MaskSize);
		GaussConvolution(imgResultGauss1,imgResultGauss2,FeatureToConv2,SmoothSize);

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==1)
		{
			//白色特征提取
			threshold(imgResultGauss2, &BlackRegion, SeriousWhitePointDynThresh, 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==-1)
		{
			//*黑色特征提取
			threshold(imgResultGauss2, &WhiteRegion, -100,SeriousBlackPointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*黑色特征提取
			threshold(imgResultGauss2, &BlackRegion,SeriousWhitePointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//白色特征提取
			threshold(imgResultGauss2, &WhiteRegion, -100, SeriousBlackPointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}

		Hobject rgnEro;
		erosion_circle(rgn,&rgnEro,2.5);
		intersection(DefectRegs,rgnEro,&DefectRegs);

		//m_FMpoints  m_ABEdgeM ，剔除覆膜边缘干扰
		HTuple Area7, Row5, Column3,Area8, Row6, Column5;
		Hobject RegionMoved,RegionDilation;
		area_center(m_FMpoints, &Area7, &Row5, &Column3);
		area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
		move_region(m_ABEdgeM, &RegionMoved, -(Row6-Row5), 0);
		dilation_rectangle1(RegionMoved, &RegionDilation, 1, 20);

		Hobject RemovedReg;
		move_region(RegionDilation,&RemovedReg,MoveSize,0);

		union1(DefectRegs,&DefectRegs);
		Hobject DefectRegs1;
		difference(DefectRegs,RemovedReg,&DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateGaussDetectFreeModelAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5520$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 5518;LP;0;7;1;1$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 5519;LP;0;7;1;0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;50$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;50$\
					 410;LP;1;200;1;10$\
					 6074;LP;-50;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::N_DerivateGaussDetectAlgo(VARIANT* rgnId,  VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//区域为空，不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		derivate_gauss(ImageReduced, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		//if (m_bDebugImg)
		//{
		//	m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
		//	m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
		//	HTuple AbsoluteHisto, RelativeHisto, Length;
		//	gray_histo (rgn, DerivGauss1, &AbsoluteHisto, &RelativeHisto);
		//	HTuple  maxValue = 0;
		//	tuple_max (AbsoluteHisto, &maxValue);
		//	tuple_length (AbsoluteHisto, &Length);
		//	float YRange = 100;
		//	float YScaleFactor = float(YRange/maxValue[0].D());
		//	int histoLength = Length[0].I();
		//	for (int i=0; i< histoLength; i++)
		//	{
		//		m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
		//	}
		//}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::N_DerivateGaussDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1146$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::GSurfaceAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("424$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 407;LP;1;999;1;100$\
					 408;LP;1;250;1;20$\
					 409;LP;1;999;1;999$\
					 410;LP;1;250;1;250");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::GSurfaceAlgo(VARIANT* rgnId, VARIANT* pBlackThred, VARIANT* pBlackAreaThred, VARIANT* pWhiteThred, VARIANT* pWhiteAreaThred, VARIANT* pDetectArea)
{
	//盖面垫模算法
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	Hobject imgRect;
	gen_rectangle1(&imgRect, 0, 0, m_imgHeight-1, m_imgWidth-1);
	intersection(imgRect, rgn, &rgn);
	int BlackThred = (int)pBlackThred->fltVal;
	int BlackArea = (int)pBlackAreaThred->fltVal;
	int WhiteThred = (int)pWhiteThred->fltVal;
	int WhiteArea = (int)pWhiteAreaThred->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ExpandedImage, DerivGauss,DerivGaussInver;
		reduce_domain (Image, rgn, &ImageReduced);
		expand_domain_gray(ImageReduced, &ExpandedImage, 2);
		derivate_gauss(ExpandedImage, &DerivGaussInver, 5, "mean_curvature");
		invert_image (DerivGaussInver, &DerivGauss);
		reduce_domain(DerivGauss, rgn, &ImageReduced);

		Hobject Regions1, ConnectedRegions1, SelectedRegions1, BlackUnion, WhiteUnion;
		threshold(ImageReduced, &Regions1, -1,(-1)* BlackThred/1000.0);
		connection(Regions1, &ConnectedRegions1);
		select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", BlackArea, 99999);
		union1(SelectedRegions1, &BlackUnion);

		Hobject Regions2, ConnectedRegions2, SelectedRegions2;
		threshold(ImageReduced, &Regions2, WhiteThred/1000.0 ,1);
		connection(Regions2, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and", WhiteArea, 99999);
		union1(SelectedRegions2, &WhiteUnion);
		if (m_bDebugImg)
		{
			HTuple Rows, Columns,Grayvals,Max,Min;
			get_region_points (rgn, &Rows, &Columns);        
			get_grayval (ImageReduced, Rows, Columns,& Grayvals);
			tuple_max (Grayvals, &Max) ;
			tuple_min (Grayvals, &Min);
			m_dictSpecialData[rId].push_back(float( (-1)*BlackThred) );
			m_dictSpecialData[rId].push_back(float(WhiteThred));
			m_dictSpecialData[rId].push_back(float(Min[0].D()*1000.0));
			m_dictSpecialData[rId].push_back(float(Max[0].D()*1000.0));
			HTuple Sum,Log,Prod,AbsoluteHisto, RelativeHisto, Length;
			Hobject ImageScaleMax;
			scale_image_max (ImageReduced, &ImageScaleMax);
			gray_histo (rgn, ImageScaleMax, &AbsoluteHisto, &RelativeHisto);   
			tuple_add (AbsoluteHisto,1, &Sum);
			tuple_log10 (Sum, &Log);   
			tuple_mult (Log, 100, &Prod);
			tuple_length (AbsoluteHisto, &Length);
			int histoLength = Length[0].I();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(Prod[i].D());
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(WhiteUnion, BlackUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif

	return S_OK;
}

STDMETHODIMP CPlugAlgo::SetCurrentTaskName(BSTR* bstrTaskName)
{
	// TODO: 在此添加实现代码

	return S_OK;
}
STDMETHODIMP CPlugAlgo::SetSelfLearningTargetTaskName(BSTR* bstrTaskName)
{
	// TODO: 在此添加实现代码

	return S_OK;
}

///plug 
STDMETHODIMP CPlugAlgo::EccentricityDetectAlgo(VARIANT* rgnId, VARIANT* pDistDiff)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||m_OutCircleRow.Num()!=1||m_OutCircleCol.Num()!=1||m_InnerCircleRow.Num()!=1||m_InnerCircleCol.Num()!=1)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDistDiff);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject InnerCircle,OutCircle,Line;
		gen_circle(&InnerCircle,m_InnerCircleRow,m_InnerCircleCol,5);
		gen_circle(&OutCircle,m_OutCircleRow,m_OutCircleCol,5);
		gen_region_line(&Line,m_InnerCircleRow,m_InnerCircleCol,m_OutCircleRow,m_OutCircleCol);

		HTuple DistDiff;
		distance_pp(m_InnerCircleRow,m_InnerCircleCol, m_OutCircleRow,m_OutCircleCol, &DistDiff);

		dilation_circle(Line,&Line,2);
		retValue = DistDiff[0].D();
		m_vErrorRgn[rId] = Line;	

		retValue.Detach(pDistDiff);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDistDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::EccentricityDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1025$\
					 397;R;FP;0;1000;1$\
					 381;B");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void  CPlugAlgo::ExtractEdgesPoints(Hobject Image, HTuple Elements, HTuple DetectHeight, HTuple DetectWidth, HTuple Sigma, HTuple Threshold, HTuple Transition, HTuple Select, 
	HTuple Row1, HTuple Column1,HTuple Row2, HTuple Column2, HTuple *ResultRow, HTuple *ResultColumn)
{
	HTuple Width,Height;
	get_image_size(Image, &Width, &Height);
	HTuple Deg,ATan,RowC,ColC;
	tuple_atan2((-Row2)+Row1, Column2-Column1, &ATan);
	ATan += HTuple(90).Rad();
	tuple_deg(ATan, &Deg);
	for (int i=1; i<=Elements; i++)
	{
		RowC = Row1+(((Row2-Row1)*i)/(Elements+1));
		ColC = Column1+(((Column2-Column1)*i)/(Elements+1));
		if ((RowC>(Height-1))||(RowC<0)||(ColC>(Width-1))||(ColC<0))
		{
			continue;
		}
		HTuple MsrHandle_Measure;
		gen_measure_rectangle2(RowC, ColC, Deg.Rad(), DetectHeight/2, DetectWidth/2, Width, Height, "nearest_neighbor", &MsrHandle_Measure);


		if (0 != (Transition==HTuple("negative")))
		{
			Transition = "negative";
		}
		else
		{
			if (0 != (Transition==HTuple("positive")))
			{

				Transition = "positive";
			}
			else
			{
				Transition = "all";
			}
		}

		if (0 != (Select==HTuple("first")))
		{
			Select = "first";
		}
		else
		{
			if (0 != (Select==HTuple("last")))
			{

				Select = "last";
			}
			else
			{
				Select = "all";
			}
		}
		HTuple RowEdge, ColEdge, Amplitude, Distance;
		measure_pos(Image, MsrHandle_Measure, Sigma, Threshold, Transition, Select, &RowEdge, &ColEdge, &Amplitude, &Distance);
		close_measure(MsrHandle_Measure);
		HTuple tRow = 0;
		HTuple tCol = 0;
		HTuple t = 0;
		HTuple Number;
		tuple_length(RowEdge, &Number);
		if (0 != (Number<1))
		{
			continue;
		}

		for (int j=0;j<=Number-1; j++)
		{
			if (0 != (((Amplitude.Select(j)).Abs())>t))
			{

				tRow = RowEdge.Select(j);
				tCol = ColEdge.Select(j);
				t = (Amplitude.Select(j)).Abs();
			}
		}

		if (0 != (t>0))
		{

			*ResultRow = (*ResultRow).Concat(tRow);
			*ResultColumn = (*ResultColumn).Concat(tCol);
		}
	}
}
void  CPlugAlgo::FitLineUseEdgesPoints(HTuple Rows,HTuple Cols,HTuple ActiveNum,HTuple *Row1,HTuple *Col1,HTuple *Row2,HTuple *Col2)
{
	Hobject  Contour; 
	HTuple  Length, Nr, Nc, Dist,Length1;
	*Row1 = 0;
	*Col1 = 0;
	*Row2 = 0;
	*Col2 = 0;
	tuple_length(Cols, &Length);
	if ((Length>=ActiveNum)&&(ActiveNum>1))
	{
		gen_contour_polygon_xld(&Contour, Rows, Cols);
		fit_line_contour_xld(Contour, "tukey", ActiveNum, 0, 5, 2, &(*Row1), &(*Col1), &(*Row2), &(*Col2), &Nr, &Nc, &Dist);
		tuple_length(Dist,&Length1);
		if (Length1<1)
		{
			return;
		}
	}
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
				Hobject Cross2Reg;
				if (Length4>2)
				{
					fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
					ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
					//gen_region_points(&Cross3,ResultRow3, ResultColumn3);
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

					gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
					gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
				}

				Hobject SelectedXLD2;
				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);

				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SortedContours5, &ObjectSelected9, 1);

						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross3Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("760$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：TotalHeightMeasureAlgo3
** 功    能：计算三个个矩形定义区域的总度（带正负，胶塞类型选择）
** 修改说明：一、 正负显示与矫正
**               内容：
**                    （1）开放一个参数：pRectifyValue，测量的修正值，范围 -0.5~0.5
**                    （2）修正误差值能够显示正负
**		              （3）加入像素当量选择项
**				 时间：2018年07月30日 
******************************************************************************************/
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo3(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pPlugType,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pRectifyValue,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	int   PlugType   = (int)pPlugType->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	float Graythresh    = (float)pGraythresh->fltVal;
	float fRectifyValue = (float)pRectifyValue->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
				Hobject Cross2Reg;
				if (Length4>2)
				{
					fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
					ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, Graythresh, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
					//gen_region_points(&Cross3,ResultRow3, ResultColumn3);
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

					gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
					gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
				}

				Hobject SelectedXLD2;
				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);

				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SortedContours5, &ObjectSelected9, 1);

						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh,  "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross3Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//选择像素当量
						if (PlugType == 32)
						{
							m_pixelSize =0.03291925466;
							retValue =ToTalHeight[0].D()*m_pixelSize-StdTotalHeight - fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal =  retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;
						}

						else if (PlugType == 20)
						{
							m_pixelSize =0.024766355;
							retValue =ToTalHeight[0].D()*m_pixelSize-StdTotalHeight - fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;
						}
						else if (PlugType == 200)
						{
							m_pixelSize =0.0209090909;
							retValue =ToTalHeight[0].D()*m_pixelSize-StdTotalHeight-fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		m_Value = retValue.fltVal;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6143$\
					 397;R;FP;-100;300;1$\
					 381;B$\
					 761;FP;1;50;0.01;8.8$\
					 1370;LP;0;500;1;32$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13$\
					 1369;FP;-0.5;0.5;0.001;0.000 ");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************************************
** 函 数 名：TotalHeightMeasureAlgo33
** 功    能：计算加塞总高度
** 修改说明：（1）根据算子TotalHeightMeasureAlgo3修改
             （2）针对胶塞冠部无圆点的情况，修改底部边缘点提取方法
** 时    间： 2018年11月13日
********************************************************************************************/
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo33(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pPlugType,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pRectifyValue,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	int   PlugType   = (int)pPlugType->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	float Graythresh    = (float)pGraythresh->fltVal;
	float fRectifyValue = (float)pRectifyValue->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);

			//**左下边缘点
			Hobject ImageReduced2,ExpandedImage1,ImageMean2,ImageReduced5,Regions1,ConnectedRegions1,SelectedRegions;
			HTuple LeftCol,Rows1, Columns,LeftRow,Indice;
			reduce_domain(ImageGuass, SelectObject1, &ImageReduced2);
			expand_domain_gray(ImageReduced2, &ExpandedImage1, 30);
			mean_image(ExpandedImage1, &ImageMean2, 1, 30);
			reduce_domain(ImageMean2, SelectObject1, &ImageReduced5);
			dyn_threshold(ImageReduced2, ImageReduced5, &Regions1, Graythresh, "light");
			connection(Regions1, &ConnectedRegions1);
			select_shape_std(ConnectedRegions1, &SelectedRegions, "max_area", 70);
			region_features(SelectedRegions, "column2", &LeftCol);
			tuple_int(LeftCol,&LeftCol);
			get_region_points(SelectedRegions, &Rows1, &Columns);
			if (Rows1.Num()<=2)
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			tuple_find(Columns, LeftCol, &Indice);
			if (Indice.Select(0)<1)
			{
				LeftRow = Rows1.Select(0);
			}
			else
			{
				LeftRow = Rows1.Select((Indice.Select(0))-1);
			}

			Hobject Cross1,Cross1Reg;
			gen_cross_contour_xld(&Cross1, LeftRow, LeftCol, 3, 0.785398);
			gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
			if(m_bDebugImg)
			{
				concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
			}
			//**
			select_obj(SortedRegions, &SelectObject2, 2);
			smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
			//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
			smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
			crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
			length_xld(UpCroppedContour, &Length6);
			count_obj(UpCroppedContour, &Number13);
			if (Number13<1)
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			tuple_sort_index(Length6, &Indices);
			select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
			HTuple Length4;
			length_xld(ObjectSelected12,&Length4);	
			Hobject Cross2Reg;
			if (Length4>2)
			{
				fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
				ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
				//gen_region_points(&Cross3,ResultRow3, ResultColumn3);
				FitLineUseEdgesPoints(ResultRow3, ResultColumn3, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

				gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
				gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			if(m_bDebugImg)
			{
				concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
			}

			Hobject SelectedXLD2;
			select_obj(SortedRegions, &SelectObject3, 3);

			//**右下边缘点
			Hobject ImageReduced3,ExpandedImage3,ImageMean,ImageReduced6,Regions2,ConnectedRegions2,SelectedRegions1;
			HTuple RightRow,RightCol,Rows2, Columns2,Indice1;
			reduce_domain(ImageGuass, SelectObject3, &ImageReduced3);
			expand_domain_gray(ImageReduced3, &ExpandedImage3, 30);

			mean_image(ExpandedImage3, &ImageMean, 1, 30);
			reduce_domain(ImageMean, SelectObject3, &ImageReduced6);
			dyn_threshold(ImageReduced3, ImageReduced6, &Regions2, Graythresh, "light");

			connection(Regions2, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &SelectedRegions1, "max_area", 70);
			region_features(SelectedRegions1, "column1", &RightCol);
			tuple_int(RightCol,&RightCol);

			get_region_points(SelectedRegions1, &Rows2, &Columns2);
			tuple_find(Columns2, RightCol, &Indice1);
			if (Rows2.Num()<=2)
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}

			if (Indice1.Select(0)<1)
			{
				RightRow = Rows2.Select(0);
			}
			else
			{
				RightRow = Rows2.Select((Indice1.Select(0))-1);
			}
			Hobject Cross3,Cross3Reg;
			gen_cross_contour_xld(&Cross3,RightRow, RightCol, 3, 0.785398);
			gen_region_contour_xld(Cross3,&Cross3Reg,"margin");
			if(m_bDebugImg)
			{
				concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
			}
			//***

			distance_pl(LeftRow, LeftCol, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
			distance_pl(RightRow, RightCol, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

			if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
			{
				tuple_mean(Distance1, &LeftDistance);
				ToTalHeight = LeftDistance;
			}
			else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
			{
				tuple_mean(Distance2, &RightDistance);
				ToTalHeight = RightDistance;
			}
			else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
			{
				tuple_mean(Distance1, &LeftDistance);
				tuple_mean(Distance2, &RightDistance);
				ToTalHeight = (LeftDistance+RightDistance)/2;
			}

			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			//选择像素当量
			if (PlugType == 32)
			{
				m_pixelSize =0.03291925466;
				retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight - fRectifyValue);
				retValue.ChangeType(VT_R4);
				if (retValue.fltVal<0)
				{
					retValue.fltVal =  retValue.fltVal - 10;
				}
				concat_obj(ErrorReg,rgn,&ErrorReg);
				m_vErrorRgn[rId] = ErrorReg;
			}

			else if (PlugType == 20)
			{
				m_pixelSize =0.024766355;
				retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight - fRectifyValue);
				retValue.ChangeType(VT_R4);
				if (retValue.fltVal<0)
				{
					retValue.fltVal = retValue.fltVal - 10;
				}
				concat_obj(ErrorReg,rgn,&ErrorReg);
				m_vErrorRgn[rId] = ErrorReg;
			}
			else if (PlugType == 200)
			{
				m_pixelSize =0.0209090909;
				retValue =ToTalHeight[0].D()*m_pixelSize-StdTotalHeight-fRectifyValue;
				retValue.ChangeType(VT_R4);
				if (retValue.fltVal<0)
				{
					retValue.fltVal = retValue.fltVal - 10;
				}
				concat_obj(ErrorReg,rgn,&ErrorReg);
				m_vErrorRgn[rId] = ErrorReg;	
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		m_Value = retValue.fltVal;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo33Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6144$\
					 397;R;FP;-100;300;1$\
					 381;B$\
					 761;FP;1;50;0.01;8.8$\
					 1370;LP;0;500;1;32$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13$\
					 1369;FP;-0.5;0.5;0.001;0.000 ");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo2(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
				Hobject Cross2Reg;
				if (Length4>2)
				{
					fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
					ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
					//gen_region_points(&Cross3,ResultRow3, ResultColumn3);
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

					gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
					gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
				}

				Hobject SelectedXLD2;
				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);

				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SortedContours5, &ObjectSelected9, 1);

						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross3Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6149$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**********************************************************************************************
**函数名：TotalHeightMeasureInjectorAlgo
**功  能：计算一种注射器胶塞的总高度度（根据算子2更新）
**说  明：(1)修改算子2的思路，对底部的边缘点拟合直线，作为基准线，求取上边缘Row最小点，计算距离
**时  间：2019年7月08日
************************************************************************************************/
STDMETHODIMP CPlugAlgo::TotalHeightMeasureInjectorAlgo(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		HTuple dRowSBaseLine,dColSBaseLine;
		dRowSBaseLine = HTuple();
		dColSBaseLine = HTuple();

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;

			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");

				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);

				Hobject RegionMid;
				HTuple RowsMid,ColumnsMid,RowsMidMean,ColumnsMidSorted,ColNumMid;
				gen_region_contour_xld(ObjectSelected12, &RegionMid, "filled");
				get_region_points(RegionMid, &RowsMid, &ColumnsMid);
				tuple_mean(RowsMid,&RowsMidMean);
				tuple_sort(ColumnsMid,&ColumnsMidSorted);
				ColNumMid=ColumnsMidSorted.Num();

				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
	
				if (Length4>2)
				{
					ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20, "all", "max", RowsMidMean,  ColumnsMidSorted.Select(1), RowsMidMean, ColumnsMidSorted.Select(ColNumMid-1), &ResultRow3, &ResultColumn3);
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				Hobject SelectedXLD2;
				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);

				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SortedContours5, &ObjectSelected9, 1);

						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
					
						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross3Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
						}

						dRowSBaseLine = dRowSBaseLine.Concat(dRowSBaseLine).Concat(ResultRow1).Concat(ResultRow4);
						dColSBaseLine = dColSBaseLine.Concat(dColSBaseLine).Concat(ResultColumn1).Concat(ResultColumn4);
						FitLineUseEdgesPoints(dRowSBaseLine, dColSBaseLine, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

						// choose the first four points ( row from up to down)
						HTuple IndexSort,IndexSel,ResultCol3Sel,ResultRow3Sel;
						if (ResultRow3.Num() > 4)
						{
							tuple_sort_index(ResultRow3,&IndexSort);
							tuple_select_range(IndexSort,0,3,&IndexSel);
							tuple_select(ResultRow3,IndexSel,&ResultRow3Sel);
							tuple_select(ResultColumn3,IndexSel,&ResultCol3Sel);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						
						Hobject rgnCorssMid,xldCorssMid;
						gen_cross_contour_xld(&xldCorssMid, ResultRow3Sel, ResultCol3Sel, 3, 0.785398);
				     	gen_region_contour_xld(xldCorssMid,&rgnCorssMid,"margin");

						if(m_bDebugImg)
				        {
				         	concat_obj (m_vRgn[rId], rgnCorssMid, &m_vRgn[rId]);
				        }

						distance_pl(ResultRow3Sel, ResultCol3Sel, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
		

						if (Distance1.Num()!=0)
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
				
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureInjectorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6098$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;13.7$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo1(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pDefectDiff)
{
	//测量算子带“1”表示为玻璃外端面涂黑的情况，影响靠近玻璃的边缘提取参数。
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	float Graythresh    = (float)pGraythresh->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
				Hobject Cross2Reg;
				if (Length4>2)
				{
					fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
					ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
					//gen_region_points(&Cross3,ResultRow3, ResultColumn3);
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, 15, &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);

					gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
					gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
				}

				Hobject SelectedXLD2;
				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);

				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SortedContours5, &ObjectSelected9, 1);

						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh,  "negative", "first", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross3Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross3Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TotalHeightMeasureAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1147$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ForkTotalHeightMeasureAlgo(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			//mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(imgReduced, &ExpandedImage, 3);		
			gauss_filter(ExpandedImage,&ImageGuass,5);

			reduce_domain(ImageGuass, rgn, &ImageReduced2);
			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);

			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");

				//******************************
				Hobject ContoursSplit;
				segment_contours_xld(UpCroppedContour, &ContoursSplit, "lines_circles", 5, 4, 2);
				HTuple pi,Eps;
				pi = (HTuple(0).Acos())*2;
				Eps = (pi*2)/20;
				Hobject SelectedContours;
				select_contours_xld(ContoursSplit, &SelectedContours, "direction", (pi*2)-Eps, (pi*2)+Eps, -0.5, 0.5);
				Hobject UnionContours1;
				union_adjacent_contours_xld(SelectedContours, &UnionContours1, 10, 1, "attr_keep");
				HTuple Number;
				count_obj(UnionContours1, &Number);

				if (0 != (Number<1))
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				HTuple Rows,Cols;
				Rows = HTuple();
				Cols = HTuple();

				Hobject defectRgn2,BaseLine2;
				gen_empty_region(&defectRgn2);

				Hobject ObjectSelected2,Cross2,BaseLineCross;
				HTuple Length8,ActiveNum,RowBegin3, ColBegin3, RowEnd3, ColEnd3, Nr3, Nc3, Dist3;
				HTuple LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd;

				int Num0=0;//用于判断不满足条件的提边轮廓
				for (int i=1;i<=Number;i++)
				{
					select_obj(UnionContours1, &ObjectSelected2, i);
					length_xld(ObjectSelected2, &Length8);
					if (0 != (Length8>=20))
					{
						ActiveNum = Length8/10;
						tuple_int(ActiveNum, &ActiveNum);
						fit_line_contour_xld(ObjectSelected2, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);

						ExtractEdgesPoints(ImageGuass, ActiveNum, 60, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
						FitLineUseEdgesPoints(ResultRow3, ResultColumn3, ActiveNum, &LBaseRowBegin,  &LBaseColBegin, &LBaseRowEnd, &LBaseColEnd);

						Hobject Cross2Reg;
						gen_cross_contour_xld(&Cross2, ResultRow3, ResultColumn3, 3, 0.785398);
						gen_region_contour_xld(Cross2,&Cross2Reg,"margin");
						concat_obj(defectRgn2,Cross2Reg,&defectRgn2);
						gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);

						if (0 != ((LBaseRowBegin.Num())!=0))
						{
							tuple_concat(LBaseRowBegin, Rows, &Rows);
							tuple_concat(LBaseColBegin, Cols, &Cols);

						}
					}
					else if (0 != (HTuple(Length8>=5).And(Length8<20)))
					{
						ActiveNum = Length8/2;
						tuple_int(ActiveNum, &ActiveNum);
						fit_line_contour_xld(ObjectSelected2, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);

						ExtractEdgesPoints(ImageGuass, ActiveNum, 60, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
						FitLineUseEdgesPoints(ResultRow3, ResultColumn3, ActiveNum, &LBaseRowBegin,  &LBaseColBegin, &LBaseRowEnd, &LBaseColEnd);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
						gen_region_contour_xld(Cross3,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);
						gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);

						if (0 != ((LBaseRowBegin.Num())!=0))
						{
							tuple_concat(LBaseRowBegin, Rows, &Rows);
							tuple_concat(LBaseColBegin, Cols, &Cols);
						}
					}
					else
					{
						//retValue = -1;
						//m_vErrorRgn[rId].Reset();
						//retValue.Detach(pDefectDiff);
						//return S_FALSE;
						Num0=Num0+1;
						continue;
					}

				}

				if (0 != (Num0==Number))
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				if (0 != ((Rows.Num())<2))
				{
					BaseRowBegin = LBaseRowBegin;
					BaseColBegin = LBaseColBegin;
					BaseRowEnd = LBaseRowEnd;
					BaseColEnd = LBaseColEnd;
					concat_obj(defectRgn2,BaseLine2,&BaseLineCross);

				}
				else
				{
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, Rows.Num(), &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);
					gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);
					concat_obj(defectRgn2,BaseLine2,&BaseLineCross);
				}

				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], BaseLineCross, &m_vRgn[rId]);
				}
				//*********************

				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SelectedXLD6, &ObjectSelected9, 1);
						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross4Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross4Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ForkTotalHeightMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1148$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ForkTotalHeightMeasureAlgo1(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pDefectDiff)
{
	//测量算子带“1”表示为玻璃外端面涂黑的情况，影响靠近玻璃的边缘提取参数。
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	float Graythresh    = (float)pGraythresh->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance;
		HTuple  Distance2, RightDistance, ToTalHeight,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==3))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			//mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(imgReduced, &ExpandedImage, 3);		
			gauss_filter(ExpandedImage,&ImageGuass,5);

			reduce_domain(ImageGuass, rgn, &ImageReduced2);
			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);

			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			if (0 != (Length2>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					sort_contours_xld(SelectedXLD, &SortedContours4, "upper_left",  "true", "row");
					select_obj(SortedContours4, &ObjectSelected8, 1);
					//
					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					//fit_line_contour_xld(ObjectSelected8, "tukey", -1, 0, 5, 2, &RowBegin1, &ColBegin1, &RowEnd1, &ColEnd1, &Nr1, &Nc1, &Dist1);					
					//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin1,  ColBegin1, RowEnd1, ColEnd1, &ResultRow1, &ResultColumn1);
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}

				select_obj(SortedRegions, &SelectObject2, 2);
				smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				//inner_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
				smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");

				//******************************
				Hobject ContoursSplit;
				segment_contours_xld(UpCroppedContour, &ContoursSplit, "lines_circles", 5, 4, 2);
				HTuple pi,Eps;
				pi = (HTuple(0).Acos())*2;
				Eps = (pi*2)/20;
				Hobject SelectedContours;
				select_contours_xld(ContoursSplit, &SelectedContours, "direction", (pi*2)-Eps, (pi*2)+Eps, -0.5, 0.5);
				Hobject UnionContours1;
				union_adjacent_contours_xld(SelectedContours, &UnionContours1, 10, 1, "attr_keep");
				HTuple Number;
				count_obj(UnionContours1, &Number);

				if (0 != (Number<1))
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				HTuple Rows,Cols;
				Rows = HTuple();
				Cols = HTuple();

				Hobject defectRgn2,BaseLine2;
				gen_empty_region(&defectRgn2);

				Hobject ObjectSelected2,Cross2,BaseLineCross;
				HTuple Length8,ActiveNum,RowBegin3, ColBegin3, RowEnd3, ColEnd3, Nr3, Nc3, Dist3;
				HTuple LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd;

				int Num0=0;//用于判断不满足条件的提边轮廓
				for (int i=1;i<=Number;i++)
				{
					select_obj(UnionContours1, &ObjectSelected2, i);
					length_xld(ObjectSelected2, &Length8);
					if (0 != (Length8>=20))
					{
						ActiveNum = Length8/10;
						tuple_int(ActiveNum, &ActiveNum);
						fit_line_contour_xld(ObjectSelected2, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);

						ExtractEdgesPoints(ImageGuass, ActiveNum, 60, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
						FitLineUseEdgesPoints(ResultRow3, ResultColumn3, ActiveNum, &LBaseRowBegin,  &LBaseColBegin, &LBaseRowEnd, &LBaseColEnd);

						Hobject Cross2Reg;
						gen_cross_contour_xld(&Cross2, ResultRow3, ResultColumn3, 3, 0.785398);
						gen_region_contour_xld(Cross2,&Cross2Reg,"margin");
						concat_obj(defectRgn2,Cross2Reg,&defectRgn2);
						gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);

						if (0 != ((LBaseRowBegin.Num())!=0))
						{
							tuple_concat(LBaseRowBegin, Rows, &Rows);
							tuple_concat(LBaseColBegin, Cols, &Cols);

						}
					}
					else if (0 != (HTuple(Length8>=5).And(Length8<20)))
					{
						ActiveNum = Length8/2;
						tuple_int(ActiveNum, &ActiveNum);
						fit_line_contour_xld(ObjectSelected2, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);

						ExtractEdgesPoints(ImageGuass, ActiveNum, 60, 5, 1, 20, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);
						FitLineUseEdgesPoints(ResultRow3, ResultColumn3, ActiveNum, &LBaseRowBegin,  &LBaseColBegin, &LBaseRowEnd, &LBaseColEnd);

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
						gen_region_contour_xld(Cross3,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);
						gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);

						if (0 != ((LBaseRowBegin.Num())!=0))
						{
							tuple_concat(LBaseRowBegin, Rows, &Rows);
							tuple_concat(LBaseColBegin, Cols, &Cols);
						}
					}
					else
					{
						//retValue = -1;
						//m_vErrorRgn[rId].Reset();
						//retValue.Detach(pDefectDiff);
						//return S_FALSE;
						Num0=Num0+1;
						continue;
					}

				}

				if (0 != (Num0==Number))
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				if (0 != ((Rows.Num())<2))
				{
					BaseRowBegin = LBaseRowBegin;
					BaseColBegin = LBaseColBegin;
					BaseRowEnd = LBaseRowEnd;
					BaseColEnd = LBaseColEnd;
					concat_obj(defectRgn2,BaseLine2,&BaseLineCross);

				}
				else
				{
					FitLineUseEdgesPoints(ResultRow3, ResultColumn3, Rows.Num(), &BaseRowBegin,  &BaseColBegin, &BaseRowEnd, &BaseColEnd);
					gen_region_line(&BaseLine2, LBaseRowBegin,  LBaseColBegin, LBaseRowEnd, LBaseColEnd);
					concat_obj(defectRgn2,BaseLine2,&BaseLineCross);
				}

				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], BaseLineCross, &m_vRgn[rId]);
				}
				//*********************

				select_obj(SortedRegions, &SelectObject3, 3);
				smallest_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				//inner_rectangle1(SelectObject3, &Row17, &Column16, &Row27,  &Column26);
				smallest_rectangle2(SelectObject3, &Row5, &Column5, &Phi2, &Length11,  &Length21);
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;
				if (0 != (Length21>5))
				{
					crop_contours_xld(Edges1, &RightCroppedContours, Row17+5, Column16+3,  Row27-5, Column26-3, "false");
					//
					union_adjacent_contours_xld(RightCroppedContours, &RightCroppedContours, 10, 1, "attr_keep");  
					crop_contours_xld(RightCroppedContours, &RightCroppedContours, Row17+5, Column16+5, Row27-5, Column26-5, "false");
					gen_region_contour_xld(RightCroppedContours, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours,Row17+5, Column16+3, Row27-5, Column26-3, "false");

					select_shape_xld(RightCroppedContours, &SelectedXLD6, "contlength", "and", Length21-5, 999999);
					count_obj(SelectedXLD6, &Number10);
					if (0 != (Number10>=1))
					{
						sort_contours_xld(SelectedXLD6, &SortedContours5, "upper_left", "true", "row");
						select_obj(SelectedXLD6, &ObjectSelected9, 1);
						//
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected9, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow4, &ResultColumn4);
						}
						//fit_line_contour_xld(ObjectSelected9, "tukey", -1, 0, 5, 2, &RowBegin4, &ColBegin4, &RowEnd4, &ColEnd4, &Nr4, &Nc4, &Dist4);
						//ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin4,  ColBegin4, RowEnd4, ColEnd4, &ResultRow4, &ResultColumn4);

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross4, ResultRow4, ResultColumn4, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross4Reg,"margin");

						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross4Reg, &m_vRgn[rId]);
						}

						distance_pl(ResultRow1, ResultColumn1, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance1);
						distance_pl(ResultRow4, ResultColumn4, BaseRowBegin, BaseColBegin,  BaseRowEnd, BaseColEnd, &Distance2);

						if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())==0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							ToTalHeight = LeftDistance;
						}
						else if (0 != (HTuple((Distance1.Num())==0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = RightDistance;
						}
						else if (0 != (HTuple((Distance1.Num())!=0).And((Distance2.Num())!=0)))
						{
							tuple_mean(Distance1, &LeftDistance);
							tuple_mean(Distance2, &RightDistance);
							ToTalHeight = (LeftDistance+RightDistance)/2;
						}

						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						//
						retValue =abs(ToTalHeight[0].D()*m_pixelSize-StdTotalHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ForkTotalHeightMeasureAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1149$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}

						if (0 != (((Rows1Mean1-RowsMean1).Abs())<60))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<60))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;					
					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("764$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 765;FP;1;30;0.01;3.3$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo2(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}

						if (0 != (((Rows1Mean1-RowsMean1).Abs())<60))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<60))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;					
					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6150$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 765;FP;1;30;0.01;3.3$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************
**函数名：CrownHeightMeasureAlgo3
**功  能：计算胶塞的冠部厚度（根据算子2更新）
**说  明： (1)开放一个参数：pRectifyValue，测量的修正值，范围 -0.5~0.5
**         (2) 修正误差值能够显示正负
**         (3) 加入像素当量选择项
**时  间：2018年7月30日
**************************************************************************************/
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo3(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pPlugType,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pRectifyValue,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	float fRectifyValue = (float)pRectifyValue->fltVal;
	int   PlugType = (int)pPlugType->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}

						if (0 != (((Rows1Mean1-RowsMean1).Abs())<60))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);

							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<60))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						if (PlugType == 32)
						{
							m_pixelSize =0.03291925466;
							retValue =Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal= retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}

						else if (PlugType == 20)
						{
							m_pixelSize =0.024766355;
							retValue =Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}
						else if (PlugType == 200)
						{
							m_pixelSize =0.0209090909;
							retValue =Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		m_Value = retValue.fltVal;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6145$\
					 397;R;FP;-100;300;1$\
					 381;B$\
					 765;FP;1;50;0.01;3.3$\
					 1370;LP;0;500;1;32$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1369;FP;-0.5;0.5;0.001;0.000 ");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************************
**函数名：CrownHeightMeasureAlgo33
**功  能：计算胶塞的冠部厚度（根据算子3更新）
**说  明： (1)针对胶塞冠部无圆点的情况，修改底部边缘点提取方法
**时  间：2018年11月13日
**************************************************************************************/
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo33(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pPlugType,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pRectifyValue,VARIANT* pDefectDiff)
{ 
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	float Graythresh    = (float)pGraythresh->fltVal;
	float fRectifyValue = (float)pRectifyValue->fltVal;
	int   PlugType = (int)pPlugType->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=1))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}

						if (0 != (((Rows1Mean1-RowsMean1).Abs())<60))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);
					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					//**左下边缘拐点
					Hobject RectLeft;
					gen_rectangle1(&RectLeft, (Row110+Row210)/2, Column19, Row210, Column29);
					Hobject ImageReduced2,ExpandedImage1,ImageMean2,ImageReduced5,Regions1,ConnectedRegions1,SelectedRegions;
					HTuple LeftCol,Rows11, Columns11,LeftRow,Indice;
					reduce_domain(ImageGuass, RectLeft, &ImageReduced2);
					expand_domain_gray(ImageReduced2, &ExpandedImage1, 30);
					mean_image(ExpandedImage1, &ImageMean2, 1, 30);
					reduce_domain(ImageMean2, RectLeft, &ImageReduced5);
					dyn_threshold(ImageReduced2, ImageReduced5, &Regions1, Graythresh, "light");
					connection(Regions1, &ConnectedRegions1);
					select_shape_std(ConnectedRegions1, &SelectedRegions, "max_area", 70);
					region_features(SelectedRegions, "column2", &LeftCol);
					tuple_int(LeftCol,&LeftCol);

					get_region_points(SelectedRegions, &Rows11, &Columns11);
					if (Rows11.Num()<=2)
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
					tuple_find(Columns11, LeftCol, &Indice);
					if (Indice.Select(0)<1)
					{
						LeftRow = Rows11.Select(0);
					}
					else
					{
						LeftRow = Rows11.Select((Indice.Select(0))-1);
					}					

					Hobject Cross2,Cross2Reg;
					gen_cross_contour_xld(&Cross2, LeftRow, LeftCol, 3, 0.785398);
					gen_region_contour_xld(Cross2,&Cross2Reg,"margin");
					//**

					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl( LeftRow, LeftCol, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=1))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<60))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);

						//**右下边缘拐点
						Hobject RectRight;
						gen_rectangle1(&RectRight, (Row111+Row211)/2, Column110, Row210, Column210);

						Hobject ImageReduced3,ExpandedImage3,ImageMean,ImageReduced6,Regions2,ConnectedRegions2,SelectedRegions1;
						HTuple RightRow,RightCol,Rows2, Columns2,Indice1;
						reduce_domain(ImageGuass, RectRight, &ImageReduced3);
						expand_domain_gray(ImageReduced3, &ExpandedImage3, 30);

						mean_image(ExpandedImage3, &ImageMean, 1, 30);
						reduce_domain(ImageMean, RectRight, &ImageReduced6);
						dyn_threshold(ImageReduced3, ImageReduced6, &Regions2, Graythresh, "light");

						connection(Regions2, &ConnectedRegions2);
						select_shape_std(ConnectedRegions2, &SelectedRegions1, "max_area", 70);
						region_features(SelectedRegions1, "column1", &RightCol);
						tuple_int(RightCol,&RightCol);

						get_region_points(SelectedRegions1, &Rows2, &Columns2);
						tuple_find(Columns2, RightCol, &Indice1);
						if (Rows2.Num()<=2)
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						if (Indice1.Select(0)<1)
						{
							RightRow = Rows2.Select(0);
						} 
						else
						{
							RightRow = Rows2.Select((Indice1.Select(0))-1);
						}

						Hobject Cross4,Cross4Reg;
						gen_cross_contour_xld(&Cross4,RightRow, RightCol, 3, 0.785398);
						gen_region_contour_xld(Cross4,&Cross4Reg,"margin");
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], Cross4Reg, &m_vRgn[rId]);
						}
						//***

						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(RightRow, RightCol, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						if (PlugType == 32)
						{
							m_pixelSize =0.03291925466;
							retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue);
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal= retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}

						else if (PlugType == 20)
						{
							m_pixelSize =0.024766355;
							retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue);
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}
						else if (PlugType == 200)
						{
							m_pixelSize =0.0209090909;
							retValue =Gheight[0].D()*m_pixelSize-StdCrownHeight-fRectifyValue;
							retValue.ChangeType(VT_R4);
							if (retValue.fltVal<0)
							{
								retValue.fltVal = retValue.fltVal - 10;
							}
							concat_obj(ErrorReg,rgn,&ErrorReg);
							m_vErrorRgn[rId] = ErrorReg;	
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		m_Value = retValue.fltVal;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo33Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6146$\
					 397;R;FP;-100;300;1$\
					 381;B$\
					 765;FP;1;50;0.01;3.3$\
					 1370;LP;0;500;1;32$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13$\
					 1369;FP;-0.5;0.5;0.001;0.000 ");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo1(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pDefectDiff)
{
	//测量算子带“1”表示为玻璃外端面涂黑的情况，影响靠近玻璃的边缘提取参数。
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	float Graythresh    = (float)pGraythresh->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}

						if (0 != (((Rows1Mean1-RowsMean1).Abs())<60))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 40, 5, 1, Graythresh, "positive", "first", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<60))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 40, 5, 1, Graythresh, "positive", "first", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;					
					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1150$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 765;FP;1;30;0.01;3.3$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CrownHeightMeasureSAlgo(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	//测量13单叉
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}
						//13型胶塞时，参数设定为30
						if (0 != (((Rows1Mean1-RowsMean1).Abs())<30))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<30))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;					
					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureSAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1150$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 765;FP;1;30;0.01;3.3$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CrownHeightMeasureSAlgo1(VARIANT* rgnId,  VARIANT* pStdCrownHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pGraythresh,VARIANT* pDefectDiff)
{
	//测量13单叉
	//测量算子带“1”表示为玻璃外端面涂黑的情况，影响靠近玻璃的边缘提取参数。
	int rId           = (int)rgnId->fltVal;
	float StdCrownHeight   = (float)pStdCrownHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;

	float Graythresh    = (float)pGraythresh->fltVal;

	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges,ConnectedRegions;

		Hobject  Edges2, ConnectedRegions1, SortedRegions1;
		Hobject  ObjectSelected2, LeftCroppedContours1, SelectedXLD1;
		Hobject  SortedContours1, ObjectSelected3,Cross5, ObjectSelected4;
		Hobject  Cross6, ObjectSelected5, RightCroppedContours1;
		Hobject  SelectedXLD2, SortedContours2, ObjectSelected6;
		Hobject  Cross7, ObjectSelected7, Cross8;
		Hobject  SortedContours6, ObjectSelected10,SortedContours7, ObjectSelected11;

		HTuple  Row110, Column19, Row210, Column29,Number1;
		HTuple  Number2, RowBegin5, ColBegin5, RowEnd5;
		HTuple  ColEnd5, Nr5, Nc5, Dist5, ResultRow5;
		HTuple  ResultColumn5, BaseRow111, BaseCol11, BaseRow211;
		HTuple  BaseCol21, Phi3, RowBegin6, ColBegin6;
		HTuple  RowEnd6, ColEnd6, Nr6, Nc6, Dist6;
		HTuple  ResultRow6, ResultColumn6, Distance3, LeftDistance3;
		HTuple  Row111, Column110, Row211, Column210;
		HTuple  Row1, Column1, Phi, Length1, Length2;
		HTuple  Number3, Phi4, RowBegin7, ColBegin7;
		HTuple  RowEnd7, ColEnd7, Nr7, Nc7, Dist7;
		HTuple  ResultRow7, ResultColumn7, BaseRow112;
		HTuple  BaseRow212, Phi5, RowBegin8, ColBegin8;
		HTuple  RowEnd8, ColEnd8, Nr8, Nc8, Dist8;
		HTuple  ResultRow8, ResultColumn8, Distance4, RightDistance4,Gheight;
		HTuple  Row6, Column6, Phi10,Length12, Length22, Number11, Row8;
		HTuple  Column8, Phi12, Length14, Length24,Number12;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		Hobject ImageMean,ImageReduced;
		if (0 != (Number1==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced,&ImageMean,7,1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage,rgn,&ImageReduced);

			gauss_filter(imgReduced,&ImageGuass,5);
			edges_sub_pix(ImageReduced, &Edges2, "canny", maskSize, thredLow, thredUpper);
			//
			Hobject ErrorReg,Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//
			count_obj(Edges2, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges2, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			Hobject defectRgn1;
			gen_empty_obj(&defectRgn1);

			sort_region(ConnectedRegions1, &SortedRegions1, "upper_left", "true",  "column");
			select_obj(SortedRegions1, &ObjectSelected2, 1);
			smallest_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			//inner_rectangle1(ObjectSelected2, &Row110, &Column19, &Row210,  &Column29);
			smallest_rectangle2(ObjectSelected2, &Row6, &Column6, &Phi10,  &Length12, &Length22);
			Hobject SelectedXLD,SelectedXLD3;
			//ROI宽度至少要大于10个像素
			if (0 != (Length22>5))
			{
				crop_contours_xld(Edges2, &LeftCroppedContours1, Row110+5, Column19+2,  Row210-5, Column29-2, "false");
				union_adjacent_contours_xld(LeftCroppedContours1,&LeftCroppedContours1,10,1,"attr_keep");

				crop_contours_xld(LeftCroppedContours1, &LeftCroppedContours1, Row110+5, Column19+5, Row210-5, Column29-5, "false");

				Hobject LeftRegion,LeftRegionDialtion,LeftRegionUnion,LeftSkeleton,LeftContours;
				gen_region_contour_xld(LeftCroppedContours1,&LeftRegion,"filled");
				dilation_rectangle1(LeftRegion,&LeftRegionDialtion,5,1);
				union1(LeftRegionDialtion,&LeftRegionUnion);
				skeleton(LeftRegionUnion,&LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton,&LeftContours,"center");
				crop_contours_xld(LeftContours, &LeftCroppedContours1, Row110+5, Column19+3,  Row210-5, Column29-3, "false");

				select_shape_xld(LeftCroppedContours1, &SelectedXLD1, "contlength",  "and", Length22-5, 999999);
				count_obj(SelectedXLD1, &Number11);
				if (0 != (Number11>=2))
				{
					sort_contours_xld(SelectedXLD1, &SortedContours6, "upper_left",  "true", "row");

					Hobject Region1,ObjectSelected;
					HTuple Rows1,Columns1,RowsMean1,Rows1Mean1,ObjSelect11;
					gen_region_contour_xld(SortedContours6,&Region1,"filled");
					for (int Index1=1;Index1<=Number11;Index1++)
					{
						select_obj(Region1, &ObjectSelected, Index1);
						get_region_points(ObjectSelected, &Rows1, &Columns1);
						tuple_mean(Rows1, &RowsMean1);
						if (0 != (Index1==1))
						{
							Rows1Mean1 = RowsMean1;

						}
						//13型胶塞时，参数设定为30
						if (0 != (((Rows1Mean1-RowsMean1).Abs())<30))
						{
							ObjSelect11 = 1;

						}
						else
						{
							ObjSelect11 = Index1;
						}
						if (0 != (ObjSelect11!=1))
						{
							break;
						}
					}	
					//select_obj(SortedContours6, &ObjectSelected10, (HTuple(1).Append(2)));
					select_obj(SortedContours6, &ObjectSelected3, 1);				
					Hobject Region;
					HTuple Rows, Columns,RowsMean,ColumnsSorted,ColNum;
					gen_region_contour_xld(ObjectSelected3, &Region, "filled");
					get_region_points(Region, &Rows, &Columns);
					tuple_mean(Rows, &RowsMean);
					tuple_sort(Columns, &ColumnsSorted);
					ColNum = Columns.Num();
					//fit_line_contour_xld(SelectedXLD, "tukey", -1, 0, 5, 2, &RowBegin5,  &ColBegin5, &RowEnd5, &ColEnd5, &Nr5, &Nc5, &Dist5);	
					if (ColNum>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 40, 5, 1, Graythresh, "positive", "first", RowsMean,  ColumnsSorted.Select(1), RowsMean, ColumnsSorted.Select(ColNum-1), &ResultRow5, &ResultColumn5);				
					}

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross5, ResultRow5, ResultColumn5, 3, 0.785398);
					gen_region_contour_xld(Cross5,&Cross1Reg,"margin");
					concat_obj(defectRgn1,Cross1Reg,&defectRgn1);

					FitLineUseEdgesPoints(ResultRow5, ResultColumn5, 8, &BaseRow111,  &BaseCol11, &BaseRow211, &BaseCol21);

					select_obj(SortedContours6, &ObjectSelected4, ObjSelect11);
					Hobject Region3;
					HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
					gen_region_contour_xld(ObjectSelected4, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3, &RowsMean3);
					tuple_sort(Columns3, &Columns3Sorted);
					ColNum3 = Columns3.Num();				
					//fit_line_contour_xld(SelectedXLD3, "tukey", -1, 0, 5, 2, &RowBegin6,  &ColBegin6, &RowEnd6, &ColEnd6, &Nr6, &Nc6, &Dist6);
					if (ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow6, &ResultColumn6);				
					}
					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross6, ResultRow6, ResultColumn6, 3, 0.785398);
					gen_region_contour_xld(Cross6,&Cross2Reg,"margin");
					concat_obj(defectRgn1,Cross2Reg,&defectRgn1);	
					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], defectRgn1, &m_vRgn[rId]);
					}

					distance_pl(ResultRow6, ResultColumn6, BaseRow111, BaseCol11,  BaseRow211, BaseCol21, &Distance3);	
					if (0 != (Distance3.Num()))
					{
						tuple_mean(Distance3, &LeftDistance3);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}


				Hobject defectRgn2;
				gen_empty_obj(&defectRgn2);

				select_obj(SortedRegions1, &ObjectSelected5, 2);
				smallest_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				//inner_rectangle1(ObjectSelected5, &Row111, &Column110, &Row211,  &Column210);
				smallest_rectangle2(ObjectSelected5, &Row8, &Column8, &Phi12, &Length14, &Length24);
				Hobject SelectedXLD4,SelectedXLD5;
				Hobject RightRegion,RightRegionDilation,RightRegionUnion,RightSkeleton,RightContours;

				if (0 != (Length24>5))
				{
					crop_contours_xld(Edges2, &RightCroppedContours1, Row111+5, Column110+2, Row211-5, Column210-2, "false");					
					union_adjacent_contours_xld(RightCroppedContours1, &RightCroppedContours1,10, 1, "attr_keep");
					crop_contours_xld(RightCroppedContours1, &RightCroppedContours1, Row111+5, Column110+5, Row211-5, Column210-5, "false");

					gen_region_contour_xld(RightCroppedContours1, &RightRegion, "filled");
					dilation_rectangle1(RightRegion, &RightRegionDilation, 5, 1);
					union1(RightRegionDilation, &RightRegionUnion);
					skeleton(RightRegionUnion, &RightSkeleton);
					gen_contour_region_xld(RightSkeleton, &RightContours, "center");
					crop_contours_xld(RightContours, &RightCroppedContours1, Row111+5,Column110+3, Row211-5, Column210-3, "false");						
					select_shape_xld(RightCroppedContours1, &SelectedXLD2, "contlength", "and", Length24-5, 999999);					
					count_obj(SelectedXLD2, &Number12);
					Hobject Region2,ObjectSelected;
					HTuple Index2,Rows2, Columns2,RowsMean2,Rows2Mean1,ObjSelect22;
					if (0 != (Number12>=2))
					{
						sort_contours_xld(SelectedXLD2, &SortedContours7, "upper_left", "true", "row");
						gen_region_contour_xld(SortedContours7, &Region2, "filled");
						for (int Index2=1;Index2<=Number12;Index2++)
						{
							select_obj(Region2, &ObjectSelected, Index2);


							get_region_points(ObjectSelected, &Rows2, &Columns2);
							tuple_mean(Rows2, &RowsMean2);
							if (0 != (Index2==1))
							{
								Rows2Mean1 = RowsMean2;

							}
							if (0 != (((Rows2Mean1-RowsMean2).Abs())<30))
							{
								ObjSelect22 = 1;
							}
							else
							{
								ObjSelect22 = Index2;
							}
							if (0 != (ObjSelect22!=1))
							{
								break;
							}
						}					
						//select_obj(SortedContours7, &ObjectSelected11, (HTuple(1).Append(2)));						
						select_obj(SortedContours7, &ObjectSelected6, 1);
						Hobject Region4;
						HTuple Rows4, Columns4,RowsMean4,Columns4Sorted,ColNum4;
						gen_region_contour_xld(ObjectSelected6, &Region4, "filled");
						get_region_points(Region4, &Rows4, &Columns4);
						tuple_mean(Rows4, &RowsMean4);
						tuple_sort(Columns4, &Columns4Sorted);
						ColNum4 = Columns4.Num();
						//fit_line_contour_xld(SelectedXLD4, "tukey", -1, 0, 5, 2, &RowBegin7, &ColBegin7, &RowEnd7, &ColEnd7, &Nr7, &Nc7, &Dist7);
						if (ColNum4>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 40, 5, 1, Graythresh, "positive", "first", RowsMean4, Columns4Sorted.Select(1), RowsMean4, Columns4Sorted.Select(ColNum4-1), &ResultRow7, &ResultColumn7);
						}

						Hobject Cross3Reg;
						gen_cross_contour_xld(&Cross7, ResultRow7, ResultColumn7, 3, 0.785398);
						gen_region_contour_xld(Cross7,&Cross3Reg,"margin");
						concat_obj(defectRgn2,Cross3Reg,&defectRgn2);

						FitLineUseEdgesPoints(ResultRow7, ResultColumn7, 8, &BaseRow112, &BaseCol11, &BaseRow212, &BaseCol21);
						select_obj(SortedContours7, &ObjectSelected7, ObjSelect22);
						Hobject Region5;
						HTuple Rows5, Columns5,Columns5Sorted,RowsMean5,ColNum5;
						gen_region_contour_xld(ObjectSelected7, &Region5, "filled");
						get_region_points(Region5, &Rows5, &Columns5);
						tuple_sort(Columns5, &Columns5Sorted);
						tuple_mean(Rows5, &RowsMean5);
						ColNum5 = Columns5.Num();						
						//fit_line_contour_xld(SelectedXLD5, "tukey", -1, 0, 5, 2, &RowBegin8,  &ColBegin8, &RowEnd8, &ColEnd8, &Nr8, &Nc8, &Dist8);
						if (ColNum5>1)
						{
							ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, Graythresh, "negative", "first", RowsMean5,  Columns5Sorted.Select(1), RowsMean5, Columns5Sorted.Select(ColNum5-1), &ResultRow8, &ResultColumn8);				
						}

						Hobject Cross4Reg;
						gen_cross_contour_xld(&Cross8, ResultRow8, ResultColumn8, 3, 0.785398);
						gen_region_contour_xld(Cross8,&Cross4Reg,"margin");
						concat_obj(defectRgn2,Cross4Reg,&defectRgn2);
						if(m_bDebugImg)
						{
							concat_obj (m_vRgn[rId], defectRgn2, &m_vRgn[rId]);
						}

						distance_pl(ResultRow8, ResultColumn8, BaseRow112, BaseCol11,  BaseRow212, BaseCol21, &Distance4);
						if (0 != (Distance4.Num()))
						{
							tuple_mean(Distance4, &RightDistance4);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}
						Gheight = (LeftDistance3+RightDistance4)/2;
						//
						retValue =abs(Gheight[0].D()*m_pixelSize-StdCrownHeight);
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;					
					}
				}
			}		
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownHeightMeasureSAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1151$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 765;FP;1;30;0.01;3.3$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40$\
					 1136;FP;5;30;0.5;13");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::DiameterMeasureAlgo(VARIANT* rgnId,  VARIANT* pStdDiameter,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdDiameter   = (float)pStdDiameter->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;

		Hobject  ExpandedImage,ConnectedRegions,ImageGuass, Edges;
		Hobject  CroppedContours, SelectedXLD,Rectangle1,ConnectedRegions1;
		Hobject  SortedContours, ObjectSelected, Regions1;
		Hobject  Cross, ObjectSelected1, Regions2,Cross2;
		Hobject  SortedContours3, ObjectSelected8;

		HTuple  Length,Number,Number1, RowBegin, ColBegin, RowEnd;
		HTuple  ColEnd, Nr, Nc, Dist, ResultRow;
		HTuple  ResultColumn, Row11, Col1, Row21, Col2;
		HTuple  RowBegin2, ColBegin2, RowEnd2, ColEnd2;
		HTuple  Nr2, Nc2, Dist2, ResultRow2, ResultColumn2,Distance;
		HTuple  Row113, Column112, Row213;
		HTuple  Column212, Row7, Column7, Phi11, Length13;
		HTuple  Length23, Number8, Diameter;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		if (0 != (Number1==1))
		{
			smallest_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			//inner_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			smallest_rectangle2(rgn, &Row7, &Column7, &Phi11,  &Length13, &Length23);
			Hobject ImageReduced2,ImageMean;
			if (0 != (Length23>5))
			{
				reduce_domain(crtImg, rgn, &imgReduced);
				mean_image(imgReduced, &ImageMean, 1, 7);
				expand_domain_gray(ImageMean, &ExpandedImage, 3);
				reduce_domain(ExpandedImage, rgn, &ImageReduced2);

				gauss_filter(imgReduced,&ImageGuass,5);
				edges_sub_pix(ImageReduced2, &Edges, "canny", maskSize, thredLow, thredUpper);
				//
				Hobject ErrorReg,Region,ObjectSelected2;
				HTuple Number3,XRow, XCol;
				//gen_region_contour_xld(Edges1,&Reg, "margin");
				//
				count_obj(Edges, &Number3);
				if (Number3>=1)
				{
					gen_empty_region(&ErrorReg);
					for (int a=1; a<=Number3[0].I(); a++)
					{
						select_obj(Edges, &ObjectSelected2, a);
						get_contour_xld(ObjectSelected2, &XRow, &XCol);
						gen_region_points(&Region, XRow, XCol);
						concat_obj(ErrorReg, Region, &ErrorReg);
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				crop_contours_xld(Edges, &CroppedContours, Row113+5, Column112,  Row213-5, Column212, "false");				
				//提取两端xld
				length_xld(CroppedContours, &Length);
				select_shape_xld(CroppedContours, &SelectedXLD, "contlength", "and", Length23-5, 999999);
				sort_contours_xld(SelectedXLD, &SortedContours3, "upper_left", "true",  "column");

				count_obj(SortedContours3, &Number8);
				select_obj(SortedContours3, &ObjectSelected8, HTuple(1).Concat(Number8));
				//
				count_obj(ObjectSelected8, &Number);
				Hobject SelectedXLD1,SelectedXLD2;

				if (0 != (Number==2))
				{
					sort_contours_xld(ObjectSelected8, &SortedContours, "upper_left",  "true", "column");
					select_obj(SortedContours, &ObjectSelected, 1);
					Hobject ContoursSplit,SortedContours1;
					HTuple Number1;
					segment_contours_xld(ObjectSelected, &ContoursSplit, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit, &SortedContours1, "upper_left", "true", "column");
					count_obj(SortedContours1, &Number1);
					select_obj(SortedContours1, &SelectedXLD1, 1);
					//
					HTuple SelectedXLD1Length;
					length_xld(SelectedXLD1,&SelectedXLD1Length);

					fit_line_contour_xld(SelectedXLD1, "tukey", -1, 0, 5, 2, &RowBegin,  &ColBegin, &RowEnd, &ColEnd, &Nr, &Nc, &Dist);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin,  ColBegin, RowEnd, ColEnd, &ResultRow, &ResultColumn);

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross, ResultRow, ResultColumn, 3, 0.785398);
					gen_region_contour_xld(Cross,&Cross1Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
					}

					HTuple Row1Base,  Col1Base, Row2Base, Col2Base;
					FitLineUseEdgesPoints(ResultRow, ResultColumn, 8, &Row1Base,  &Col1Base, &Row2Base, &Col2Base);

					select_obj(SortedContours, &ObjectSelected1, 2);
					Hobject ContoursSplit1,SortedContours2;
					HTuple Number2;
					segment_contours_xld(ObjectSelected1, &ContoursSplit1, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit1, &SortedContours2, "upper_left", "true", "column");
					count_obj(SortedContours2, &Number2);
					select_obj(SortedContours2, &SelectedXLD2, Number2);
					//
					HTuple SelectedXLD2Length;
					length_xld(SelectedXLD2,&SelectedXLD2Length);

					fit_line_contour_xld(SelectedXLD2, "tukey", -1, 0, 5, 2, &RowBegin2,  &ColBegin2, &RowEnd2, &ColEnd2, &Nr2, &Nc2, &Dist2);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin2,  ColBegin2, RowEnd2, ColEnd2, &ResultRow2, &ResultColumn2);

					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross2, ResultRow2, ResultColumn2, 3, 0.785398);
					gen_region_contour_xld(Cross2,&Cross2Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
					}

					HTuple Row3Base,  Col3Base, Row4Base, Col4Base;
					FitLineUseEdgesPoints(ResultRow2, ResultColumn2, 8, &Row3Base,  &Col3Base, &Row4Base, &Col4Base);
					//
					if (0 != ((SelectedXLD1Length-SelectedXLD2Length)>10))
					{
						distance_pl(ResultRow2, ResultColumn2, Row1Base, Col1Base, Row2Base, Col2Base, &Distance);

					}
					else if (0 != ((SelectedXLD1Length-SelectedXLD2Length)<-10))
					{
						distance_pl(ResultRow, ResultColumn, Row3Base, Col3Base, Row4Base, Col4Base, &Distance);
					}
					else
					{
						if (ResultRow.Num()==ResultRow2.Num())
						{
							distance_pp(ResultRow, ResultColumn, ResultRow2, ResultColumn2, &Distance);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
					if (0 != (Distance.Num()))
					{
						tuple_mean(Distance, &Diameter);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
					retValue =abs(Diameter[0].D()*m_pixelSize-StdDiameter);
					concat_obj(ErrorReg,rgn,&ErrorReg);
					m_vErrorRgn[rId] = ErrorReg;
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DiameterMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("766$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 767;FP;1;30;0.01;18.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：DiameterMeasureAlgo3
** 功    能：计算一个矩形区域宽度（带正负，胶塞类型选择）
** 修改说明：一、 正负显示与矫正
**               内容：
**                    （1）开放一个参数：pRectifyValue，测量的修正值，范围 -0.5~0.5
**                    （2）修正误差值能够显示正负
**		              （3）加入像素当量选择项
**				 时间：2018年07月30日 
******************************************************************************************/
STDMETHODIMP CPlugAlgo::DiameterMeasureAlgo3(VARIANT* rgnId,  VARIANT* pStdDiameter,VARIANT* pPlugType,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pRectifyValue,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdDiameter   = (float)pStdDiameter->fltVal;
	int PlugType   = (int)pPlugType->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	float fRectifyValue = (float)pRectifyValue->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;

		Hobject  ExpandedImage,ConnectedRegions,ImageGuass, Edges;
		Hobject  CroppedContours, SelectedXLD,Rectangle1,ConnectedRegions1;
		Hobject  SortedContours, ObjectSelected, Regions1;
		Hobject  Cross, ObjectSelected1, Regions2,Cross2;
		Hobject  SortedContours3, ObjectSelected8;

		HTuple  Length,Number,Number1, RowBegin, ColBegin, RowEnd;
		HTuple  ColEnd, Nr, Nc, Dist, ResultRow;
		HTuple  ResultColumn, Row11, Col1, Row21, Col2;
		HTuple  RowBegin2, ColBegin2, RowEnd2, ColEnd2;
		HTuple  Nr2, Nc2, Dist2, ResultRow2, ResultColumn2,Distance;
		HTuple  Row113, Column112, Row213;
		HTuple  Column212, Row7, Column7, Phi11, Length13;
		HTuple  Length23, Number8, Diameter;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		if (0 != (Number1==1))
		{
			smallest_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			//inner_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			smallest_rectangle2(rgn, &Row7, &Column7, &Phi11,  &Length13, &Length23);
			Hobject ImageReduced2,ImageMean;
			if (0 != (Length23>5))
			{
				reduce_domain(crtImg, rgn, &imgReduced);
				mean_image(imgReduced, &ImageMean, 1, 7);
				expand_domain_gray(ImageMean, &ExpandedImage, 3);
				reduce_domain(ExpandedImage, rgn, &ImageReduced2);

				gauss_filter(imgReduced,&ImageGuass,5);
				edges_sub_pix(ImageReduced2, &Edges, "canny", maskSize, thredLow, thredUpper);
				//
				Hobject ErrorReg,Region,ObjectSelected2;
				HTuple Number3,XRow, XCol;
				//gen_region_contour_xld(Edges1,&Reg, "margin");
				//
				count_obj(Edges, &Number3);
				if (Number3>=1)
				{
					gen_empty_region(&ErrorReg);
					for (int a=1; a<=Number3[0].I(); a++)
					{
						select_obj(Edges, &ObjectSelected2, a);
						get_contour_xld(ObjectSelected2, &XRow, &XCol);
						gen_region_points(&Region, XRow, XCol);
						concat_obj(ErrorReg, Region, &ErrorReg);
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				crop_contours_xld(Edges, &CroppedContours, Row113+5, Column112,  Row213-5, Column212, "false");				
				//提取两端xld
				length_xld(CroppedContours, &Length);
				select_shape_xld(CroppedContours, &SelectedXLD, "contlength", "and", Length23-5, 999999);
				sort_contours_xld(SelectedXLD, &SortedContours3, "upper_left", "true",  "column");

				count_obj(SortedContours3, &Number8);
				select_obj(SortedContours3, &ObjectSelected8, HTuple(1).Concat(Number8));
				//
				count_obj(ObjectSelected8, &Number);
				Hobject SelectedXLD1,SelectedXLD2;

				if (0 != (Number==2))
				{
					sort_contours_xld(ObjectSelected8, &SortedContours, "upper_left",  "true", "column");
					select_obj(SortedContours, &ObjectSelected, 1);
					Hobject ContoursSplit,SortedContours1;
					HTuple Number1;
					segment_contours_xld(ObjectSelected, &ContoursSplit, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit, &SortedContours1, "upper_left", "true", "column");
					count_obj(SortedContours1, &Number1);
					select_obj(SortedContours1, &SelectedXLD1, 1);
					//
					HTuple SelectedXLD1Length;
					length_xld(SelectedXLD1,&SelectedXLD1Length);

					fit_line_contour_xld(SelectedXLD1, "tukey", -1, 0, 5, 2, &RowBegin,  &ColBegin, &RowEnd, &ColEnd, &Nr, &Nc, &Dist);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin,  ColBegin, RowEnd, ColEnd, &ResultRow, &ResultColumn);

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross, ResultRow, ResultColumn, 3, 0.785398);
					gen_region_contour_xld(Cross,&Cross1Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
					}

					HTuple Row1Base,  Col1Base, Row2Base, Col2Base;
					FitLineUseEdgesPoints(ResultRow, ResultColumn, 8, &Row1Base,  &Col1Base, &Row2Base, &Col2Base);

					select_obj(SortedContours, &ObjectSelected1, 2);
					Hobject ContoursSplit1,SortedContours2;
					HTuple Number2;
					segment_contours_xld(ObjectSelected1, &ContoursSplit1, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit1, &SortedContours2, "upper_left", "true", "column");
					count_obj(SortedContours2, &Number2);
					select_obj(SortedContours2, &SelectedXLD2, Number2);
					//
					HTuple SelectedXLD2Length;
					length_xld(SelectedXLD2,&SelectedXLD2Length);

					fit_line_contour_xld(SelectedXLD2, "tukey", -1, 0, 5, 2, &RowBegin2,  &ColBegin2, &RowEnd2, &ColEnd2, &Nr2, &Nc2, &Dist2);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin2,  ColBegin2, RowEnd2, ColEnd2, &ResultRow2, &ResultColumn2);

					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross2, ResultRow2, ResultColumn2, 3, 0.785398);
					gen_region_contour_xld(Cross2,&Cross2Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
					}

					HTuple Row3Base,  Col3Base, Row4Base, Col4Base;
					FitLineUseEdgesPoints(ResultRow2, ResultColumn2, 8, &Row3Base,  &Col3Base, &Row4Base, &Col4Base);
					//
					if (0 != ((SelectedXLD1Length-SelectedXLD2Length)>10))
					{
						distance_pl(ResultRow2, ResultColumn2, Row1Base, Col1Base, Row2Base, Col2Base, &Distance);

					}
					else if (0 != ((SelectedXLD1Length-SelectedXLD2Length)<-10))
					{
						distance_pl(ResultRow, ResultColumn, Row3Base, Col3Base, Row4Base, Col4Base, &Distance);
					}
					else
					{
						if (ResultRow.Num()==ResultRow2.Num())
						{
							distance_pp(ResultRow, ResultColumn, ResultRow2, ResultColumn2, &Distance);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
					if (0 != (Distance.Num()))
					{
						tuple_mean(Distance, &Diameter);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}

					if (PlugType == 32)
					{
						m_pixelSize =0.03291925466;
						retValue = Diameter[0].D()*m_pixelSize-StdDiameter - fRectifyValue;
						retValue.ChangeType(VT_R4);
						if (retValue.fltVal<0)
						{
							retValue.fltVal = retValue.fltVal - 10;
						}

						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
					else if (PlugType == 20)
					{
						m_pixelSize =0.024766355;
						retValue = Diameter[0].D()*m_pixelSize-StdDiameter - fRectifyValue;
						retValue.ChangeType(VT_R4);

						if (retValue.fltVal<0)
						{
							retValue.fltVal = retValue.fltVal - 10;
						}
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;
					}
					else if (PlugType == 200)
					{
						m_pixelSize =0.0209090909;
						retValue =Diameter[0].D()*m_pixelSize-StdDiameter-fRectifyValue;
						retValue.ChangeType(VT_R4);
						if (retValue.fltVal<0)
						{
							retValue.fltVal = retValue.fltVal - 10;
						}
						concat_obj(ErrorReg,rgn,&ErrorReg);
						m_vErrorRgn[rId] = ErrorReg;	
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}


				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		m_Value = retValue.fltVal;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DiameterMeasureAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6147$\
					 397;R;FP;-100;300;1$\
					 381;B$\
					 767;FP;1;50;0.01;18.8$\
					 1370;LP;1;500;1;32 $\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40 $\
					 1369;FP;-0.5;0.5;0.001;0.000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::DiameterMeasureAlgo2(VARIANT* rgnId,  VARIANT* pStdDiameter,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdDiameter   = (float)pStdDiameter->fltVal;
	//float PixelSize   = (float)pPixelSize->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;

		Hobject  ExpandedImage,ConnectedRegions,ImageGuass, Edges;
		Hobject  CroppedContours, SelectedXLD,Rectangle1,ConnectedRegions1;
		Hobject  SortedContours, ObjectSelected, Regions1;
		Hobject  Cross, ObjectSelected1, Regions2,Cross2;
		Hobject  SortedContours3, ObjectSelected8;

		HTuple  Length,Number,Number1, RowBegin, ColBegin, RowEnd;
		HTuple  ColEnd, Nr, Nc, Dist, ResultRow;
		HTuple  ResultColumn, Row11, Col1, Row21, Col2;
		HTuple  RowBegin2, ColBegin2, RowEnd2, ColEnd2;
		HTuple  Nr2, Nc2, Dist2, ResultRow2, ResultColumn2,Distance;
		HTuple  Row113, Column112, Row213;
		HTuple  Column212, Row7, Column7, Phi11, Length13;
		HTuple  Length23, Number8, Diameter;

		connection(rgn, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number1);
		if (0 != (Number1==1))
		{
			smallest_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			//inner_rectangle1(rgn, &Row113, &Column112, &Row213, &Column212);
			smallest_rectangle2(rgn, &Row7, &Column7, &Phi11,  &Length13, &Length23);
			Hobject ImageReduced2,ImageMean;
			if (0 != (Length23>5))
			{
				reduce_domain(crtImg, rgn, &imgReduced);
				mean_image(imgReduced, &ImageMean, 1, 7);
				expand_domain_gray(ImageMean, &ExpandedImage, 3);
				reduce_domain(ExpandedImage, rgn, &ImageReduced2);

				gauss_filter(imgReduced,&ImageGuass,5);
				edges_sub_pix(ImageReduced2, &Edges, "canny", maskSize, thredLow, thredUpper);
				//
				Hobject ErrorReg,Region,ObjectSelected2;
				HTuple Number3,XRow, XCol;
				//gen_region_contour_xld(Edges1,&Reg, "margin");
				//
				count_obj(Edges, &Number3);
				if (Number3>=1)
				{
					gen_empty_region(&ErrorReg);
					for (int a=1; a<=Number3[0].I(); a++)
					{
						select_obj(Edges, &ObjectSelected2, a);
						get_contour_xld(ObjectSelected2, &XRow, &XCol);
						gen_region_points(&Region, XRow, XCol);
						concat_obj(ErrorReg, Region, &ErrorReg);
					}
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}

				crop_contours_xld(Edges, &CroppedContours, Row113+5, Column112,  Row213-5, Column212, "false");				
				//提取两端xld
				length_xld(CroppedContours, &Length);
				select_shape_xld(CroppedContours, &SelectedXLD, "contlength", "and", Length23-5, 999999);
				sort_contours_xld(SelectedXLD, &SortedContours3, "upper_left", "true",  "column");

				count_obj(SortedContours3, &Number8);
				select_obj(SortedContours3, &ObjectSelected8, HTuple(1).Concat(Number8));
				//
				count_obj(ObjectSelected8, &Number);
				Hobject SelectedXLD1,SelectedXLD2;

				if (0 != (Number==2))
				{
					sort_contours_xld(ObjectSelected8, &SortedContours, "upper_left",  "true", "column");
					select_obj(SortedContours, &ObjectSelected, 1);
					Hobject ContoursSplit,SortedContours1;
					HTuple Number1;
					segment_contours_xld(ObjectSelected, &ContoursSplit, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit, &SortedContours1, "upper_left", "true", "column");
					count_obj(SortedContours1, &Number1);
					select_obj(SortedContours1, &SelectedXLD1, 1);
					//
					HTuple SelectedXLD1Length;
					length_xld(SelectedXLD1,&SelectedXLD1Length);

					fit_line_contour_xld(SelectedXLD1, "tukey", -1, 0, 5, 2, &RowBegin,  &ColBegin, &RowEnd, &ColEnd, &Nr, &Nc, &Dist);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin,  ColBegin, RowEnd, ColEnd, &ResultRow, &ResultColumn);

					Hobject Cross1Reg;
					gen_cross_contour_xld(&Cross, ResultRow, ResultColumn, 3, 0.785398);
					gen_region_contour_xld(Cross,&Cross1Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
					}

					HTuple Row1Base,  Col1Base, Row2Base, Col2Base;
					FitLineUseEdgesPoints(ResultRow, ResultColumn, 8, &Row1Base,  &Col1Base, &Row2Base, &Col2Base);

					select_obj(SortedContours, &ObjectSelected1, 2);
					Hobject ContoursSplit1,SortedContours2;
					HTuple Number2;
					segment_contours_xld(ObjectSelected1, &ContoursSplit1, "lines_circles", 5, 4, 2);
					sort_contours_xld(ContoursSplit1, &SortedContours2, "upper_left", "true", "column");
					count_obj(SortedContours2, &Number2);
					select_obj(SortedContours2, &SelectedXLD2, Number2);
					//
					HTuple SelectedXLD2Length;
					length_xld(SelectedXLD2,&SelectedXLD2Length);

					fit_line_contour_xld(SelectedXLD2, "tukey", -1, 0, 5, 2, &RowBegin2,  &ColBegin2, &RowEnd2, &ColEnd2, &Nr2, &Nc2, &Dist2);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 20, "all", "max", RowBegin2,  ColBegin2, RowEnd2, ColEnd2, &ResultRow2, &ResultColumn2);

					Hobject Cross2Reg;
					gen_cross_contour_xld(&Cross2, ResultRow2, ResultColumn2, 3, 0.785398);
					gen_region_contour_xld(Cross2,&Cross2Reg,"margin");

					if(m_bDebugImg)
					{
						concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
					}

					HTuple Row3Base,  Col3Base, Row4Base, Col4Base;
					FitLineUseEdgesPoints(ResultRow2, ResultColumn2, 8, &Row3Base,  &Col3Base, &Row4Base, &Col4Base);
					//
					if (0 != ((SelectedXLD1Length-SelectedXLD2Length)>10))
					{
						distance_pl(ResultRow2, ResultColumn2, Row1Base, Col1Base, Row2Base, Col2Base, &Distance);

					}
					else if (0 != ((SelectedXLD1Length-SelectedXLD2Length)<-10))
					{
						distance_pl(ResultRow, ResultColumn, Row3Base, Col3Base, Row4Base, Col4Base, &Distance);
					}
					else
					{
						if (ResultRow.Num()==ResultRow2.Num())
						{
							distance_pp(ResultRow, ResultColumn, ResultRow2, ResultColumn2, &Distance);
						}
						else
						{
							retValue = -1;
							m_vErrorRgn[rId].Reset();
							retValue.Detach(pDefectDiff);
							return S_FALSE;
						}

					}
					if (0 != (Distance.Num()))
					{
						tuple_mean(Distance, &Diameter);
					}
					else
					{
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pDefectDiff);
						return S_FALSE;
					}
					retValue =abs(Diameter[0].D()*m_pixelSize-StdDiameter);
					concat_obj(ErrorReg,rgn,&ErrorReg);
					m_vErrorRgn[rId] = ErrorReg;
				}
			}
		}
		else
		{
			retValue = 100.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DiameterMeasureAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6151$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 767;FP;1;30;0.01;18.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::HeightMeasureAlgo(VARIANT* rgnId, VARIANT* pStdTotalHeight,VARIANT* pMaskSize,VARIANT* pThredLow, VARIANT* pThredUpper,VARIANT* pDefectDiff)
{
	int rId           = (int)rgnId->fltVal;
	float StdTotalHeight    = (float)pStdTotalHeight->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int thredLow   = (int)pThredLow->fltVal;
	int thredUpper = (int)pThredUpper->fltVal;
	if(thredUpper<=thredLow)
	{
		thredUpper=thredLow+3;
	}
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		Hobject imgReduced;
		Hobject ExpandedImage,ImageGuass,Edges;

		Hobject  Edges1, ConnectedRegions, SortedRegions;
		Hobject  SelectObject1, LeftCroppedContours, SelectedXLD3;
		Hobject  Cross1, SelectObject2, UpCroppedContour,Cross3;
		Hobject  SelectObject3, RightCroppedContours;
		Hobject  SelectedXLD, SortedContours4;
		Hobject  ObjectSelected8, ObjectSelected12, SelectedXLD6;
		Hobject  SortedContours5, ObjectSelected9,Cross4,ErrorReg;

		HTuple  Number4, Row15, Column14;
		HTuple  Row25, Column24, Number5, RowBegin1;
		HTuple  ColBegin1, RowEnd1, ColEnd1, Nr1, Nc1;
		HTuple  Dist1, ResultRow1, ResultColumn1, Row16;
		HTuple  Column15, Row26, Column25, Number6;
		HTuple  RowBegin3, ColBegin3, RowEnd3, ColEnd3;
		HTuple  Nr3, Nc3, Dist3, ResultRow3, ResultColumn3;
		HTuple  BaseRowBegin, BaseColBegin, BaseRowEnd;
		HTuple  BaseColEnd, Row17, Column16, Row27;
		HTuple  Column26, Number7, RowBegin4, ColBegin4;
		HTuple  RowEnd4, ColEnd4, Nr4, Nc4, Dist4;
		HTuple  ResultRow4, ResultColumn4, Distance1, LeftDistance,Distance;
		HTuple  Distance2, RightDistance, Height,Row4;
		HTuple  Column4, Phi, Length1, Length2, Number9;
		HTuple  Row9, Column9, Phi13, Length15, Length25;
		HTuple  Length6, Number13, Indices, Row5, Column5;
		HTuple  Phi2, Length11, Length21, Number10;

		connection(rgn, &ConnectedRegions);
		count_obj(ConnectedRegions, &Number4);
		Hobject ImageReduced2,ImageMean;

		if (0 != (Number4==2))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			HTuple LongLength,ShortLength;
			if (Length1>=Length2)
			{
				LongLength=Length1;
				ShortLength=Length2;
			} 
			else
			{
				LongLength=Length2;
				ShortLength=Length1;
			}

			if (0 != (ShortLength>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				HTuple Length7,Indices0;
				length_xld(SelectedXLD, &Length7);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					tuple_sort_index(Length7, &Indices0);
					select_obj(SelectedXLD, &ObjectSelected8, (Indices0.Select(Number9-1))+1);

					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}
			}
			else
			{
				retValue = 100.0;
				Hobject newRgn; 
				m_vErrorRgn[rId] = newRgn;
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			//
			select_obj(SortedRegions, &SelectObject2, 2);
			smallest_rectangle1(SelectObject2, &Row16, &Column15, &Row26, &Column25);
			smallest_rectangle2(SelectObject2, &Row9, &Column9, &Phi13, &Length15,  &Length25);
			if (Length15>=Length25)
			{
				LongLength=Length15;
				ShortLength=Length25;
			} 
			else
			{
				LongLength=Length25;
				ShortLength=Length15;
			}
			if (0 != (ShortLength>5))
			{

				crop_contours_xld(Edges1, &UpCroppedContour, Row16+5, Column15+3,  Row26-5, Column25-3, "false");
				length_xld(UpCroppedContour, &Length6);
				count_obj(UpCroppedContour, &Number13);
				if (Number13<1)
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				tuple_sort_index(Length6, &Indices);
				select_obj(UpCroppedContour, &ObjectSelected12, (Indices.Select(Number13-1))+1);
				HTuple Length4;
				length_xld(ObjectSelected12,&Length4);	
				Hobject Cross2Reg;
				if (Length4>2)
				{
					fit_line_contour_xld(ObjectSelected12, "tukey", -1, 0, 5, 2, &RowBegin3, &ColBegin3, &RowEnd3, &ColEnd3, &Nr3, &Nc3, &Dist3);
					ExtractEdgesPoints(ImageGuass, 10, 20, 5, 1, 10, "all", "max", RowBegin3,  ColBegin3, RowEnd3, ColEnd3, &ResultRow3, &ResultColumn3);

					gen_cross_contour_xld(&Cross3, ResultRow3, ResultColumn3, 3, 0.785398);
					gen_region_contour_xld(Cross3,&Cross2Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross2Reg, &m_vRgn[rId]);
				}
			}
			else
			{
				retValue = 100.0;
				Hobject newRgn; 
				m_vErrorRgn[rId] = newRgn;
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}


			if (0 != (HTuple((ResultRow1.Num())!=0).And((ResultRow3.Num())==0)))
			{
				tuple_mean(ResultRow1, &LeftDistance);
				Height = LeftDistance;
			}
			else if (0 != (HTuple((ResultRow1.Num())==0).And((ResultRow3.Num())!=0)))
			{
				tuple_mean(ResultRow3, &RightDistance);
				Height = RightDistance;
			}
			else if (0 != (HTuple((ResultRow1.Num())!=0).And((ResultRow3.Num())!=0)))
			{
				tuple_mean(ResultRow1, &LeftDistance);
				tuple_mean(ResultRow3, &RightDistance);
				Height = (LeftDistance+RightDistance)/2;
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}

		}
		if (0 != (Number4==1))
		{
			reduce_domain(crtImg, rgn, &imgReduced);
			mean_image(imgReduced, &ImageMean, 7, 1);
			expand_domain_gray(ImageMean, &ExpandedImage, 3);
			reduce_domain(ExpandedImage, rgn, &ImageReduced2);		
			gauss_filter(imgReduced,&ImageGuass,5);

			edges_sub_pix(ImageReduced2, &Edges1, "canny", maskSize, thredLow, thredUpper);
			Hobject Region,ObjectSelected2;
			HTuple Number3,XRow, XCol;
			//gen_region_contour_xld(Edges1,&Reg, "margin");
			//
			count_obj(Edges1, &Number3);
			if (Number3>=1)
			{
				gen_empty_region(&ErrorReg);
				for (int a=1; a<=Number3[0].I(); a++)
				{
					select_obj(Edges1, &ObjectSelected2, a);
					get_contour_xld(ObjectSelected2, &XRow, &XCol);
					gen_region_points(&Region, XRow, XCol);
					concat_obj(ErrorReg, Region, &ErrorReg);
				}
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}
			sort_region(ConnectedRegions, &SortedRegions, "upper_left", "true",  "column");
			select_obj(SortedRegions, &SelectObject1, 1);
			smallest_rectangle1(SelectObject1, &Row15, &Column14, &Row25, &Column24);
			//inner_rectangle1(SelectObject1,&Row15, &Column14, &Row25, &Column24);
			smallest_rectangle2(SelectObject1, &Row4, &Column4, &Phi, &Length1, &Length2);
			Hobject Cross1Reg,LeftRegion,LeftRegionDilation,LeftRegionUnion,LeftSkeleton,LeftContours;
			HTuple LongLength,ShortLength;
			if (Length1>=Length2)
			{
				LongLength=Length1;
				ShortLength=Length2;
			} 
			else
			{
				LongLength=Length2;
				ShortLength=Length1;
			}

			if (0 != (ShortLength>5))
			{
				crop_contours_xld(Edges1, &LeftCroppedContours, Row15+5, Column14+2,  Row25-5, Column24-2, "false");
				//
				union_adjacent_contours_xld(LeftCroppedContours, &LeftCroppedContours, 10, 1, "attr_keep");
				crop_contours_xld(LeftCroppedContours, &LeftCroppedContours, Row15+5, Column14+5, Row25-5, Column24-5, "false");
				gen_region_contour_xld(LeftCroppedContours, &LeftRegion, "filled");
				dilation_rectangle1(LeftRegion, &LeftRegionDilation, 5, 1);
				union1(LeftRegionDilation, &LeftRegionUnion); 
				skeleton(LeftRegionUnion, &LeftSkeleton);
				gen_contour_region_xld(LeftSkeleton, &LeftContours, "center");
				crop_contours_xld(LeftContours, &LeftCroppedContours, Row15+5, Column14+3, Row25-5, Column24-3, "false");
				//	
				select_shape_xld(LeftCroppedContours, &SelectedXLD, "contlength",  "and", Length2-5, 999999);
				HTuple Length7,Indices0;
				length_xld(SelectedXLD, &Length7);
				count_obj(SelectedXLD, &Number9);
				Hobject Region3;
				HTuple Rows3, Columns3,RowsMean3,Columns3Sorted,ColNum3;
				if (0 != (Number9>=1))
				{
					tuple_sort_index(Length7, &Indices0);
					select_obj(SelectedXLD, &ObjectSelected8, (Indices0.Select(Number9-1))+1);

					gen_region_contour_xld(ObjectSelected8, &Region3, "filled");
					get_region_points(Region3, &Rows3, &Columns3);
					tuple_mean(Rows3,&RowsMean3);
					tuple_sort(Columns3,&Columns3Sorted);
					ColNum3=Columns3.Num();
					if(ColNum3>1)
					{
						ExtractEdgesPoints(ImageGuass, 20, 20, 5, 1, 20,  "all", "max", RowsMean3,  Columns3Sorted.Select(1), RowsMean3, Columns3Sorted.Select(ColNum3-1), &ResultRow1, &ResultColumn1);	
					}
					gen_cross_contour_xld(&Cross1, ResultRow1, ResultColumn1, 3, 0.785398);
					gen_region_contour_xld(Cross1,&Cross1Reg,"margin");
				}
				else
				{
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pDefectDiff);
					return S_FALSE;
				}
				if(m_bDebugImg)
				{
					concat_obj (m_vRgn[rId], Cross1Reg, &m_vRgn[rId]);
				}
			}
			else
			{
				retValue = 100.0;
				Hobject newRgn; 
				m_vErrorRgn[rId] = newRgn;
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}


			if (0 != ((ResultRow1.Num())!=0))
			{
				tuple_mean(ResultRow1, &Distance);
				Height = Distance;
			}
			else
			{
				retValue = -1;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pDefectDiff);
				return S_FALSE;
			}

		}
		//
		retValue =abs(Height[0].D()*m_pixelSize-StdTotalHeight);
		concat_obj(ErrorReg,rgn,&ErrorReg);
		m_vErrorRgn[rId] = ErrorReg;
		retValue.Detach(pDefectDiff);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectDiff);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::HeightMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("760$\
					 397;R;FP;0;300;1$\
					 381;B$\
					 761;FP;1;30;0.01;8.8$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;20$\
					 763;LP;5;254;1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::BarLocationAlgo(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pMaskSize,VARIANT* pThreshLowValue,VARIANT* pThreshUpValue,VARIANT* pAreaLimitSize)
{
	int id = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	float maskSize    = (float)pMaskSize->fltVal;
	int ThreshLowValue = (int)pThreshLowValue->fltVal;
	int ThreshUpValue = (int)pThreshUpValue->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}

	if(ThreshUpValue<=ThreshLowValue)
	{
		ThreshUpValue=ThreshLowValue+3;
	}
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,Circle;
		Hobject Image=m_ImageScaleMax;

		//scale_image_max(Image,&Image);
		//
		Hobject ROI_0,ROI_1,RegionDiff;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &RegionDiff);
		//
		Hobject ImageMedian,ExpandedImage;
		reduce_domain(Image, RegionDiff, &ImageReduced);
		median_image(ImageReduced, &ImageMedian, "circle", 3, "mirrored");
		expand_domain_gray(ImageMedian, &ExpandedImage, 3);
		reduce_domain(ExpandedImage, RegionDiff, &ImageReduced);
		Hobject Edges,SmoothedContours,UnionContours;
		edges_sub_pix(ImageReduced, &Edges, "canny", maskSize, ThreshLowValue, ThreshUpValue);
		smooth_contours_xld(Edges, &SmoothedContours, 5);
		union_adjacent_contours_xld(SmoothedContours, &UnionContours, 10, 1, "attr_keep");

		Hobject Region,RegionErosion,RegionDilation2,ConnectionRegions2;
		gen_region_contour_xld(UnionContours, &Region, "filled");
		erosion_circle(Region, &RegionErosion, 1.5);
		dilation_circle(RegionErosion, &RegionDilation2, 1.5);
		connection(RegionDilation2,&ConnectionRegions2);
		Hobject SelectedRegions3;
		HTuple Row1, Column1, Phi2, rect2_len1, rect2_len2;
		select_shape(ConnectionRegions2, &SelectedRegions3, "area", "and", AreaLimitSize, 5000);
		smallest_rectangle2(SelectedRegions3, &Row1, &Column1, &Phi2, &rect2_len1, &rect2_len2);
		HTuple len1mean,len2mean;
		if ((rect2_len1.Num()==0)||(rect2_len2.Num()==0))
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		tuple_mean(rect2_len1, &len1mean);
		tuple_mean(rect2_len2, &len2mean);
		//输出显示
		Hobject SelectedRegions2;
		select_shape(SelectedRegions3, &SelectedRegions2, (HTuple("rect2_len1").Append("rect2_len2")), "and", (len1mean*0.6).Concat(len2mean*0.6), (len1mean*1.4).Concat(len2mean*1.4));

		HTuple Number1,Length;
		Length=HTuple();
		count_obj(SelectedRegions2,&Number1);
		if (Number1==0)
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		Hobject ObjectSelected;
		HTuple Row, Column, Phi, Length1, Length2;

		HTuple LongLength,ShortLength;
		for (int i=1;i<=Number1;i++)
		{
			select_obj(SelectedRegions2, &ObjectSelected, i);
			smallest_rectangle2(ObjectSelected, &Row, &Column, &Phi, &Length1, &Length2);
			//
			if (0 != (Length1>=Length2))
			{
				LongLength = Length1;
				ShortLength = Length2;
			}
			else
			{
				LongLength = Length2;
				ShortLength = Length1;
			}
			Length = Length.Concat(LongLength);
			//Length = Length.Concat(Length1);
		}
		HTuple Sorted,middle,Selected,Indice;
		tuple_sort(Length, &Sorted);
		middle = HTuple((Sorted.Num())/2).Round();
		//
		if (0 != (HTuple((middle.Num())!=0).And(middle>=1)))
		{

			tuple_select(Sorted, middle-1, &Selected);

		}
		else
		{
			tuple_select(Sorted, middle, &Selected);

		}

		tuple_find(Length, Selected, &Indice);
		Hobject ObjectSelected1;
		if (0 != ((Indice.Num())==1))
		{
			select_obj(SelectedRegions2, &ObjectSelected1, Indice+1);
		}
		else
		{
			HTuple a;
			a = Indice.Select(0);
			if (0 != (a==0))
			{
				select_obj(SelectedRegions2, &ObjectSelected1, a+1);
			}
			else
			{
				select_obj(SelectedRegions2, &ObjectSelected1, a);
			}
		}
		HTuple Area_Select, Row_Select, Column_Select;
		HTuple Row2, Column2, Phi3, Length12,Length22;
		area_center(ObjectSelected1, &Area_Select, &Row_Select, &Column_Select);
		smallest_rectangle2(ObjectSelected1, &Row2, &Column2, &Phi3, &Length12,&Length22);
		Hobject RegionLine;
		gen_region_line(&RegionLine,Row_Select, Column_Select,fCenterY, fCenterX);

		Hobject CenterCircle,SelectCircle,RegionUnion;
		HTuple Angle;
		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle, Row_Select, Column_Select, 20);
		union2(CenterCircle, SelectCircle, &RegionUnion);
		orientation_region(RegionUnion, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		HTuple Distance;
		distance_pp(Row_Select, Column_Select,fCenterY, fCenterX,&Distance);

		if((Distance<(Radius-10))&&(Distance>(Radius-RoiWidth+10)))
		{
			m_modelAngle=Angle;
			Hobject Reg;
			concat_obj(RegionDiff,SelectedRegions2,&Reg);
			concat_obj(Reg,RegionLine,&Reg);
			m_vRgn[id]=Reg;
		}
		else
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif

	return S_OK;

}
STDMETHODIMP CPlugAlgo::BarLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("858$\
					 381;B$\
					 859;LP;80;800;1;185$\
					 860;LP;25;300;1;100$\
					 643;FP;0.1;20;0.1;1.0$\
					 762;LP;1;100;1;8$\
					 763;LP;1;200;1;15$\
					 861;LP;20;3600;1;800");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BarLocationAlgo1(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pGrayValue,VARIANT* pAreaLimitSize)
{
	int id = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	//float maskSize    = (float)pMaskSize->fltVal;
	//int ThreshLowValue = (int)pThreshLowValue->fltVal;
	//int ThreshUpValue = (int)pThreshUpValue->fltVal;
	float GrayValue = (float)pGrayValue->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,Circle;
		Hobject Image=m_ImageScaleMax;

		//scale_image_max(Image,&Image);
		//
		Hobject ROI_0,ROI_1,RegionDiff;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &RegionDiff);
		if (m_bDebugImg)
		{
			concat_obj(RegionDiff,m_vRgn[id],&m_vRgn[id]);
		}
		//
		Hobject ImageMedian,ExpandedImage;
		reduce_domain(Image, RegionDiff, &ImageReduced);
		median_image(ImageReduced, &ImageMedian, "circle", 3.0, "mirrored");

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,ImageMin;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_image_ext(ImageMedian, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		gray_erosion_rect(PolarTransImage, &ImageMin, 11, 22);

		//找条状特征
		Hobject ImageMean,RegionDynThresh,ConnectedRegions1,ConnectedRegions2,Domain1,SelectedRegions1;
		HTuple Row11, Column11, Row21, Column21;
		mean_image(ImageMin, &ImageMean, 130, 20);
		dyn_threshold(ImageMin, ImageMean, &RegionDynThresh, GrayValue, "dark");
		connection(RegionDynThresh, &ConnectedRegions1);
		connection(ConnectedRegions1, &ConnectedRegions2);
		get_domain(PolarTransImage, &Domain1);
		smallest_rectangle1(Domain1, &Row11, &Column11, &Row21, &Column21);
		select_shape(ConnectedRegions2, &SelectedRegions1, "column", "and", Column11+100, Column21-100);
		//
		Hobject SelectedRegions3;
		HTuple Row1, Column1, Phi2, rect2_len1, rect2_len2;
		select_shape(SelectedRegions1, &SelectedRegions3, "area", "and", AreaLimitSize, 9500);
		smallest_rectangle2(SelectedRegions3, &Row1, &Column1, &Phi2, &rect2_len1, &rect2_len2);
		HTuple len1mean,len2mean;
		if ((rect2_len1.Num()==0)||(rect2_len2.Num()==0))
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}

		tuple_mean(rect2_len1, &len1mean);
		tuple_mean(rect2_len2, &len2mean);
		//输出显示
		Hobject SelectedRegions2;
		select_shape(SelectedRegions3, &SelectedRegions2, (HTuple("rect2_len1").Append("rect2_len2")), "and", (len1mean*0.6).Concat(len2mean*0.6), (len1mean*1.4).Concat(len2mean*1.4));
		if (m_bDebugImg)
		{
			Hobject XYTransRegion1;
			polar_trans_region_inv(SelectedRegions2, &XYTransRegion1,fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
			concat_obj(XYTransRegion1,m_vRgn[id],&m_vRgn[id]);
		}

		//
		Hobject RegionClosing,RegionOpening;
		closing_rectangle1(SelectedRegions2, &RegionClosing, 1, HeightPolar);
		opening_rectangle1(RegionClosing, &RegionOpening, 1, HeightPolar/2);
		HTuple Number1,Length;
		Length=HTuple();
		count_obj(RegionOpening,&Number1);
		if (Number1==0)
		{
			//Hobject newRgn;
			//m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		Hobject ObjectSelected;
		HTuple Row, Column, Phi, Length1, Length2;

		HTuple LongLength,ShortLength;
		for (int i=1;i<=Number1;i++)
		{
			select_obj(RegionOpening, &ObjectSelected, i);
			smallest_rectangle2(ObjectSelected, &Row, &Column, &Phi, &Length1, &Length2);
			//
			if (0 != (Length1>=Length2))
			{
				LongLength = Length1;
				ShortLength = Length2;
			}
			else
			{
				LongLength = Length2;
				ShortLength = Length1;
			}
			//Length = Length.Concat(LongLength);
			Length = Length.Concat(ShortLength);
		}
		HTuple Sorted,middle,Selected,Indice;
		tuple_sort(Length, &Sorted);
		middle = HTuple((Sorted.Num())/2).Round();
		//
		if (0 != (HTuple((middle.Num())!=0).And(middle>=1)))
		{

			tuple_select(Sorted, middle-1, &Selected);

		}
		else
		{
			tuple_select(Sorted, middle, &Selected);

		}

		tuple_find(Length, Selected, &Indice);
		Hobject ObjectSelected1;
		if (0 != ((Indice.Num())==1))
		{
			select_obj(SelectedRegions2, &ObjectSelected1, Indice+1);
		}
		else
		{
			HTuple a;
			a = Indice.Select(0);
			if (0 != (a==0))
			{
				select_obj(SelectedRegions2, &ObjectSelected1, a+1);
			}
			else
			{
				select_obj(SelectedRegions2, &ObjectSelected1, a);
			}
		}
		HTuple RectRow, RectColumn, RectPhi, RectLength1, RectLength2;
		HTuple Area_Select, Row_Select, Column_Select;
		Hobject RectSelect,XYTransRegion;
		smallest_rectangle2(ObjectSelected1, &RectRow, &RectColumn, &RectPhi, &RectLength1, &RectLength2);
		gen_rectangle2(&RectSelect, RectRow, RectColumn, RectPhi, RectLength1, RectLength2);
		polar_trans_region_inv(RectSelect, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
		area_center(XYTransRegion, &Area_Select, &Row_Select, &Column_Select);
		//
		Hobject RegionLine;
		gen_region_line(&RegionLine,Row_Select, Column_Select,fCenterY, fCenterX);

		Hobject CenterCircle,SelectCircle,RegionUnion;
		HTuple Angle;
		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle, Row_Select, Column_Select, 20);
		union2(CenterCircle, SelectCircle, &RegionUnion);
		orientation_region(RegionUnion, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		HTuple Distance;
		distance_pp(Row_Select, Column_Select,fCenterY, fCenterX,&Distance);

		if((Distance<(Radius-10))&&(Distance>(Radius-RoiWidth+10)))
		{
			m_modelAngle=Angle;
			concat_obj(RegionLine,m_vRgn[id],&m_vRgn[id]);
		}
		else
		{
			m_modelAngle=0;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif

	return S_OK;

}
STDMETHODIMP CPlugAlgo::BarLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6121$\
					 381;B$\
					 859;LP;80;800;1;185$\
					 860;LP;25;300;1;100$\
					 1316;FP;1;200;0.5;5$\
					 861;LP;20;3600;1;800");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BarLocationAlgo2(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pGrayValue,VARIANT* pAreaLimitSize,VARIANT* pMaskSize,VARIANT* pDynThred)
{
	int id = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	float MaskSize    = (float)pMaskSize->fltVal;
	float DynThred = (float)pDynThred->fltVal;
	//int ThreshUpValue = (int)pThreshUpValue->fltVal;
	float GrayValue = (float)pGrayValue->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,Circle;
		Hobject Image=m_ImageScaleMax;

		//scale_image_max(Image,&Image);
		//
		Hobject ROI_0,ROI_1,RegionDiff;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &RegionDiff);
		if (m_bDebugImg)
		{
			concat_obj(RegionDiff,m_vRgn[id],&m_vRgn[id]);
		}
		//
		Hobject ImageMedian,ExpandedImage;
		reduce_domain(Image, RegionDiff, &ImageReduced);
		median_image(ImageReduced, &ImageMedian, "circle", 3.0, "mirrored");

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,ImageMin;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_image_ext(ImageMedian, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		gray_erosion_rect(PolarTransImage, &ImageMin, 11, 22);

		//找条状特征
		Hobject ImageMean,RegionDynThresh,ConnectedRegions1,ConnectedRegions2,Domain1,SelectedRegions1;
		HTuple Row11, Column11, Row21, Column21;
		mean_image(ImageMin, &ImageMean, 130, 20);
		dyn_threshold(ImageMin, ImageMean, &RegionDynThresh, GrayValue, "dark");
		connection(RegionDynThresh, &ConnectedRegions1);
		connection(ConnectedRegions1, &ConnectedRegions2);
		get_domain(PolarTransImage, &Domain1);
		smallest_rectangle1(Domain1, &Row11, &Column11, &Row21, &Column21);
		select_shape(ConnectedRegions2, &SelectedRegions1, "column", "and", Column11+100, Column21-100);
		//
		Hobject SelectedRegions3;
		HTuple Row1, Column1, Phi2, rect2_len1, rect2_len2;
		select_shape(SelectedRegions1, &SelectedRegions3, "area", "and", AreaLimitSize, 9500);
		smallest_rectangle2(SelectedRegions3, &Row1, &Column1, &Phi2, &rect2_len1, &rect2_len2);
		HTuple len1mean,len2mean;
		if ((rect2_len1.Num()==0)||(rect2_len2.Num()==0))
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}

		tuple_mean(rect2_len1, &len1mean);
		tuple_mean(rect2_len2, &len2mean);
		//输出显示
		Hobject SelectedRegions2;
		select_shape(SelectedRegions3, &SelectedRegions2, (HTuple("rect2_len1").Append("rect2_len2")), "and", (len1mean*0.6).Concat(len2mean*0.6), (len1mean*1.4).Concat(len2mean*1.4));
		if (m_bDebugImg)
		{
			Hobject XYTransRegion1;
			polar_trans_region_inv(SelectedRegions2, &XYTransRegion1,fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
			concat_obj(XYTransRegion1,m_vRgn[id],&m_vRgn[id]);
		}

		//
		Hobject RegionClosing,RegionOpening;
		closing_rectangle1(SelectedRegions2, &RegionClosing, 1, HeightPolar);
		//opening_rectangle1(RegionClosing, &RegionOpening, 1, HeightPolar/2);
		HTuple AreaAll,hv_Number,Area2, Row6, Column6,Max;
		Hobject ObjectSelected2,ImageReduced1,ImageMean3,RegionDynThresh2;
		AreaAll = HTuple();
		count_obj(RegionClosing, &hv_Number);
		if (hv_Number==0)
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}

		for (int i=1; i<=hv_Number;i++)
		{
			select_obj(RegionClosing, &ObjectSelected2, i);
			reduce_domain(PolarTransImage, ObjectSelected2, &ImageReduced1);
			mean_image(ImageReduced1, &ImageMean3, (Hlong)MaskSize, 5);
			dyn_threshold(ImageReduced1, ImageMean3, &RegionDynThresh2, DynThred, "dark");
			area_center(RegionDynThresh2, &Area2, &Row6, &Column6);
			AreaAll = AreaAll.Concat(Area2);
		}
		HTuple Indices;
		Hobject ObjectSelected1;
		tuple_max(AreaAll, &Max);
		tuple_find(AreaAll, Max, &Indices);
		select_obj(RegionClosing, &ObjectSelected1, Indices[0].I()+1);
		////

		HTuple RectRow, RectColumn, RectPhi, RectLength1, RectLength2;
		HTuple Area_Select, Row_Select, Column_Select;
		Hobject RectSelect,XYTransRegion;
		smallest_rectangle2(ObjectSelected1, &RectRow, &RectColumn, &RectPhi, &RectLength1, &RectLength2);
		gen_rectangle2(&RectSelect, RectRow, RectColumn, RectPhi, RectLength1, RectLength2);
		polar_trans_region_inv(RectSelect, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
		area_center(XYTransRegion, &Area_Select, &Row_Select, &Column_Select);
		//
		Hobject RegionLine;
		gen_region_line(&RegionLine,Row_Select, Column_Select,fCenterY, fCenterX);

		Hobject CenterCircle,SelectCircle,RegionUnion;
		HTuple Angle;
		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle, Row_Select, Column_Select, 20);
		union2(CenterCircle, SelectCircle, &RegionUnion);
		orientation_region(RegionUnion, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		HTuple Distance;
		distance_pp(Row_Select, Column_Select,fCenterY, fCenterX,&Distance);

		if((Distance<(Radius-0))&&(Distance>(Radius-RoiWidth+0)))
		{
			m_modelAngle=Angle;
			concat_obj(RegionLine,m_vRgn[id],&m_vRgn[id]);
		}
		else
		{
			m_modelAngle=0;
		}
		//m_modelAngleTmp = HTuple();
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif

	return S_OK;

}
STDMETHODIMP CPlugAlgo::BarLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6122$\
					 381;B$\
					 859;LP;80;800;1;185$\
					 860;LP;25;300;1;100$\
					 1316;FP;1;200;0.5;5$\
					 861;LP;20;3600;1;800$\
					 1195;FP;1;100;0.5;50$\
					 6007;FP;1;50;0.2;8");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************************
**函数名：BarLocationAlgo3
**功  能：胶塞冠部条形定位算子，使用情况：冠部油污较多，干扰Bar定位情况
**思  路：极坐标展开下进行求导，检测条状花纹，再进行筛选
**时  间：2019年3月12日
**作  者：WuSir
*************************************************************************************/
STDMETHODIMP CPlugAlgo::BarLocationAlgo3(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pAreaLimitSize,VARIANT* pMaskSize,VARIANT* pDynThred)
{
	int id = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	float MaskSize    = (float)pMaskSize->fltVal;
	float DynThred = (float)pDynThred->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,Circle;
		Hobject Image=m_ImageScaleMax;

		//scale_image_max(Image,&Image);
		//
		Hobject ROI_0,ROI_1,RegionDiff;
		
		if (Radius > RoiWidth)
		{
			gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
			gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		}
		else if(Radius < RoiWidth)
		{
			gen_circle(&ROI_1, fCenterY, fCenterX, Radius);
			gen_circle(&ROI_0, fCenterY, fCenterX, Radius-RoiWidth);
		}
		else if (Radius == RoiWidth)
		{
			gen_circle(&ROI_0, fCenterY, fCenterX, 20);
			gen_circle(&ROI_1, fCenterY, fCenterX, 5);
		}
		difference(ROI_0, ROI_1, &RegionDiff);
		if (m_bDebugImg)
		{
			concat_obj(RegionDiff,m_vRgn[id],&m_vRgn[id]);
		}
		//
		Hobject ImageMedian,ExpandedImage;
		reduce_domain(Image, RegionDiff, &ImageReduced);
		median_image(ImageReduced, &ImageMedian, "circle", 3.0, "mirrored");

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,ImageMin;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_image_ext(ImageMedian, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		
		Hobject imgGauss,imgGaussMax,imgGaussMean,rgnsThresh;
		Hobject rgnsCon,rgnsSel,rgnsUni,rgnsClos,rgnsOpn,rgnsClsCon;
		derivate_gauss(PolarTransImage, &imgGauss, 1, "x");
		scale_image_max(imgGauss, &imgGaussMax);
		mean_image(imgGaussMax, &imgGaussMean, (Hlong)MaskSize, 1);
		dyn_threshold(imgGaussMean, imgGaussMax, &rgnsThresh, DynThred, "light");
		connection(rgnsThresh, &rgnsCon);
		select_shape(rgnsCon, &rgnsSel, "area", "and", 150, 99999);

		union1(rgnsSel, &rgnsUni);
		closing_rectangle1(rgnsUni, &rgnsClos, 15, 1);
		opening_circle(rgnsClos, &rgnsOpn, 2.5);
		connection(rgnsOpn, &rgnsClsCon);

		Hobject rgnRectSml ;
		HTuple dRow1, dColumn1, dRow2, dColumn2,dRowRect, dColRect, dPhiRect, dLength1, dLength2 ;
		HTuple dLen1Mean,dLen2Mean ;

		smallest_rectangle1(rgnsClsCon, &dRow1, &dColumn1, &dRow2, &dColumn2);
		if ((dRow2.Num()==0)||(dColumn2.Num()==0))
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		
		gen_rectangle1(&rgnRectSml, dRow1, dColumn1, dRow2, dColumn2);
		smallest_rectangle2(rgnsClsCon, &dRowRect, &dColRect, &dPhiRect, &dLength1, &dLength2);

		tuple_mean(dLength1, &dLen1Mean);
		tuple_mean(dLength2, &dLen2Mean);

		Hobject rgnSelFin,rgnSelFin1,rgnSelFin2 ;
		select_shape(rgnRectSml, &rgnSelFin, (HTuple("width").Append("area")), "and", (HTuple(10).Append(500)), (HTuple(100).Append(99999)));
		select_shape(rgnSelFin, &rgnSelFin1, "rect2_len1", "and", dLen1Mean*0.8, 1000);
		select_shape(rgnSelFin1, &rgnSelFin2, "rect2_len2", "and", dLen2Mean*0.8, 1000);

		HTuple Number2 ;
		count_obj(rgnSelFin2, &Number2);
		
		Hobject rgnBar;
		 //*选择与Bar的平均值相差最小的Bar
		if (Number2 > 0)
		{
			HTuple dAreaFin, dRowFin, dColFin,dAreaMeanFin,iLength;
			area_center(rgnSelFin2, &dAreaFin, &dRowFin, &dColFin);
			tuple_mean(dAreaFin, &dAreaMeanFin);
			tuple_length(dAreaFin, &iLength);

			HTuple dAreaLength,dAreaDiff,dAbsAreaDiff,dMinFind,dIndicesFind;
			tuple_gen_const(iLength, dAreaMeanFin, &dAreaLength);
			tuple_sub(dAreaFin, dAreaLength, &dAreaDiff);
			dAbsAreaDiff = dAreaDiff.Abs();

			tuple_min(dAbsAreaDiff, &dMinFind);
			tuple_find(dAbsAreaDiff, dMinFind, &dIndicesFind);

			HTuple dLenChose,dAreaFinMax,AreaMaxIndice;
			tuple_length(dIndicesFind, &dLenChose);
			if (dLenChose>=2)
			{
				tuple_max2(dAreaFin.Select(dIndicesFind.Select(0)), dAreaFin.Select(dIndicesFind.Select(1)), &dAreaFinMax);
				tuple_find(dAreaFin, dAreaFinMax, &AreaMaxIndice);
				select_obj(rgnSelFin2, &rgnBar, (AreaMaxIndice.Select(0))+1);
			}
			else if (dLenChose==1)
			{
				select_obj(rgnSelFin2, &rgnBar, dIndicesFind+1);
			}
			else
			{
				Hobject newRgn;
				m_vRgn[id] = newRgn;
				return S_FALSE;
			}

		}
		else
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		
		//输出显示
		if (m_bDebugImg)
		{
			Hobject XYTransRegion1;
			polar_trans_region_inv(rgnSelFin2, &XYTransRegion1,fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
			concat_obj(XYTransRegion1,m_vRgn[id],&m_vRgn[id]);
		}

		Hobject  XYTransRegion;
		HTuple   Area_Select, Row_Select, Column_Select;
	
		polar_trans_region_inv(rgnBar, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
		area_center(XYTransRegion, &Area_Select, &Row_Select, &Column_Select);
		//
		Hobject RegionLine;
		gen_region_line(&RegionLine,Row_Select, Column_Select,fCenterY, fCenterX);

		Hobject CenterCircle,SelectCircle,RegionUnion;
		HTuple Angle;
		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle, Row_Select, Column_Select, 20);
		union2(CenterCircle, SelectCircle, &RegionUnion);
		orientation_region(RegionUnion, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		HTuple Distance;
		distance_pp(Row_Select, Column_Select,fCenterY, fCenterX,&Distance);

		if((Distance<(Radius-0))&&(Distance>(Radius-RoiWidth+0)))
		{
			m_modelAngle=Angle;
			concat_obj(RegionLine,m_vRgn[id],&m_vRgn[id]);
		}
		else
		{
			m_modelAngle=0;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif

	return S_OK;

}
STDMETHODIMP CPlugAlgo::BarLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6123$\
					 381;B$\
					 859;LP;80;800;1;185$\
					 860;LP;25;300;1;100$\
					 861;LP;20;3600;1;800$\
					 1198;FP;1;100;0.5;15$\
					 6007;FP;1;50;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6059$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 859;LP;80;600;1;185$\
					 860;LP;25;300;1;100$\
					 6061;LP;1;100;1;20$\
					 6060;FP;1;50;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名：CharacterLocationAlgo
** 功  能; 针对一种底部存在字符的胶塞，对其底部字符区域进行定位
*********************************************************************************/
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgo(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT*pMaskSize,VARIANT*pThredValue,VARIANT*pCharacterArea )
{
	int rId = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	int MaskSize = (int)pMaskSize->fltVal;        // 20
	float ThredValue = (float)pThredValue->fltVal;  // 8
	 
	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}

	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image=m_ImageScaleMax;
		rgb1_to_gray(Image,&Image);
		Hobject ROI_0,ROI_1,rgnDiff,rgnSearch,imgSearch;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &rgnDiff);

		intersection(rgn,rgnDiff,&rgnSearch);
		reduce_domain(rgnSearch,Image,&imgSearch);

		if (m_bDebugImg)
		{
			concat_obj(rgnDiff,m_vRgn[rId],&m_vRgn[rId]);
		}

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,rgnSearchXY,imgSearchXY;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_region(rgnSearch,&rgnSearchXY, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		polar_trans_image_ext(Image, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		reduce_domain(PolarTransImage,rgnSearchXY,&imgSearchXY);

		Hobject imgMeanPolar,rgnBlack,rgnBlackFil,rgnBlackOpn,rgnBlackCls,rgnBlackCon,rgnBlackSel;
		mean_image(imgSearchXY,&imgMeanPolar,MaskSize,MaskSize*2/3);
		dyn_threshold(imgSearchXY,imgMeanPolar,&rgnBlack,ThredValue,"dark");
		fill_up(rgnBlack,&rgnBlackFil);
		opening_circle(rgnBlackFil,&rgnBlackOpn,1.5);
		closing_circle(rgnBlackOpn,&rgnBlackCls,5);
		connection(rgnBlackCls,&rgnBlackCon);
		select_shape_std(rgnBlackCon,&rgnBlackSel,"max_area",70);

		// 返回直角坐标系
		Hobject XYTransRegion;
		polar_trans_region_inv(rgnBlackSel, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");

		if (m_bDebugImg)
		{
			concat_obj(XYTransRegion,m_vRgn[rId],&m_vRgn[rId]);
		}

		HTuple dArea,dRow,dCol;
		area_center(XYTransRegion,&dArea,&dRow,&dCol);
		if ( dArea < 0)
		{
			retValue=0.0;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pCharacterArea);
			return S_FALSE;
		}

		Hobject rgnCon,rgnCharacter;
		HTuple  iNum;
		connection(rgn,&rgnCon);
		count_obj(rgnCon,&iNum);
		gen_empty_obj(&rgnCharacter);
		if ( iNum > 0)
		{
			Hobject objSel;
			for (int i = 1;i <= iNum;i++)
			{
				Hobject rgnIntersect;
				HTuple dArea,dRow,dCol;
				select_obj(rgnCon,&objSel,i);
				intersection(objSel,XYTransRegion,&rgnIntersect);
				area_center(rgnIntersect,&dArea,&dRow,&dCol);
				if ( dArea > 0)
				{
					rgnCharacter = objSel;
				}
			}
		}

		m_rgnCharacter = rgnCharacter;
		retValue = dArea[0].I();
		m_vErrorRgn[rId] = rgnCharacter;
		retValue.Detach(pCharacterArea);
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/*********************************************************************************
** 函数名：CharacterLocationAlgo
** 功  能; (1) 针对一种底部存在字符的胶塞，对其底部字符区域进行定位(单角度，多位置字符)
**         (2) 并传递出面积最大的字符位置角度信息
**             时  间：2019年10月17日
**        （3）新增参数：pAngleSelect---当参数=0时，不使用角度，直接传出字符区域，
**             当参数==1 时，使用角度，通过模板绘图工具画字符区域
**             时间：2019年10月23日
*********************************************************************************/
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6171$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 6172;LP;0;1;1;1$\
					 859;LP;80;350;1;185$\
					 860;LP;25;180;1;100$\
					 6170;LP;1;4;1;1$\
					 6061;LP;1;100;1;20$\
					 6060;FP;1;50;0.5;10$\
					 6162;LP;1;200;0.5;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgo2(VARIANT* rgnId,VARIANT* pAngleSelect, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT*pCharNum,VARIANT*pMaskSize,VARIANT*pThredValue,VARIANT*pSelArea,VARIANT*pCharacterArea )
{
	int rId = (int)rgnId->fltVal;

	int AngleSelect = (int)pAngleSelect->fltVal;         // 0:不使用角度，1：使用角度
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	int CharNum = (int)pCharNum->fltVal;            // 字符位置个数1~4

	int MaskSize = (int)pMaskSize->fltVal;          // 20
	float ThredValue = (float)pThredValue->fltVal;  // 8
	int SelArea = (int)pSelArea->fltVal;            // 20

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}

	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image=m_ImageScaleMax;
		rgb1_to_gray(Image,&Image);
		Hobject ROI_0,ROI_1,rgnDiff,rgnSearch,imgSearch;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &rgnDiff);

		intersection(rgn,rgnDiff,&rgnSearch);
		reduce_domain(rgnSearch,Image,&imgSearch);

		if (m_bDebugImg)
		{
			concat_obj(rgnDiff,m_vRgn[rId],&m_vRgn[rId]);
		}

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,rgnSearchXY,imgSearchXY;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_region(rgnSearch,&rgnSearchXY, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		polar_trans_image_ext(Image, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		reduce_domain(PolarTransImage,rgnSearchXY,&imgSearchXY);

		Hobject imgMeanPolar,rgnBlack,rgnBlackFil,rgnBlackOpn,rgnBlackCls,rgnBlackCon,rgnBlackSel;
		mean_image(imgSearchXY,&imgMeanPolar,MaskSize,MaskSize*2/3);
		dyn_threshold(imgSearchXY,imgMeanPolar,&rgnBlack,ThredValue,"dark");
		fill_up(rgnBlack,&rgnBlackFil);
		opening_circle(rgnBlackFil,&rgnBlackOpn,1.5);
		closing_circle(rgnBlackOpn,&rgnBlackCls,5);
		connection(rgnBlackCls,&rgnBlackCon);
		select_shape(rgnBlackCon,&rgnBlackSel,"area","and",SelArea,9999999);
		union1(rgnBlackSel,&rgnBlackSel );

		// 返回直角坐标系
		Hobject XYTransRegion;
		polar_trans_region_inv(rgnBlackSel, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");

		if (m_bDebugImg)
		{
			concat_obj(XYTransRegion,m_vRgn[rId],&m_vRgn[rId]);
		}

		HTuple dArea,dRow,dCol;
		area_center(XYTransRegion,&dArea,&dRow,&dCol);
		if ( dArea < 0)
		{
			retValue=0.0;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pCharacterArea);
			return S_FALSE;
		}

		Hobject rgnCon,rgnCharacter,rgnCharacterMax;
		HTuple  iNum,dMaxArea;
		dMaxArea = 0;
		gen_empty_obj( &rgnCharacterMax);
		connection(rgn,&rgnCon);
		count_obj(rgnCon,&iNum);
		gen_empty_obj(&rgnCharacter);
		if ( iNum > 0)
		{
			Hobject objSel;
			for (int i = 1;i <= iNum;i++)
			{
				Hobject rgnIntersect;
				HTuple dArea,dRow,dCol;
				select_obj(rgnCon,&objSel,i);
				intersection(objSel,XYTransRegion,&rgnIntersect);
				area_center(rgnIntersect,&dArea,&dRow,&dCol);
				if ( dArea > 0)
				{
					concat_obj(rgnCharacter,objSel ,&rgnCharacter );
				}

				if (dArea > dMaxArea )
				{
					dMaxArea = dArea;
					gen_empty_obj( &rgnCharacterMax);
					rgnCharacterMax = rgnIntersect;
				}
			}
		}

		Hobject rgnCharacterCon ;
		union1(rgnCharacter,&rgnCharacter );
		connection(rgnCharacter,&rgnCharacterCon );
		HTuple NumSel;
		count_obj(rgnCharacterCon,&NumSel );

		Hobject rgnCharacterSelFil;
		gen_empty_obj(&rgnCharacterSelFil );

		if (NumSel >  CharNum)
		{
			for ( int i =1;i<=CharNum;i++)
			{  
				Hobject objSel;
				select_obj(rgnCharacterCon,&objSel,i );
				concat_obj(rgnCharacterSelFil,objSel,& rgnCharacterSelFil);
			}
		}
		else
			rgnCharacterSelFil = rgnCharacter;

		union1(rgnCharacterSelFil,&rgnCharacterSelFil );

		// 传递出交集最多的区域的角度
		HTuple dAreaMax,dCenRowMax,dCenColMax;
		union1( rgnCharacterMax,&rgnCharacterMax);
		area_center(rgnCharacterMax,&dAreaMax,&dCenRowMax,&dCenColMax );

		Hobject rgnCir1,rgnCir2 ,rgnUni,rgnLine;
		HTuple  Angle;
		gen_circle(&rgnCir1, fCenterY, fCenterX, 5);
		gen_circle(&rgnCir2, dCenRowMax, dCenColMax, 20);
		gen_region_line(&rgnLine ,fCenterY, fCenterX,dCenRowMax, dCenColMax);
		union2(rgnCir1, rgnCir2, &rgnUni);
		orientation_region(rgnUni, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		m_modelAngle=Angle; 
		m_modelAngleTmp = HTuple();
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);

		if (m_bDebugImg)
		{
			concat_obj(rgnLine,m_vRgn[rId],&m_vRgn[rId]);
		}

		// 输出参数
		if ( AngleSelect == 0)
		{
			// 不使用角度时，就直接传出文字区域
			m_rgnCharacter = rgnCharacterSelFil;
		}
		
		retValue = dArea[0].I();
		m_vErrorRgn[rId] = rgnCharacterSelFil;
		retValue.Detach(pCharacterArea);

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/*********************************************************************************
** 函数名：CharacterLocationAlgo1
** 功  能; 针对一种底部存在四个小圆且存在字符的胶塞，对其底部字符区域进行定位
*********************************************************************************/
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6117$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 6109;LP;1;2;1;1$\
					 859;LP;80;350;1;185$\
					 860;LP;25;180;1;100$\
					 6061;LP;1;100;1;20$\
					 6060;FP;1;50;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomCharacterLocationAlgo1(VARIANT* rgnId,VARIANT* pSelection, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT*pMaskSize,VARIANT*pThredValue,VARIANT*pCharacterArea )
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;      // 1--角度1；2--角度2 + 确认选择的角度
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	int MaskSize = (int)pMaskSize->fltVal;        // 20
	float ThredValue = (float)pThredValue->fltVal;  // 8

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}

	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image=m_ImageScaleMax;
		rgb1_to_gray(Image,&Image);
		Hobject ROI_0,ROI_1,rgnDiff,rgnSearch,imgSearch;
		gen_circle(&ROI_0, fCenterY, fCenterX, Radius);
		gen_circle(&ROI_1, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ROI_0, ROI_1, &rgnDiff);

		intersection(rgn,rgnDiff,&rgnSearch);
		reduce_domain(rgnSearch,Image,&imgSearch);

		if (m_bDebugImg)
		{
			concat_obj(rgnDiff,m_vRgn[rId],&m_vRgn[rId]);
		}

		//极坐标展开
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,rgnSearchXY,imgSearchXY;
		RadiusInner = Radius-RoiWidth+5;
		RadiusExt = Radius-5;
		AngleRad = 7.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_region(rgnSearch,&rgnSearchXY, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		polar_trans_image_ext(Image, &PolarTransImage, fCenterY, fCenterX,0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");
		reduce_domain(PolarTransImage,rgnSearchXY,&imgSearchXY);

		Hobject imgMeanPolar,rgnBlack,rgnBlackFil,rgnBlackOpn,rgnBlackCls,rgnBlackCon,rgnBlackSel;
		mean_image(imgSearchXY,&imgMeanPolar,MaskSize,MaskSize*2/3);
		dyn_threshold(imgSearchXY,imgMeanPolar,&rgnBlack,ThredValue,"dark");
		fill_up(rgnBlack,&rgnBlackFil);
		opening_circle(rgnBlackFil,&rgnBlackOpn,1.5);
		closing_circle(rgnBlackOpn,&rgnBlackCls,5);
		connection(rgnBlackCls,&rgnBlackCon);
		select_shape_std(rgnBlackCon,&rgnBlackSel,"max_area",70);

		// 返回直角坐标系
		Hobject XYTransRegion;
		polar_trans_region_inv(rgnBlackSel, &XYTransRegion, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");

		if (m_bDebugImg)
		{
			concat_obj(XYTransRegion,m_vRgn[rId],&m_vRgn[rId]);
		}

		HTuple dArea,dRow,dCol;
		area_center(XYTransRegion,&dArea,&dRow,&dCol);
		if ( dArea < 0)
		{
			retValue=0.0;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pCharacterArea);
			return S_FALSE;
		}

		if ( Selection == 1)
		{
			// 第一个角度定位到的字符区域面积
			m_rgnCharacterArea1 = dArea[0].I();
		}
		else if ( Selection == 2)
		{
			// 第二个角度定位到的字符区域面积
			m_rgnCharacterArea2 = dArea[0].I();
		}

		if ( Selection == 2)
		{
			if ( m_rgnCharacterArea1 > m_rgnCharacterArea2 )
			{
				m_modelAngleTmp = HTuple();
				m_modelAngle = m_AngleFirstCir;
				m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
			}
			else
			{
				m_modelAngleTmp = HTuple();
				m_modelAngle = m_AngleSecondCir;
				m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
			}
			//m_rgnCharacter = rgn;
		}

		retValue = dArea[0].I();
		m_vErrorRgn[rId] = rgn;
		retValue.Detach(pCharacterArea);
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pCharacterArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}

STDMETHODIMP CPlugAlgo::BottomCharacterRegionAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6062$\
					 381;B$\
					 859;LP;80;800;1;185$\
					 860;LP;25;300;1;100$\
					 1063;FP;1;50;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名：BottomCharacterRegionAlgoHelp
** 功  能; 针对一种底部存在字符的胶塞，确定其字符检测区域
*********************************************************************************/
STDMETHODIMP CPlugAlgo::BottomCharacterRegionAlgo(VARIANT* rgnId, VARIANT* pOuterEdge,VARIANT* pInnerEdge,VARIANT* pEroSize)
{
	/*利用边缘轮廓来定位圆*/
	int id = (int)rgnId->fltVal;
	float EroSize = (float)pEroSize->fltVal;
	int  OuterEdge = (int)pOuterEdge->fltVal;
	int  InnerEdge = (int)pInnerEdge->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((OuterEdge-InnerEdge)<2)
	{
		OuterEdge=InnerEdge+2;
	}

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	HTuple dRow,dCol,dArea;
    area_center(m_rgnCharacter,&dArea,&dRow,&dCol);

	if (dArea <= 0)
	{
		m_vRgn[id] = newRgn;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		
		Hobject ROI_0,ROI_1,rgnDiff,rgnSearch;
		gen_circle(&ROI_0, fCenterY, fCenterX, OuterEdge);
		gen_circle(&ROI_1, fCenterY, fCenterX,OuterEdge-InnerEdge);
		difference(ROI_0, ROI_1, &rgnDiff);

		Hobject rgnCharacter,rgnCharacterCon,rgnCharacterSel;
	    erosion_circle(m_rgnCharacter,&rgnCharacter,EroSize);
		connection(rgnCharacter,&rgnCharacterCon);
		select_shape(rgnCharacterCon,&rgnCharacterSel,"area","and",70,999999999 );
		//select_shape_std(rgnCharacterCon,&rgnCharacterSel,"max_area",70);
		intersection(rgnCharacterSel,rgnDiff,&rgnCharacterSel);

		HTuple dAreaSel,dRowSel,dColSel;
		area_center(rgnCharacterSel,&dAreaSel,&dRowSel,&dColSel);

		if ( dAreaSel > 0)
		{
			m_vRgn[id] = rgnCharacterSel;
		}
		else
		{
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RegionLocationByModelTool(VARIANT*rgnId,BSTR* bstrRgnFile)
{
	int id = (int)rgnId->fltVal;
	//
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	int fCenterX = 0;
	int fCenterY = 0;
	fCenterX = (int)m_vPos[0].m_x;
	fCenterY = (int)m_vPos[0].m_y;
	//
	CString sRgnPath  = *bstrRgnFile;
	string strRgnPath = CT2A(sRgnPath);

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			if(!_access(strRgnPath.c_str(),0))
			{
				Hobject retRgn;
				read_region(&retRgn,strRgnPath.c_str());
				m_dictCrtPathRgn[strRgnPath] = retRgn;
				m_dictNewPathRgn[strRgnPath] = retRgn;

			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("初始化参数,检测区域路径设置错误。"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );	
				}
				else
				{
					MessageBox(NULL, _T("Initialization parameter（detect region path）setting is wrong!"),_T("Initial configuration is wrong："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				m_vRgn[id].Reset();
				return S_FALSE;
			}
			m_vRgn[id].Reset();
			return S_OK;
		}

		Hobject RegionDetect;

		HTuple modelPARAID = m_vRgnReadData[id];
		if(m_dictCrtPathRgn.find(strRgnPath) == m_dictCrtPathRgn.end())
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		Hobject roiRgn = m_dictCrtPathRgn[strRgnPath];
		m_modelPARA = modelPARAID;

		Hobject  RegionAffineTrans;
		move_region (roiRgn,&RegionAffineTrans,fCenterY,fCenterX) ;
		//
		if (0!=(m_modelAngle.Num()!=0))
		{
			HTuple   HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX,0,fCenterY,fCenterX,m_modelAngle,&HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (RegionAffineTrans, &RegionAffineTrans, HomMat2DAdapted, "bilinear");
			//
			m_vRgn[id] = RegionAffineTrans ;	
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		//	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RegionLocationByModelToolHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("442$\
					 167;B$\
					 267;SPR" );

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**********************************************************************************
** 函数名：RegionLocationByModelTool1
** 功  能：增加一个圆形区域，与模板绘制的区域求取交集
** 说  明：根据 RegionLocationByModelTool 修改
** 时  间：2019年5月29日
***********************************************************************************/
STDMETHODIMP CPlugAlgo::RegionLocationByModelTool1(VARIANT*rgnId,VARIANT* pRadius,VARIANT* pRoiWidth,BSTR* bstrRgnFile)
{
	int id = (int)rgnId->fltVal;
	//
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	int fCenterX = 0;
	int fCenterY = 0;
	fCenterX = (int)m_vPos[0].m_x;
	fCenterY = (int)m_vPos[0].m_y;
	//
	CString sRgnPath  = *bstrRgnFile;
	string strRgnPath = CT2A(sRgnPath);

	float Radius =(float)pRadius->fltVal;
	float RoiWidth =(float)pRoiWidth->fltVal;

	if (Radius<20)
	{
		Radius=20.0;
	}
	Hobject rgnOuterCircle,rgnOuterCircle1,rgnAnnulus;
	if ((m_fCenterX<1)||(m_fCenterY<1))
	{
		if ( Radius > RoiWidth)
		{
			gen_circle(&rgnOuterCircle,fCenterY,fCenterX,Radius);
		    gen_circle(&rgnOuterCircle1,fCenterY,fCenterX,Radius-RoiWidth);
		} 
		else
		{
            gen_circle(&rgnOuterCircle,fCenterY,fCenterX,5);
			gen_circle(&rgnOuterCircle1,fCenterY,fCenterX,1);
		}
		
	}
	else
	{
		if ( Radius > RoiWidth)
		{
			gen_circle(&rgnOuterCircle,m_fCenterY,m_fCenterX,Radius);
		    gen_circle(&rgnOuterCircle1,m_fCenterY,m_fCenterX,Radius-RoiWidth);
		}
		else
		{
			gen_circle(&rgnOuterCircle,fCenterY,fCenterX,5);
			gen_circle(&rgnOuterCircle1,fCenterY,fCenterX,1);
		}
		
	}

	difference(rgnOuterCircle,rgnOuterCircle1,&rgnAnnulus);

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			if(!_access(strRgnPath.c_str(),0))
			{
				Hobject retRgn;
				read_region(&retRgn,strRgnPath.c_str());
				m_dictCrtPathRgn[strRgnPath] = retRgn;
				m_dictNewPathRgn[strRgnPath] = retRgn;

			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("初始化参数,检测区域路径设置错误。"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );	
				}
				else
				{
					MessageBox(NULL, _T("Initialization parameter（detect region path）setting is wrong!"),_T("Initial configuration is wrong："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				m_vRgn[id].Reset();
				return S_FALSE;
			}
			m_vRgn[id].Reset();
			return S_OK;
		}

		Hobject RegionDetect;

		HTuple modelPARAID = m_vRgnReadData[id];
		if(m_dictCrtPathRgn.find(strRgnPath) == m_dictCrtPathRgn.end())
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		Hobject roiRgn = m_dictCrtPathRgn[strRgnPath];
		m_modelPARA = modelPARAID;

		Hobject  RegionAffineTrans;
		move_region (roiRgn,&RegionAffineTrans,fCenterY,fCenterX) ;
	
		if (0!=(m_modelAngle.Num()!=0))
		{
			HTuple   HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX,0,fCenterY,fCenterX,m_modelAngle,&HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (RegionAffineTrans, &RegionAffineTrans, HomMat2DAdapted, "bilinear");
			//
			intersection(RegionAffineTrans,rgnAnnulus,&RegionAffineTrans);
	
			m_vRgn[id] = RegionAffineTrans ;	
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		//	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RegionLocationByModelTool1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5546$\
					 167;B$\
					 194;FP;1.0;2000.0;0.5;205$\
					 5547;FP;1.0;400.0;0.5;20$\
					 267;SPR" );

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//避免因偏心引起的检测区域缩小
STDMETHODIMP CPlugAlgo::RegionLocationDiffByModelTool(VARIANT*rgnId, VARIANT* pRadius,BSTR* bstrRgnFile)
{
	int id = (int)rgnId->fltVal;
	//
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	int fCenterX = 0;
	int fCenterY = 0;
	fCenterX = (int)m_vPos[0].m_x;
	fCenterY = (int)m_vPos[0].m_y;
	float Radius =(float)pRadius->fltVal;
	if (Radius<20)
	{
		Radius=20.0;
	}
	Hobject RegionCenter;
	if ((m_fCenterX<1)||(m_fCenterY<1))
	{
		gen_circle(&RegionCenter,fCenterY,fCenterX,Radius);
	}
	else
	{
		gen_circle(&RegionCenter,m_fCenterY,m_fCenterX,Radius);
	}
	//
	CString sRgnPath  = *bstrRgnFile;
	string strRgnPath = CT2A(sRgnPath);

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			if(!_access(strRgnPath.c_str(),0))
			{
				Hobject retRgn;
				read_region(&retRgn,strRgnPath.c_str());
				m_dictCrtPathRgn[strRgnPath] = retRgn;
				m_dictNewPathRgn[strRgnPath] = retRgn;

			}
			else
			{
				if(m_isChineseLanguage)
				{
					MessageBox(NULL,_T("初始化参数,检测区域路径设置错误。"),_T("初始配置错误："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );	
				}
				else
				{
					MessageBox(NULL, _T("Initialization parameter（detect region path）setting is wrong!"),_T("Initial configuration is wrong："), MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
				}
				m_vRgn[id].Reset();
				return S_FALSE;
			}
			m_vRgn[id].Reset();
			return S_OK;
		}

		Hobject RegionDetect;

		HTuple modelPARAID = m_vRgnReadData[id];
		if(m_dictCrtPathRgn.find(strRgnPath) == m_dictCrtPathRgn.end())
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		Hobject roiRgn = m_dictCrtPathRgn[strRgnPath];
		m_modelPARA = modelPARAID;

		Hobject  RegionAffineTrans;
		move_region (roiRgn,&RegionAffineTrans,fCenterY,fCenterX) ;
		//
		if (0!=(m_modelAngle.Num()!=0))
		{
			HTuple   HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX,0,fCenterY,fCenterX,m_modelAngle,&HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (RegionAffineTrans, &RegionAffineTrans, HomMat2DAdapted, "bilinear");
			//
			difference(RegionCenter,RegionAffineTrans,&RegionAffineTrans);
			difference(RegionAffineTrans ,m_rgnCharacter,&RegionAffineTrans);
			m_vRgn[id] = RegionAffineTrans ;	
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		//	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RegionLocationDiffByModelToolHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("575$\
					 167;B$\
					 194;FP;1.0;2000.0;0.5;205$\
					 232;SPR" );

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CenterRelocationAlgoHS1(VARIANT* rgnId,  VARIANT* pRadius,VARIANT* pStdRadius, VARIANT* pThreshValue, VARIANT* pOpeningSize, VARIANT* pClosingSize)
{
	int id = (int)rgnId->fltVal;
	double Radius = (double)pRadius->fltVal;
	double StdRadius = (double)pStdRadius->fltVal;
	double ThreshValue= (double)pThreshValue->fltVal;
	double OpeningSize= (double)pOpeningSize->fltVal;
	double ClosingSize = (double)pClosingSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
#ifdef NDEBUG
	try
	{
#endif 
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		Hobject Image = m_ImageScaleMax;

		//scale_image_max(Image,&Image);
		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		Hobject Circle,RegionErosion;
		gen_circle(&Circle, fCenterY, fCenterX, Radius);
		erosion_circle(Circle, &RegionErosion, 8);

		Hobject ImageReduced,Regions;
		reduce_domain(Image, RegionErosion, &ImageReduced);
		threshold(ImageReduced, &Regions, 0, ThreshValue);
		Hobject RegionClosing,RegionOpening;
		opening_circle(Regions, &RegionOpening, OpeningSize+0.5);
		closing_circle(RegionOpening, &RegionClosing, ClosingSize+0.5);
		HTuple hv_Class;
		get_obj_class(RegionClosing, &hv_Class);
		if (0 != (hv_Class==HTuple("region")))
		{	
			Hobject ReLocationCircle;
			HTuple Row_Center, Column_Center, Radius_Center;
			smallest_circle(RegionClosing, &Row_Center, &Column_Center, &Radius_Center);
			//
			if((Radius_Center<StdRadius*1.3)&(Radius_Center>StdRadius*0.7))
			{
				gen_circle(&ReLocationCircle, Row_Center, Column_Center, Radius_Center);

				m_locationRadius=Radius_Center;

				m_InnerCircleRow=Row_Center;
				m_InnerCircleCol=Column_Center;

				m_vPos[0].m_y = (float)Row_Center[0].D();
				m_vPos[0].m_x = (float)Column_Center[0].D();
				m_vRgn[id] = ReLocationCircle;
			}
			else
			{
				m_InnerCircleRow=m_imgHeight/2;
				m_InnerCircleCol=m_imgWidth/2;
				gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, StdRadius);
				m_vPos[0].m_x = 0.0;
				m_vPos[0].m_y = 0.0;
				m_vRgn[id] = Circle;
				return S_FALSE;
			}		
		}
		else
		{
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, StdRadius);
			m_vPos[0].m_x = 0.0;
			m_vPos[0].m_y = 0.0;
			m_vRgn[id] = Circle;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterRelocationAlgoHS1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("685$\
					 381;B$\
					 862;FP;80;350;1;250$\
					 374;FP;10;250;1;130$\
					 863;FP;1;250;0.5;50$\
					 864;FP;1;200;0.5;30$\
					 865;FP;1;200;0.5;100");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ModelCreate2(double Radius,int UsePolarity,  HTuple * ModelID1)
{
	//产生一个标准圆创建一个形状模板
	if (Radius <= 0) 
	{
		return S_FALSE;
	}
	else
	{
		Hobject ContCircle, EmptyImage, SyntheticModelImage;
		HTuple  SizeSynthImage = 2* Radius + 10;

		gen_circle_contour_xld(&ContCircle, SizeSynthImage/2, SizeSynthImage/2, Radius, 0, 6.28318, "positive", 1);
		gen_image_const(&EmptyImage, "byte", SizeSynthImage, SizeSynthImage);
		paint_xld(ContCircle, EmptyImage, &SyntheticModelImage, 128);
		//
		if(UsePolarity)
		{
			invert_image(SyntheticModelImage,&SyntheticModelImage);
		}
		//create_scaled_shape_model(SyntheticModelImage, "auto", 0, 0, 0, 0.95, 1.05, "auto","auto", "use_polarity", 40, "auto", ModelID1);
		create_scaled_shape_model(SyntheticModelImage, "auto", 0, 0, 0, 0.9, 1.1, "auto","auto", "use_polarity", 40, "auto", ModelID1);
		return S_OK;
	}
}
STDMETHODIMP CPlugAlgo::CenterReLocationAlgo2(VARIANT* rgnId,VARIANT* pUsePolarity, VARIANT* pRadius, VARIANT* pMinScore)
{
	/*利用形状模板来定位圆*/
	int id = (int)rgnId->fltVal;
	int  UsePolarity=(int)pUsePolarity->fltVal;
	double Radius = (double)pRadius->fltVal;
	float MinScore = (float)pMinScore->fltVal;
	Hobject newRgn;
	m_vRgn[id] = newRgn;

	double Row, Column, Radius1;
	Hlong Width, Height;
	HTuple CenterRow, CenterColumn, Angle, Scale, Score, CenterRadius, MovementOfObject, MoveAndScaleOfObject;
	Hobject  ContCircle, EmptyImage, SyntheticModelImage;
	Hobject  ShapeModelImage, ShapeModelRegion, ShapeModel, SearchImage;
	Hobject  Ellipse, ImageReduced, ModelAtNewPosition, Region, Circle1;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData.clear();
		}
		//
		Hobject Image = m_crtImg;

		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		Hobject ROI,ImageReduced0,ImageReducedScaled;
		gen_circle(&ROI,fCenterY, fCenterX, Radius+Radius/2);
		reduce_domain(Image,ROI,&ImageReduced0);
		scale_image_max(ImageReduced0,&ImageReducedScaled);

		//gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/5.0, Height/5.0);   //默认图片的大小有要求
		gen_circle(&Ellipse,fCenterY, fCenterX, Radius/2);

		reduce_domain (ImageReducedScaled, Ellipse, &ImageReduced);
		if(m_isFirstBot)
		{
			ModelCreate2(Radius,UsePolarity, &m_modelIdBot);
			m_isFirstBot = false;
		}
		if(m_oldRadiusBot != Radius||m_oldPalarity!=UsePolarity )
		{
			clear_shape_model(m_modelIdBot);
			ModelCreate2(Radius,UsePolarity, &m_modelIdBot);
			m_oldRadiusBot = Radius;
			m_oldPalarity=UsePolarity;
		}
		get_shape_model_contours (&ShapeModel, m_modelIdBot, 1);
		find_scaled_shape_model (ImageReduced, m_modelIdBot, 0, 0, 0.9, 1.1, MinScore, 1, 0.5, "least_squares", (HTuple(4).Append(-2)), 0.7, &CenterRow, &CenterColumn, &Angle, &Scale, &Score);
		if (CenterRow.Num()==0)
		{
			gen_circle(&Circle1,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			m_vRgn[id] = Circle1;
			//
			m_InnerCircleRow=fCenterY;
			m_InnerCircleCol=fCenterX;
			return S_FALSE;
		}
		double a =abs(CenterColumn[0].D()-fCenterX);
		double b =abs(CenterRow[0].D()-fCenterY);
		if ((0 != (Score>0.05))&&(a<15)&&(b<15))
		{
			vector_angle_to_rigid(0, 0, 0, CenterRow[0].D(), CenterColumn[0].D(), Angle[0].D(), &MovementOfObject);
			hom_mat2d_scale(MovementOfObject, Scale[0].D(), Scale[0].D(),CenterRow[0].D(), CenterColumn[0].D(), &MoveAndScaleOfObject);
			affine_trans_contour_xld(ShapeModel, &ModelAtNewPosition, MoveAndScaleOfObject);
			gen_region_contour_xld(ModelAtNewPosition, &Region, "filled");
			smallest_circle(Region, &Row, &Column, &Radius1);
			Hobject Circle, RegionDifference;
			gen_circle(&Circle, Row, Column, Radius1);
			gen_circle(&Circle1, Row, Column, Radius);
			m_vPos[0].m_y = (float)Row;
			m_vPos[0].m_x = (float)Column;

			//
			m_InnerCircleRow=(float)Row;
			m_InnerCircleCol=(float)Column;
			if(Circle.Id() != H_EMPTY_REGION) 
			{
				if(Radius1 >= Radius)
				{
					if(Radius1-Radius < 1)
					{
						gen_circle(&Circle, Row, Column, Radius1+1);
					}
					else
					{
						gen_circle(&Circle, Row, Column, Radius1);
					}
					difference (Circle, Circle1, &RegionDifference);
				}
				else
				{
					if(Radius - Radius1 < 1)
					{
						gen_circle(&Circle, Row, Column, Radius1-1);
					}
					else
					{
						gen_circle(&Circle, Row, Column, Radius1);
					}
					difference (Circle1, Circle, &RegionDifference);
				}
				m_vRgn[id] = RegionDifference;
			}
		}
		else
		{
			gen_circle(&Circle1,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			m_vRgn[id] = Circle1;
			//
			m_InnerCircleRow=fCenterY;
			m_InnerCircleCol=fCenterX;
			return S_FALSE;
		}
#ifdef NDEBUG
	}

	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CenterReLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("948$\
					 381;B$\
					 949;LP;0;1;1;1$\
					 374;LP;10;2000;1;192$\
					 377;FP;0.5;1.0;0.05;0.85");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//D13_侧面（13单叉、双叉）
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgo(VARIANT* rgnId, VARIANT* pThresholdLow,VARIANT* pOutlierRemoverSize,VARIANT* pErosionSize)
{
	/*异形胶塞侧面工站中心定位*/
	int id = (int)rgnId->fltVal;
	int ThresholdLow = (int)pThresholdLow->fltVal;
	int OutlierRemoverSize = (int)pOutlierRemoverSize->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	Hlong Width, Height;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject Image = m_crtImg;
		Hobject Ellipse,ImageReduced;
		get_image_size (Image, &Width, &Height);
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/1.6, Height/2.0);   //默认图片的大小有要求(/0.1)
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		reduce_domain (Image, Ellipse, &ImageReduced);
		Hobject ImageReducedScaleMax;
		scale_image_max(ImageReduced,&ImageReducedScaleMax);

		//*提取整个ROI
		Hobject Regions,ConnectedRegions,RegionFillUp,RegionOpening,RegionSelect,RegionClosing;
		threshold(ImageReducedScaleMax, &Regions, ThresholdLow, 255);

		fill_up(Regions, &RegionFillUp);
		opening_circle(RegionFillUp, &RegionOpening, OutlierRemoverSize+0.5);

		connection(RegionOpening, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);
		closing_circle(RegionSelect, &RegionClosing, 3.5);

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(RegionClosing,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(RegionClosing, &ROI, ErosionSize);
			m_vPos[0].m_x =(float)ROIcol[0].D();
			m_vPos[0].m_y =(float)ROIrow[0].D();
			m_vRgn[id] = ROI;
			m_ROI=ROI;
			m_WholeRoi=RegionSelect;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vPos[0].m_x = (float)(m_imgWidth/2.0);
			m_vPos[0].m_y = (float)(m_imgHeight/2.0);
			m_vRgn[id] = Circle;
			m_ROI=newRgn;
			m_WholeRoi=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1013$\
					 381;B$\
					 640;LP;1;255;1;23$\
					 641;LP;1;800;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名：SideCenterLocationAlgoForColor
** 功  能：针对一种32胶塞因为挡板干扰开发的侧面中心定位算子
** 时  间：2019年11月27日
**********************************************************************************/
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgoForColor(VARIANT* rgnId, VARIANT* pColorTransType,VARIANT* pChannelSelect,VARIANT* pRowBgn,VARIANT* pRgnWidth,VARIANT* pRgnHeight,VARIANT* pThresholdLow,VARIANT* pOutlierRemoverSize,VARIANT* pErosionSize)
{
	/*异形胶塞侧面工站中心定位*/
	int id = (int)rgnId->fltVal;
	int ColorTransType     = (int)pColorTransType->fltVal;
	int ChannelSelect      = (int)pChannelSelect->fltVal;
	int RowBgn             = (int)pRowBgn->fltVal;
	int RgnWidth           = (int)pRgnWidth->fltVal;
	int RgnHeight          = (int)pRgnHeight->fltVal;
	int ThresholdLow       = (int)pThresholdLow->fltVal;
	int OutlierRemoverSize = (int)pOutlierRemoverSize->fltVal;
	float ErosionSize      = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}

		HTuple  iWidth,iHeight;
		get_image_size(m_crtImg,&iWidth,&iHeight );

		Hobject Image;
		HTuple  ChannelNum = 1;
		count_channels(m_crtImgMult,&ChannelNum);
		if (ChannelNum[0].I()==3)
		{
			if(!H_ColorImageTransAll(m_crtImgMult,&Image,ColorTransType, ChannelSelect))
			{
				Hobject Circle,newRgn;
				gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
				m_vPos[0].m_x = (float)(m_imgWidth/2.0);
				m_vPos[0].m_y = (float)(m_imgHeight/2.0);
				m_vRgn[id] = Circle;
				m_ROI=newRgn;
				m_WholeRoi=newRgn;
				return S_FALSE;
			}
		}
		else
		{
			Image = m_crtImg;
		}

		Hobject Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, iHeight/2.0, iWidth/2.0, 0.0, iWidth/1.6, iHeight/2.0);   //默认图片的大小有要求(/0.1)
		m_imgWidth  = (long)iWidth[0].I();
		m_imgHeight = (long)iHeight[0].I();

		reduce_domain (Image, Ellipse, &ImageReduced);
		Hobject ImageReducedScaleMax;
		scale_image_max(ImageReduced,&ImageReducedScaleMax);

		// 冠部搜索区域
		if ( RowBgn >= iHeight)
		{
			RowBgn = iHeight[0].I()-1;
		}
		if ( RgnWidth  > iWidth/2)
		{
			RgnWidth = (iWidth[0].I())/2-3;
		}

		Hobject  rgnRect,rgnImgDomain ;
		gen_rectangle1(&rgnRect,RowBgn,RgnWidth, RowBgn+RgnHeight,iWidth - RgnWidth );

		get_domain(Image,&rgnImgDomain);
		intersection(rgnRect,rgnImgDomain,&rgnRect );

		// 冠部搜索
		Hobject imgRect,rgnThr,rgnFil,rgnOpn,rgnCon,rgnSel,rgnCls;
		reduce_domain(ImageReducedScaleMax,rgnRect, &imgRect);
        threshold(imgRect, &rgnThr, ThresholdLow/2.0, 255);
		fill_up(rgnThr, &rgnFil);
		opening_circle(rgnFil, &rgnOpn, OutlierRemoverSize/2.0+0.5);
		connection(rgnOpn, &rgnCon);
		select_shape_std(rgnCon, &rgnSel, "max_area", 70);
		closing_circle(rgnSel, &rgnCls, 3.5);

		//*提取整个ROI
		Hobject Regions,ConnectedRegions,RegionFillUp,RegionOpening,RegionSelect,RegionClosing;
		threshold(ImageReducedScaleMax, &Regions, ThresholdLow, 255);

		fill_up(Regions, &RegionFillUp);
		opening_circle(RegionFillUp, &RegionOpening, OutlierRemoverSize+0.5);

		connection(RegionOpening, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);
		closing_circle(RegionSelect, &RegionClosing, 3.5);

		// 合并
		Hobject  rgnUni;
		union2(RegionClosing,rgnCls,&rgnUni );
		closing_rectangle1(rgnUni,&rgnUni,10,50 );

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(rgnUni,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(rgnUni, &ROI, ErosionSize);
			m_vPos[0].m_x =(float)ROIcol[0].D();
			m_vPos[0].m_y =(float)ROIrow[0].D();
			m_vRgn[id] = ROI;
			if (m_bDebugImg)
			{
				concat_obj(m_vRgn[id],rgnRect,&m_vRgn[id]);
			}
			m_ROI=ROI;
			m_WholeRoi=rgnUni;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vPos[0].m_x = (float)(m_imgWidth/2.0);
			m_vPos[0].m_y = (float)(m_imgHeight/2.0);
			m_vRgn[id] = Circle;
			m_ROI=newRgn;
			m_WholeRoi=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgoForColorHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6202$\
					 381;B$\
					 657;LP;0;6;1;0$\
					 658;LP;1;3;1;3$\
					 6203;LP;1;1000;1;800$\
					 6204;LP;1;800;1;200$\
					 6205;LP;1;800;1;350$\
					 640;LP;1;255;1;40$\
					 641;LP;1;800;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_GetEllipseLongAxis(Halcon::Hobject Ellipse, Halcon::Hobject * BaseRegionLine)
{
	HTuple BaseEllipseArea2, BaseEllipseRow2, BaseEllipseColumn2;
	HTuple BaseEllipseRadius2, BaseEllipseRadius3, BaseEllipsePhi2;
	area_center(Ellipse, &BaseEllipseArea2, &BaseEllipseRow2, &BaseEllipseColumn2);
	elliptic_axis(Ellipse, &BaseEllipseRadius2, &BaseEllipseRadius3, &BaseEllipsePhi2);
	HTuple RowPoint, ColPoint;
	get_points_ellipse(0, BaseEllipseRow2, BaseEllipseColumn2, BaseEllipsePhi2, BaseEllipseRadius2, BaseEllipseRadius3, &RowPoint, &ColPoint);
	HTuple RowPoint2,ColPoint2;
	RowPoint2 = RowPoint+((BaseEllipseRadius2*(BaseEllipsePhi2.Sin()))*2);
	ColPoint2 = ColPoint-((BaseEllipseRadius2*(BaseEllipsePhi2.Cos()))*2);
	gen_region_line(&(*BaseRegionLine), RowPoint, ColPoint, RowPoint2, ColPoint2);
	return;

}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pSearchSize, VARIANT* pHclipSize,VARIANT* pMaskSize, VARIANT* pThredLower, VARIANT* pThredUpper,VARIANT* pABEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int SearchSize  =(int)pSearchSize->fltVal;
	int HclipSize  =(int)pHclipSize->fltVal;

	float maskSize    = (float)pMaskSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;
	double ThredUpper = (double)pThredUpper->fltVal;
	if(ThredUpper<=ThredLower)
	{
		ThredUpper=ThredLower+0.5;
	}

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		Hobject ABsearchImage;

		//模板工具画基准椭圆->产生AB基准线搜索区域，通过AB基准线->拟合AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse0;
		HTuple Rows, Columns;
		boundary(rgn, &ABEllipse0, "outer");

		/*gen_contour_region_xld(rgn, &ABEllipseXld, "border");
		gen_region_contour_xld(ABEllipseXld, &ABEllipseReg, "margin");
		get_region_points(ABEllipseReg, &Rows, &Columns);
		gen_region_points(&ABEllipse0, Rows, Columns);*/
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse0, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);
		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HclipSize, HclipSize);
		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);
		Hobject ABsearchReg;
		dilation_rectangle1(ABReg, &ABsearchReg, 1, SearchSize);
		if(m_bDebugImg)
		{
			concat_obj (m_vRgn[rId], ABsearchReg, &m_vRgn[rId]);
		}
		//
		reduce_domain(crtImg, ABsearchReg, &ABsearchImage);
		Hobject ABsearchDerivGaus4,ABEdges;
		derivate_gauss(ABsearchImage, &ABsearchDerivGaus4, 1.0, "y");
		lines_gauss(ABsearchDerivGaus4, &ABEdges, maskSize, ThredLower, ThredUpper, "light", "true", "bar-shaped", "true");

		HTuple length,Ln,num;
		Hobject OutLengthN;
		count_obj(ABEdges,&num);
		if (num<1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		length_xld(ABEdges, &length);
		tuple_sort_index(length, &Ln);
		select_obj(ABEdges, &OutLengthN,(Ln.Select(num-1))+1);

		HTuple OutRow, OutCol;
		Hobject ABEdgeReg;
		get_contour_xld(OutLengthN, &OutRow, &OutCol);
		gen_region_points(&ABEdgeReg, OutRow, OutCol);
		HTuple ABAreaCenter, ABRowCenter, ABColumnCenter;
		area_center(ABEdgeReg, &ABAreaCenter, &ABRowCenter, &ABColumnCenter);

		Hobject SmoothXLD;
		smooth_contours_xld(OutLengthN,&SmoothXLD,5);

		HTuple ABEllipseRowCenter, ABEllipseColumnCenter, ABPhi, ABRadius1, ABRadius2, StartPhi, EndPhi, PointOrder;
		fit_ellipse_contour_xld(SmoothXLD, "fhuber", -1, 0, 0, 200, 3, 2, &ABEllipseRowCenter, &ABEllipseColumnCenter, &ABPhi, &ABRadius1, &ABRadius2, &StartPhi, &EndPhi, &PointOrder);
		Hobject ABEllipse;
		gen_ellipse(&ABEllipse, ABEllipseRowCenter, ABEllipseColumnCenter, ABPhi, ABRadius1, ABRadius2);

		////*获取AB基准线
		//Hobject BaseRegionLine,ABEllipseXld,ABEllipseBorder,RegionDiff1,ConnectedRegs1;
		//P_GetEllipseLongAxis(ABEllipse, &BaseRegionLine);
		//HTuple ABEllipseXldRow, ABEllipseXldCol;
		//gen_contour_region_xld(ABEllipse, &ABEllipseXld, "center");
		//get_contour_xld(ABEllipseXld, &ABEllipseXldRow, &ABEllipseXldCol);
		//gen_region_polygon(&ABEllipseBorder, ABEllipseXldRow, ABEllipseXldCol);
		//difference(ABEllipseBorder, BaseRegionLine, &RegionDiff1);
		//connection(RegionDiff1, &ConnectedRegs1);
		//Hobject ABEdge;
		//select_shape(ConnectedRegs1, &ABEdge, "row", "and", ABEllipseRowCenter, 99999);

		//不拟合椭圆
		Hobject ABEdge;
		gen_empty_region(&ABEdge);
		union2(ABEdge, ABEdgeReg, &ABEdge);

		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		area_center(ABEdge, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdge=ABEdge;
		m_ABEdgeRowS=ABEdgeRow;
		m_ABEllipse=ABEllipse;

		Hobject RegionClosingMoved,ABEdgeRegDilation;
		if(m_bDebugImg)
		{
			dilation_circle(ABEdgeReg, &ABEdgeRegDilation,3);
			concat_obj (m_vRgn[rId], ABEdgeRegDilation, &m_vRgn[rId]);
		}
		//
		Hobject ABEdgeDilation;
		//拟合后的半个椭圆边缘面积
		if(ABEdgeArea > 1)
		{
			retValue = ABEdgeArea[0].I();
			m_vErrorRgn[rId] = ABEllipse;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pABEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("986$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1100;LP;10;80;1;40$\
					 1101;LP;0;50;1;5$\
					 643;FP;0.1;20;0.1;1.5$\
					 762;FP;0.1;100;0.1;0.5$\
					 763;FP;0.1;254;0.1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		//用于提取侧面内壁区域
		m_ImageReducedAroi=ImageReducedAroi;


		////灰度均值进行阈值分割
		//Hobject ImageReducedAroiScaled;
		//scale_image_max(ImageReducedAroi,&ImageReducedAroiScaled);
		//HTuple Mean,Deviation;
		//intensity(AroiClosing,ImageReducedAroiScaled,&Mean,&Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//	ThredLower=254.0-Mean[0].D();
		//}

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroi, &Regions, ThredLower, 255);
		Hobject RegionsFillUp,TopRegionOpening,TopRegionClosing;
		fill_up(Regions,&RegionsFillUp);
		opening_circle(RegionsFillUp, &TopRegionOpening, 3.5);
		closing_circle(TopRegionOpening, &TopRegionClosing, 3.5);
		connection(TopRegionClosing, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);
		//closing_circle(RegionSelect,&AroiT,10);

		m_TopRegion=RegionSelect;

		Hobject AroiTClosing,TopAngleRegDiff,TopAngleRegConnected,TopAngleRegSelected;
		HTuple TopArea, TopRow, TopCol;
		closing_circle(RegionSelect, &AroiTClosing, 100);

		m_AroiTClosing=AroiTClosing;
		area_center(AroiTClosing, &TopArea, &TopRow, &TopCol);
		difference(AroiTClosing, RegionSelect, &TopAngleRegDiff);
		connection(TopAngleRegDiff, &TopAngleRegConnected);
		select_shape_std(TopAngleRegConnected, &TopAngleRegSelected, "max_area", 70);

		m_TopInnerRgion=TopAngleRegSelected;
		Hobject RegionErosion1,RegionClosingDiff,TopAngleReg;
		erosion_circle(AroiTClosing, &RegionErosion1, 3.5);
		difference(AroiTClosing, RegionErosion1, &RegionClosingDiff);
		intersection(RegionClosingDiff, TopAngleRegSelected, &TopAngleReg);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], Regions, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
			//concat_obj(m_vRgn[rId], TopAngleReg, &m_vRgn[rId]);
		}

		HTuple TopAngleArea, TopAngleRow, TopAngleCol,Angle;
		Hobject TopAngleLine;
		area_center(TopAngleReg, &TopAngleArea, &TopAngleRow, &TopAngleCol);
		//角度线段端点坐标
		m_TopRow=TopRow;
		m_TopCol=TopCol;
		m_TopAngleRow=TopAngleRow;
		m_TopAngleCol=TopAngleCol;

		if ((TopArea==0)||(TopAngleArea==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		gen_region_line(&TopAngleLine, TopRow, TopCol, TopAngleRow, TopAngleCol);
		HTuple AngleLineArea,LineRow,LineCol;
		area_center(TopAngleLine,&AngleLineArea,&LineRow,&LineCol);
		//line_orientation(TopRow, TopCol, TopAngleRow, TopAngleCol, &Angle);
		orientation_region(TopAngleLine, &Angle);
		if (0 != (Angle<0))
		{
			Angle += PI;
		}
		m_Angle=Angle;

		//Hobject RegionClosingMoved,ABEdgeDilation;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopAngleLine, &m_vRgn[rId]);
		}
		//
		HTuple Deg;
		tuple_deg(Angle, &Deg);
		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = Deg[0].D();
			dilation_circle(TopAngleLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("987$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;350;1;185$\
					 989;FP;0;250;0.5;145");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideTopRegAngleDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		scale_image_max(crtImg,&crtImg);
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		m_SideTopMoveCol=MoveSize;
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);//胶塞轮廓的 顶部区域。可进一步提取顶部平面区域。
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		//用于提取侧面内壁区域
		m_ImageReducedAroi=ImageReducedAroi;


		////灰度均值进行阈值分割
		//Hobject ImageReducedAroiScaled;
		//scale_image_max(ImageReducedAroi,&ImageReducedAroiScaled);
		//HTuple Mean,Deviation;
		//intensity(AroiClosing,ImageReducedAroiScaled,&Mean,&Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//	ThredLower=254.0-Mean[0].D();
		//}

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroi, &Regions, ThredLower, 255);
		Hobject RegionsFillUp;
		fill_up(Regions,&RegionsFillUp);
		Hobject TopRegionOpening,TopRegionClosing,RegionSelectUnion;
		opening_circle(RegionsFillUp, &TopRegionOpening, 3.5);
		closing_circle(TopRegionOpening, &TopRegionClosing, 3.5);
		connection(TopRegionClosing, &ConnectedRegions);
		select_shape(ConnectedRegions, &RegionSelect, "area", "and", 600,99999);
		//closing_circle(RegionSelect,&AroiT,10);
		union1(RegionSelect,&RegionSelectUnion);
		m_TopRegion=RegionSelectUnion;//顶部平面区域（两个顶部平面）

		Hobject AroiTClosing,TopAngleRegDiff,TopAngleRegConnected,TopAngleRegSelected;
		HTuple TopArea, TopRow, TopCol;
		closing_circle(RegionSelect, &AroiTClosing, 50);
		Hobject RegUnion;
		union1(AroiTClosing,&RegUnion);
		m_AroiTClosing=RegUnion;//顶部平面区域分别闭处理（两个顶部平面）
		area_center(AroiTClosing, &TopArea, &TopRow, &TopCol);//双叉胶塞 利用两个端面的区域中心定位。

		difference(AroiTClosing, RegionSelect, &TopAngleRegDiff);
		connection(TopAngleRegDiff, &TopAngleRegConnected);
		select_shape_std(TopAngleRegConnected, &TopAngleRegSelected, "max_area", 70);

		m_TopInnerRgion=TopAngleRegSelected;//提取顶部区域的缺口区域。目前两叉盖 该区域几乎为空。
		Hobject RegionErosion1,RegionClosingDiff,TopAngleReg;
		erosion_circle(AroiTClosing, &RegionErosion1, 3.5);
		difference(AroiTClosing, RegionErosion1, &RegionClosingDiff);
		intersection(RegionClosingDiff, TopAngleRegSelected, &TopAngleReg);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], Regions, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
			//concat_obj(m_vRgn[rId], TopAngleReg, &m_vRgn[rId]);
		}

		HTuple TopAngleArea, TopAngleRow, TopAngleCol,Angle;
		Hobject TopAngleLine;
		area_center(TopAngleReg, &TopAngleArea, &TopAngleRow, &TopAngleCol);
		//
		HTuple Length;
		tuple_length (TopRow, &Length);
		if (Length[0].I()!=2)
		{
			m_Angle=-1.0;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		else
		{
			//角度线段端点坐标

			m_TopRow=TopRow[0];
			m_TopCol=TopCol[0];
			m_TopAngleRow=TopRow[1];
			m_TopAngleCol=TopCol[1];
		}
		//
		gen_region_line(&TopAngleLine,m_TopRow,m_TopCol, m_TopAngleRow, m_TopAngleCol);
		HTuple AngleLineArea,LineRow,LineCol;
		area_center(TopAngleLine,&AngleLineArea,&LineRow,&LineCol);
		//line_orientation(TopRow, TopCol, TopAngleRow, TopAngleCol, &Angle);
		orientation_region(TopAngleLine, &Angle);
		if (0 != (Angle<0))
		{
			Angle += PI;
		}
		m_Angle=Angle;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopAngleLine, &m_vRgn[rId]);
		}
		//
		HTuple Deg;
		tuple_deg(Angle, &Deg);
		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = Deg[0].D();
			dilation_circle(TopAngleLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideTopRegAngleDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("987$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;350;1;185$\
					 989;FP;0;250;0.5;145");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_PlatformSelect(Hobject PlatformAB,Hobject PlatformRegions,HTuple SearchSize,HTuple TopRow,HTuple TopCol,HTuple TopAngleRow,HTuple TopAngleCol, Hobject * Platform,Hobject * PlatformReg,Hobject *PlatformRegDilation0)
{
	//筛选平台区域，剔除干扰区域
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);
	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegErosion,PlatformRegConnected;
	HTuple PlatformRegNum;
	//connection(PlatformRegDilation, &PlatformRegConnected);
	Hobject PlatformRegDilationUion;
	union1(PlatformRegions,&PlatformRegDilationUion);
	HTuple PlatformRegDilationArea,PlatformRegDilationRow,PlatformRegDilationCol;
	area_center(PlatformRegDilationUion,&PlatformRegDilationArea,&PlatformRegDilationRow,&PlatformRegDilationCol);
	if (PlatformRegDilationArea>0)
	{
		count_obj(PlatformRegions, &PlatformRegNum);
		Hobject PlatformRegs,PlatformRegSelected;
		HTuple PlatformArea, PlatformRow, PlatformCol,PlatformColRound,ABColIndice,PlatABrow;
		gen_empty_obj(&PlatformRegs);
		for (int i=1;i<=PlatformRegNum;i++)
		{
			select_obj(PlatformRegions, &PlatformRegSelected, i);
			area_center(PlatformRegSelected, &PlatformArea, &PlatformRow, &PlatformCol);
			tuple_round(PlatformCol, &PlatformColRound);
			tuple_find(PlatformABColsRound, PlatformColRound, &ABColIndice);
			if (ABColIndice==-1)
			{
				return;
			}

			PlatABrow = PlatformABRowsRound.Select(ABColIndice.Select(0));
			HTuple RowDiff;
			RowDiff=PlatABrow-PlatformRow;
			if (0 != (RowDiff<(SearchSize/2)))
			{
				concat_obj(PlatformRegs, PlatformRegSelected, &PlatformRegs);
			}
		}

		Hobject PlatformRegsConnected;
		HTuple PlatformRegNum1;
		union1(PlatformRegs, &PlatformRegs);
		connection(PlatformRegs, &PlatformRegsConnected);
		count_obj(PlatformRegsConnected, &PlatformRegNum1);

		Hobject PlatformRegSelected1,PlatformABIntersection,PlatformRegs1;
		HTuple Area, Row, Column;
		gen_empty_obj(&PlatformRegs1);
		for (int i=1;i<=PlatformRegNum1;i++)
		{
			select_obj(PlatformRegsConnected, &PlatformRegSelected1, i);
			intersection(PlatformRegSelected1, PlatformAB, &PlatformABIntersection);
			area_center(PlatformABIntersection, &Area, &Row, &Column);
			if(Area>0)
			{
				concat_obj(PlatformRegs1, PlatformRegSelected1, &PlatformRegs1);
			}
		}
		HTuple PlatformRegsNum;
		union1(PlatformRegs1,&PlatformRegs1);
		connection(PlatformRegs1, &PlatformRegs1);
		count_obj(PlatformRegs1, &PlatformRegsNum);

		//根据与叉口朝向线段的角度进行筛选
		Hobject PlatformRegsUnion;
		HTuple PlatformAngles,PlatformRegsUnionArea,PlatformRegsUnionRow,PlatformRegsUnionCol;
		gen_empty_region(&(*PlatformReg));
		//
		union1(PlatformRegs1,&PlatformRegsUnion);
		area_center(PlatformRegsUnion,&PlatformRegsUnionArea,&PlatformRegsUnionRow,&PlatformRegsUnionCol);

		PlatformAngles = HTuple();
		Hobject PlatformSelected;
		HTuple PlatformArea1, PlatformRow1, PlatformCol1,PlatformAngle,PlatformAngleAbs,PlatformAngleMin,PlatformAngleIndice;
		if (0 != (PlatformRegsUnionArea>0))
		{
			for (int i=1; i<=PlatformRegsNum; i++)
			{
				select_obj(PlatformRegs1, &PlatformSelected, i);
				area_center(PlatformSelected, &PlatformArea1, &PlatformRow1, &PlatformCol1);
				//move_region(PlatformSelected, &PlatformRegSelectedMoved, -(PlatformRow1-TopAngleRow), 0);
				angle_ll(TopRow, TopCol, TopAngleRow, PlatformCol1, TopRow, TopCol, TopAngleRow, TopAngleCol, &PlatformAngle);
				tuple_abs(PlatformAngle, &PlatformAngleAbs);
				//tuple_deg(PlatformAngleAbs, &Deg);
				PlatformAngles.ReplaceElements(i-1,PlatformAngleAbs);
			}
			tuple_min(PlatformAngles, &PlatformAngleMin);
			tuple_find(PlatformAngles, PlatformAngleMin, &PlatformAngleIndice);
			select_obj(PlatformRegs1, &(*PlatformReg), PlatformAngleIndice+1);

		}
		HTuple PlatformRegArea, PlatformRegRow, PlatformRegCol;
		area_center(*PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegCol);

		* Platform=*PlatformReg;
		Hobject PlatformRegDilation1,PlatformRegDiff,PlatformRegDiffConnected,SelectedRegions;
		dilation_rectangle1((*PlatformReg), &(*PlatformRegDilation0), 1, 500);
		dilation_circle((*PlatformReg), &PlatformRegDilation1, 3.5);
		difference((*PlatformRegDilation0), PlatformRegDilation1, &PlatformRegDiff);
		connection(PlatformRegDiff, &PlatformRegDiffConnected);
		select_shape(PlatformRegDiffConnected, &SelectedRegions, "row", "and", PlatformRegRow, 999999);
		difference((*PlatformRegDilation0), SelectedRegions, &(*PlatformReg));
	}
	else
	{
		gen_empty_region(&(*Platform));
		gen_empty_region(&(*PlatformReg));
		gen_empty_region(&(*PlatformRegDilation0));
	}
	return;
}
STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower,VARIANT* pAngle, VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;
	int HSearchSize    =(int)pHSearchSize->fltVal;

	double ThredLower   = (double)pThredLower->fltVal;
	double Angle   = (double)pAngle->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_ImageScaleMax;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//注意颈部基准线平移到平台的中间区域,且低于花纹区域
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT,PlatformSearch;

		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		//opening_circle(PlatformRegDilationT, &PlatformSearch, 5);
		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);

		////灰度均值
		//HTuple Mean, Deviation;
		//intensity(PlatformSearch, PlatformImageReduced, &Mean, &Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//	ThredLower=254.0-Mean[0].D();
		//}
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);

		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle (PlatformRegFillup, &PlatformRegErosion, 1.5);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 1.5);

		//剔除小缺陷
		Hobject PlatformRegConnected,PlatformRegions;
		connection(PlatformRegDilation,&PlatformRegConnected);
		select_shape(PlatformRegConnected, &PlatformRegions, "area", "and", 10, 9999999);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_TopAngleCol==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject Platform,PlatformReg,Platform0;
		gen_empty_region(&Platform);
		gen_empty_region(&PlatformReg);
		gen_empty_region(&Platform0);

		//用于判断生成ARegionT
		m_AngleP=Angle;  

		if (Angle>=0)
		{
			HTuple a,b,c;
			tuple_rad(Angle, &a);
			tuple_rad((180-Angle), &b);
			tuple_rad(180, &c);

			if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<a))//第一象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol<m_TopCol)&&(m_Angle>b)&&(m_Angle<c))//第二象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol))//第三象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol))//第四象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
		} 
		else
		{
			HTuple a,b,c;
			tuple_rad(-Angle, &a);
			tuple_rad((180+Angle), &b);
			tuple_rad(180, &c);

			if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
		}

		//if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//
		//dilation_rectangle1(PlatformReg,&PlatformReg,DilationSize,1);

		m_Platform0=Platform0;
		m_PlatformReg=PlatformReg;
		m_Platform=Platform;
		if(m_bDebugImg)
		{
			//dilation_rectangle1(Platform,&Platform,DilationSize,1);
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;75$\
					 998;LP;1;100;1;60$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;60$\
					 1097;FP;-5;10;0.1;2.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//去掉角度测试，目前仅屏蔽了个别返回-1的情况
void CPlugAlgo::P_PlatformSelectNoAngle(Hobject PlatformAB,Hobject PlatformRegions,HTuple SearchSize,HTuple TopRow,HTuple TopCol,HTuple TopAngleRow,HTuple TopAngleCol, Hobject * Platform,Hobject * PlatformReg,Hobject *PlatformRegDilation0)
{
	//筛选平台区域，剔除干扰区域
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);
	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegErosion,PlatformRegConnected;
	HTuple PlatformRegNum;
	//connection(PlatformRegDilation, &PlatformRegConnected);
	Hobject PlatformRegDilationUion;
	union1(PlatformRegions,&PlatformRegDilationUion);
	HTuple PlatformRegDilationArea,PlatformRegDilationRow,PlatformRegDilationCol;
	area_center(PlatformRegDilationUion,&PlatformRegDilationArea,&PlatformRegDilationRow,&PlatformRegDilationCol);
	if (PlatformRegDilationArea>0)
	{
		count_obj(PlatformRegions, &PlatformRegNum);
		Hobject PlatformRegs,PlatformRegSelected;
		HTuple PlatformArea, PlatformRow, PlatformCol,PlatformColRound,ABColIndice,PlatABrow;
		gen_empty_obj(&PlatformRegs);
		for (int i=1;i<=PlatformRegNum;i++)
		{
			select_obj(PlatformRegions, &PlatformRegSelected, i);
			area_center(PlatformRegSelected, &PlatformArea, &PlatformRow, &PlatformCol);
			tuple_round(PlatformCol, &PlatformColRound);
			tuple_find(PlatformABColsRound, PlatformColRound, &ABColIndice);
			if (ABColIndice==-1)
			{
				return;
			}

			PlatABrow = PlatformABRowsRound.Select(ABColIndice.Select(0));
			HTuple RowDiff;
			RowDiff=PlatABrow-PlatformRow;
			if (0 != (RowDiff<(SearchSize/2)))
			{
				concat_obj(PlatformRegs, PlatformRegSelected, &PlatformRegs);
			}
		}

		Hobject PlatformRegsConnected;
		HTuple PlatformRegNum1;
		union1(PlatformRegs, &PlatformRegs);
		connection(PlatformRegs, &PlatformRegsConnected);
		count_obj(PlatformRegsConnected, &PlatformRegNum1);

		Hobject PlatformRegSelected1,PlatformABIntersection,PlatformRegs1;
		HTuple Area, Row, Column;
		gen_empty_obj(&PlatformRegs1);
		for (int i=1;i<=PlatformRegNum1;i++)
		{
			select_obj(PlatformRegsConnected, &PlatformRegSelected1, i);
			intersection(PlatformRegSelected1, PlatformAB, &PlatformABIntersection);
			area_center(PlatformABIntersection, &Area, &Row, &Column);
			if(Area>0)
			{
				concat_obj(PlatformRegs1, PlatformRegSelected1, &PlatformRegs1);
			}
		}
		HTuple PlatformRegsNum;
		union1(PlatformRegs1,&PlatformRegs1);
		connection(PlatformRegs1, &PlatformRegs1);
		count_obj(PlatformRegs1, &PlatformRegsNum);

		//根据与叉口朝向线段的角度进行筛选
		Hobject PlatformRegsUnion;
		HTuple PlatformAngles,PlatformRegsUnionArea,PlatformRegsUnionRow,PlatformRegsUnionCol;
		gen_empty_region(&(*PlatformReg));
		//
		union1(PlatformRegs1,&PlatformRegsUnion);
		area_center(PlatformRegsUnion,&PlatformRegsUnionArea,&PlatformRegsUnionRow,&PlatformRegsUnionCol);

		PlatformAngles = HTuple();
		Hobject PlatformSelected;
		HTuple PlatformArea1, PlatformRow1, PlatformCol1,PlatformAngle,PlatformAngleAbs,PlatformAngleMin,PlatformAngleIndice;
		if (0 != (PlatformRegsUnionArea>0))
		{
			for (int i=1; i<=PlatformRegsNum; i++)
			{
				select_obj(PlatformRegs1, &PlatformSelected, i);
				area_center(PlatformSelected, &PlatformArea1, &PlatformRow1, &PlatformCol1);
				//move_region(PlatformSelected, &PlatformRegSelectedMoved, -(PlatformRow1-TopAngleRow), 0);
				angle_ll(TopRow, TopCol, TopAngleRow, PlatformCol1, TopRow, TopCol, TopAngleRow, TopAngleCol, &PlatformAngle);
				tuple_abs(PlatformAngle, &PlatformAngleAbs);
				//tuple_deg(PlatformAngleAbs, &Deg);
				PlatformAngles.ReplaceElements(i-1,PlatformAngleAbs);
			}
			tuple_min(PlatformAngles, &PlatformAngleMin);
			tuple_find(PlatformAngles, PlatformAngleMin, &PlatformAngleIndice);
			select_obj(PlatformRegs1, &(*PlatformReg), PlatformAngleIndice+1);

		}
		HTuple PlatformRegArea, PlatformRegRow, PlatformRegCol;
		area_center(*PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegCol);

		* Platform=*PlatformReg;
		Hobject PlatformRegDilation1,PlatformRegDiff,PlatformRegDiffConnected,SelectedRegions;
		dilation_rectangle1((*PlatformReg), &(*PlatformRegDilation0), 1, 500);
		dilation_circle((*PlatformReg), &PlatformRegDilation1, 3.5);
		difference((*PlatformRegDilation0), PlatformRegDilation1, &PlatformRegDiff);
		connection(PlatformRegDiff, &PlatformRegDiffConnected);
		select_shape(PlatformRegDiffConnected, &SelectedRegions, "row", "and", PlatformRegRow, 999999);
		difference((*PlatformRegDilation0), SelectedRegions, &(*PlatformReg));
	}
	else
	{
		gen_empty_region(&(*Platform));
		gen_empty_region(&(*PlatformReg));
		gen_empty_region(&(*PlatformRegDilation0));
	}
	return;
}
STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower,VARIANT* pAngle, VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;
	int HSearchSize    =(int)pHSearchSize->fltVal;

	double ThredLower   = (double)pThredLower->fltVal;
	double Angle   = (double)pAngle->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_ImageScaleMax;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//注意颈部基准线平移到平台的中间区域,且低于花纹区域
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT,PlatformSearch;

		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		//opening_circle(PlatformRegDilationT, &PlatformSearch, 5);
		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);

		////灰度均值
		//HTuple Mean, Deviation;
		//intensity(PlatformSearch, PlatformImageReduced, &Mean, &Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//	ThredLower=254.0-Mean[0].D();
		//}
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);

		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle (PlatformRegFillup, &PlatformRegErosion, 1.5);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 1.5);

		//剔除小缺陷
		Hobject PlatformRegConnected,PlatformRegions;
		connection(PlatformRegDilation,&PlatformRegConnected);
		select_shape(PlatformRegConnected, &PlatformRegions, "area", "and", 10, 9999999);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_TopAngleCol==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject Platform,PlatformReg,Platform0;
		gen_empty_region(&Platform);
		gen_empty_region(&PlatformReg);
		gen_empty_region(&Platform0);

		//用于判断生成ARegionT
		m_AngleP=Angle;  

		if (Angle>=0)
		{
			HTuple a,b,c;
			tuple_rad(Angle, &a);
			tuple_rad((180-Angle), &b);
			tuple_rad(180, &c);

			if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<a))//第一象限、剔除小角度
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol<m_TopCol)&&(m_Angle>b)&&(m_Angle<c))//第二象限、剔除小角度
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol))//第三象限
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol))//第四象限
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
		} 
		else
		{
			HTuple a,b,c;
			tuple_rad(-Angle, &a);
			tuple_rad((180+Angle), &b);
			tuple_rad(180, &c);

			if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
			{
				P_PlatformSelectNoAngle(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
		}

		//if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//
		//dilation_rectangle1(PlatformReg,&PlatformReg,DilationSize,1);

		m_Platform0=Platform0;
		m_PlatformReg=PlatformReg;
		m_Platform=Platform;
		if(m_bDebugImg)
		{
			//dilation_rectangle1(Platform,&Platform,DilationSize,1);
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{

			retValue = 100;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_OK;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;75$\
					 998;LP;1;100;1;60$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;60$\
					 1097;FP;-5;10;0.1;2.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower,VARIANT* pAngle, VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;
	int HSearchSize    =(int)pHSearchSize->fltVal;

	double ThredLower   = (double)pThredLower->fltVal;
	double Angle   = (double)pAngle->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_ImageScaleMax;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//注意颈部基准线平移到平台的中间区域,且低于花纹区域
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT,PlatformSearch;

		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		//opening_circle(PlatformRegDilationT, &PlatformSearch, 5);
		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);

		////灰度均值
		//HTuple Mean, Deviation;
		//intensity(PlatformSearch, PlatformImageReduced, &Mean, &Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//	ThredLower=254.0-Mean[0].D();
		//}
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);

		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle (PlatformRegFillup, &PlatformRegErosion, 1.5);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 1.5);

		//剔除小缺陷
		Hobject PlatformRegConnected,PlatformRegions;
		connection(PlatformRegDilation,&PlatformRegConnected);
		select_shape(PlatformRegConnected, &PlatformRegions, "area", "and", 10, 9999999);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_TopAngleCol==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject Platform,PlatformReg,Platform0;
		gen_empty_region(&Platform);
		gen_empty_region(&PlatformReg);
		gen_empty_region(&Platform0);

		//用于判断生成ARegionT
		m_AngleP=Angle;  

		if (Angle>=0)
		{
			/*		HTuple a,b,c;
			tuple_rad(Angle, &a);
			tuple_rad((180-Angle), &b);
			tuple_rad(180, &c);
			*/
			if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol>m_TopCol))//第一象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol<m_TopCol))//第二象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol))//第三象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol))//第四象限
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
			//my_disp_obj(Platform);
			//my_disp_obj(PlatformReg);
			//my_disp_obj(Platform0);
		} 
		else
		{
			HTuple a,b,c;
			tuple_rad(-Angle, &a);
			tuple_rad((180+Angle), &b);
			tuple_rad(180, &c);

			if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
			{
				P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
			}
			else
			{
				//m_Platform0 剔除AB基准线
				//m_PlatformReg  剔除颈部叉口区域
				//m_Platform 侧面叉口检测区域
				m_Platform0=Platform0;
				m_PlatformReg=PlatformReg;
				m_Platform=Platform;

				retValue = 100;
				m_vErrorRgn[rId].Reset();
				retValue.Detach(pPlatformArea);
				return S_OK;
			}
		}

		//if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a))//第三象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//else if ((m_TopAngleRow>=m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)&&(m_Angle>0))//第四象限、剔除小角度
		//{
		//	P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		//}
		//
		//dilation_rectangle1(PlatformReg,&PlatformReg,DilationSize,1);

		m_Platform0=Platform0;
		m_PlatformReg=PlatformReg;
		m_Platform=Platform;
		if(m_bDebugImg)
		{
			//dilation_rectangle1(Platform,&Platform,DilationSize,1);
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea<=0)
		{
			m_Platform0=Platform0;
			m_PlatformReg=PlatformReg;
			m_Platform=Platform;

			retValue = 100;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_OK;
		}
		else
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_PlatformDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;75$\
					 998;LP;1;100;1;60$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;60$\
					 1097;FP;-5;10;0.1;2.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_EdgePointsFitCurve(Hobject SearchReg, Hobject Image,HTuple PartInterval, HTuple LineLength, HTuple RemoveSize, HTuple * DefinedRow, HTuple *DefinedCol)
{
	Hobject ReinforcedRegPartitioned,SortedRegions,ReinRegPartitioned;
	HTuple PartitionedNum,SearchRegArea,SearchRegRow,SearchRegCol;
	area_center(SearchReg,&SearchRegArea,&SearchRegRow,&SearchRegCol);
	if (SearchRegArea==0||SearchRegArea.Num()==0)
	{
		return;
	}
	partition_rectangle(SearchReg, &ReinforcedRegPartitioned, PartInterval, 300);
	sort_region(ReinforcedRegPartitioned, &SortedRegions, "first_point", "true", "column");
	count_obj(SortedRegions, &PartitionedNum);
	gen_empty_obj(&ReinRegPartitioned);
	if ((RemoveSize<1)||(RemoveSize>PartitionedNum))
	{
		return;
	}
	Hobject PartitionedSelected;
	for (int i=RemoveSize[0].I();i<=(PartitionedNum-RemoveSize);i++)
	{
		select_obj(SortedRegions, &PartitionedSelected, i);
		concat_obj(PartitionedSelected, ReinRegPartitioned, &ReinRegPartitioned);

	}
	HTuple PartitionedArea, PartitionedRow, PartitionedCol;
	area_center(ReinRegPartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);

	if (PartitionedArea.Num()==0)
	{
		return;
	}
	HTuple StepNum,BeginRow,BeginCol,EndRow,EndCol;
	StepNum = PartitionedRow.Num();
	BeginRow = PartitionedRow-(LineLength/2);
	BeginCol = PartitionedCol;
	EndRow = PartitionedRow+(LineLength/2);
	EndCol = PartitionedCol;

	HTuple MatrixID,MatrixIDX,MatrixIDY,MatrixID_sub;
	create_matrix(LineLength+1, StepNum, 0, &MatrixID);
	create_matrix(LineLength+1, StepNum, 0, &MatrixIDX);
	create_matrix(LineLength+1, StepNum, 0, &MatrixIDY);

	create_matrix(1, StepNum, 0, &MatrixID_sub);
	//create_matrix(1, StepNum, 0, &MatrixID_sub1);
	//create_matrix(1, StepNum, 0, &MatrixID_sub2);

	//create_matrix(LineLength+1, 1, 0, &MatrixID_subY);
	//create_matrix(LineLength, 1, 0, &MatrixID_subY1);
	//create_matrix(LineLength, 1, 0, &MatrixID_subY2);
	HTuple pRow,pCol,RowRound,ColRound,Grayval1,Width, Height,RowMax,ColumnMax;
	Hobject Region3;
	for (int i=0;i<=LineLength;i++)
	{
		pRow = BeginRow+((EndRow-BeginRow)*(i/(LineLength+0.001)));
		pCol = BeginCol+((EndCol-BeginCol)*(i/(LineLength+0.001)));
		tuple_round(pRow, &RowRound);
		tuple_round(pCol, &ColRound);
		gen_region_points(&Region3, RowRound, ColRound);
		//
		get_image_size(Image, &Width, &Height);
		tuple_max(RowRound, &RowMax);
		tuple_max(ColRound, &ColumnMax);
		//min
		HTuple RowMin,ColumnMin;
		tuple_min(RowRound, &RowMin);
		tuple_min(ColRound, &ColumnMin);
		//
		if((RowMax>=Height-1)||(ColumnMax>=Width-1)||(RowMin<=0)||(ColumnMin<=0))
		{
			continue;
		}

		//
		/*Hobject Domain,RegDiff;
		HTuple area,row,col;
		get_domain(Image,&Domain);
		difference(Region3,Domain,&RegDiff);
		area_center(RegDiff,&area,&row,&col);
		if (area>1)
		{
		continue;
		}*/
		get_grayval(Image, RowRound, ColRound, &Grayval1);
		if (Grayval1.Num()==0)
		{
			continue;
		}
		set_full_matrix(MatrixID_sub, Grayval1);
		set_sub_matrix(MatrixID, MatrixID_sub, i, 0);
		set_full_matrix(MatrixID_sub, RowRound);
		set_sub_matrix(MatrixIDY, MatrixID_sub, i, 0);
		set_full_matrix(MatrixID_sub, ColRound);
		set_sub_matrix(MatrixIDX, MatrixID_sub, i, 0);

	}
	(*DefinedRow) = HTuple();
	(*DefinedCol) = HTuple();

	HTuple Values1,Values2,Diff,absDiff,Indices,ValueX,ValueY,MatrixID_subY1,MatrixID_subY2;
	for (int Index1=0;Index1<=StepNum-1;Index1++)
	{
		get_sub_matrix(MatrixID, 0, Index1, LineLength, 1, &MatrixID_subY1);
		get_full_matrix(MatrixID_subY1, &Values1);
		get_sub_matrix(MatrixID, 1, Index1, LineLength, 1, &MatrixID_subY2);
		get_full_matrix(MatrixID_subY2, &Values2);
		tuple_sub(Values1, Values2, &Diff);
		tuple_abs(Diff,&absDiff);
		tuple_sort_index(absDiff, &Indices);
		get_value_matrix(MatrixIDX, Indices.Select(LineLength-1), Index1, &ValueX);
		get_value_matrix(MatrixIDY, Indices.Select(LineLength-1), Index1, &ValueY);
		(*DefinedRow).ReplaceElements(Index1,ValueY);
		(*DefinedCol).ReplaceElements(Index1,ValueX);

		clear_matrix(MatrixID_subY1);
		clear_matrix(MatrixID_subY2);
	}

	clear_matrix(MatrixID);
	clear_matrix(MatrixIDX);
	clear_matrix(MatrixIDY);
	clear_matrix(MatrixID_sub);

	return;
}
STDMETHODIMP CPlugAlgo::D13_SlopEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pTopSlopEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdge, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); //实际情况调整膨胀搜索区域
		difference(TopSlopEdgeDilation, m_PlatformReg, &TopSlopEdgeDiff);

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
		reduce_domain(crtImgReduced, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow,DefinedCol;
		//PartInterval=5;LineLength:=膨胀尺寸;RemoveSize=1
		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
		m_TopSlopEdgeRow=TopSlopEdgeRow;
		//ARegionT为没有提出花纹的整个颈部区域
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);

		//剔除叉口区域的AB基准线
		Hobject ABEdgeDiff;
		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		difference(m_ABEdge,m_Platform0, &ABEdgeDiff);
		area_center(ABEdgeDiff, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdgeRow=ABEdgeRow;

		//***
		HTuple DilationSize;
		DilationSize = ABEdgeRow-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-DilationSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, DilationSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//无叉口平台时，剔除叉口下部区域
		HTuple PlatArea, PlatRow, PlatColumn;
		area_center(m_PlatformReg, &PlatArea, &PlatRow, &PlatColumn);

		HTuple innerRow1, innerCol1, innerRow2, innerCol2,outRow1, outCol1, outRow2, outCol2;
		inner_rectangle1(ARegionT, &innerRow1, &innerCol1, &innerRow2, &innerCol2);
		smallest_rectangle1(ARegionT, &outRow1, &outCol1, &outRow2, &outCol2);
		//

		HTuple ColDiff1,ColDiff2;
		ColDiff1=innerCol1-outCol1;
		ColDiff2=outCol2-innerCol2;
		if (0 != (PlatArea==0))
		{
			if (m_AngleP<0)
			{
				HTuple a,b;
				tuple_rad(-m_AngleP, &a);
				tuple_rad((180+m_AngleP), &b);

				if (0 != (HTuple(ColDiff1>5).Or(ColDiff2>5)))
				{
					clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);

				}
				else if(((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle<a))||((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle>b)))
				{
					clip_region_rel(ARegionT, &ARegionT, 0, 0, 15, 15);
				}
				else
				{
					clip_region_rel(ARegionT, &ARegionT, 0, 0, 5, 5);	
				}
			}
			else
			{
				if (0 != (HTuple(ColDiff1>5).Or(ColDiff2>5)))
				{
					clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);
				}
				else
				{
					clip_region_rel(ARegionT, &ARegionT, 0, 0, 5, 5);	
				}

			}
		}
		else
		{
			clip_region_rel(ARegionT, &ARegionT, 0, 0, 5, 5);
		}

		m_ARegionT=ARegionT;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SlopEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("997$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;190$\
					 998;LP;1;100;1;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_AroiTClosing.Id() == H_EMPTY_REGION||m_TopInnerRgion.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 250);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -0, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);
		//
		Hobject RegionTrans;
		shape_trans(m_AroiTClosing, &RegionTrans, "convex");
		HTuple AroiTRegArea, AroiTRegRow, AroiTRegColumn;
		area_center(RegionTrans, &AroiTRegArea, &AroiTRegRow, &AroiTRegColumn);
		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-AroiTRegRow)+MoveSize), -(ABEllipseColumnCenter-AroiTRegColumn));

		Hobject RegionDifference2,ConnectedRegions5,SelectedRegions1;
		difference(m_ROI, RegionMoved, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		Hobject RegionIntersection1,RegionUnion;
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);

		//如果角度在（60度--120度），避免叉口朝外时，边缘太亮
		HTuple s,t;
		tuple_rad(50, &s);
		tuple_rad(130, &t);
		if (0 != ((m_Angle>s)&&(m_Angle<t)))
		{
			union2(m_PlatformReg, m_AroiTClosing, &RegionUnion);
		}
		else
		{
			union2(m_PlatformReg, m_TopInnerRgion, &RegionUnion);

		}

		Hobject RegionClosing1,RegionOpening,RegionDilation1;
		closing_circle(RegionUnion, &RegionClosing1, 40);
		opening_circle(RegionClosing1, &RegionOpening, 3.5);
		dilation_rectangle1(RegionOpening, &RegionDilation1, 5, 1);
		Hobject SideSlopReg;
		difference(RegionIntersection1, RegionDilation1, &SideSlopReg);
		HTuple PlatformRegArea, PlatformRegRow,PlatformRegColumn;
		area_center(m_PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegColumn);

		if (0 != (PlatformRegArea==0))
		{
			Hobject ConnectedRegions2;
			connection(SideSlopReg, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &SideSlopReg, "max_area", 70);
		}
		opening_circle(SideSlopReg, &SideSlopReg, 2);
		HTuple ROIRow1,ROIColumn1,ROIRow2,ROIColumn2;
		HTuple InnerRow1, InnerCol1, InnerRow2, InnerCol2;
		inner_rectangle1(m_ARegionT, &InnerRow1, &InnerCol1, &InnerRow2, &InnerCol2);
		HTuple OutRow1, OutCol1, OutRow2, OutCol2;
		smallest_rectangle1(m_ARegionT, &OutRow1, &OutCol1, &OutRow2, &OutCol2);
		smallest_rectangle1(m_ROI, &ROIRow1, &ROIColumn1, &ROIRow2, &ROIColumn2);
		//如果没有平台叉口，斜坡区域两端裁剪
		if (0 != (PlatformRegArea==0))
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, InnerCol1+20, OutRow2, InnerCol2-20);
		}
		else
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, OutCol1, OutRow2, OutCol2);
		}

		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,HErosionSize,VErosionSize);
		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_AroiTClosing.Id() == H_EMPTY_REGION||m_TopInnerRgion.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 250);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -0, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);
		//
		Hobject RegionTrans;
		shape_trans(m_AroiTClosing, &RegionTrans, "convex");
		HTuple AroiTRegArea, AroiTRegRow, AroiTRegColumn;
		area_center(RegionTrans, &AroiTRegArea, &AroiTRegRow, &AroiTRegColumn);
		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-AroiTRegRow)+1), -(ABEllipseColumnCenter-AroiTRegColumn));
		//添加最小斜坡区域宽度
		HTuple HeightMinSlop;
		Hobject SlopRegionMaxEdge;
		HeightMinSlop=MoveSize;
		move_region (m_ARegionT, &SlopRegionMaxEdge, -HeightMinSlop, 0);
		difference (RegionMoved, SlopRegionMaxEdge, &RegionMoved);
		//
		Hobject RegionDifference2,ConnectedRegions5,SelectedRegions1;
		difference(m_ROI, RegionMoved, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		Hobject RegionIntersection1,RegionUnion;
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);
		//如果角度在（60度--120度），避免叉口朝外时，边缘太亮
		HTuple s,t;
		tuple_rad(50, &s);
		tuple_rad(130, &t);
		Hobject RegNewDiff;
		if (0 != ((m_Angle>s)&&(m_Angle<t)))
		{
			//扣除区域 先去掉顶部边缘以下的区域。
			difference (m_AroiTClosing, SlopRegionMaxEdge,& RegNewDiff);
			//
			union2(m_PlatformReg, RegNewDiff, &RegionUnion);
		}
		else
		{
			//扣除区域 先去掉顶部边缘以下的区域。
			difference (m_TopInnerRgion, SlopRegionMaxEdge,& RegNewDiff);
			//
			union2(m_PlatformReg,RegNewDiff , &RegionUnion);
		}
		Hobject RegionClosing1,RegionOpening,RegionDilation1,RegionUnionDilation;

		dilation_rectangle1(RegionUnion, &RegionUnionDilation,7, 1);
		closing_circle(RegionUnionDilation, &RegionClosing1, 50);
		opening_circle(RegionClosing1, &RegionOpening, 3.5);
		dilation_rectangle1(RegionOpening, &RegionDilation1,7, 1);
		Hobject SideSlopReg;
		difference(RegionIntersection1, RegionDilation1, &SideSlopReg);
		HTuple PlatformRegArea, PlatformRegRow,PlatformRegColumn;
		area_center(m_PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegColumn);
		if (0 != (PlatformRegArea==0))
		{
			Hobject ConnectedRegions2;
			connection(SideSlopReg, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &SideSlopReg, "max_area", 70);
		}

		opening_circle(SideSlopReg, &SideSlopReg, 2);
		HTuple ROIRow1,ROIColumn1,ROIRow2,ROIColumn2;
		HTuple InnerRow1, InnerCol1, InnerRow2, InnerCol2;
		inner_rectangle1(m_ARegionT, &InnerRow1, &InnerCol1, &InnerRow2, &InnerCol2);
		HTuple OutRow1, OutCol1, OutRow2, OutCol2;
		smallest_rectangle1(m_ARegionT, &OutRow1, &OutCol1, &OutRow2, &OutCol2);
		smallest_rectangle1(m_ROI, &ROIRow1, &ROIColumn1, &ROIRow2, &ROIColumn2);

		//my_disp_obj(m_crtImg);
		//my_disp_obj(RegionIntersection1);///////
		//my_disp_obj(m_AroiTClosing);///////
		//my_disp_obj(m_TopInnerRgion);///////
		//如果没有平台叉口，斜坡区域两端裁剪
		if (0 != (PlatformRegArea==0))
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, InnerCol1+20, OutRow2, InnerCol2-20);
		}
		else
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, OutCol1, OutRow2, OutCol2);
		}

		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,abs(HErosionSize),1);
		if (VErosionSize>=1)
		{
			erosion_rectangle1(SideSlopRegErosion,&SideSlopRegErosion,1,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			dilation_rectangle1(SideSlopRegErosion,&SideSlopRegErosion,1,-VErosionSize);
		}
		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 994;LP;1;35;1;1$\
					 995;LP;-16;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_AllSideConeBiasDection (Hobject ConeReg,Hobject Platform, Hobject *ConeEdge, HTuple RadiusSet, HTuple CenterCol, HTuple RowSet,HTuple ColSet)
{

	// Local iconic variables 
	Hobject  ConeLine;


	// Local control variables 
	HTuple  ConeLineRows, ConeLineColumns, Row11;
	HTuple  Column11, Row21, Column22, CenterColPlatform;
	HTuple  ConeLineColMax, ColMaxIndex, RateSin, ColOffset;
	HTuple  ConeCol2, ConeRow2, ConeCol1, ConeRow1;

	intersection(ConeReg, Platform, &ConeLine);
	get_region_points(ConeLine, &ConeLineRows, &ConeLineColumns);

	HTuple LineLength;
	tuple_length (ConeLineRows, &LineLength);
	if (LineLength<2)
	{
		gen_empty_region(ConeEdge);
		return;
	}
	smallest_rectangle1(Platform, &Row11, &Column11, &Row21, &Column22);
	CenterColPlatform = (Column11+Column22)/2.0;
	if (0 != (CenterColPlatform>CenterCol))
	{
		tuple_min(ConeLineColumns, &ConeLineColMax);
		tuple_find(ConeLineColumns, ConeLineColMax, &ColMaxIndex);
		RateSin = (Column11-CenterCol)/RadiusSet;
		if (0 != (Column11>=CenterCol))
		{
			ColOffset = (-ColSet)*RateSin;
		}
		else
		{
			ColOffset = ColSet*RateSin;
		}
		ConeCol2 = ConeLineColMax;
		ConeRow2 = ConeLineRows.Select(ColMaxIndex);
		ConeCol2 = ConeCol2.Select(0);
		ConeRow2 = ConeRow2.Select(0);
		ConeCol1 = ConeCol2+ColOffset;
		ConeRow1 = ConeRow2-RowSet;
	}
	else if (0 != (CenterColPlatform<=CenterCol))
	{
		tuple_max(ConeLineColumns, &ConeLineColMax);
		tuple_find(ConeLineColumns, ConeLineColMax, &ColMaxIndex);
		RateSin = (Column22-CenterCol)/RadiusSet;
		if (0 != (Column22<=CenterCol))
		{
			ColOffset = (-ColSet)*RateSin;
		}
		else
		{
			ColOffset = ColSet*RateSin;
		}
		ConeCol2 = ConeLineColMax;
		ConeRow2 = ConeLineRows.Select(ColMaxIndex);
		ConeCol2 = ConeCol2.Select(0);
		ConeRow2 = ConeRow2.Select(0);
		ConeCol1 = ConeCol2+ColOffset;
		ConeRow1 = ConeRow2-RowSet;
	}

	gen_region_line(&(*ConeEdge), ConeRow1, ConeCol1, ConeRow2, ConeCol2);
	return;
}
STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pBlackThred, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int BlackThred    = (int)pBlackThred->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	//显示测试
	//my_disp_obj(m_crtImg);
	//my_disp_obj(m_ARegionT);
	//||m_TopInnerRgion.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_AroiTClosing.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 250);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -0, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);
		//
		Hobject RegionTrans;
		shape_trans(m_AroiTClosing, &RegionTrans, "convex");
		HTuple AroiTRegArea, AroiTRegRow, AroiTRegColumn;
		area_center(RegionTrans, &AroiTRegArea, &AroiTRegRow, &AroiTRegColumn);
		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-AroiTRegRow)+1), -(ABEllipseColumnCenter-AroiTRegColumn));
		//添加最小斜坡区域宽度
		HTuple HeightMinSlop;
		Hobject SlopRegionMaxEdge;
		HeightMinSlop=MoveSize;
		move_region (m_ARegionT, &SlopRegionMaxEdge, -HeightMinSlop, 0);
		difference (RegionMoved, SlopRegionMaxEdge, &RegionMoved);
		//
		/////////////////////以上不变！
		HTuple Row12, Column12, Row21, Column22;
		inner_rectangle1 (m_ARegionT, &Row12,& Column12,& Row21,& Column22);
		HTuple OutRow1, OutCol1, OutRow2, OutCol2;
		smallest_rectangle1(m_ARegionT, &OutRow1, &OutCol1, &OutRow2, &OutCol2);
		//斜坡区域，叉口边缘定位
		Hobject ConeReg,ConeLine;//斜坡区域 叉口边缘 斜线
		HTuple RadiusSet,ColSet,RowSet,ConeCol,ConeArea, ConeRow,ConeDeepth;
		RadiusSet = 89.0;
		ColSet = 30;
		RowSet = 29;
		ConeDeepth=(Row21-Row12)+((OutRow2-OutRow1)-(Row21-Row12))*0.5;
		move_region(m_ABEdge,&ConeReg, -ConeDeepth, 0);
		area_center(ConeReg, &ConeArea, &ConeRow, &ConeCol);
		//my_disp_obj(m_crtImg);
		P_AllSideConeBiasDection(ConeReg, m_PlatformReg, &ConeLine, RadiusSet, ConeCol, RowSet, ColSet);

		//
		Hobject RegionEdgeErosion;
		erosion_rectangle1(RegionMoved, &RegionEdgeErosion, 11, 1);
		dilation_rectangle1(RegionEdgeErosion,&RegionEdgeErosion,13,1);
		//
		Hobject RegionDifference2,ConnectedRegions5,SelectedRegions1;
		difference(m_ROI, RegionEdgeErosion, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		Hobject RegionIntersection1,RegionUnion;
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);
		//my_disp_obj(RegionIntersection1);
		//以上已测试！
		Hobject ConePlatformClosing;
		//扣除区域 先去掉顶部边缘以下的区域。
		difference (ConeLine, SlopRegionMaxEdge,& ConeLine);
		//
		union2(ConeLine, m_PlatformReg, &RegionUnion);

		closing_circle(RegionUnion, &ConePlatformClosing, 60);
		//
		Hobject RegionOpening,RegionDilation1;
		opening_circle(ConePlatformClosing, &RegionOpening, 3.5);
		dilation_rectangle1(RegionOpening, &RegionDilation1, 5, 1);
		//my_disp_obj(RegionDilation1);
		Hobject SideSlopReg;
		difference(RegionIntersection1, RegionDilation1, &SideSlopReg);
		HTuple PlatformRegArea, PlatformRegRow,PlatformRegColumn;
		area_center(m_PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegColumn);

		if (0 != (PlatformRegArea==0))
		{
			Hobject ConnectedRegions2;
			connection(SideSlopReg, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &SideSlopReg, "max_area", 70);
		}
		opening_circle(SideSlopReg, &SideSlopReg, 2);
		HTuple ROIRow1,ROIColumn1,ROIRow2,ROIColumn2;
		HTuple InnerRow1, InnerCol1, InnerRow2, InnerCol2;
		inner_rectangle1(m_ARegionT, &InnerRow1, &InnerCol1, &InnerRow2, &InnerCol2);
		smallest_rectangle1(m_ROI, &ROIRow1, &ROIColumn1, &ROIRow2, &ROIColumn2);
		//如果没有平台叉口，斜坡区域两端裁剪
		if (0 != (PlatformRegArea==0))
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, InnerCol1+20, OutRow2, InnerCol2-20);
		}
		else
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, OutCol1, OutRow2, OutCol2);
		}

		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,HErosionSize,VErosionSize);
		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideSlopRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 1022;FP;0;70;0.5;20$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pThredValue, VARIANT* pClosingSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float ThredValue   = (float)pThredValue->fltVal;
	float ClosingSize   = (float)pClosingSize->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}


		//
		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		//
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		Hobject Regions1,RegionClosing3,RegionConnection,AroiTSelected1,RegionFillUp1;
		threshold (ImageReducedAroi, &Regions1, ThredValue, 255);
		fill_up(Regions1, &RegionFillUp1);
		closing_circle(RegionFillUp1, &RegionClosing3, ClosingSize);
		connection(RegionClosing3, &RegionConnection);
		select_shape_std(RegionConnection, &AroiTSelected1, "max_area", 70);
		Hobject SideTopRegErosion;
		erosion_circle(AroiTSelected1,&SideTopRegErosion,ErosionSize);

		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;185$\
					 989;FP;1;240;0.5;140$\
					 1093;FP;1;100;0.5;45$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//剔除叉口位置缺口区域
STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pThredValue, VARIANT* pClosingSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float ThredValue   = (float)pThredValue->fltVal;
	float ClosingSize   = (float)pClosingSize->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}


		//
		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		//
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		Hobject Regions1,RegionClosing3,RegionConnection,AroiTSelected1,RegionFillUp1;
		threshold (ImageReducedAroi, &Regions1, ThredValue, 255);
		fill_up(Regions1, &RegionFillUp1);
		closing_circle(RegionFillUp1, &RegionClosing3, ClosingSize);
		connection(RegionClosing3, &RegionConnection);
		select_shape_std(RegionConnection, &AroiTSelected1, "max_area", 70);
		Hobject SideTopRegErosion;
		//剔除内部叉口区域
		Hobject InnerRegionDilation;
		dilation_circle(m_TopInnerRgion,&InnerRegionDilation,1.5);
		difference(AroiTSelected1,InnerRegionDilation,&AroiTSelected1);
		//
		erosion_circle(AroiTSelected1,&SideTopRegErosion,ErosionSize);
		//
		opening_circle(SideTopRegErosion,&SideTopRegErosion,9);
		Hobject RegConnect,RegSelect;
		connection(SideTopRegErosion,&RegConnect);
		select_shape (RegConnect, &RegSelect, "area","and", 100, 99999);
		union1(RegSelect,&SideTopRegErosion);
		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;185$\
					 989;FP;1;240;0.5;140$\
					 1093;FP;1;100;0.5;45$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	//float ThredValue   = (float)pThredValue->fltVal;
	//float ClosingSize   = (float)pClosingSize->fltVal;

	//int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn; 
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		//下边缘处理
		//颈部边缘椭圆上移距离m_SideTopMoveCol
		Hobject ConeReg1,ConeRegDilation,AroiDiffABEdge;
		//计算位置
		HTuple Row12, Column12, Row21, Column22;
		inner_rectangle1 (m_ARegionT, &Row12,& Column12,& Row21,& Column22);
		HTuple OutRow1, OutCol1, OutRow2, OutCol2;
		smallest_rectangle1(m_ARegionT, &OutRow1, &OutCol1, &OutRow2, &OutCol2);
		//斜坡区域，叉口边缘定位
		HTuple ConeDeepth;
		ConeDeepth=(Row21-Row12)+((OutRow2-OutRow1)-(Row21-Row12))*0.5;
		//
		move_region(m_ABEdge,&ConeReg1, -ConeDeepth+10, 0);
		dilation_circle(ConeReg1,&ConeRegDilation,10.5);
		dilation_rectangle1(ConeRegDilation,&ConeRegDilation,7,1);
		difference(Aroi,ConeRegDilation,&AroiDiffABEdge);
		//
		Hobject NecRegion;
		dilation_rectangle1(m_ARegionT, &NecRegion, 1, 260);
		intersection(AroiDiffABEdge,NecRegion,&AroiDiffABEdge);
		opening_circle(AroiDiffABEdge,&AroiDiffABEdge,7);//边角凸出容易误检
		//Hobject NewEdgeLowEllipse;
		//move_region(m_ABEllipse, &NewEdgeLowEllipse, -ConeDeepth-3, 0);
		//intersection(Aroi, NewEdgeLowEllipse, &AroiDiffABEdge);
		//my_disp_obj(m_crtImg);
		//my_disp_obj(NewEdgeLowEllipse);
		//my_disp_obj(ConeRegDilation);
		//
		Hobject SideTopRegErosion;
		erosion_circle(AroiDiffABEdge,&SideTopRegErosion,ErosionSize);

		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_SideTopRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;240$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TriangleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pWhiteThred, VARIANT* pBlackThred,VARIANT* pTriangleSize,VARIANT* pTopRegArea,VARIANT* pTriangleDist,VARIANT* pTriangleArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	double BlackThred   = (double)pBlackThred->fltVal;
	int TriangleSize   = (int)pTriangleSize->fltVal;
	int TopRegArea   = (int)pTopRegArea->fltVal;
	//int EliminateSize   = (int)pEliminateSize->fltVal;

	int TriangleDist   = (int)pTriangleDist->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ARegionT.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_ImageScaleMax;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		//三角形花纹提取
		Hobject ABtriangleReg;
		Hobject ABTriangleArea, ABTriangleRow, ABTriangleColumn;
		move_region(m_ABEdge, &ABtriangleReg, -MoveSize, 0);
		Hobject ABtriangleRegDilation,ABtriangleRegIntersection;
		dilation_rectangle1(ABtriangleReg, &ABtriangleRegDilation, 1, SearchSize);
		intersection(ABtriangleRegDilation, m_ARegionT, &ABtriangleRegIntersection);
		Hobject RegionDiffH2,triangleRegOpening,triangleSearchReg;
		difference(ABtriangleRegIntersection, m_Platform0, &RegionDiffH2);

		//intersection(RegionDiffH2,m_ARegionT,&RegionDiffH2);
		opening_circle(RegionDiffH2, &triangleRegOpening, 3);
		union1(triangleRegOpening, &triangleSearchReg);

		//用于判断白点特征
		Hobject ABtriangleRegDilation1,ABtriangleRegIntersection1,RegionDiffH3;
		dilation_rectangle1(ABtriangleReg, &ABtriangleRegDilation1, 1, 150);
		Hobject RegionErosion1;
		erosion_rectangle1(m_ARegionT,&RegionErosion1,1, 15);

		intersection(ABtriangleRegDilation1, RegionErosion1, &ABtriangleRegIntersection1);
		difference(ABtriangleRegIntersection1, m_Platform0, &RegionDiffH3);
		//
		Hobject triangleRegOpening1,triangleJudgeReg;
		opening_circle(RegionDiffH3, &triangleRegOpening1, 3);
		union1(triangleRegOpening1, &triangleJudgeReg);
		Hobject triangleJudgeRegImage;
		reduce_domain(crtImgReduced, triangleJudgeReg, &triangleJudgeRegImage);
		scale_image_max(triangleJudgeRegImage, &triangleJudgeRegImage);

		//图像增强
		Hobject triangleRegImage;
		reduce_domain(crtImgReduced, triangleSearchReg, &triangleRegImage);
		emphasize(triangleRegImage, &triangleRegImage, 7, 7, 1);

		//白色
		Hobject WhiteTriangleRoi,WhiteTriangleRoiFillUp,WhiteRegionErosion;
		//HTuple Mean, Deviation;
		//intensity(triangleSearchReg, triangleRegImage, &Mean, &Deviation);
		/*if(Mean[0].D()+WhiteThred>=255.0)
		{
		WhiteThred=254.0-Mean[0].D();
		}*/
		threshold(triangleRegImage, &WhiteTriangleRoi, WhiteThred, 255);
		fill_up(WhiteTriangleRoi, &WhiteTriangleRoiFillUp);

		//剔除小白点		
		Hobject WhiteTriangleRoi1,WhiteTriangleRegConnected;
		connection(WhiteTriangleRoiFillUp, &WhiteTriangleRegConnected);
		select_shape(WhiteTriangleRegConnected, &WhiteTriangleRoi1, "area", "and", 10, 999999);

		HTuple Number;
		Hobject BlackSearchReg;
		count_obj(WhiteTriangleRoi1, &Number);

		//筛选基准线以上的白色区域
		Hobject ABEdgePartitioned;
		HTuple PartitionedArea, PartitionedRow, PartitionedCol;
		partition_rectangle(ABtriangleReg, &ABEdgePartitioned, 1, 100);
		area_center(ABEdgePartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);
		Hobject TriangleObject,WhiteTriangleRegSelected;
		HTuple WhiteTriangleArea, WhiteTriangleRow, WhiteTriangleCol;

		if(m_bDebugImg)
		{
			Hobject ABtriangleRegInterscted;
			intersection(ABtriangleReg,triangleSearchReg,&ABtriangleRegInterscted);
			concat_obj(m_vRgn[rId], ABtriangleRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteTriangleRoi, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], triangleSearchReg, &m_vRgn[rId]);
		}
		HTuple Area8, Row6, Column4;
		Hobject RegionUnion;
		union1(WhiteTriangleRoi1, &RegionUnion);

		area_center(RegionUnion, &Area8, &Row6, &Column4);
		if(Area8==0||Area8.Num()==0)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_TriangleReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTriangleArea);
			return S_FALSE;
		}
		gen_empty_obj(&TriangleObject);
		HTuple RowRound,ColRound,Indice;
		for (int i=1; i<=Number; i++)
		{
			select_obj(WhiteTriangleRoi1, &WhiteTriangleRegSelected, i);
			area_center(WhiteTriangleRegSelected, &WhiteTriangleArea, &WhiteTriangleRow, &WhiteTriangleCol);

			tuple_round(WhiteTriangleRow, &RowRound);
			tuple_round(WhiteTriangleCol, &ColRound);
			tuple_find(PartitionedCol, ColRound, &Indice);
			if(Indice==-1)
			{
				continue;
			}

			HTuple RowDiff;
			RowDiff = (PartitionedRow.Select(Indice.Select(0)))-WhiteTriangleRow;
			if (0 != (RowDiff>=0))
			{
				concat_obj(TriangleObject, WhiteTriangleRegSelected, &TriangleObject);
			}
		}

		union1(TriangleObject, &TriangleObject);
		Hobject TriangleObjectConnected;
		connection(TriangleObject, &TriangleObjectConnected);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑（-13,13），实际情况调整
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		Hobject TriangleRoiCliped,RegionUnion1,RegionUnion2,TriangleDiff,WhiteTriangleUpUnion;
		smallest_rectangle1(m_Platform0, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
		select_shape(TriangleObjectConnected, &TriangleRoiCliped, "column", "and", PlatformColL-13, PlatformColR+13);

		union1(TriangleRoiCliped, &RegionUnion2);
		difference(TriangleObjectConnected, RegionUnion2, &TriangleDiff);
		union1(TriangleDiff, &WhiteTriangleUpUnion);

		//排除白条上面的白点干扰
		//Hobject RegionDilation,WhiteTriangleRoiClosing;
		//dilation_rectangle1(WhiteTriangleUpUnion, &RegionDilation, 1, SearchSize/2);
		//erosion_rectangle1(RegionDilation, &WhiteTriangleRoiClosing, 1, SearchSize/2);
		//
		//Hobject WhiteTriangleRgn,WhiteTriangleRoiConnected;
		//HTuple WhiteTriangleRoiNum;
		//gen_empty_region(&WhiteTriangleRgn);
		//connection(WhiteTriangleRoiClosing, &WhiteTriangleRoiConnected);
		//count_obj(WhiteTriangleRoiConnected, &WhiteTriangleRoiNum);

		//Hobject WhiteTriangleSelected;
		//HTuple WhiteTriangleRow1, WhiteTriangleCol1, WhiteTrianglePhi, WhiteTriangleLength1, WhiteTriangleLength2;
		//HTuple ShortLength,LongLength;
		//Hobject Rect,TriangleSearchRegErosion,RectIntersection,RegionDilation1,RegionErosion,RegionDiff;
		//Hobject RegionDiffConnected,RegionDiffSelected,RegionDiffUnion;
		//HTuple WhiteTriangleArea2, WhiteTriangleRow2, WhiteTriangleColumn2;
		//HTuple Row, Column, Phi, Length1, Length2;
		//Hobject BalckRect,WhiteTriangleDiff,ConnectedRegions,SelectedRegions;
		//
		//for (int i=1;i<=WhiteTriangleRoiNum[0].I();i++)
		//{
		//	select_obj(WhiteTriangleRoiConnected, &WhiteTriangleSelected, i);
		//	smallest_rectangle2(WhiteTriangleSelected, &WhiteTriangleRow1, &WhiteTriangleCol1, &WhiteTrianglePhi, &WhiteTriangleLength1, &WhiteTriangleLength2);
		//	ShortLength = HTuple();
		//	LongLength = HTuple();
		//	if (0 != (WhiteTriangleLength1>=WhiteTriangleLength2))
		//	{
		//		ShortLength = WhiteTriangleLength2;
		//		LongLength = WhiteTriangleLength1;
		//	}
		//	else
		//	{
		//		ShortLength = WhiteTriangleLength1;
		//		LongLength = WhiteTriangleLength2;
		//	}
		//	gen_rectangle2(&Rect, WhiteTriangleRow1, WhiteTriangleCol1, WhiteTrianglePhi, WhiteTriangleLength1, WhiteTriangleLength2);

		//	if (0 != ((ShortLength*2)>TriangleSize))
		//	{
		//		gen_empty_region(&WhiteTriangleRgn);
		//		continue;
		//	}

		//	erosion_circle(triangleSearchReg, &TriangleSearchRegErosion, 1);
		//	intersection(Rect, TriangleSearchRegErosion, &RectIntersection);

		//	dilation_rectangle1(RectIntersection, &RegionDilation1, 1, 10);
		//	erosion_rectangle1(RegionDilation1, &RegionErosion, 10, 1);

		//	difference(RegionErosion, WhiteTriangleSelected, &RegionDiff);
		//	connection(RegionDiff, &RegionDiffConnected);
		//	area_center(WhiteTriangleSelected, &WhiteTriangleArea2, &WhiteTriangleRow2, &WhiteTriangleColumn2);
		//	select_shape(RegionDiffConnected, &RegionDiffSelected, "row", "and", 0, WhiteTriangleRow2);
		//	
		//	Hobject SelectedRegions1;
		//	select_shape_std(RegionDiffSelected, &SelectedRegions1, "max_area", 70);
		//	//union1(RegionDiffSelected, &RegionDiffUnion);
		//	smallest_rectangle2(SelectedRegions1, &Row, &Column, &Phi, &Length1, &Length2);
		//	
		//	if (0 != ((Row.Num())==0))
		//	{
		//		concat_obj(WhiteTriangleRgn, WhiteTriangleSelected, &WhiteTriangleRgn);

		//	}
		//	else
		//	{
		//		gen_rectangle2(&BalckRect, Row, Column, Phi, Length1, Length2);
		//		ShortLength = HTuple();
		//		LongLength = HTuple();
		//		if (0 != (Length1>=Length2))
		//		{
		//			ShortLength = Length2;
		//			LongLength = Length1;
		//		}
		//		else
		//		{
		//			ShortLength = Length1;
		//			LongLength = Length2;
		//		}

		//		if (0 != ((ShortLength*2)>EliminateSize))
		//		{
		//			difference(WhiteTriangleSelected, BalckRect, &WhiteTriangleDiff); 
		//			connection(WhiteTriangleDiff, &ConnectedRegions);
		//			select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		//			//
		//			concat_obj(WhiteTriangleRgn, SelectedRegions, &WhiteTriangleRgn);
		//		}
		//		else
		//		{
		//			concat_obj(WhiteTriangleRgn, WhiteTriangleSelected, &WhiteTriangleRgn);
		//		}
		//	}
		//}
		//Hobject WhiteTriangleRgnUnion;
		//union1(WhiteTriangleRgn, &WhiteTriangleRgnUnion);

		//根据白条之间的距离进行判断筛选
		Hobject TriangleRoi;
		connection(WhiteTriangleUpUnion, &TriangleRoi);
		HTuple triangleNumber;
		Hobject ObjectSelectedUnion,ObjectConcat;
		count_obj(TriangleRoi, &triangleNumber);

		gen_empty_region(&ObjectSelectedUnion);
		gen_empty_region(&ObjectConcat);
		Hobject TriangleRegSorted,ObjectSelectedx,ObjectSelectedy;
		HTuple ObjectSelectedAreax, ObjectSelectedRowx, ObjectSelectedColx,ObjectSelectedAreay, ObjectSelectedRowy, ObjectSelectedColy,Distance;
		for (int x=1; x<=triangleNumber; x++)
		{
			for (int y=1; y<=triangleNumber; y++)
			{
				sort_region(TriangleRoi, &TriangleRegSorted, "first_point", "true", "column");
				select_obj(TriangleRegSorted, &ObjectSelectedx, x);
				area_center(ObjectSelectedx, &ObjectSelectedAreax, &ObjectSelectedRowx, &ObjectSelectedColx);

				select_obj(TriangleRegSorted, &ObjectSelectedy, y);
				area_center(ObjectSelectedy, &ObjectSelectedAreay, &ObjectSelectedRowy, &ObjectSelectedColy);
				if (ObjectSelectedColx.Num()==0 ||ObjectSelectedColy.Num()==0)
				{
					continue;
				}
				distance_pp(ObjectSelectedRowx, ObjectSelectedColx, ObjectSelectedRowy, ObjectSelectedColy, &Distance);
				//ColDiff=(ObjectSelectedColx-ObjectSelectedColy).Abs();
				//实际情况调整
				if (0 != ((Distance[0].I()<TriangleDist)&&(Distance[0].I()>0)))
				{
					union2(ObjectSelectedx, ObjectSelectedy, &ObjectSelectedUnion);
					concat_obj(ObjectSelectedUnion, ObjectConcat, &ObjectConcat);
				}
			}
		}
		Hobject ObjectConnected;
		HTuple Num,Rectangularity,RectangularityMax,Indice0;

		union1(ObjectConcat,&ObjectConcat);
		connection(ObjectConcat, &ObjectConnected);
		count_obj(ObjectConnected, &Num);
		if (Num>1)
		{
			Hobject ObjectSelected4,TriangleRoiDiff0;
			select_shape_std(ObjectConnected, &ObjectSelected4, "max_area", 70);
			difference(ObjectConnected, ObjectSelected4, &TriangleRoiDiff0);
			difference(TriangleRoi, TriangleRoiDiff0, &TriangleRoi);
		}

		//根据白点上下灰度差进行筛选
		HTuple TriangleArea, TriangleRow, TriangleColumn;
		HTuple MidRow, MidCol, phi, Length3,Length4,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2;
		Hobject ObjectSelected,TReg,ObjectsConcat,TriangleReg,ErrorRegion;
		Hobject ObjectMovedDown,RegionMovedUp,ObjectIntersection,TriangleRoiConnected,TriangleDisplay;
		HTuple MeanDown, DeviationDown,MeanUp, DeviationUp,MeanDiff;
		gen_empty_obj(&TriangleReg);
		gen_empty_region(&ErrorRegion);
		//gen_empty_obj(&TriangleDisplay);

		union1(TriangleRoi, &TriangleRoi);
		connection(TriangleRoi, &TriangleRoiConnected);
		count_obj(TriangleRoiConnected, &triangleNumber);

		HTuple ObjectArea, ObjectRow, ObjectCol,MoveSize0;

		for (int i=1;i<=triangleNumber;i++)
		{
			select_obj(TriangleRoiConnected, &ObjectSelected, i);
			area_center(ObjectSelected, &TriangleArea, &TriangleRow, &TriangleColumn);

			smallest_rectangle2(ObjectSelected, &MidRow, &MidCol, &phi, &Length3, &Length4);
			if (0 != (Length3>=Length4))
			{
				LengthLong = Length3;
				LengthShort = Length4;
			}
			else
			{
				LengthLong = Length4;
				LengthShort = Length3;
			}
			Row1 = MidRow+(LengthLong*(phi.Sin()));
			Col1 = MidCol-(LengthLong*(phi.Cos()));
			Row2 = MidRow-(LengthLong*(phi.Sin()));
			Col2 = MidCol+(LengthLong*(phi.Cos()));

			//13-D1-3: TriangleSize=20
			//13-D1、13-D1-2:   TriangleSize=30
			//13-D1-4: TriangleSize=40

			area_center(ObjectSelected, &ObjectArea, &ObjectRow, &ObjectCol);
			if (0 != (TriangleSize>35))
			{
				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 15;
				}
				else
				{
					MoveSize0 = 5;
				}

			}
			else if (0 != (HTuple(TriangleSize>20).And(TriangleSize<=35)))
			{

				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 10;
				}
				else
				{
					MoveSize0 = 5;
				}

			}
			else if (0 != (TriangleSize<=20))
			{
				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 8;
				}
				else
				{
					MoveSize0 = 0;
				}

			}
			gen_region_polygon(&TReg, ((Row1.Concat(Row2)).Concat(MidRow+TriangleSize)).Concat(Row1),((Col1.Concat(Col2)).Concat(MidCol)).Concat(Col1));
			fill_up(TReg, &TReg);

			if (TriangleSize-MoveSize0<1)
			{
				MoveSize0=0;
			}
			move_region(ObjectSelected, &ObjectMovedDown, TriangleSize-MoveSize0, 0);
			intersection(TReg, ObjectMovedDown, &ObjectIntersection);
			difference(ObjectIntersection, ObjectSelected, &ObjectMovedDown);
			intensity(ObjectIntersection, triangleJudgeRegImage, &MeanDown, &DeviationDown);

			move_region(ObjectIntersection, &RegionMovedUp, -(TriangleSize+15), 0);
			difference(RegionMovedUp, ObjectSelected, &RegionMovedUp);
			intensity(RegionMovedUp, triangleJudgeRegImage, &MeanUp, &DeviationUp);
			//实际情况调整
			MeanDiff = MeanUp-MeanDown;
			if (0 != (MeanDiff<BlackThred))
			{
				concat_obj(ObjectSelected, ErrorRegion, &ErrorRegion);

			}
			else
			{
				//concat_obj(ObjectSelected, TriangleDisplay, &TriangleDisplay);
				concat_obj(ObjectSelected, TReg, &ObjectsConcat);
				concat_obj(TriangleReg, ObjectsConcat, &TriangleReg);
			}

		}
		//初始化成员变量
		Hobject TriangleRegUnion,TriangleRegFillUp;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);
		Hobject TriangleConnected;
		intersection(m_ARegionT, TriangleRegFillUp, &TriangleRegFillUp);
		connection(TriangleRegFillUp, &TriangleConnected);
		HTuple TriangleNumber,TriangleRegArea, TriangleRegRow, TriangleRegColumn;
		count_obj(TriangleConnected, &TriangleNumber);
		area_center(TriangleRegFillUp, &TriangleRegArea, &TriangleRegRow, &TriangleRegColumn);

		//dilation_circle(TriangleRegFillUp,&TriangleRegFillUp,DilationSize);

		m_TriangleReg=TriangleRegFillUp;
		if(m_bDebugImg)
		{
			//concat_obj(m_vRgn[rId], TriangleDisplay, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TriangleRegFillUp, &m_vRgn[rId]);
		}
		if (TriangleNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId] = TriangleRegFillUp;
			retValue.Detach(pTriangleArea);
			return S_FALSE;
		}
		//是否不需要返回错误。
		if (TriangleRegArea>=0)
		{
			retValue = TriangleRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTriangleArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TriangleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;100$\
					 998;LP;1;100;1;50$\
					 999;FP;0;250;0.5;60$\
					 1000;FP;0;250;0.5;30$\
					 1018;LP;5;80;1;20$\
					 1096;LP;20;250;1;100$\
					 1155;LP;5;80;1;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//取消花纹空区域 返回-1
STDMETHODIMP CPlugAlgo::D13_TriangleDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pWhiteThred, VARIANT* pBlackThred,VARIANT* pTriangleSize,VARIANT* pTopRegArea,VARIANT* pTriangleDist,VARIANT* pTriangleArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	double BlackThred   = (double)pBlackThred->fltVal;
	int TriangleSize   = (int)pTriangleSize->fltVal;
	int TopRegArea   = (int)pTopRegArea->fltVal;
	//int EliminateSize   = (int)pEliminateSize->fltVal;

	int TriangleDist   = (int)pTriangleDist->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ARegionT.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		Hobject crtImgReduced;
		reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		//三角形花纹提取
		Hobject ABtriangleReg;
		Hobject ABTriangleArea, ABTriangleRow, ABTriangleColumn;
		move_region(m_ABEdge, &ABtriangleReg, -MoveSize, 0);
		Hobject ABtriangleRegDilation,ABtriangleRegIntersection;
		dilation_rectangle1(ABtriangleReg, &ABtriangleRegDilation, 1, SearchSize);
		intersection(ABtriangleRegDilation, m_ARegionT, &ABtriangleRegIntersection);
		Hobject RegionDiffH2,triangleRegOpening,triangleSearchReg;
		difference(ABtriangleRegIntersection, m_Platform0, &RegionDiffH2);

		//intersection(RegionDiffH2,m_ARegionT,&RegionDiffH2);
		opening_circle(RegionDiffH2, &triangleRegOpening, 3);
		union1(triangleRegOpening, &triangleSearchReg);

		//用于判断白点特征
		Hobject ABtriangleRegDilation1,ABtriangleRegIntersection1,RegionDiffH3;
		dilation_rectangle1(ABtriangleReg, &ABtriangleRegDilation1, 1, 150);
		Hobject RegionErosion1;
		erosion_rectangle1(m_ARegionT,&RegionErosion1,1, 15);

		intersection(ABtriangleRegDilation1, RegionErosion1, &ABtriangleRegIntersection1);
		difference(ABtriangleRegIntersection1, m_Platform0, &RegionDiffH3);
		//
		Hobject triangleRegOpening1,triangleJudgeReg;
		opening_circle(RegionDiffH3, &triangleRegOpening1, 3);
		union1(triangleRegOpening1, &triangleJudgeReg);
		Hobject triangleJudgeRegImage;
		reduce_domain(crtImgReduced, triangleJudgeReg, &triangleJudgeRegImage);
		scale_image_max(triangleJudgeRegImage, &triangleJudgeRegImage);

		//图像增强
		Hobject triangleRegImage;
		reduce_domain(crtImgReduced, triangleSearchReg, &triangleRegImage);
		emphasize(triangleRegImage, &triangleRegImage, 7, 7, 1);

		//白色
		Hobject WhiteTriangleRoi,WhiteTriangleRoiFillUp,WhiteRegionErosion;
		//HTuple Mean, Deviation;
		//intensity(triangleSearchReg, triangleRegImage, &Mean, &Deviation);
		/*if(Mean[0].D()+WhiteThred>=255.0)
		{
		WhiteThred=254.0-Mean[0].D();
		}*/
		threshold(triangleRegImage, &WhiteTriangleRoi, WhiteThred, 255);
		fill_up(WhiteTriangleRoi, &WhiteTriangleRoiFillUp);

		//剔除小白点		
		Hobject WhiteTriangleRoi1,WhiteTriangleRegConnected;
		connection(WhiteTriangleRoiFillUp, &WhiteTriangleRegConnected);
		select_shape(WhiteTriangleRegConnected, &WhiteTriangleRoi1, "area", "and", 10, 999999);

		HTuple Number;
		Hobject BlackSearchReg;
		count_obj(WhiteTriangleRoi1, &Number);

		//筛选基准线以上的白色区域
		Hobject ABEdgePartitioned;
		HTuple PartitionedArea, PartitionedRow, PartitionedCol;
		partition_rectangle(ABtriangleReg, &ABEdgePartitioned, 1, 100);
		area_center(ABEdgePartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);
		Hobject TriangleObject,WhiteTriangleRegSelected;
		HTuple WhiteTriangleArea, WhiteTriangleRow, WhiteTriangleCol;

		if(m_bDebugImg)
		{
			Hobject ABtriangleRegInterscted;
			intersection(ABtriangleReg,triangleSearchReg,&ABtriangleRegInterscted);
			concat_obj(m_vRgn[rId], ABtriangleRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteTriangleRoi, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], triangleSearchReg, &m_vRgn[rId]);
		}
		HTuple Area8, Row6, Column4;
		Hobject RegionUnion;
		union1(WhiteTriangleRoi1, &RegionUnion);

		area_center(RegionUnion, &Area8, &Row6, &Column4);
		if(Area8==0||Area8.Num()==0)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_TriangleReg=EmptyRegion;

			retValue = 100;
			m_vErrorRgn[rId] = EmptyRegion;
			retValue.Detach(pTriangleArea);
			return S_FALSE;
		}
		gen_empty_obj(&TriangleObject);
		HTuple RowRound,ColRound,Indice;
		for (int i=1; i<=Number; i++)
		{
			select_obj(WhiteTriangleRoi1, &WhiteTriangleRegSelected, i);
			area_center(WhiteTriangleRegSelected, &WhiteTriangleArea, &WhiteTriangleRow, &WhiteTriangleCol);

			tuple_round(WhiteTriangleRow, &RowRound);
			tuple_round(WhiteTriangleCol, &ColRound);
			tuple_find(PartitionedCol, ColRound, &Indice);
			if(Indice==-1)
			{
				continue;
			}

			HTuple RowDiff;
			RowDiff = (PartitionedRow.Select(Indice.Select(0)))-WhiteTriangleRow;
			if (0 != (RowDiff>=0))
			{
				concat_obj(TriangleObject, WhiteTriangleRegSelected, &TriangleObject);
			}
		}

		union1(TriangleObject, &TriangleObject);
		Hobject TriangleObjectConnected;
		connection(TriangleObject, &TriangleObjectConnected);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑（-13,13），实际情况调整
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		Hobject TriangleRoiCliped,RegionUnion1,RegionUnion2,TriangleDiff,WhiteTriangleUpUnion;
		smallest_rectangle1(m_Platform0, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
		select_shape(TriangleObjectConnected, &TriangleRoiCliped, "column", "and", PlatformColL-13, PlatformColR+13);

		union1(TriangleRoiCliped, &RegionUnion2);
		difference(TriangleObjectConnected, RegionUnion2, &TriangleDiff);
		union1(TriangleDiff, &WhiteTriangleUpUnion);

		//排除白条上面的白点干扰
		//Hobject RegionDilation,WhiteTriangleRoiClosing;
		//dilation_rectangle1(WhiteTriangleUpUnion, &RegionDilation, 1, SearchSize/2);
		//erosion_rectangle1(RegionDilation, &WhiteTriangleRoiClosing, 1, SearchSize/2);
		//
		//Hobject WhiteTriangleRgn,WhiteTriangleRoiConnected;
		//HTuple WhiteTriangleRoiNum;
		//gen_empty_region(&WhiteTriangleRgn);
		//connection(WhiteTriangleRoiClosing, &WhiteTriangleRoiConnected);
		//count_obj(WhiteTriangleRoiConnected, &WhiteTriangleRoiNum);

		//Hobject WhiteTriangleSelected;
		//HTuple WhiteTriangleRow1, WhiteTriangleCol1, WhiteTrianglePhi, WhiteTriangleLength1, WhiteTriangleLength2;
		//HTuple ShortLength,LongLength;
		//Hobject Rect,TriangleSearchRegErosion,RectIntersection,RegionDilation1,RegionErosion,RegionDiff;
		//Hobject RegionDiffConnected,RegionDiffSelected,RegionDiffUnion;
		//HTuple WhiteTriangleArea2, WhiteTriangleRow2, WhiteTriangleColumn2;
		//HTuple Row, Column, Phi, Length1, Length2;
		//Hobject BalckRect,WhiteTriangleDiff,ConnectedRegions,SelectedRegions;
		//
		//for (int i=1;i<=WhiteTriangleRoiNum[0].I();i++)
		//{
		//	select_obj(WhiteTriangleRoiConnected, &WhiteTriangleSelected, i);
		//	smallest_rectangle2(WhiteTriangleSelected, &WhiteTriangleRow1, &WhiteTriangleCol1, &WhiteTrianglePhi, &WhiteTriangleLength1, &WhiteTriangleLength2);
		//	ShortLength = HTuple();
		//	LongLength = HTuple();
		//	if (0 != (WhiteTriangleLength1>=WhiteTriangleLength2))
		//	{
		//		ShortLength = WhiteTriangleLength2;
		//		LongLength = WhiteTriangleLength1;
		//	}
		//	else
		//	{
		//		ShortLength = WhiteTriangleLength1;
		//		LongLength = WhiteTriangleLength2;
		//	}
		//	gen_rectangle2(&Rect, WhiteTriangleRow1, WhiteTriangleCol1, WhiteTrianglePhi, WhiteTriangleLength1, WhiteTriangleLength2);

		//	if (0 != ((ShortLength*2)>TriangleSize))
		//	{
		//		gen_empty_region(&WhiteTriangleRgn);
		//		continue;
		//	}

		//	erosion_circle(triangleSearchReg, &TriangleSearchRegErosion, 1);
		//	intersection(Rect, TriangleSearchRegErosion, &RectIntersection);

		//	dilation_rectangle1(RectIntersection, &RegionDilation1, 1, 10);
		//	erosion_rectangle1(RegionDilation1, &RegionErosion, 10, 1);

		//	difference(RegionErosion, WhiteTriangleSelected, &RegionDiff);
		//	connection(RegionDiff, &RegionDiffConnected);
		//	area_center(WhiteTriangleSelected, &WhiteTriangleArea2, &WhiteTriangleRow2, &WhiteTriangleColumn2);
		//	select_shape(RegionDiffConnected, &RegionDiffSelected, "row", "and", 0, WhiteTriangleRow2);
		//	
		//	Hobject SelectedRegions1;
		//	select_shape_std(RegionDiffSelected, &SelectedRegions1, "max_area", 70);
		//	//union1(RegionDiffSelected, &RegionDiffUnion);
		//	smallest_rectangle2(SelectedRegions1, &Row, &Column, &Phi, &Length1, &Length2);
		//	
		//	if (0 != ((Row.Num())==0))
		//	{
		//		concat_obj(WhiteTriangleRgn, WhiteTriangleSelected, &WhiteTriangleRgn);

		//	}
		//	else
		//	{
		//		gen_rectangle2(&BalckRect, Row, Column, Phi, Length1, Length2);
		//		ShortLength = HTuple();
		//		LongLength = HTuple();
		//		if (0 != (Length1>=Length2))
		//		{
		//			ShortLength = Length2;
		//			LongLength = Length1;
		//		}
		//		else
		//		{
		//			ShortLength = Length1;
		//			LongLength = Length2;
		//		}

		//		if (0 != ((ShortLength*2)>EliminateSize))
		//		{
		//			difference(WhiteTriangleSelected, BalckRect, &WhiteTriangleDiff); 
		//			connection(WhiteTriangleDiff, &ConnectedRegions);
		//			select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		//			//
		//			concat_obj(WhiteTriangleRgn, SelectedRegions, &WhiteTriangleRgn);
		//		}
		//		else
		//		{
		//			concat_obj(WhiteTriangleRgn, WhiteTriangleSelected, &WhiteTriangleRgn);
		//		}
		//	}
		//}
		//Hobject WhiteTriangleRgnUnion;
		//union1(WhiteTriangleRgn, &WhiteTriangleRgnUnion);

		//根据白条之间的距离进行判断筛选
		Hobject TriangleRoi;
		connection(WhiteTriangleUpUnion, &TriangleRoi);
		HTuple triangleNumber;
		Hobject ObjectSelectedUnion,ObjectConcat;
		count_obj(TriangleRoi, &triangleNumber);

		gen_empty_region(&ObjectSelectedUnion);
		gen_empty_region(&ObjectConcat);
		Hobject TriangleRegSorted,ObjectSelectedx,ObjectSelectedy;
		HTuple ObjectSelectedAreax, ObjectSelectedRowx, ObjectSelectedColx,ObjectSelectedAreay, ObjectSelectedRowy, ObjectSelectedColy,Distance;
		for (int x=1; x<=triangleNumber; x++)
		{
			for (int y=1; y<=triangleNumber; y++)
			{
				sort_region(TriangleRoi, &TriangleRegSorted, "first_point", "true", "column");
				select_obj(TriangleRegSorted, &ObjectSelectedx, x);
				area_center(ObjectSelectedx, &ObjectSelectedAreax, &ObjectSelectedRowx, &ObjectSelectedColx);

				select_obj(TriangleRegSorted, &ObjectSelectedy, y);
				area_center(ObjectSelectedy, &ObjectSelectedAreay, &ObjectSelectedRowy, &ObjectSelectedColy);
				if (ObjectSelectedColx.Num()==0 ||ObjectSelectedColy.Num()==0)
				{
					continue;
				}
				distance_pp(ObjectSelectedRowx, ObjectSelectedColx, ObjectSelectedRowy, ObjectSelectedColy, &Distance);
				//ColDiff=(ObjectSelectedColx-ObjectSelectedColy).Abs();
				//实际情况调整
				if (0 != ((Distance[0].I()<TriangleDist)&&(Distance[0].I()>0)))
				{
					union2(ObjectSelectedx, ObjectSelectedy, &ObjectSelectedUnion);
					concat_obj(ObjectSelectedUnion, ObjectConcat, &ObjectConcat);
				}
			}
		}
		Hobject ObjectConnected;
		HTuple Num,Rectangularity,RectangularityMax,Indice0;

		union1(ObjectConcat,&ObjectConcat);
		connection(ObjectConcat, &ObjectConnected);
		count_obj(ObjectConnected, &Num);
		if (Num>1)
		{
			Hobject ObjectSelected4,TriangleRoiDiff0;
			select_shape_std(ObjectConnected, &ObjectSelected4, "max_area", 70);
			difference(ObjectConnected, ObjectSelected4, &TriangleRoiDiff0);
			difference(TriangleRoi, TriangleRoiDiff0, &TriangleRoi);
		}

		//根据白点上下灰度差进行筛选
		HTuple TriangleArea, TriangleRow, TriangleColumn;
		HTuple MidRow, MidCol, phi, Length3,Length4,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2;
		Hobject ObjectSelected,TReg,ObjectsConcat,TriangleReg,ErrorRegion;
		Hobject ObjectMovedDown,RegionMovedUp,ObjectIntersection,TriangleRoiConnected,TriangleDisplay;
		HTuple MeanDown, DeviationDown,MeanUp, DeviationUp,MeanDiff;
		gen_empty_obj(&TriangleReg);
		gen_empty_region(&ErrorRegion);
		//gen_empty_obj(&TriangleDisplay);

		union1(TriangleRoi, &TriangleRoi);
		connection(TriangleRoi, &TriangleRoiConnected);
		count_obj(TriangleRoiConnected, &triangleNumber);

		HTuple ObjectArea, ObjectRow, ObjectCol,MoveSize0;

		for (int i=1;i<=triangleNumber;i++)
		{
			select_obj(TriangleRoiConnected, &ObjectSelected, i);
			area_center(ObjectSelected, &TriangleArea, &TriangleRow, &TriangleColumn);

			smallest_rectangle2(ObjectSelected, &MidRow, &MidCol, &phi, &Length3, &Length4);
			if (0 != (Length3>=Length4))
			{
				LengthLong = Length3;
				LengthShort = Length4;
			}
			else
			{
				LengthLong = Length4;
				LengthShort = Length3;
			}
			Row1 = MidRow+(LengthLong*(phi.Sin()));
			Col1 = MidCol-(LengthLong*(phi.Cos()));
			Row2 = MidRow-(LengthLong*(phi.Sin()));
			Col2 = MidCol+(LengthLong*(phi.Cos()));

			//13-D1-3: TriangleSize=20
			//13-D1、13-D1-2:   TriangleSize=30
			//13-D1-4: TriangleSize=40

			area_center(ObjectSelected, &ObjectArea, &ObjectRow, &ObjectCol);
			if (0 != (TriangleSize>35))
			{
				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 15;
				}
				else
				{
					MoveSize0 = 5;
				}

			}
			else if (0 != (HTuple(TriangleSize>20).And(TriangleSize<=35)))
			{

				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 10;
				}
				else
				{
					MoveSize0 = 5;
				}

			}
			else if (0 != (TriangleSize<=20))
			{
				if (0 != (ObjectArea<TopRegArea))
				{
					MoveSize0 = 8;
				}
				else
				{
					MoveSize0 = 0;
				}

			}
			gen_region_polygon(&TReg, ((Row1.Concat(Row2)).Concat(MidRow+TriangleSize)).Concat(Row1),((Col1.Concat(Col2)).Concat(MidCol)).Concat(Col1));
			fill_up(TReg, &TReg);

			if (TriangleSize-MoveSize0<1)
			{
				MoveSize0=0;
			}
			move_region(ObjectSelected, &ObjectMovedDown, TriangleSize-MoveSize0, 0);
			intersection(TReg, ObjectMovedDown, &ObjectIntersection);
			difference(ObjectIntersection, ObjectSelected, &ObjectMovedDown);
			intensity(ObjectIntersection, triangleJudgeRegImage, &MeanDown, &DeviationDown);

			move_region(ObjectIntersection, &RegionMovedUp, -(TriangleSize+15), 0);
			difference(RegionMovedUp, ObjectSelected, &RegionMovedUp);
			intensity(RegionMovedUp, triangleJudgeRegImage, &MeanUp, &DeviationUp);
			//实际情况调整
			MeanDiff = MeanUp-MeanDown;
			if (0 != (MeanDiff<BlackThred))
			{
				concat_obj(ObjectSelected, ErrorRegion, &ErrorRegion);

			}
			else
			{
				//concat_obj(ObjectSelected, TriangleDisplay, &TriangleDisplay);
				concat_obj(ObjectSelected, TReg, &ObjectsConcat);
				concat_obj(TriangleReg, ObjectsConcat, &TriangleReg);
			}

		}
		//初始化成员变量
		Hobject TriangleRegUnion,TriangleRegFillUp;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);
		Hobject TriangleConnected;
		intersection(m_ARegionT, TriangleRegFillUp, &TriangleRegFillUp);
		connection(TriangleRegFillUp, &TriangleConnected);
		HTuple TriangleNumber,TriangleRegArea, TriangleRegRow, TriangleRegColumn;
		count_obj(TriangleConnected, &TriangleNumber);
		area_center(TriangleRegFillUp, &TriangleRegArea, &TriangleRegRow, &TriangleRegColumn);

		//dilation_circle(TriangleRegFillUp,&TriangleRegFillUp,DilationSize);

		m_TriangleReg=TriangleRegFillUp;
		if(m_bDebugImg)
		{
			//concat_obj(m_vRgn[rId], TriangleDisplay, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TriangleRegFillUp, &m_vRgn[rId]);
		}
		if (TriangleNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId] = TriangleRegFillUp;
			retValue.Detach(pTriangleArea);
			return S_FALSE;
		}
		//是否不需要返回错误。
		if (TriangleRegArea>=0)
		{
			retValue = TriangleRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			retValue = 100;
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		retValue.Detach(pTriangleArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTriangleArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TriangleDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;100$\
					 998;LP;1;100;1;50$\
					 999;FP;0;250;0.5;60$\
					 1000;FP;0;250;0.5;30$\
					 1018;LP;5;80;1;20$\
					 1096;LP;20;250;1;100$\
					 1155;LP;5;80;1;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//
STDMETHODIMP CPlugAlgo::D13_StripePatternDetectAlgo2(VARIANT* rgnId,VARIANT* pSwitch,VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pWhiteThred,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int Switch    = (int)pSwitch->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	//int EliminateSize    =(int)pEliminateSize->fltVal;
	//int TriangleDist   = (int)pTriangleDist->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		//条形花纹提取
		Hobject ABStripeReg;
		HTuple ABStripeArea, ABStripeRow, ABStripeColumn;
		move_region(m_ABEdge, &ABStripeReg, -MoveSize, 0);
		intersection(ABStripeReg, m_ROI, &ABStripeReg);
		area_center(ABStripeReg, &ABStripeArea, &ABStripeRow, &ABStripeColumn);

		Hobject ABStripeRegDilation,ABStripeRegIntersection;
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection(ABStripeRegDilation, m_ROI, &ABStripeRegIntersection);

		Hobject RegionDiffH2,StripeRegOpening,StripeSearchReg;
		difference(ABStripeRegIntersection, m_Platform0, &RegionDiffH2);
		opening_circle(RegionDiffH2, &StripeRegOpening, 3);
		union1(StripeRegOpening, &StripeSearchReg);

		Hobject StripeRegImage;
		reduce_domain(crtImgReduced, StripeSearchReg, &StripeRegImage);
		emphasize(StripeRegImage, &StripeRegImage, 7, 7, 1);
		//HTuple Mean, Deviation;
		/*intensity(StripeSearchReg, StripeRegImage, &Mean, &Deviation);
		if (Mean.Num()!=1)
		{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
		}	
		if(Mean[0].D()+WhiteThred>=255.0)
		{
		WhiteThred=254.0-Mean[0].D();
		}*/

		Hobject WhiteStripeRoi0,WhiteStripeRoi;
		threshold(StripeRegImage, &WhiteStripeRoi0, WhiteThred, 255);

		Hobject WhiteStripeRoiFillUp,WhiteRegionErosion;
		fill_up(WhiteStripeRoi0, &WhiteStripeRoiFillUp);
		Hobject WhiteStripeRoiOpening;
		//opening_circle(WhiteStripeRoiFillUp, &WhiteStripeRoiOpening, 2);

		//剔除小的干扰点
		Hobject ConnectedRegions2;
		connection(WhiteStripeRoiFillUp, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &WhiteStripeRoi, "area", "and", 20, 999999);

		Hobject StripeRoiUnion,StripeRoiConnected,PlatformRegConnected;
		union1(WhiteStripeRoi, &StripeRoiUnion);

		if(m_bDebugImg)
		{
			Hobject ABStripeRegInterscted;
			intersection(ABStripeReg,StripeSearchReg,&ABStripeRegInterscted);
			concat_obj(m_vRgn[rId], ABStripeRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], StripeSearchReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteStripeRoi0, &m_vRgn[rId]); //用于显示阈值分割情况
		}
		//
		HTuple Area8, Row8, Column8;
		area_center(StripeRoiUnion, &Area8, &Row8, &Column8);
		if(Area8==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		connection(StripeRoiUnion, &StripeRoiConnected);
		connection(m_PlatformReg, &PlatformRegConnected);
		HTuple Number1,SelectSzie;
		count_obj(PlatformRegConnected, &Number1);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑,由于存在变形，适当改小了
		SelectSzie=10;
		Hobject SortedRegions,ObjectSelected,TriangleRoiCliped,ConnectedRegions1,RegionUnion2,RegionUnionDiff;
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		if (0 != (Number1==2))
		{
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected, 1);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			select_shape(StripeRoiConnected, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiUnion, RegionUnion2, &RegionUnionDiff);

			select_obj(SortedRegions, &ObjectSelected, 2);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(RegionUnionDiff, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);

			union1(TriangleRoiCliped, &RegionUnion2);
			difference(RegionUnionDiff, RegionUnion2, &WhiteStripeRoi);
		}
		else
		{
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(StripeRoiConnected, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiConnected, RegionUnion2, &WhiteStripeRoi);
		}

		//排除白条下面的白点干扰,只选择基准线以上的白条区域
		Hobject ABStripePartitioned;
		HTuple ABStripePartitionedArea, ABStripeRegRows, ABStripeRegCols;
		partition_rectangle(ABStripeReg, &ABStripePartitioned, 1, 100);
		area_center(ABStripePartitioned, &ABStripePartitionedArea, &ABStripeRegRows, &ABStripeRegCols);

		HTuple ABrowsRound,ABcolsRound,WhiteStripeNumber;
		Hobject WhiteStripeRoiConnected;
		tuple_round(ABStripeRegRows, &ABrowsRound);
		tuple_round(ABStripeRegCols, &ABcolsRound);
		union1(WhiteStripeRoi, &WhiteStripeRoi);
		connection(WhiteStripeRoi, &WhiteStripeRoiConnected);
		count_obj(WhiteStripeRoiConnected, &WhiteStripeNumber);

		Hobject WhiteStripeUp,WhiteStripeSelected;
		HTuple StripeArea, StripeRow, StripeCol,StripeColRound,ColIndice;
		gen_empty_region(&WhiteStripeUp);
		for(int i=1;i<=WhiteStripeNumber;i++)
		{
			select_obj(WhiteStripeRoiConnected, &WhiteStripeSelected, i);
			area_center(WhiteStripeSelected, &StripeArea, &StripeRow, &StripeCol);
			tuple_round(StripeCol, &StripeColRound);
			tuple_find(ABcolsRound, StripeColRound, &ColIndice);
			//
			if (0 != (ColIndice==-1))
			{
				continue;
			}

			if (0 != (StripeRow<=(ABrowsRound.Select(ColIndice.Select(0)))))
			{
				concat_obj(WhiteStripeUp, WhiteStripeSelected, &WhiteStripeUp);

			}

		}
		Hobject WhiteStripeUpUnion;
		union1(WhiteStripeUp, &WhiteStripeUpUnion);

		////排除白条上面的白点干扰
		//Hobject RegionDilation,WhiteStripeRoiClosing;
		//dilation_rectangle1(WhiteStripeUpUnion, &RegionDilation, 1, SearchSize/2);
		//erosion_rectangle1(RegionDilation, &WhiteStripeRoiClosing, 1,  SearchSize/2);

		//Hobject WhiteStripeRgn,WhiteStripeRoiConnected1;
		//HTuple WhiteStripeRoiNum;
		//gen_empty_region(&WhiteStripeRgn);
		//connection(WhiteStripeRoiClosing, &WhiteStripeRoiConnected1);
		//count_obj(WhiteStripeRoiConnected1, &WhiteStripeRoiNum);

		//HTuple ShortLength,LongLength,WhiteStripeRow, WhiteStripeCol, WhiteStripePhi, WhiteStripeLength1, WhiteStripeLength2;
		//Hobject Rect;
		//for (int i=1;i<=WhiteStripeRoiNum;i++)
		//{
		//	select_obj(WhiteStripeRoiConnected1, &WhiteStripeSelected, i);
		//	smallest_rectangle2(WhiteStripeSelected, &WhiteStripeRow, &WhiteStripeCol, &WhiteStripePhi, &WhiteStripeLength1, &WhiteStripeLength2);
		//	ShortLength = HTuple();
		//	LongLength = HTuple();

		//	if (0 != (WhiteStripeLength1>=WhiteStripeLength2))
		//	{
		//		ShortLength = WhiteStripeLength2;
		//		LongLength = WhiteStripeLength1;
		//	}
		//	else
		//	{
		//		ShortLength = WhiteStripeLength1;
		//		LongLength = WhiteStripeLength2;
		//	}

		//	gen_rectangle2(&Rect, WhiteStripeRow, WhiteStripeCol, WhiteStripePhi, WhiteStripeLength1, WhiteStripeLength2);
		//	//实际情况调整,
		//	if (0 != ((ShortLength*2)>30))
		//	{
		//		gen_empty_region(&WhiteStripeRgn);
		//		continue;
		//	}
		//	Hobject StripeSearchRegErosion,RectIntersection;
		//	erosion_circle(StripeSearchReg, &StripeSearchRegErosion, 1);
		//	intersection(Rect, StripeSearchRegErosion, &RectIntersection);
		//	Hobject RegionDilation1,RegionErosion;
		//	dilation_rectangle1(RectIntersection, &RegionDilation1, 1, 10);
		//	erosion_rectangle1(RegionDilation1, &RegionErosion, 10, 1);

		//	Hobject RegionDiff,RegionDiffConnected,RegionDiffSelected,RegionDiffUnion;
		//	HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeColumn1;
		//	difference(RegionErosion, WhiteStripeSelected, &RegionDiff);
		//	connection(RegionDiff, &RegionDiffConnected);
		//	area_center(WhiteStripeSelected, &WhiteStripeArea1, &WhiteStripeRow1, &WhiteStripeColumn1);
		//	select_shape(RegionDiffConnected, &RegionDiffSelected, "row", "and", 0, WhiteStripeRow1);
		//	//
		//	Hobject SelectedRegions1;
		//	select_shape_std(RegionDiffSelected, &SelectedRegions1, "max_area", 70);
		//	//
		//	union1(SelectedRegions1, &RegionDiffUnion);
		//	HTuple Row, Column, Phi, Length1, Length2;
		//	smallest_rectangle2(RegionDiffUnion, &Row, &Column, &Phi, &Length1, &Length2);
		//	Hobject BalckRect,WhiteStripeDiff,ConnectedRegions,SelectedRegions;
		//	if (0 != ((Row.Num())==0))
		//	{
		//		concat_obj(WhiteStripeRgn, WhiteStripeSelected, &WhiteStripeRgn);

		//	}
		//	else
		//	{
		//		gen_rectangle2(&BalckRect, Row, Column, Phi, Length1, Length2);
		//		ShortLength = HTuple();
		//		LongLength = HTuple();
		//		if (0 != (Length1>=Length2))
		//		{
		//			ShortLength = Length2;
		//			LongLength = Length1;
		//		}
		//		else
		//		{
		//			ShortLength = Length1;
		//			LongLength = Length2;
		//		}
		//		//实际情况调整，开放此参数
		//		if (0 != (ShortLength*2>EliminateSize))
		//		{
		//			Hobject BalckRect1;
		//			gen_rectangle2(&BalckRect1, Row, Column, Phi, LongLength+ShortLength, ShortLength);
		//			difference(WhiteStripeSelected, BalckRect1, &WhiteStripeDiff);
		//			connection(WhiteStripeDiff, &ConnectedRegions);
		//			select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		//			concat_obj(WhiteStripeRgn, SelectedRegions, &WhiteStripeRgn);
		//			
		//		}
		//		else
		//		{
		//			concat_obj(WhiteStripeRgn, WhiteStripeSelected, &WhiteStripeRgn);
		//		}
		//	}
		//}

		Hobject WhiteStripeRgnUnion,WhiteStripeRegConnected,ObjectUnion,StripeRoiError;
		connection(WhiteStripeUpUnion, &WhiteStripeRegConnected);

		//根据白条之间的距离进行判断筛选
		HTuple TriangleRegNum;
		count_obj(WhiteStripeRegConnected, &TriangleRegNum);

		HTuple ObjectSelectedArea, ObjectSelectedRow, ObjectSelectedCol;
		Hobject TriangleRegL,TriangleRegR,WhiteStripeReg;
		Hobject TriangleRegLConnected,TriangleRegLeft;
		HTuple NumberL;
		Hobject TriangleRegRConnected,TriangleRegRight;
		HTuple NumberR;

		gen_empty_region(&TriangleRegL);
		gen_empty_region(&TriangleRegR);
		gen_empty_region(&TriangleRegLeft);
		gen_empty_region(&TriangleRegRight);
		gen_empty_region(&WhiteStripeReg);
		if (0 != (Number1==2))
		{
			Hobject SortedRegions,ObjectSelected1,ObjectSelected2;
			HTuple Area1, Row1, Column1;
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected1, 1);
			area_center(ObjectSelected1, &Area1, &Row1, &Column1);
			HTuple PlatformRowL1, PlatformColL1, PlatformRowR1, PlatformColR1;
			smallest_rectangle1(ObjectSelected1, &PlatformRowL1, &PlatformColL1, &PlatformRowR1, &PlatformColR1);

			HTuple Area2, Row2, Column2,PlatformRowL2, PlatformColL2, PlatformRowR2, PlatformColR2;
			select_obj(SortedRegions, &ObjectSelected2, 2);
			area_center(ObjectSelected2, &Area2, &Row2, &Column2);
			smallest_rectangle1(ObjectSelected2, &PlatformRowL2, &PlatformColL2, &PlatformRowR2, &PlatformColR2);

			if (0 != (Area1>Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL1))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR1))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}
			}
			else if (0 != (Area1<Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR2))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}

			}
			else
			{
				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
				}

			}	
			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}

			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		else
		{
			HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			for (int i=1; i<=TriangleRegNum; i++)
			{
				select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
				area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
				if (0 != (ObjectSelectedCol<PlatformColL))
				{
					concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
				}
				else if (0 != (ObjectSelectedCol>PlatformColR))
				{
					concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
				}
			}

			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}
			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}

		///////////////////////
		//Hobject StripeRegSorted,ObjectSelectedx,ObjectSelectedy;
		//HTuple ObjectSelectedAreax, ObjectSelectedRowx, ObjectSelectedColx,ObjectSelectedAreay, ObjectSelectedRowy, ObjectSelectedColy;
		//HTuple ColDiff;
		//count_obj(WhiteStripeReg, &TriangleRegNum);
		//gen_empty_region(&ObjectUnion);
		//gen_empty_obj(&StripeRoiError);
		//for (int x=1;x<=TriangleRegNum;x++)
		//{
		//	for (int y=1;y<=TriangleRegNum;y++)
		//	{
		//		sort_region(WhiteStripeReg, &StripeRegSorted, "first_point", "true", "column");
		//		select_obj(StripeRegSorted, &ObjectSelectedx, x);
		//		area_center(ObjectSelectedx, &ObjectSelectedAreax, &ObjectSelectedRowx, &ObjectSelectedColx);

		//		select_obj(StripeRegSorted, &ObjectSelectedy, y);
		//		area_center(ObjectSelectedy, &ObjectSelectedAreay, &ObjectSelectedRowy, &ObjectSelectedColy);
		//		ColDiff = (ObjectSelectedColx-ObjectSelectedColy).Abs();
		//		//实际情况调整
		//		if (0 != (HTuple(ColDiff<TriangleDist).And(ColDiff>0)))
		//		{
		//			union2(ObjectSelectedx, ObjectSelectedy, &ObjectUnion);
		//			concat_obj(ObjectUnion, StripeRoiError, &StripeRoiError);
		//			my_disp_obj(StripeRoiError);
		//		}
		//	}
		//}
		//Hobject StripeRoiErrorConnected,ObjectSelected4,TriangleRoiDiff0;
		//HTuple Num;
		//union1(StripeRoiError, &StripeRoiError);
		//connection(StripeRoiError, &StripeRoiErrorConnected);
		//count_obj(StripeRoiErrorConnected, &Num);
		//if (0 != (Num>1))
		//{
		//	select_shape_std(StripeRoiErrorConnected, &ObjectSelected4, "max_area", 70);
		//	difference(StripeRoiErrorConnected, ObjectSelected4, &TriangleRoiDiff0);
		//	difference(WhiteStripeReg, TriangleRoiDiff0, &WhiteStripeReg);
		//}

		//白条往下平移，闭合
		Hobject StripeRegConnected1,StripeRegs;
		HTuple StripeRegNum;
		connection(WhiteStripeReg, &StripeRegConnected1);
		count_obj(StripeRegConnected1, &StripeRegNum);
		gen_empty_region(&StripeRegs);
		Hobject WhiteStripeSelected1,WhiteStripeMoved0,WhiteStripeMoved,WhiteStripeUnion,WhiteStripeClosing,StripeRoiClosing1,StripeRegion;
		HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeCol1;
		for (int i=1;i<=StripeRegNum;i++)
		{
			select_obj(StripeRegConnected1, &WhiteStripeSelected1, i);
			closing_circle(WhiteStripeSelected1, &WhiteStripeSelected1, 10);

			move_region(WhiteStripeSelected1, &WhiteStripeMoved0, -3, 0);
			dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);

			move_region(StripeRegion, &WhiteStripeMoved, 15, 0);
			union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
			closing_rectangle1(WhiteStripeUnion, &WhiteStripeClosing, 2, 20);
			concat_obj(WhiteStripeClosing, StripeRegs, &StripeRegs);
		}
		union1(StripeRegs, &StripeRegs);

		Hobject StripeConnected;
		connection(StripeRegs, &StripeConnected);
		HTuple StripeNumber,StripeRegArea, StripeRegRow, StripeRegColumn;
		count_obj(StripeConnected, &StripeNumber);
		area_center(StripeRegs, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		Hobject StripeReg,EmptyRegion;
		//dilation_circle(StripeRegs,&StripeReg,DilationSize);
		if (Switch==1)
		{
			//gen_empty_region(&EmptyRegion);
			m_StripeReg1=StripeRegs;
			m_StripeReg2=StripeRegs;
		}
		else if(Switch==2)
		{
			m_StripeReg1=m_StripeReg1;
			m_StripeReg2=StripeRegs;
		}
		if(m_bDebugImg)
		{
			Hobject StripeRegInterscted;
			intersection(StripeRegs,StripeSearchReg,&StripeRegInterscted);
			concat_obj(m_vRgn[rId], StripeRegInterscted, &m_vRgn[rId]);
		}
		if (StripeNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		if (StripeRegArea>0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegs;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_StripePatternDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 1023;LP;1;2;1;1$\
					 991;LP;0;250;1;90$\
					 998;LP;1;100;1;60$\
					 999;FP;0;250;0.5;80");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_NeckRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pUpEdgeMoveSize,VARIANT* pMoveSize,VARIANT* pDilationSizeP,VARIANT* pDilationSizeT)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	//int VErosionSize   = (int)pVErosionSize->fltVal;

	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;

	int DilationSizeP   = (int)pDilationSizeP->fltVal;
	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_TriangleReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1,RegionMoved1;
		//水平缩放
		clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);

		//erosion_rectangle1(ARegionT0,&ARegionT1,1,VErosionSize);
		//上边缘
		move_region(ARegionT0, &RegionMoved1, UpEdgeMoveSize, 0);
		intersection(RegionMoved1, ARegionT0, &ARegionT1);

		Hobject PlatformReg,TriangleReg;
		//叉口平台膨胀
		dilation_rectangle1(m_PlatformReg,&PlatformReg,DilationSizeP,1);
		//花纹膨胀
		dilation_circle(m_TriangleReg,&TriangleReg,DilationSizeT);

		//剔除平台
		Hobject ARegionPlatDiff,ARegionDiff;
		difference(ARegionT1, PlatformReg, &ARegionPlatDiff);
		//剔除三角形
		difference(ARegionPlatDiff, TriangleReg, &ARegionDiff);

		m_vRgn[rId] = ARegionDiff ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 994;LP;1;40;1;1$\
					 1126;LP;1;50;1;5$\
					 1127;LP;1;20;1;1$\
					 1021;LP;1;20;1;1$\
					 1020;LP;1;20;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_NeckRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pLowerEdgeMoveSize, VARIANT* pUpEdgeMoveSize,VARIANT* pHErosionSize, VARIANT* pMoveSize,VARIANT* pDilationSizeH1,VARIANT* pVDilationSizeH2,VARIANT* pHDilationSizeH2,VARIANT* pDilationSizeT)
{
	int rId           = (int)rgnId->fltVal;
	int LowerEdgeMoveSize   = (int)pLowerEdgeMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;

	int MoveSize   = (int)pMoveSize->fltVal;
	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int VDilationSizeH2   = (int)pVDilationSizeH2->fltVal;
	int HDilationSizeH2   = (int)pHDilationSizeH2->fltVal;
	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_StripeReg1.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-LowerEdgeMoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1,RegionMoved1;
		//水平缩放
		clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//垂直缩放
		//erosion_rectangle1(ARegionT0,&ARegionT1,1,VErosionSize);

		//上边缘
		move_region(ARegionT0, &RegionMoved1, UpEdgeMoveSize, 0);
		intersection(RegionMoved1, ARegionT0, &ARegionT1);

		//剔除平台
		Hobject PlatformReg;
		dilation_circle(m_PlatformReg,&PlatformReg,DilationSizeT);
		Hobject ARegionPlatDiff,ARegionDiff;
		difference(ARegionT1, PlatformReg, &ARegionPlatDiff);
		//剔除花纹
		Hobject StripeReg1;
		//下花纹缩放
		dilation_circle(m_StripeReg1,&StripeReg1,DilationSizeH1);

		Hobject StripeReg2,StripeReg22;
		move_region(m_StripeReg1, &StripeReg2, -MoveSize, 0);
		//上花纹垂直缩放
		Hobject StripeRegDilation,RegionDetect;
		dilation_rectangle1(StripeReg2,&StripeRegDilation,1,VDilationSizeH2);
		//上花纹水平缩放
		dilation_rectangle1(StripeRegDilation,&StripeReg22,HDilationSizeH2,1);

		Hobject StripeReg;
		union2(StripeReg1,StripeReg22,&StripeReg);
		union1(StripeReg,&StripeReg);	
		//下边缘接口区域
		Hobject EdgeMove;
		move_region(m_DownEdge,&EdgeMove,4,0);
		dilation_circle(EdgeMove,&EdgeMove,DilationSizeH1+5.0);
		union2(EdgeMove,StripeReg,&StripeReg);
		//
		difference(ARegionPlatDiff, StripeReg, &ARegionDiff);

		m_StripeRegD=StripeReg;
		m_vRgn[rId] = ARegionDiff ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_NeckRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1169$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 1126;LP;1;50;1;5$\
					 994;LP;1;50;1;2$\
					 1168;LP;20;100;1;60$\
					 1170;LP;1;45;1;1$\
					 1167;LP;1;45;1;1$\
					 1172;LP;1;45;1;1$\
					 1021;LP;1;45;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgo(VARIANT* rgnId, VARIANT* pThredValue,VARIANT* pDilationSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//m_ABEllipse是通过提取AB基准线拟合出来的
	//配合NeckBaseEdgeDetectAlgo算子使用（找线）
	int rId           = (int)rgnId->fltVal;
	double ThredValue   = (double)pThredValue->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ROI.Id() == H_EMPTY_REGION)||(m_ContEllipse.Id()== H_EMPTY_REGION)||(m_ABEllipse.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDiation,CRegionDiff1;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(m_ContEllipse, m_ABEllipse, &CRegionDiff1);
		Hobject CRegionDiff2,CRegionDiffConnected,CRegionDiffSorted;
		difference(CRegionDiff1, BaseRegionLineDiation, &CRegionDiff2);
		connection(CRegionDiff2, &CRegionDiffConnected);
		sort_region(CRegionDiffConnected, &CRegionDiffSorted, "first_point", "true", "row");
		HTuple BaseEllipseArea2, BaseEllipseRow2, BaseEllipseColumn2;
		Hobject CRegionSelected;
		area_center(m_ContEllipse, &BaseEllipseArea2, &BaseEllipseRow2, &BaseEllipseColumn2);
		select_shape(CRegionDiffSorted, &CRegionSelected, "row", "and", BaseEllipseRow2, 999999);

		//区域二次定位--自动灰度阈值提取
		Hobject CRegionDilation,CRegionIntersection,CRegionImageReduced;
		dilation_circle(CRegionSelected, &CRegionDilation, 15);
		intersection(CRegionDilation, m_ROI, &CRegionIntersection);
		reduce_domain(crtImg, CRegionIntersection, &CRegionImageReduced);
		HTuple CRegionMean, CRegionDeviation;
		//min_max_gray(CRegionIntersection, CRegionImageReduced, 0, &Min, &Max, &Range);
		Hobject CRegionImageScaleMax;
		scale_image_max(CRegionImageReduced, &CRegionImageScaleMax);
		intensity(CRegionIntersection, CRegionImageScaleMax, &CRegionMean, &CRegionDeviation);
		if (CRegionMean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		Hobject CRegion,CRegionFillUp,CRegionClosing,CRegionOpening;
		if(CRegionMean[0].D()-ThredValue<0)
		{
			ThredValue=CRegionMean[0].D();
		}
		threshold(CRegionImageScaleMax, &CRegion, CRegionMean-ThredValue, 255);
		fill_up(CRegion, &CRegionFillUp);
		//
		Hobject CRegionConnected,CRegionSelected1;
		connection(CRegionFillUp, &CRegionConnected);
		select_shape_std(CRegionConnected, &CRegionSelected1, "max_area", 70);

		opening_circle(CRegionSelected1, &CRegionOpening, 10.0);
		Hobject ConnectedRegions6,SelectedRegions2;
		connection(CRegionOpening, &ConnectedRegions6);
		select_shape_std(ConnectedRegions6, &SelectedRegions2, "max_area",70);
		closing_circle(SelectedRegions2, &CRegionClosing, 10.0);
		//
		closing_rectangle1(CRegionClosing, &CRegionClosing, 30, 1);
		//针对颈部拐角反光的情况，内边缘膨胀
		Hobject CRegionDiff,ABEllipseDilation;
		dilation_circle(m_ABEllipse, &ABEllipseDilation, DilationSize);
		difference(CRegionClosing, ABEllipseDilation, &CRegionDiff);

		//水平垂直缩放
		Hobject SealingFaceRegion;
		erosion_rectangle1(CRegionDiff,&SealingFaceRegion,HErosionSize,VErosionSize);

		m_vRgn[rId] = SealingFaceRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1002$\
					 167;B$\
					 1017;FP;0;250;0.5;15$\
					 1117;LP;1;50;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pThredValue,VARIANT* pDilationSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//m_ABEllipse是通过模板工具画的，而不是通过提取AB基准线拟合出来的，其位置进行了横坐标校正
	//配合NeckBaseEdgeDetectAlgo1算子使用（找点）
	int rId           = (int)rgnId->fltVal;
	double ThredValue   = (double)pThredValue->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ROI.Id() == H_EMPTY_REGION)||(m_ContEllipse.Id()== H_EMPTY_REGION)||(m_ABEllipse.Id()== H_EMPTY_REGION)||(m_RowDiff.Num()!=1)||(m_ColDiff.Num()!=1))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;
		Hobject ABEllipseMoved;
		move_region(m_ABEllipse, &ABEllipseMoved, -m_RowDiff, -m_ColDiff);

		//
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDiation,CRegionDiff1;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(m_ContEllipse, ABEllipseMoved, &CRegionDiff1);
		Hobject CRegionDiff2,CRegionDiffConnected,CRegionDiffSorted;
		difference(CRegionDiff1, BaseRegionLineDiation, &CRegionDiff2);
		connection(CRegionDiff2, &CRegionDiffConnected);
		sort_region(CRegionDiffConnected, &CRegionDiffSorted, "first_point", "true", "row");
		HTuple BaseEllipseArea2, BaseEllipseRow2, BaseEllipseColumn2;
		Hobject CRegionSelected;
		area_center(m_ContEllipse, &BaseEllipseArea2, &BaseEllipseRow2, &BaseEllipseColumn2);
		select_shape(CRegionDiffSorted, &CRegionSelected, "row", "and", BaseEllipseRow2, 999999);

		//区域二次定位--自动灰度阈值提取
		Hobject CRegionDilation,CRegionIntersection,CRegionImageReduced;
		dilation_circle(CRegionSelected, &CRegionDilation, 15);
		intersection(CRegionDilation, m_ROI, &CRegionIntersection);
		reduce_domain(crtImg, CRegionIntersection, &CRegionImageReduced);
		HTuple CRegionMean, CRegionDeviation;
		//min_max_gray(CRegionIntersection, CRegionImageReduced, 0, &Min, &Max, &Range);
		Hobject CRegionImageScaleMax;
		scale_image_max(CRegionImageReduced, &CRegionImageScaleMax);
		intensity(CRegionIntersection, CRegionImageScaleMax, &CRegionMean, &CRegionDeviation);
		if (CRegionMean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		Hobject CRegion,CRegionFillUp,CRegionClosing,CRegionOpening;
		if(CRegionMean[0].D()-ThredValue<0)
		{
			ThredValue=CRegionMean[0].D();
		}
		threshold(CRegionImageScaleMax, &CRegion, CRegionMean-ThredValue, 255);
		fill_up(CRegion, &CRegionFillUp);
		//
		Hobject CRegionConnected,CRegionSelected1;
		connection(CRegionFillUp, &CRegionConnected);
		select_shape_std(CRegionConnected, &CRegionSelected1, "max_area", 70);

		opening_circle(CRegionSelected1, &CRegionOpening, 10.0);

		Hobject ConnectedRegions6,SelectedRegions2;
		connection(CRegionOpening, &ConnectedRegions6);
		select_shape_std(ConnectedRegions6, &SelectedRegions2, "max_area", 70);
		closing_circle(SelectedRegions2, &CRegionClosing, 10.0);
		//
		closing_rectangle1(CRegionClosing, &CRegionClosing, 30, 1);
		//针对颈部拐角反光的情况，内边缘膨胀
		Hobject CRegionDiff,ABEllipseDilation;
		dilation_circle(ABEllipseMoved, &ABEllipseDilation, DilationSize);
		difference(CRegionClosing, ABEllipseDilation, &CRegionDiff);

		//水平垂直缩放
		Hobject SealingFaceRegion;
		erosion_rectangle1(CRegionDiff,&SealingFaceRegion,HErosionSize,VErosionSize);

		m_vRgn[rId] = SealingFaceRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1154$\
					 167;B$\
					 1017;FP;0;250;0.5;15$\
					 1117;LP;1;50;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***********************************************************************
** 函数名：SealingFaceRegionLocationAlgo2
** 功  能：密封面提取；根据算子1优化，开放出两个椭圆区域相减之后的区域的膨胀尺寸（原来固定值为15）
** 时  间：2018年12月20日，华润现场
************************************************************************/
STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pSealDilationSize,VARIANT* pThredValue,VARIANT* pDilationSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//m_ABEllipse是通过模板工具画的，而不是通过提取AB基准线拟合出来的，其位置进行了横坐标校正
	//配合NeckBaseEdgeDetectAlgo1算子使用（找点）
	int rId           = (int)rgnId->fltVal;
	double ThredValue   = (double)pThredValue->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;
	double SealDilationSize   = (double)pSealDilationSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ROI.Id() == H_EMPTY_REGION)||(m_ContEllipse.Id()== H_EMPTY_REGION)||(m_ABEllipse.Id()== H_EMPTY_REGION)||(m_RowDiff.Num()!=1)||(m_ColDiff.Num()!=1))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;
		Hobject ABEllipseMoved;
		move_region(m_ABEllipse, &ABEllipseMoved, -m_RowDiff, -m_ColDiff);

		//
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDiation,CRegionDiff1;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(m_ContEllipse, ABEllipseMoved, &CRegionDiff1);
		Hobject CRegionDiff2,CRegionDiffConnected,CRegionDiffSorted;
		difference(CRegionDiff1, BaseRegionLineDiation, &CRegionDiff2);
		connection(CRegionDiff2, &CRegionDiffConnected);
		sort_region(CRegionDiffConnected, &CRegionDiffSorted, "first_point", "true", "row");
		HTuple BaseEllipseArea2, BaseEllipseRow2, BaseEllipseColumn2;
		Hobject CRegionSelected;
		area_center(m_ContEllipse, &BaseEllipseArea2, &BaseEllipseRow2, &BaseEllipseColumn2);
		select_shape(CRegionDiffSorted, &CRegionSelected, "row", "and", BaseEllipseRow2, 999999);

		//区域二次定位--自动灰度阈值提取
		Hobject CRegionDilation,CRegionIntersection,CRegionImageReduced;
		dilation_circle(CRegionSelected, &CRegionDilation, SealDilationSize);  //------
		intersection(CRegionDilation, m_ROI, &CRegionIntersection);
		reduce_domain(crtImg, CRegionIntersection, &CRegionImageReduced);
		HTuple CRegionMean, CRegionDeviation;
		//min_max_gray(CRegionIntersection, CRegionImageReduced, 0, &Min, &Max, &Range);
		Hobject CRegionImageScaleMax;
		scale_image_max(CRegionImageReduced, &CRegionImageScaleMax);
		intensity(CRegionIntersection, CRegionImageScaleMax, &CRegionMean, &CRegionDeviation);
		if (CRegionMean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		Hobject CRegion,CRegionFillUp,CRegionClosing,CRegionOpening;
		if(CRegionMean[0].D()-ThredValue<0)
		{
			ThredValue=CRegionMean[0].D();
		}
		threshold(CRegionImageScaleMax, &CRegion, CRegionMean-ThredValue, 255);
		fill_up(CRegion, &CRegionFillUp);
		//
		Hobject CRegionConnected,CRegionSelected1;
		connection(CRegionFillUp, &CRegionConnected);
		select_shape_std(CRegionConnected, &CRegionSelected1, "max_area", 70);

		opening_circle(CRegionSelected1, &CRegionOpening, 10.0);

		Hobject ConnectedRegions6,SelectedRegions2;
		connection(CRegionOpening, &ConnectedRegions6);
		select_shape_std(ConnectedRegions6, &SelectedRegions2, "max_area", 70);
		closing_circle(SelectedRegions2, &CRegionClosing, 10.0);
		//
		closing_rectangle1(CRegionClosing, &CRegionClosing, 30, 1);
		//针对颈部拐角反光的情况，内边缘膨胀
		Hobject CRegionDiff,ABEllipseDilation;
		dilation_circle(ABEllipseMoved, &ABEllipseDilation, DilationSize);
		difference(CRegionClosing, ABEllipseDilation, &CRegionDiff);

		//水平垂直缩放
		Hobject SealingFaceRegion;
		erosion_rectangle1(CRegionDiff,&SealingFaceRegion,HErosionSize,VErosionSize);

		m_vRgn[rId] = SealingFaceRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SealingFaceRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1154$\
					 167;B$\
					 714;FP;0;30;0.5;10$\
					 1017;FP;0;250;0.5;15$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************
** 函数名：ScrapEdgeDetectAlgo2
** 功  能：冠部切边提取
** 说  明：根据算子1修改，主要增加了m_ABEllipse水平膨胀尺寸和向上平移尺寸
** 时  间：2019年9月24日
****************************************************************/
STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pScrapEdgeArea)
{
	//20圆形覆膜
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION)||(m_ABEllipse.Id() == H_EMPTY_REGION)||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject ImageReduced = m_crtImg; 
		//Hobject ImageReduced;
		//reduce_domain(crtImg,rgn,&ImageReduced);
		//
		Hobject ABEllipseDilation,ABEllipseDilationMoved;
		dilation_circle(m_ABEllipse, &ABEllipseDilation, 35);
		dilation_rectangle1(ABEllipseDilation,&ABEllipseDilation,20,1 );
		HTuple ABEllipseArea,ABEllipseRow,ABEllipseCol;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRow,&ABEllipseCol);
		move_region(ABEllipseDilation, &ABEllipseDilationMoved, -40, 0);

		Hobject RegionDifference1,ConnectedRegions4,SortedRegions1,SelectedRegions;
		difference(m_ROI, ABEllipseDilationMoved, &RegionDifference1);
		connection(RegionDifference1, &ConnectedRegions4);
		//HTuple Num4;
		//count_obj(ConnectedRegions4,&Num4);
		//if (Num4<2)
		//{
		//	Hobject EmptyRegion;
		//	gen_empty_region(&EmptyRegion);
		//	m_CrownRegionT=EmptyRegion;
		//	m_ScrapEdgeReg=EmptyRegion;

		//	retValue = -1;
		//	m_vErrorRgn[rId].Reset();
		//	retValue.Detach(pScrapEdgeArea);
		//	return S_FALSE;
		//}

		sort_region(ConnectedRegions4, &SortedRegions1, "first_point", "true", "row");
		select_shape(SortedRegions1, &SelectedRegions, "row", "and", ABEllipseRow, 999999);
		select_shape_std (SelectedRegions, &SelectedRegions, "max_area", 70);
		Hobject DRegErosion;
		erosion_circle(SelectedRegions, &DRegErosion, 3.5);

		//获得用于提取密封面边缘的搜索区域线
		Hobject BaseEllipseXld,BaseEllipseReg;
		HTuple BaseXldRow6, BaseXldCol;
		gen_contour_region_xld(m_ContEllipse, &BaseEllipseXld, "border");

		HTuple ContEllipseArea,ContEllipseRow,ContEllipseCol;
		area_center(m_ContEllipse,&ContEllipseArea,&ContEllipseRow,&ContEllipseCol);
		get_contour_xld(BaseEllipseXld, &BaseXldRow6, &BaseXldCol);
		gen_region_contour_xld(BaseEllipseXld, &BaseEllipseReg, "margin");

		//获取密封面基准椭圆的长轴
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDilation,BaseDregn,BaseDregConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDilation, 20+5, 2);
		difference(BaseEllipseReg, BaseRegionLineDilation, &BaseDregn);
		connection(BaseDregn, &BaseDregConnected);
		Hobject BaseDregSorted,BaseDregSelected;
		sort_region(BaseDregConnected, &BaseDregSorted, "first_point", "true", "row");
		select_shape(BaseDregSorted, &BaseDregSelected, "row", "and", ContEllipseRow, 999999);
		Hobject ImageDRegReduced,BaseDregDilation;
		reduce_domain(ImageReduced, DRegErosion, &ImageDRegReduced);
		//搜索区域大小
		dilation_rectangle1(BaseDregSelected, &BaseDregDilation, 1, 30);

		HTuple DefinedRow, DefinedCol;
		P_EdgePointsFitCurve(BaseDregDilation, ImageDRegReduced, 10, 30, 1, &DefinedRow, &DefinedCol);
		Hobject CotReg,ContXld,ContXldSmoothed;
		gen_region_points(&CotReg, DefinedRow, DefinedCol);

		if (DefinedRow.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld, &ContXldSmoothed, 15);

		HTuple ContXldRow, ContXldCol;
		Hobject ContRegion,ContRegionMoved;
		get_contour_xld(ContXldSmoothed, &ContXldRow, &ContXldCol);
		gen_region_polygon(&ContRegion, ContXldRow, ContXldCol);
		move_region(ContRegion, &ContRegionMoved, 3, 0);

		HTuple ROIRow1, ROICol1, ROIRow2, ROICol2;
		smallest_rectangle1(m_ROI, &ROIRow1, &ROICol1, &ROIRow2, &ROICol2);
		HTuple ContRectRow1, ContRectCol1, ContRectRow2, ContRectCol2;
		smallest_rectangle1(ContRegionMoved, &ContRectRow1, &ContRectCol1, &ContRectRow2, &ContRectCol2);
		HTuple ColDiffL,ColDiffR,ColDiffMax;
		ColDiffL = (ContRectCol1-ROICol1).Abs();
		ColDiffR = (ROICol2-ContRectCol2).Abs();
		if ((ColDiffL.Num()==0) &&(ColDiffR.Num()==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		tuple_max(ColDiffL.Concat(ColDiffR), &ColDiffMax);

		Hobject ContRegionDilation,DRegIntersection,DRegion,DRegionConnected;
		dilation_rectangle1(ContRegionMoved, &ContRegionDilation, 1, 5);
		clip_region(DRegErosion,&DRegIntersection, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);

		//填补侧面冠部区域区域的凹坑
		m_ColDiffMax=ColDiffMax;
		difference(DRegIntersection, ContRegionDilation, &DRegion);
		connection(DRegion, &DRegionConnected);

		HTuple ContArea, ContRow, ContCol;
		Hobject SelectedRegions1,CrownRegionT;
		area_center(ContRegionMoved,&ContArea, &ContRow, &ContCol);
		select_shape(DRegionConnected, &SelectedRegions1, "row", "and", ContRow, 999999);
		select_shape_std(SelectedRegions1, &CrownRegionT, "max_area", 70);

		m_CrownRegionT=CrownRegionT;
		m_ContRegionDilation=ContRegionDilation;
		//找侧面冠部区域棱边
		HTuple ContRegionRow1, ContRegionColumn1, ContRegionRow2, ContRegionColumn2;
		smallest_rectangle1(ContRegion, &ContRegionRow1, &ContRegionColumn1, &ContRegionRow2, &ContRegionColumn2);
		clip_region(ContRegion, &ContRegion, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);
		Hobject BaseDregMoved,BaseDregDilation1,GrayImageBaseDreg;
		move_region(ContRegion, &BaseDregMoved, MoveSize, 0);
		dilation_rectangle1(BaseDregMoved, &BaseDregDilation1, 1, SearchSize);
		reduce_domain(ImageReduced, BaseDregDilation1, &GrayImageBaseDreg);

		HTuple DefinedRow1, DefinedCol1;
		P_EdgePointsFitCurve(BaseDregDilation1, GrayImageBaseDreg, 10, SearchSize, 1, &DefinedRow1, &DefinedCol1);
		Hobject CotReg1,ContXld1,ContXldSmoothed1;
		gen_region_points(&CotReg1, DefinedRow1, DefinedCol1);
		if (DefinedRow1.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld1, DefinedRow1, DefinedCol1, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld1, &ContXldSmoothed1, 15);
		HTuple ContXldRow1, ContXldCol1;
		Hobject ContSmoothedReg;
		get_contour_xld(ContXldSmoothed1, &ContXldRow1, &ContXldCol1);
		gen_region_points(&ContSmoothedReg, ContXldRow1, ContXldCol1);

		HTuple BaseDregArea, BaseDregRow, BaseDregCol,CotRegArea, CotRegRow, CotRegCol;
		area_center(ContRegion, &BaseDregArea, &BaseDregRow, &BaseDregCol);
		area_center(ContSmoothedReg, &CotRegArea, &CotRegRow, &CotRegCol);
		Hobject ScrapEdgeReg;
		move_region(ContRegion, &ScrapEdgeReg, CotRegRow-BaseDregRow, 0);

		m_ScrapEdgeReg=ScrapEdgeReg;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], BaseDregDilation1, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], CotReg1, &m_vRgn[rId]);
		}
		if (CotRegArea>=0)
		{
			Hobject ScrapEdgeRegDilation;
			retValue = CotRegArea[0].I();
			dilation_circle(ScrapEdgeReg, &ScrapEdgeRegDilation, 2);
			m_vErrorRgn[rId] = ScrapEdgeRegDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pScrapEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6152$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1003;LP;0;100;1;28$\
					 998;LP;1;100;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pScrapEdgeArea)
{
	//20圆形覆膜
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION)||(m_ABEllipse.Id() == H_EMPTY_REGION)||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject ImageReduced = m_crtImg; 
		//Hobject ImageReduced;
		//reduce_domain(crtImg,rgn,&ImageReduced);
		//
		Hobject ABEllipseDilation,ABEllipseDilationMoved;
		dilation_circle(m_ABEllipse, &ABEllipseDilation, 35);
		HTuple ABEllipseArea,ABEllipseRow,ABEllipseCol;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRow,&ABEllipseCol);
		move_region(ABEllipseDilation, &ABEllipseDilationMoved, -35, 0);

		Hobject RegionDifference1,ConnectedRegions4,SortedRegions1,SelectedRegions;
		difference(m_ROI, ABEllipseDilationMoved, &RegionDifference1);
		connection(RegionDifference1, &ConnectedRegions4);
		//HTuple Num4;
		//count_obj(ConnectedRegions4,&Num4);
		//if (Num4<2)
		//{
		//	Hobject EmptyRegion;
		//	gen_empty_region(&EmptyRegion);
		//	m_CrownRegionT=EmptyRegion;
		//	m_ScrapEdgeReg=EmptyRegion;

		//	retValue = -1;
		//	m_vErrorRgn[rId].Reset();
		//	retValue.Detach(pScrapEdgeArea);
		//	return S_FALSE;
		//}

		sort_region(ConnectedRegions4, &SortedRegions1, "first_point", "true", "row");
		select_shape(SortedRegions1, &SelectedRegions, "row", "and", ABEllipseRow, 999999);
		select_shape_std (SelectedRegions, &SelectedRegions, "max_area", 70);
		Hobject DRegErosion;
		erosion_circle(SelectedRegions, &DRegErosion, 3.5);

		//获得用于提取密封面边缘的搜索区域线
		Hobject BaseEllipseXld,BaseEllipseReg;
		HTuple BaseXldRow6, BaseXldCol;
		gen_contour_region_xld(m_ContEllipse, &BaseEllipseXld, "border");

		HTuple ContEllipseArea,ContEllipseRow,ContEllipseCol;
		area_center(m_ContEllipse,&ContEllipseArea,&ContEllipseRow,&ContEllipseCol);
		get_contour_xld(BaseEllipseXld, &BaseXldRow6, &BaseXldCol);
		gen_region_contour_xld(BaseEllipseXld, &BaseEllipseReg, "margin");

		//获取密封面基准椭圆的长轴
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDilation,BaseDregn,BaseDregConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDilation, 20+5, 2);
		difference(BaseEllipseReg, BaseRegionLineDilation, &BaseDregn);
		connection(BaseDregn, &BaseDregConnected);
		Hobject BaseDregSorted,BaseDregSelected;
		sort_region(BaseDregConnected, &BaseDregSorted, "first_point", "true", "row");
		select_shape(BaseDregSorted, &BaseDregSelected, "row", "and", ContEllipseRow, 999999);
		Hobject ImageDRegReduced,BaseDregDilation;
		reduce_domain(ImageReduced, DRegErosion, &ImageDRegReduced);
		//搜索区域大小
		dilation_rectangle1(BaseDregSelected, &BaseDregDilation, 1, 30);

		HTuple DefinedRow, DefinedCol;
		P_EdgePointsFitCurve(BaseDregDilation, ImageDRegReduced, 10, 30, 1, &DefinedRow, &DefinedCol);
		Hobject CotReg,ContXld,ContXldSmoothed;
		gen_region_points(&CotReg, DefinedRow, DefinedCol);

		if (DefinedRow.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld, &ContXldSmoothed, 15);

		HTuple ContXldRow, ContXldCol;
		Hobject ContRegion,ContRegionMoved;
		get_contour_xld(ContXldSmoothed, &ContXldRow, &ContXldCol);
		gen_region_polygon(&ContRegion, ContXldRow, ContXldCol);
		move_region(ContRegion, &ContRegionMoved, 3, 0);

		HTuple ROIRow1, ROICol1, ROIRow2, ROICol2;
		smallest_rectangle1(m_ROI, &ROIRow1, &ROICol1, &ROIRow2, &ROICol2);
		HTuple ContRectRow1, ContRectCol1, ContRectRow2, ContRectCol2;
		smallest_rectangle1(ContRegionMoved, &ContRectRow1, &ContRectCol1, &ContRectRow2, &ContRectCol2);
		HTuple ColDiffL,ColDiffR,ColDiffMax;
		ColDiffL = (ContRectCol1-ROICol1).Abs();
		ColDiffR = (ROICol2-ContRectCol2).Abs();
		if ((ColDiffL.Num()==0) &&(ColDiffR.Num()==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		tuple_max(ColDiffL.Concat(ColDiffR), &ColDiffMax);

		Hobject ContRegionDilation,DRegIntersection,DRegion,DRegionConnected;
		dilation_rectangle1(ContRegionMoved, &ContRegionDilation, 1, 5);
		clip_region(DRegErosion,&DRegIntersection, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);

		//填补侧面冠部区域区域的凹坑
		m_ColDiffMax=ColDiffMax;
		difference(DRegIntersection, ContRegionDilation, &DRegion);
		connection(DRegion, &DRegionConnected);

		HTuple ContArea, ContRow, ContCol;
		Hobject SelectedRegions1,CrownRegionT;
		area_center(ContRegionMoved,&ContArea, &ContRow, &ContCol);
		select_shape(DRegionConnected, &SelectedRegions1, "row", "and", ContRow, 999999);
		select_shape_std(SelectedRegions1, &CrownRegionT, "max_area", 70);

		m_CrownRegionT=CrownRegionT;
		m_ContRegionDilation=ContRegionDilation;
		//找侧面冠部区域棱边
		HTuple ContRegionRow1, ContRegionColumn1, ContRegionRow2, ContRegionColumn2;
		smallest_rectangle1(ContRegion, &ContRegionRow1, &ContRegionColumn1, &ContRegionRow2, &ContRegionColumn2);
		clip_region(ContRegion, &ContRegion, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);
		Hobject BaseDregMoved,BaseDregDilation1,GrayImageBaseDreg;
		move_region(ContRegion, &BaseDregMoved, MoveSize, 0);
		dilation_rectangle1(BaseDregMoved, &BaseDregDilation1, 1, SearchSize);
		reduce_domain(ImageReduced, BaseDregDilation1, &GrayImageBaseDreg);

		HTuple DefinedRow1, DefinedCol1;
		P_EdgePointsFitCurve(BaseDregDilation1, GrayImageBaseDreg, 10, SearchSize, 1, &DefinedRow1, &DefinedCol1);
		Hobject CotReg1,ContXld1,ContXldSmoothed1;
		gen_region_points(&CotReg1, DefinedRow1, DefinedCol1);
		if (DefinedRow1.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld1, DefinedRow1, DefinedCol1, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld1, &ContXldSmoothed1, 15);
		HTuple ContXldRow1, ContXldCol1;
		Hobject ContSmoothedReg;
		get_contour_xld(ContXldSmoothed1, &ContXldRow1, &ContXldCol1);
		gen_region_points(&ContSmoothedReg, ContXldRow1, ContXldCol1);

		HTuple BaseDregArea, BaseDregRow, BaseDregCol,CotRegArea, CotRegRow, CotRegCol;
		area_center(ContRegion, &BaseDregArea, &BaseDregRow, &BaseDregCol);
		area_center(ContSmoothedReg, &CotRegArea, &CotRegRow, &CotRegCol);
		Hobject ScrapEdgeReg;
		move_region(ContRegion, &ScrapEdgeReg, CotRegRow-BaseDregRow, 0);

		m_ScrapEdgeReg=ScrapEdgeReg;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], BaseDregDilation1, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], CotReg1, &m_vRgn[rId]);
		}
		if (CotRegArea>=0)
		{
			Hobject ScrapEdgeRegDilation;
			retValue = CotRegArea[0].I();
			dilation_circle(ScrapEdgeReg, &ScrapEdgeRegDilation, 2);
			m_vErrorRgn[rId] = ScrapEdgeRegDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pScrapEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6153$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1003;LP;0;100;1;28$\
					 998;LP;1;100;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pScrapEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION)||(m_ABEllipse.Id() == H_EMPTY_REGION)||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject ImageReduced = m_crtImg; 
		//Hobject ImageReduced;
		//reduce_domain(crtImg,rgn,&ImageReduced);
		//
		Hobject ABEllipseDilation,ABEllipseDilationMoved;
		dilation_circle(m_ABEllipse, &ABEllipseDilation, 35);
		HTuple ABEllipseArea,ABEllipseRow,ABEllipseCol;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRow,&ABEllipseCol);
		move_region(ABEllipseDilation, &ABEllipseDilationMoved, -35, 0);

		Hobject RegionDifference1,ConnectedRegions4,SortedRegions1,SelectedRegions;
		difference(m_ROI, ABEllipseDilationMoved, &RegionDifference1);
		connection(RegionDifference1, &ConnectedRegions4);
		HTuple Num4;
		count_obj(ConnectedRegions4,&Num4);
		if (Num4<2)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}

		sort_region(ConnectedRegions4, &SortedRegions1, "first_point", "true", "row");
		select_shape(SortedRegions1, &SelectedRegions, "row", "and", ABEllipseRow, 999999);
		Hobject DRegErosion;
		erosion_circle(SelectedRegions, &DRegErosion, 3.5);

		//*获得用于提取密封面边缘的搜索区域线
		Hobject BaseEllipseXld,BaseEllipseReg;
		HTuple BaseXldRow6, BaseXldCol;
		gen_contour_region_xld(m_ContEllipse, &BaseEllipseXld, "border");

		HTuple ContEllipseArea,ContEllipseRow,ContEllipseCol;
		area_center(m_ContEllipse,&ContEllipseArea,&ContEllipseRow,&ContEllipseCol);
		get_contour_xld(BaseEllipseXld, &BaseXldRow6, &BaseXldCol);
		gen_region_contour_xld(BaseEllipseXld, &BaseEllipseReg, "margin");

		//获取密封面基准椭圆的长轴
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(m_ContEllipse, &BaseRegionLine);

		Hobject BaseRegionLineDilation,BaseDregn,BaseDregConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDilation, 20+5, 2);
		difference(BaseEllipseReg, BaseRegionLineDilation, &BaseDregn);
		connection(BaseDregn, &BaseDregConnected);
		Hobject BaseDregSorted,BaseDregSelected;
		sort_region(BaseDregConnected, &BaseDregSorted, "first_point", "true", "row");
		select_shape(BaseDregSorted, &BaseDregSelected, "row", "and", ContEllipseRow, 999999);
		Hobject ImageDRegReduced,BaseDregDilation;
		reduce_domain(ImageReduced, DRegErosion, &ImageDRegReduced);
		//搜索区域大小
		dilation_rectangle1(BaseDregSelected, &BaseDregDilation, 1, 30);

		HTuple DefinedRow, DefinedCol;
		P_EdgePointsFitCurve(BaseDregDilation, ImageDRegReduced, 10, 30, 1, &DefinedRow, &DefinedCol);
		Hobject CotReg,ContXld,ContXldSmoothed;
		gen_region_points(&CotReg, DefinedRow, DefinedCol);

		if (DefinedRow.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld, &ContXldSmoothed, 15);

		HTuple ContXldRow, ContXldCol;
		Hobject ContRegion,ContRegionMoved;
		get_contour_xld(ContXldSmoothed, &ContXldRow, &ContXldCol);
		gen_region_polygon(&ContRegion, ContXldRow, ContXldCol);
		move_region(ContRegion, &ContRegionMoved, 3, 0);

		HTuple ROIRow1, ROICol1, ROIRow2, ROICol2;
		smallest_rectangle1(m_ROI, &ROIRow1, &ROICol1, &ROIRow2, &ROICol2);
		HTuple ContRectRow1, ContRectCol1, ContRectRow2, ContRectCol2;
		smallest_rectangle1(ContRegionMoved, &ContRectRow1, &ContRectCol1, &ContRectRow2, &ContRectCol2);
		HTuple ColDiffL,ColDiffR,ColDiffMax;
		ColDiffL = (ContRectCol1-ROICol1).Abs();
		ColDiffR = (ROICol2-ContRectCol2).Abs();
		if ((ColDiffL.Num()==0) &&(ColDiffR.Num()==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		tuple_max(ColDiffL.Concat(ColDiffR), &ColDiffMax);

		Hobject ContRegionDilation,DRegIntersection,DRegion,DRegionConnected;
		dilation_rectangle1(ContRegionMoved, &ContRegionDilation, 1, 5);
		clip_region(DRegErosion,&DRegIntersection, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);

		//填补侧面冠部区域区域的凹坑
		m_ColDiffMax=ColDiffMax;
		difference(DRegIntersection, ContRegionDilation, &DRegion);
		connection(DRegion, &DRegionConnected);

		HTuple ContArea, ContRow, ContCol;
		Hobject SelectedRegions1,CrownRegionT;
		area_center(ContRegionMoved,&ContArea, &ContRow, &ContCol);
		select_shape(DRegionConnected, &SelectedRegions1, "row", "and", ContRow, 999999);
		select_shape_std(SelectedRegions1, &CrownRegionT, "max_area", 70);

		m_CrownRegionT=CrownRegionT;
		m_ContRegionDilation=ContRegionDilation;
		//找侧面冠部区域棱边
		HTuple ContRegionRow1, ContRegionColumn1, ContRegionRow2, ContRegionColumn2;
		smallest_rectangle1(ContRegion, &ContRegionRow1, &ContRegionColumn1, &ContRegionRow2, &ContRegionColumn2);
		clip_region(ContRegion, &ContRegion, ROIRow1, ROICol1+ColDiffMax+1, ROIRow2, ROICol2-ColDiffMax-1);
		Hobject BaseDregMoved,BaseDregDilation1,GrayImageBaseDreg;
		move_region(ContRegion, &BaseDregMoved, MoveSize, 0);
		dilation_rectangle1(BaseDregMoved, &BaseDregDilation1, 1, SearchSize);
		reduce_domain(ImageReduced, BaseDregDilation1, &GrayImageBaseDreg);

		HTuple DefinedRow1, DefinedCol1;
		P_EdgePointsFitCurve(BaseDregDilation1, GrayImageBaseDreg, 10, SearchSize, 1, &DefinedRow1, &DefinedCol1);
		Hobject CotReg1,ContXld1,ContXldSmoothed1;
		gen_region_points(&CotReg1, DefinedRow1, DefinedCol1);
		if (DefinedRow1.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld1, DefinedRow1, DefinedCol1, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld1, &ContXldSmoothed1, 15);
		HTuple ContXldRow1, ContXldCol1;
		Hobject ContSmoothedReg;
		get_contour_xld(ContXldSmoothed1, &ContXldRow1, &ContXldCol1);
		gen_region_points(&ContSmoothedReg, ContXldRow1, ContXldCol1);

		HTuple BaseDregArea, BaseDregRow, BaseDregCol,CotRegArea, CotRegRow, CotRegCol;
		area_center(ContRegion, &BaseDregArea, &BaseDregRow, &BaseDregCol);
		area_center(ContSmoothedReg, &CotRegArea, &CotRegRow, &CotRegCol);
		Hobject ScrapEdgeReg;
		move_region(ContRegion, &ScrapEdgeReg, CotRegRow-BaseDregRow, 0);

		m_ScrapEdgeReg=ScrapEdgeReg;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], BaseDregDilation1, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], CotReg1, &m_vRgn[rId]);
		}
		if (CotRegArea>=0)
		{
			Hobject ScrapEdgeRegDilation;
			retValue = CotRegArea[0].I();
			dilation_circle(ScrapEdgeReg, &ScrapEdgeRegDilation, 2);
			m_vErrorRgn[rId] = ScrapEdgeRegDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pScrapEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ScrapEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1006$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1003;LP;0;100;1;28$\
					 998;LP;1;100;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//胶垫切边检测测试
STDMETHODIMP CPlugAlgo::RubberMatScrapEdgeDetectAlgo(VARIANT* rgnId,VARIANT*pThredValue,VARIANT*pGrayValue, VARIANT* pMoveSize1,VARIANT* pMoveSize2,VARIANT* pSearchSize,VARIANT* pScrapEdgeArea)
{
	//胶塞检测  修改完善小胶垫侧面切边提取算子。RubberMatScrapEdge
	//m_ScrapEdgeReg、m_CrownRegionT、m_ContRegionDilation、m_ColDiffMax
	int rId           = (int)rgnId->fltVal;
	int ThredValue    = (int)pThredValue->fltVal;
	int GrayValue    = (int)pGrayValue->fltVal;

	int MoveSize1    = (int)pMoveSize1->fltVal;
	int MoveSize2    = (int)pMoveSize2->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		Hobject EmptyRegion;
		gen_empty_region(&EmptyRegion);
		m_CrownRegionT=EmptyRegion;
		m_ScrapEdgeReg=EmptyRegion;
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//通过定位算子提取
		Hobject Image = m_crtImg; 

		Hobject ConnectedRegions4,SortedRegions1,SelectedRegions;
		Hobject Rectangle,RegionBorder,BaseEllipseReg;
		HTuple BaseXldRow6, BaseXldCol,Row11, Column11, Row2, Column2;
		smallest_rectangle1 (m_ROI, &Row11, &Column11, &Row2, &Column2)   ;  
		if((Row2-Row11<90)||(Column2-Column11<90))
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		//rgn标识圆环，自动提取顶部高亮圆环
		Hobject ImageReduced3,Regions1,RegionFillUp1,ConnectedRegions3,SelectedRegions3,RegionTrans;
		reduce_domain(Image, m_ROI, &ImageReduced3);
		threshold(ImageReduced3, &Regions1, ThredValue, 255);
		fill_up(Regions1, &RegionFillUp1);
		connection(RegionFillUp1, &ConnectedRegions3);
		select_shape_std(ConnectedRegions3, &SelectedRegions3, "max_area", 70);
		shape_trans(SelectedRegions3, &RegionTrans, "ellipse");
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionTrans, &m_vRgn[rId]);
		}
		//
		Hobject ContRegionDilation,CrownRegionT,RegionDifference,RegionDifference1,RegionOpening1,DRegionConnected,Rectangle2,ConnectedRegions,ContRegion;
		dilation_circle(RegionTrans, &ContRegionDilation,1.5);
		difference (m_ROI, ContRegionDilation, &RegionDifference);
		opening_circle (RegionDifference, &RegionOpening1, 7.5);
		gen_rectangle1 (&Rectangle2, Row11, Column11+10, Row2+10, Column2-10);
		intersection (Rectangle2, RegionOpening1, &RegionDifference1);
		connection (RegionDifference1, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &CrownRegionT, "max_area", 70);

		m_CrownRegionT=CrownRegionT;

		//找侧面切边区域棱边
		gen_rectangle1 (&Rectangle, Row2-80, Column11+15, Row2+10, Column2-15);
		boundary (m_ROI, &RegionBorder, "outer");
		intersection (RegionBorder, Rectangle, &ContRegion);

		Hobject BaseDregMoved1,BaseDregDilation1,BaseDregMoved2,BaseDregDilation2,GrayImageBaseDreg1,GrayImageBaseDreg2;
		move_region(ContRegion, &BaseDregMoved1, MoveSize1, 0);
		dilation_rectangle1(BaseDregMoved1, &BaseDregDilation1, 1, SearchSize);
		reduce_domain(Image, BaseDregDilation1, &GrayImageBaseDreg1);
		Hobject ModelImages1,ModelRegions1;
		inspect_shape_model(GrayImageBaseDreg1, &ModelImages1, &ModelRegions1, 1, ((HTuple(GrayValue).Append(GrayValue*2)).Append(40)));
		HTuple EdgesArea1,EdgesRow1,EdgesCol1;
		area_center(ModelRegions1,&EdgesArea1,&EdgesRow1,&EdgesCol1);
		//
		move_region(ContRegion, &BaseDregMoved2, MoveSize2, 0);
		dilation_rectangle1(BaseDregMoved2, &BaseDregDilation2, 1, SearchSize);
		reduce_domain(Image, BaseDregDilation2, &GrayImageBaseDreg2);
		Hobject ModelImages2,ModelRegions2;
		inspect_shape_model(GrayImageBaseDreg2, &ModelImages2, &ModelRegions2, 1, ((HTuple(GrayValue).Append(GrayValue*2)).Append(40)));
		HTuple EdgesArea2,EdgesRow2,EdgesCol2;
		area_center(ModelRegions2,&EdgesArea2,&EdgesRow2,&EdgesCol2);
		//
		HTuple DefinedRow1, DefinedCol1;
		if ((EdgesArea1<40)&(EdgesArea2<40))
		{

			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], BaseDregDilation1, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], BaseDregDilation2, &m_vRgn[rId]);
			}
			Hobject ScrapEdgeRegNo;
			move_region(ContRegion, &ScrapEdgeRegNo, -190, 0);
			m_ScrapEdgeReg=ScrapEdgeRegNo;
			Hobject ScrapEdgeRegDilation;
			dilation_circle(m_ScrapEdgeReg, &ScrapEdgeRegDilation, 2);
			m_vErrorRgn[rId] = ScrapEdgeRegDilation;
			retValue = 999;

			retValue.Detach(pScrapEdgeArea);
			return S_OK;
		} 
		else if (EdgesArea1>EdgesArea2)
		{	
			P_EdgePointsFitCurve(BaseDregDilation1, GrayImageBaseDreg1, 10, SearchSize, 1, &DefinedRow1, &DefinedCol1);
		}
		else
		{
			P_EdgePointsFitCurve(BaseDregDilation2, GrayImageBaseDreg2, 10, SearchSize, 1, &DefinedRow1, &DefinedCol1);
		}
		Hobject CotReg1,ContXld1,ContXldSmoothed1;
		gen_region_points(&CotReg1, DefinedRow1, DefinedCol1);
		if (DefinedRow1.Num()<4)
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			m_CrownRegionT=EmptyRegion;
			m_ScrapEdgeReg=EmptyRegion;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pScrapEdgeArea);
			return S_FALSE;
		}
		gen_contour_nurbs_xld(&ContXld1, DefinedRow1, DefinedCol1, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(ContXld1, &ContXldSmoothed1, 15);
		HTuple ContXldRow1, ContXldCol1;
		Hobject ContSmoothedReg;
		get_contour_xld(ContXldSmoothed1, &ContXldRow1, &ContXldCol1);
		gen_region_points(&ContSmoothedReg, ContXldRow1, ContXldCol1);

		HTuple BaseDregArea, BaseDregRow, BaseDregCol,CotRegArea, CotRegRow, CotRegCol;
		area_center(ContRegion, &BaseDregArea, &BaseDregRow, &BaseDregCol);
		area_center(ContSmoothedReg, &CotRegArea, &CotRegRow, &CotRegCol);
		Hobject ScrapEdgeReg;
		move_region(ContRegion, &ScrapEdgeReg, CotRegRow-BaseDregRow, 0);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], BaseDregDilation1, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], BaseDregDilation2, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], CotReg1, &m_vRgn[rId]);
		}
		//是否不需要返回错误。
		if (CotRegArea>=0)
		{
			m_ScrapEdgeReg=ScrapEdgeReg;
			retValue = CotRegArea[0].I();
		}
		else
		{
			Hobject ScrapEdgeRegNo;
			move_region(ContRegion, &ScrapEdgeRegNo, -190, 0);
			m_ScrapEdgeReg=ScrapEdgeRegNo;
			retValue = 999;
		}
		Hobject ScrapEdgeRegDilation;
		dilation_circle(m_ScrapEdgeReg, &ScrapEdgeRegDilation, 2);
		m_vErrorRgn[rId] = ScrapEdgeRegDilation;

		retValue.Detach(pScrapEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pScrapEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberMatScrapEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1006$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 989;LP;10;250;1;160$\
					 1038;LP;2;50;1;10$\
					 1003;LP;-200;10;-1;-120$\
					 1003;LP;-100;10;-1;-20$\
					 998;LP;1;100;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberMatRegionLocationAlgo(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pDilationSize, VARIANT* pmoveSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     =(int)pSelection->fltVal;

	int DilationSize   = (int)pDilationSize->fltVal;
	int moveSize   = (int)pmoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ScrapEdgeReg.Id()== H_EMPTY_REGION)||(m_CrownRegionT.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//垂直缩放
		Hobject CrownRegion;
		HTuple row1,col1,row2,col2;
		smallest_rectangle1(m_ScrapEdgeReg,&row1,&col1,&row2,&col2);
		clip_region(m_CrownRegionT,&CrownRegion,0,col1,m_imgHeight,col2);
		erosion_rectangle1(CrownRegion,&CrownRegion,1,VErosionSize);

		Hobject ScrapEdgeDilation,CrownRegionDiff;
		dilation_rectangle1(m_ScrapEdgeReg, &ScrapEdgeDilation, 1, DilationSize);
		Hobject ScrapEdgeMoved;
		move_region(ScrapEdgeDilation,&ScrapEdgeMoved,moveSize,0);
		difference(CrownRegion, ScrapEdgeMoved, &CrownRegionDiff);

		Hobject CrownRegionDiffConnection;
		connection(CrownRegionDiff,&CrownRegionDiffConnection);

		HTuple AreaD, RowD, ColumnD;
		Hobject SelectedRegion1,SelectedRegion2;
		select_shape_std(CrownRegionDiffConnection,&SelectedRegion2,"max_area",70);
		//area_center(ScrapEdgeMoved,&AreaD, &RowD, &ColumnD);
		//select_shape(CrownRegionDiffConnection, &SelectedRegion2, "row", "and", RowD, 9999999);
		if (Selection==1)
		{
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(CrownRegion, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionClip ;	

		}
		else if(Selection==2)
		{
			//切边区域
			difference(CrownRegionDiff,SelectedRegion2,&SelectedRegion1);
			union1(SelectedRegion1,&SelectedRegion1);
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(SelectedRegion1, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionClip ;
		}
		else if(Selection==3)
		{
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(SelectedRegion2, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionClip ;	
		}


#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberMatRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1004$\
					 167;B$\
					 1138;LP;1;3;1;1$\
					 1005;LP;1;80;1;10$\
					 1016;LP;-20;20;1;0$\
					 994;LP;1;50;1;1$\
					 995;LP;1;40;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberDotRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pThredValue,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT*pGrayValue,VARIANT* pDilationSize)
{
	//
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	float ThredValue    = (float)pThredValue->fltVal;
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	float GrayValue    = (float)pGrayValue->fltVal;
	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		reduce_domain(Image, rgn, &ImageReduced);

		Hobject ImageAffinTrans,RegionDynThresh,RegionClosing1,RegionOpening4,RegionFillUp1;
		HTuple HomMat2D;
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(16).Rad(), fCenterY, fCenterX, 0, &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "constant", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThredValue, "dark");
		closing_circle(RegionDynThresh, &RegionClosing1, 3.5);
		fill_up_shape(RegionClosing1, &RegionFillUp1, "area", 1, 100);
		opening_circle(RegionFillUp1, &RegionOpening4, 4.5);

		HTuple HomMat2D120,HomMat2D_120;
		Hobject RegionAffineTrans1,RegionAffineTrans,RegionUnion,RegionUnion1,ThreeCirclesRegion;
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(120).Rad(), fCenterY, fCenterX, 0, &HomMat2D120);
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(-120).Rad(), fCenterY, fCenterX, 0, &HomMat2D_120);
		//异常判断，剔除大黑点
		Hobject ConnectedRegions1,CircleRegs,ObjectSelected;
		HTuple Number,Mean, Deviation,Mean1,Deviation1,MeanDiff;
		connection(RegionOpening4, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number);
		gen_empty_region(&CircleRegs);
		if(Number>=1)
		{
			for (int i=1;i<=Number; i++)
			{
				select_obj(ConnectedRegions1, &ObjectSelected, i);
				affine_trans_region(ObjectSelected, &RegionAffineTrans1, HomMat2D_120, "nearest_neighbor");
				intensity(RegionAffineTrans1, ImageReduced, &Mean, &Deviation);
				intensity(ObjectSelected, ImageReduced, &Mean1, &Deviation1);
				MeanDiff = (Mean1-Mean).Abs();
				if (0 != (MeanDiff<GrayValue))
				{
					concat_obj(ObjectSelected, CircleRegs, &CircleRegs);
				}
			}
		}
		union1(CircleRegs, &CircleRegs);
		//
		affine_trans_region(CircleRegs, &RegionAffineTrans1, HomMat2D_120, "nearest_neighbor");
		affine_trans_region(CircleRegs, &RegionAffineTrans, HomMat2D120, "nearest_neighbor");
		union2(RegionAffineTrans1, RegionAffineTrans, &RegionUnion);
		union2(RegionUnion, CircleRegs, &RegionUnion1);
		dilation_circle(RegionUnion1,&ThreeCirclesRegion,DilationSize);

		if (Selection==1)
		{
			m_vRgn[rId]=ThreeCirclesRegion;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,ThreeCirclesRegion,&RegionDiff);
			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberDotRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1119$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 1141;FP;2.0;50.0;0.5;15$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208$\
					 1268;FP;2;100.0;0.5;30$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************
** 函数名 ：RubberDotRegionLocationAlgo1
** 功  能 ：定位胶塞顶部或底部的圆点区域（3圆定位）
** 说  明 ：根据原算子修改
** 时  间 ：2019年12月22日
*****************************************************************************/
STDMETHODIMP CPlugAlgo::RubberDotRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pAngleRota,VARIANT* pThredValue,VARIANT* pCirDiameter,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT*pGrayValue,VARIANT* pDilationSize)
{
	//
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	float AngleRota    = (float)pAngleRota->fltVal;       // 根据小圆直径确定旋转角度 16
	float ThredValue    = (float)pThredValue->fltVal;
	float CirDiameter    = (float)pCirDiameter->fltVal;   // 根据小圆直径确定闭合尺寸 16
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	float GrayValue    = (float)pGrayValue->fltVal;
	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		reduce_domain(Image, rgn, &ImageReduced);

		Hobject ImageAffinTrans,RegionDynThresh,RegionClosing1,RegionOpening4,RegionFillUp1;
		HTuple HomMat2D;
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(AngleRota).Rad(), fCenterY, fCenterX, 0, &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "constant", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThredValue, "dark");
		closing_circle(RegionDynThresh, &RegionClosing1, 3.5);
		fill_up_shape(RegionClosing1, &RegionFillUp1, "area", 1, 100);
		opening_circle(RegionFillUp1, &RegionOpening4, 4.5);

		HTuple HomMat2D120,HomMat2D_120;
		Hobject RegionAffineTrans1,RegionAffineTrans,RegionUnion,RegionUnion1,ThreeCirclesRegion;
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(120).Rad(), fCenterY, fCenterX, 0, &HomMat2D120);
		vector_angle_to_rigid(fCenterY, fCenterX, HTuple(-120).Rad(), fCenterY, fCenterX, 0, &HomMat2D_120);
		//异常判断，剔除大黑点
		Hobject ConnectedRegions1,CircleRegs,ObjectSelected;
		HTuple Number,Mean, Deviation,Mean1,Deviation1,MeanDiff;
		connection(RegionOpening4, &ConnectedRegions1);
		count_obj(ConnectedRegions1, &Number);
		gen_empty_region(&CircleRegs);
		if(Number>=1)
		{
			for (int i=1;i<=Number; i++)
			{
				select_obj(ConnectedRegions1, &ObjectSelected, i);
				affine_trans_region(ObjectSelected, &RegionAffineTrans1, HomMat2D_120, "nearest_neighbor");
				intensity(RegionAffineTrans1, ImageReduced, &Mean, &Deviation);
				intensity(ObjectSelected, ImageReduced, &Mean1, &Deviation1);
				MeanDiff = (Mean1-Mean).Abs();
				if (MeanDiff<GrayValue)
				{
					concat_obj(ObjectSelected, CircleRegs, &CircleRegs);
				}
			}
		}
		// 根据小圆直径确定闭合尺寸
		Hobject CircleRegsCon;
		HTuple iNum,dMeans,dDevs,iIndices,dMeansSort;
		union1(CircleRegs, &CircleRegs);  
		closing_circle(CircleRegs,&CircleRegs,CirDiameter );
		union1(CircleRegs,&CircleRegs );
		connection(CircleRegs,&CircleRegsCon);
		count_obj(CircleRegsCon,&iNum );
		if ( iNum >= 2)
		{
			Hobject objSel;
			intensity(CircleRegsCon, Image,&dMeans,&dDevs);
			tuple_sort(dMeans, &dMeansSort);
			tuple_find(dMeans,dMeansSort[0],&iIndices );
			select_obj(CircleRegsCon,&objSel,iIndices.Select(0) + 1);
			CircleRegs = objSel;
		}

		//
		affine_trans_region(CircleRegs, &RegionAffineTrans1, HomMat2D_120, "nearest_neighbor");
		affine_trans_region(CircleRegs, &RegionAffineTrans, HomMat2D120, "nearest_neighbor");
		union2(RegionAffineTrans1, RegionAffineTrans, &RegionUnion);
		union2(RegionUnion, CircleRegs, &RegionUnion1);
		dilation_circle(RegionUnion1,&ThreeCirclesRegion,DilationSize);

		if (Selection==1)
		{
			m_vRgn[rId]=ThreeCirclesRegion;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,ThreeCirclesRegion,&RegionDiff);
			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::RubberDotRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6242$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 610;FP;0.5;60;0.5;16.5$\
					 630;LP;1;250;1;12$\
					 6241;FP;2.0;50.0;0.5;16.0$\
					 194;FP;1.0;2000.0;0.5;165$\
					 413;FP;1.5;2000;0.5;30$\
					 1268;FP;2;100.0;0.5;30$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/////
STDMETHODIMP CPlugAlgo::CrownRegionLocationAlgo(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pDilationSize, VARIANT* pmoveSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     =(int)pSelection->fltVal;

	int DilationSize   = (int)pDilationSize->fltVal;
	int moveSize   = (int)pmoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ScrapEdgeReg.Id()== H_EMPTY_REGION)||(m_CrownRegionT.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ScrapEdgeDilation,CrownRegionDiff;
		dilation_rectangle1(m_ScrapEdgeReg, &ScrapEdgeDilation, 1, DilationSize);
		Hobject ScrapEdgeMoved;
		move_region(ScrapEdgeDilation,&ScrapEdgeMoved,moveSize,0);
		difference(m_CrownRegionT, ScrapEdgeMoved, &CrownRegionDiff);

		Hobject CrownRegionDiffConnection;
		connection(CrownRegionDiff,&CrownRegionDiffConnection);

		HTuple AreaD, RowD, ColumnD;
		Hobject SelectedRegion1,SelectedRegion2;
		area_center(ScrapEdgeMoved,&AreaD, &RowD, &ColumnD);
		select_shape(CrownRegionDiffConnection, &SelectedRegion2, "row", "and", RowD, 9999999);

		if (Selection==1)
		{
			//整个区域
			Hobject CrownRegion;
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(CrownRegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			erosion_rectangle1(RegionClip,&CrownRegion,1,VErosionSize);
			m_vRgn[rId] = CrownRegion ;	

		}
		else if(Selection==2)
		{
			//切边区域
			difference(CrownRegionDiff,SelectedRegion2,&SelectedRegion1);
			union1(SelectedRegion1,&SelectedRegion1);
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(SelectedRegion1, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			//垂直缩放
			Hobject CrownRegion1;
			erosion_rectangle1(RegionClip,&CrownRegion1,1,VErosionSize);

			m_vRgn[rId] = CrownRegion1 ;
		}
		else if(Selection==3)
		{
			//冠部区域
			Hobject CrownRegion2;
			union1(SelectedRegion2,&SelectedRegion2);

			//水平缩放
			Hobject RegionClip;
			clip_region_rel(SelectedRegion2, &RegionClip, 0, 0, HErosionSize, HErosionSize);

			erosion_rectangle1(RegionClip,&CrownRegion2,1,VErosionSize);
			m_vRgn[rId] = CrownRegion2 ;	

		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1004$\
					 167;B$\
					 1138;LP;1;3;1;1$\
					 1005;LP;1;80;1;10$\
					 1016;LP;-20;20;1;0$\
					 994;LP;1;50;1;1$\
					 995;LP;1;40;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CrownRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pDilationSize, VARIANT* pmoveSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     =(int)pSelection->fltVal;

	int DilationSize   = (int)pDilationSize->fltVal;
	int moveSize   = (int)pmoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_ScrapEdgeReg.Id()== H_EMPTY_REGION)||(m_CrownRegionT.Id()== H_EMPTY_REGION)||(m_ContRegionDilation.Id()==H_EMPTY_REGION)||m_ColDiffMax.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ScrapEdgeDilation,CrownRegionDiff;
		dilation_rectangle1(m_ScrapEdgeReg, &ScrapEdgeDilation, 1, DilationSize);
		Hobject ScrapEdgeMoved;
		move_region(ScrapEdgeDilation,&ScrapEdgeMoved,moveSize,0);
		difference(m_CrownRegionT, ScrapEdgeMoved, &CrownRegionDiff);

		Hobject CrownRegionDiffConnection;
		connection(CrownRegionDiff,&CrownRegionDiffConnection);

		HTuple AreaD, RowD, ColumnD;
		Hobject SelectedRegion1,SelectedRegion2;
		area_center(ScrapEdgeMoved,&AreaD, &RowD, &ColumnD);
		select_shape(CrownRegionDiffConnection, &SelectedRegion2, "row", "and", RowD, 9999999);

		if (Selection==1)
		{
			//整个区域
			Hobject CrownRegion;
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(CrownRegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			erosion_rectangle1(RegionClip,&CrownRegion,1,VErosionSize);
			m_vRgn[rId] = CrownRegion ;	

		}
		else if(Selection==2)
		{
			//切边区域
			difference(CrownRegionDiff,SelectedRegion2,&SelectedRegion1);
			union1(SelectedRegion1,&SelectedRegion1);
			//水平缩放
			Hobject RegionClip;
			clip_region_rel(SelectedRegion1, &RegionClip, 0, 0, HErosionSize, HErosionSize);
			//垂直缩放
			Hobject CrownRegion1;
			erosion_rectangle1(RegionClip,&CrownRegion1,1,VErosionSize);

			m_vRgn[rId] = CrownRegion1 ;
		}
		else if(Selection==3)
		{
			//冠部区域
			Hobject CrownRegion2;
			union1(SelectedRegion2,&SelectedRegion2);
			//剔除玻璃脏污干扰
			HTuple ROIRow1, ROICol1, ROIRow2, ROICol2;
			smallest_rectangle1(m_ROI, &ROIRow1, &ROICol1, &ROIRow2, &ROICol2);

			Hobject RegionDilation7,RegionMoved6;
			dilation_rectangle1(m_ContRegionDilation,&RegionDilation7, 1, 80);
			move_region(RegionDilation7, &RegionMoved6, VErosionSize, 0);

			Hobject RegionIntersection1,RegionUnion2;
			intersection(RegionMoved6, SelectedRegion2, &RegionIntersection1);
			union2(RegionIntersection1, RegionMoved6, &RegionUnion2);
			clip_region(RegionUnion2, &RegionUnion2, ROIRow1, ROICol1+m_ColDiffMax+1, ROIRow2, ROICol2-m_ColDiffMax-1);

			Hobject RegionDifference3,ConnectedRegions7,ObjectSelected2;
			difference(RegionUnion2, ScrapEdgeMoved, &RegionDifference3);
			connection(RegionDifference3, &ConnectedRegions7);
			select_shape(ConnectedRegions7, &ObjectSelected2, "row", "and", RowD, 9999999);
			select_shape_std(ObjectSelected2, &ObjectSelected2, "max_area", 70);

			//水平缩放
			Hobject RegionClip;
			clip_region_rel(ObjectSelected2, &RegionClip, 0, 0, HErosionSize, HErosionSize);

			//erosion_rectangle1(RegionClip,&CrownRegion2,1,VErosionSize);
			m_vRgn[rId] = RegionClip ;	

		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1233$\
					 167;B$\
					 1138;LP;1;3;1;1$\
					 1005;LP;1;80;1;10$\
					 1016;LP;-20;20;1;0$\
					 994;LP;1;50;1;1$\
					 995;LP;1;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pDilationSizeP,VARIANT* pDilationSizeT,VARIANT* pOpeningSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     =(int)pSelection->fltVal;

	int DilationSizeP   = (int)pDilationSizeP->fltVal;
	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	int OpeningSize   = (int)pOpeningSize->fltVal;

	int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_WholeRoi.Id()==H_EMPTY_REGION||m_Platform.Id()==H_EMPTY_REGION||m_TriangleReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//基准椭圆
		//Hobject TopEllipse;
		//move_region(m_ContEllipse, &TopEllipse, -UpEdgeMoveSize, 0);

		if (Selection==1)
		{
			Hobject TotallRoi;

			erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
			m_vRgn[rId] = TotallRoi ;
		} 
		else if(Selection==2)
		{
			Hobject TotallRoi,RegionDiff1,RegionDiff2,Platform,TriangleReg;
			//difference(m_WholeRoi,TopEllipse, &RegionDiff1);
			//erosion_circle(RegionDiff1,&ROIErosion, ErosionSize);

			erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
			dilation_circle(m_Platform,&Platform,DilationSizeP);
			difference(TotallRoi, Platform, &RegionDiff2);

			dilation_circle(m_TriangleReg,&TriangleReg,DilationSizeT);

			difference(RegionDiff2, TriangleReg, &TotallRoi);
			opening_circle(TotallRoi,&TotallRoi,OpeningSize);
			m_vRgn[rId] = TotallRoi ;
		}

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1066;LP;1;2;1;2$\
					 1070;LP;1;35;1;10$\
					 1020;LP;1;35;1;10$\
					 864;FP;1;35;0.5;3$\
					 1063;LP;1;35;1;12");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TriangleRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id()==H_EMPTY_REGION||m_TriangleReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//花纹
		Hobject TriangleReg;
		union1(m_TriangleReg,&TriangleReg);

		//缩放
		Hobject TriangleRegDilation,TriangleRegion;
		dilation_rectangle1(TriangleReg,&TriangleRegDilation,HErosionSize,VErosionSize);
		intersection(m_ROI,TriangleRegDilation,&TriangleRegion);

		opening_circle(TriangleRegion,&TriangleRegion,3.5);
		m_vRgn[rId] = TriangleRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TriangleRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_13D_InWallRegionDetect(Hobject ARegionT, Hobject PlatformReg,Hobject AroiTSelected, Hobject ROI,HTuple BaseRow,HTuple BaseColumn, HTuple RowPos,HTuple ErosionSize,Hobject *InWallRegion)
{
	// Local iconic variables 
	Hobject  RectDomain, ARegionTDiff, AroiTDilation;
	Hobject  ARegionTDilation, AROIMoved, RegionUnion1;
	Hobject  RegionClosing2, RegionOpening, ROIErosion;
	Hobject  ROIDiff, RegionDiff, ConnectedRegions,PlatformRegDilation;
	// Local control variables 
	HTuple  RowPosOut;

	RowPosOut = RowPos;
	if (0 != ((BaseRow-RowPosOut)<=0))
	{
		RowPosOut = 10;
	}
	gen_rectangle1(&RectDomain, BaseRow-RowPosOut, 1, m_imgHeight-1, m_imgWidth-1);

	erosion_circle(PlatformReg, &PlatformRegDilation, 2);
	difference(ARegionT, PlatformRegDilation, &ARegionTDiff);

	dilation_circle(AroiTSelected, &AroiTDilation, ErosionSize);
	dilation_circle(ARegionTDiff, &ARegionTDilation, ErosionSize);

	move_region(ARegionTDilation, &AROIMoved, -5, 0);
	union2(AROIMoved, AroiTDilation, &RegionUnion1);

	closing_circle(RegionUnion1, &RegionClosing2, 5);
	opening_circle(RegionClosing2, &RegionOpening, 5);

	erosion_circle(ROI, &ROIErosion, ErosionSize);
	difference(ROIErosion, RectDomain, &ROIDiff);
	difference(ROIDiff, RegionOpening, &RegionDiff);

	connection(RegionDiff, &ConnectedRegions);
	//select_shape_std(ConnectedRegions, &(*InWallRegion), "max_area", 70);

	//依据叉口区域进行筛选
	HTuple Row1, Column1, Row2, Column2;
	Hobject SelectedRegions2;
	smallest_rectangle1(PlatformReg, &Row1, &Column1, &Row2, &Column2);    

	if ((BaseColumn>=Column1)&&(BaseColumn<=Column2))
	{
		select_shape(ConnectedRegions, &SelectedRegions2, "column", "and", Column1, Column2);
	}
	else if(BaseColumn<Column1)
	{
		select_shape(ConnectedRegions, &SelectedRegions2, "column", "and", BaseColumn, Column2);
	}
	else if(BaseColumn>Column2)
	{
		select_shape(ConnectedRegions, &SelectedRegions2, "column", "and", Column1, BaseColumn);
	}
	select_shape_std(SelectedRegions2,  &(*InWallRegion), "max_area", 70);
	//
	//**ARegionT
	HTuple Row3, Column3, Row4, Column4,RoiRow1, RoiColumn1, RoiRow2, RoiColumn2;
	smallest_rectangle1(ARegionT, &Row3, &Column3, &Row4, &Column4);  
	smallest_rectangle1(ROI, &RoiRow1, &RoiColumn1, &RoiRow2, &RoiColumn2);  
	clip_region((*InWallRegion), &(*InWallRegion), RoiRow1, Column3, RoiRow2, Column4);
	return;
}
STDMETHODIMP CPlugAlgo::D13_InWallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pGrayThred,VARIANT* pPos,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	float GrayThred   = (float)pGrayThred->fltVal;
	int Pos   = (int)pPos->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ABEllipse.Id()==H_EMPTY_REGION||m_ImageReducedAroi.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		HTuple a,b;
		tuple_rad(3, &a);
		tuple_rad(177, &b);
		HTuple d,e,f,g;
		tuple_rad(15, &d);
		tuple_rad(70, &e);
		tuple_rad(120, &f);
		tuple_rad(165,&g);
		HTuple BaseArea, BaseRow, BaseColumn;
		area_center(m_ABEllipse, &BaseArea, &BaseRow, &BaseColumn);

		//根据叉口角度，设置内壁区域的下边缘位置
		HTuple RowPos;
		if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a)&&(m_Angle<d)))
		{
			RowPos = 90;
		}
		else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle>g)&&(m_Angle<b)))
		{
			RowPos = 90;
		}
		else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_Angle>e)&&(m_Angle<f)))   //开口朝外
		{
			RowPos = 60;
		}
		else
		{
			RowPos = 80;
		}
		//
		Hobject Regions,Regions2,RegionFillUp2,AroiTSelected2;
		threshold (m_ImageReducedAroi, &Regions2, GrayThred, 255);
		fill_up(Regions2, &RegionFillUp2);
		connection(RegionFillUp2, &RegionFillUp2);
		select_shape_std(RegionFillUp2, &AroiTSelected2,"max_area", 70);

		if (RowPos+Pos<=0)
		{
			Pos=0;
		}

		Hobject InWallRegion;
		if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>(HTuple(5).Rad()))))
		{
			P_13D_InWallRegionDetect(m_ARegionT, m_PlatformReg,AroiTSelected2, m_ROI,BaseRow,BaseColumn, RowPos+Pos,ErosionSize,&InWallRegion);

		}
		else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<(HTuple(175).Rad()))))
		{
			P_13D_InWallRegionDetect(m_ARegionT, m_PlatformReg,AroiTSelected2, m_ROI,BaseRow,BaseColumn, RowPos+Pos,ErosionSize,&InWallRegion);
		}
		else
		{
			gen_empty_region(&InWallRegion);
		}

		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_InWallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1102$\
					 167;B$\
					 1125;FP;20;250;0.5;70$\
					 1137;LP;-50;50;1;10$\
					 1103;FP;3;35;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_13_InWallRegionDetect2 (Hobject GrayImage, Hobject ROI, Hobject ABEllipseAffineTrans,Hobject TopRegion,Hobject PlatformReg, Hobject PlatformRegV, Halcon::Hobject *InWallRegion, HTuple ThresholdBlack, HTuple ThresholdPlug)
{

	// Local iconic variables 
	Hobject  RegionClosing1, RegionDifference6;
	Hobject  RegionOpening6, SelectedRegions7, RegionClipped1;
	Hobject  ImageReduced2, ImageScaleMax, Region1;
	Hobject  RegionClosing5, RegionOpening5, ConnectedRegions10;
	Hobject  SelectedRegions6, RegionDilation6, RegionOpening2;
	Hobject  ConnectedRegions7, SelectedRegions3, RegionDifference5;
	Hobject  ConnectedRegions2, SelectedRegions8, RegionUnion5;
	Hobject  Partitioned, ConnectedRegions11, RegionIntersection2;
	Hobject  RegionOpening, RegionDilation2, RegionDifference3;
	Hobject  RegionDilation3, RegionDifference4, ABEdgeMovedCenter;
	Hobject  RegionDilation5, ImageReducedAroi, ImageScaleMax1;
	Hobject  TopRegionT, ConnectedRegions8, RegionFillUp1;
	Hobject  SelectedRegions5, RegionUnion4, RegionDiffTop;
	Hobject  Rectangle, RegionDilation4, MidRegOfTop;
	Hobject  RegionClosing4, RegionDifference8, RegionOpening4;
	Hobject  ConnectedRegions9, RegionDifference7, InWallRegionNew;
	Hobject  RegionIntersection3, ConnectedRegions;


	// Local control variables 
	HTuple  Area9, Row8, Column7, Row12;
	HTuple  Column12, Row22, Column23, Area4, Row6;
	HTuple  Column5, Row14, Column14, Row24, Column25;
	HTuple  Area8, Row7, Column6, Area3, Row3;
	HTuple  Column4, Row11, Column11, Row21, Column22;

	gen_empty_region(&(*InWallRegion));
	closing_rectangle1(ROI, &RegionClosing1, 81, 3);
	difference(RegionClosing1, ROI, &RegionDifference6);
	opening_rectangle1(RegionDifference6, &RegionOpening6, 2, 5);
	gen_empty_region(&SelectedRegions7);
	area_center(RegionOpening6, &Area9, &Row8, &Column7);
	if (0 != (Area9>0))
	{
		smallest_rectangle1(RegionClosing1, &Row12, &Column12, &Row22, &Column23);
		clip_region(RegionClosing1, &RegionClipped1, Row12, Column12, Row12+140, 
			Column23);
		reduce_domain(GrayImage, RegionClipped1, &ImageReduced2);
		scale_image_max(ImageReduced2, &ImageScaleMax);
		threshold(ImageScaleMax, &Region1, 0, ThresholdBlack);
		closing_circle(Region1, &RegionClosing5, 1.5);
		opening_rectangle1(RegionClosing5, &RegionOpening5, 1, 5);
		connection(RegionOpening5, &ConnectedRegions10);
		select_shape(ConnectedRegions10, &SelectedRegions6, (HTuple("width").Append("height")), 
			"and", (HTuple(30).Append(45)), (HTuple(2000).Append(2000)));
		select_shape_std(SelectedRegions6, &SelectedRegions7, "max_area", 70);
		area_center(SelectedRegions7, &Area4, &Row6, &Column5);
	}
	else
	{
		Area4 = 0;
	}
	gen_empty_region(&RegionDilation6);
	if (0 != (Area4>0))
	{
		smallest_rectangle1(SelectedRegions7, &Row14, &Column14, &Row24, 
			&Column25);
		opening_rectangle1(SelectedRegions7, &RegionOpening2, 8, 1);
		connection(RegionOpening2, &ConnectedRegions7);
		select_shape_std(ConnectedRegions7, &SelectedRegions3, "max_area", 70);
		difference(SelectedRegions7, SelectedRegions3, &RegionDifference5);
		connection(RegionDifference5, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &SelectedRegions8, "height", "and", 5, 
			99999);
		select_shape_std(SelectedRegions8, &SelectedRegions8, "max_area", 70);
		union1(SelectedRegions8, &RegionUnion5);
		dilation_circle(RegionUnion5, &RegionDilation6, 1.5);
		area_center(RegionDilation6, &Area8, &Row7, &Column6);
		if (0 != (Area8<2))
		{
			smallest_rectangle1(SelectedRegions7, &Row14, &Column14, &Row24, 
				&Column25);
			partition_rectangle(SelectedRegions6, &Partitioned, 1, 500);
			connection(Partitioned, &ConnectedRegions11);
			select_shape(ConnectedRegions11, &SelectedRegions8, "height", "and", 
				(Row24-Row14)-7, 99999);
			union1(SelectedRegions8, &RegionUnion5);
			//dilation_circle(RegionUnion5, &RegionDilation6, 1.5);
			Hobject RegionDilation,RegionIntersection;
			dilation_rectangle1 (RegionUnion5, &RegionDilation, 15, 3);     
			intersection (SelectedRegions7, RegionDilation, &RegionIntersection);
			dilation_circle (RegionIntersection, &RegionDilation6, 1.5);   
		}
		opening_rectangle1(RegionDilation6, &RegionDilation6, 1, 9);
	}
	intersection(ROI, PlatformRegV, &RegionIntersection2);
	difference(RegionIntersection2, RegionDilation6, &RegionIntersection2);
	opening_rectangle1(RegionIntersection2, &RegionOpening, 11, 3);
	dilation_circle(TopRegion, &RegionDilation2, 5.5);
	difference(RegionOpening, RegionDilation2, &RegionDifference3);
	dilation_circle(PlatformReg, &RegionDilation3, 3.5);
	difference(RegionDifference3, RegionDilation3, &RegionDifference4);
	//*
	move_region(ABEllipseAffineTrans, &ABEdgeMovedCenter, -150, 0);
	dilation_circle(ABEdgeMovedCenter, &RegionDilation5, 15);
	reduce_domain(GrayImage, RegionDilation5, &ImageReducedAroi);
	scale_image_max(ImageReducedAroi, &ImageScaleMax1);
	threshold(ImageScaleMax1, &TopRegionT, ThresholdPlug, 255);
	connection(TopRegionT, &ConnectedRegions8);
	fill_up(ConnectedRegions8, &RegionFillUp1);
	select_shape(RegionFillUp1, &SelectedRegions5, (HTuple("width").Append("height")), 
		"and", (HTuple(60).Append(10)), (HTuple(300000).Append(30000)));
	union1(SelectedRegions5, &RegionUnion4);
	dilation_circle(RegionUnion4, &RegionDiffTop, 3.5);
	//***
	area_center(RegionDilation6, &Area3, &Row3, &Column4);
	//**
	if (0 != (Area3>30))
	{
		smallest_rectangle1(RegionDilation6, &Row11, &Column11, &Row21, &Column22);
		if (0 != ((Column22-Column11)<9))
		{
			gen_rectangle1(&Rectangle, Row11, Column11, Row21+150, Column22);
			dilation_rectangle1(Rectangle, &RegionDilation4, 9, 3);
		}
		else
		{
			gen_rectangle1(&Rectangle, Row21, Column11, Row21+15, Column22);
			dilation_rectangle1(Rectangle, &RegionDilation4, 9, 3);
		}
		gen_empty_region(&MidRegOfTop);
	}
	else
	{
		gen_empty_region(&RegionDilation4);
		closing_circle(RegionDiffTop, &RegionClosing4, 21);
		difference(RegionClosing4, RegionDiffTop, &RegionDifference8);
		opening_circle(RegionDifference8, &RegionOpening4, 1.5);
		connection(RegionOpening4, &ConnectedRegions9);
		select_shape_std(ConnectedRegions9, &MidRegOfTop, "max_area", 70);
	}
	//*
	union2(RegionDifference4, MidRegOfTop, &RegionDifference4);
	difference(RegionDifference4, RegionDilation4, &RegionDifference7);
	difference(RegionDifference7, RegionDiffTop, &InWallRegionNew);
	intersection(InWallRegionNew, ROI, &RegionIntersection3);
	opening_circle(RegionIntersection3, &(*InWallRegion), 1.5);
	connection((*InWallRegion), &ConnectedRegions);
	select_shape_std(ConnectedRegions, &(*InWallRegion), "max_area", 70);
	return;
}
STDMETHODIMP CPlugAlgo::D13_InWallRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pGrayThred,VARIANT* pBlackThred,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int GrayThred   = (int)pGrayThred->fltVal;
	int BlackThred   = (int)pBlackThred->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEllipse.Id()==H_EMPTY_REGION||m_AroiTClosing.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	//显示测试
	//my_disp_obj(m_crtImg);
	//my_disp_obj(m_ROI);
	//my_disp_obj(m_ABEllipse);
	//my_disp_obj(m_AroiTClosing);
	//my_disp_obj(m_Platform);
	//my_disp_obj(m_PlatformReg);
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject InWallRegion;
		P_13_InWallRegionDetect2 (crtImg,m_ROI, m_ABEllipse,m_AroiTClosing,m_Platform,m_PlatformReg, &InWallRegion,BlackThred, GrayThred);
		//叉口平台区域 有点小，重新处理一下
		Hobject PlatformDelation;
		dilation_circle(m_Platform,&PlatformDelation,3.5);
		difference(InWallRegion,PlatformDelation,&InWallRegion);
		closing_circle(InWallRegion,&InWallRegion,9);
		erosion_circle(InWallRegion, &InWallRegion,abs(ErosionSize)+0.5);  
		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_InWallRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1102$\
					 167;B$\
					 1125;LP;20;250;1;70$\
					 648;LP;1;255;1;20$\
					 1103;FP;0.0;35;0.5;1.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::NeckRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pUpEdgeMoveSize,VARIANT* pLowerEdgeMoveSize,VARIANT* pHErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;
	int LowerEdgeMoveSize   = (int)pLowerEdgeMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdge.Id()== H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject NeckEdge,NeckRegDilation,RegionMoved,RegionIntersection;
		move_region(m_ABEdge, &NeckEdge, -UpEdgeMoveSize, 0);
		dilation_rectangle1(NeckEdge, &NeckRegDilation, 1, 30);

		Hobject PlatformReg;
		union1(m_PlatformReg,&PlatformReg);
		move_region(PlatformReg,&RegionMoved, LowerEdgeMoveSize, 0);
		intersection(NeckRegDilation, RegionMoved, &RegionIntersection);
		//水平缩放
		Hobject RegionClip;
		clip_region_rel(RegionIntersection, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		m_vRgn[rId] = RegionClip;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1128$\
					 167;B$\
					 1126;LP;10;150;1;50$\
					 1127;LP;5;35;1;10$\
					 994;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//D13_顶部（13单叉、双叉）
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshUpValue,VARIANT* pBlackThresh,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	float BlackThresh = (float)pBlackThresh->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageEmphasize;
		Hobject Image=m_ImageScaleMax;

		//scale_image_max(Image, &ImageEmphasize);
		reduce_domain(Image, rgn, &ImageEmphasize);

		Hobject Region,RegionFillUp,RegionClosing,RegionOpening;
		threshold(ImageEmphasize, &Region, 0, ThreshUpValue);
		fill_up(Region, &RegionFillUp);
		//根据内孔半径调整
		closing_circle(RegionFillUp, &RegionClosing, 10);
		opening_circle(RegionClosing, &RegionOpening, Radius-5);

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionOpening, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		Hobject Circle1,Circle2;
		HTuple Row, Column, OutRadius;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius+13);
		gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, InnerCircleRadius+23);
		smallest_circle(Circle2, &Row, &Column, &OutRadius);
		Hobject RegionDiff,ImageReduced1;
		difference(Circle2, Circle1, &RegionDiff);
		reduce_domain(ImageEmphasize, RegionDiff, &ImageReduced1);
		HTuple HomMat2D;
		Hobject ImageAffinTrans,ImageReduced2;
		vector_angle_to_rigid(InnerCircleRow, InnerCircleCol, 0, InnerCircleRow, InnerCircleCol, HTuple(180).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced1, &ImageAffinTrans, HomMat2D, "constant", "false");
		reduce_domain(ImageAffinTrans, RegionDiff, &ImageReduced2);

		Hobject RegionDynThresh,RegionFillUp1;
		dyn_threshold(ImageReduced1, ImageReduced2, &RegionDynThresh, BlackThresh, "dark");
		fill_up(RegionDynThresh, &RegionFillUp1);

		Hobject ConnectedRegions,SelectedRegions,GapRegion;
		connection(RegionFillUp1, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		closing_circle(SelectedRegions, &GapRegion, 10);
		HTuple GapArea, GapRow, GapCol;
		area_center(GapRegion, &GapArea, &GapRow, &GapCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], GapRegion, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple RegionOpeningArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionOpening, &RegionOpeningArea, &RegionOpeningRow, &RegionOpeningCol);

		if (RegionOpeningArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;
		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,InnerCircleRow, InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);
		if (0 != (Angle<0))
		{
			Angle = Angle +PI*2;
		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//是否不需要返回错误。
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapArea[0].I();
			Hobject RegionUnion;
			union2(GapLine,GapRegion,&RegionUnion);
			m_vErrorRgn[rId] = RegionUnion;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1010$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;100;0.5;50$\
					 1011;FP;1;250;0.5;50$\
					 1012;FP;1;250;0.5;35");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo1(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshUpValue,VARIANT* pBlackThresh,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	float BlackThresh = (float)pBlackThresh->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageEmphasize;
		Hobject Image=m_crtImg;

		reduce_domain(Image, rgn, &ImageReduced);
		scale_image_max(ImageReduced, &ImageEmphasize);

		Hobject Region,RegionFillUp,RegionClosing,RegionOpening;
		threshold(ImageEmphasize, &Region, 0, ThreshUpValue);
		fill_up(Region, &RegionFillUp);
		//根据内孔半径调整
		closing_circle(RegionFillUp, &RegionClosing, 10);
		opening_circle(RegionClosing, &RegionOpening, Radius-5);

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionOpening, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		m_InnerCircleT=RegionOpening;
		Hobject Circle1,Circle2;
		HTuple Row, Column, OutRadius;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius+13);
		gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, InnerCircleRadius+23);
		smallest_circle(Circle2, &Row, &Column, &OutRadius);
		Hobject RegionDiff,ImageReduced1;
		difference(Circle2, Circle1, &RegionDiff);
		reduce_domain(ImageEmphasize, RegionDiff, &ImageReduced1);
		HTuple HomMat2D;
		Hobject ImageAffinTrans,ImageReduced2;
		vector_angle_to_rigid(InnerCircleRow, InnerCircleCol, 0, InnerCircleRow, InnerCircleCol, HTuple(180).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced1, &ImageAffinTrans, HomMat2D, "constant", "false");
		reduce_domain(ImageAffinTrans, RegionDiff, &ImageReduced2);

		Hobject RegionDynThresh,RegionFillUp1;
		dyn_threshold(ImageReduced1, ImageReduced2, &RegionDynThresh, BlackThresh, "dark");
		fill_up(RegionDynThresh, &RegionFillUp1);

		Hobject ConnectedRegions,SelectedRegions,GapRegion;
		connection(RegionFillUp1, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		closing_circle(SelectedRegions, &GapRegion, 10);
		HTuple GapArea, GapRow, GapCol;
		area_center(GapRegion, &GapArea, &GapRow, &GapCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], GapRegion, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple RegionOpeningArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionOpening, &RegionOpeningArea, &RegionOpeningRow, &RegionOpeningCol);

		if (RegionOpeningArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			//用于检测偏心
			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;

		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,InnerCircleRow, InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//是否不需要返回错误。
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapArea[0].I();
			Hobject RegionUnion;
			union2(GapLine,GapRegion,&RegionUnion);
			m_vErrorRgn[rId] = RegionUnion;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1153$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;100;0.5;50$\
					 1011;FP;1;250;0.5;50$\
					 1012;FP;1;250;0.5;35");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//不做增强处理、可缩小中心定位计算区域//添加平均灰度值叉口区域判断
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo11(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshUpValue,VARIANT* pBlackThresh,VARIANT* pThreshLow,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	float BlackThresh = (float)pBlackThresh->fltVal;
	int   ThreshLow=(int)pThreshLow->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageEmphasize;
		Hobject Image=m_ImageScaleMax;

		reduce_domain(Image, rgn, &ImageReduced);
		//scale_image_max(ImageReduced, &ImageEmphasize);

		Hobject Region,RegionFillUp,RegionClosing,RegionOpening;
		threshold(ImageReduced, &Region, 0, ThreshUpValue);
		fill_up(Region, &RegionFillUp);
		//根据内孔半径调整
		closing_circle(RegionFillUp, &RegionClosing, 10);
		opening_circle(RegionClosing, &RegionOpening, Radius-5);

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionOpening, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);
		if (InnerCircleRadius<10)
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		m_InnerCircleT=RegionOpening;
		Hobject Circle1,Circle2;
		HTuple Row, Column, OutRadius;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius+7);
		gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, InnerCircleRadius+17);
		smallest_circle(Circle2, &Row, &Column, &OutRadius);
		Hobject RegionDiff,ImageReduced1;
		difference(Circle2, Circle1, &RegionDiff);
		reduce_domain(Image, RegionDiff, &ImageReduced1);
		HTuple HomMat2D;
		Hobject ImageAffinTrans,ImageReduced2;
		vector_angle_to_rigid(InnerCircleRow, InnerCircleCol, 0, InnerCircleRow, InnerCircleCol, HTuple(180).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced1, &ImageAffinTrans, HomMat2D, "constant", "false");
		//reduce_domain(ImageAffinTrans, RegionDiff, &ImageReduced2);

		Hobject RegionDynThresh,RegionFillUp1;
		dyn_threshold(ImageReduced1, ImageAffinTrans, &RegionDynThresh, BlackThresh, "dark");
		//**
		Hobject GapRegion1,PolarTransImage;
		HTuple RegionalIn,RegionalOut;
		RegionalIn=InnerCircleRadius+7;
		RegionalOut=InnerCircleRadius+17;
		int angleCirle=360;
		polar_trans_image_ext(Image, &PolarTransImage, InnerCircleRow, InnerCircleCol, 0,HTuple(angleCirle).Rad(), HTuple(RegionalOut) , HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), "nearest_neighbor");
		HTuple PolarTransImageWidth,PolarTransImageHeight,Mean, Deviation;
		get_image_size(PolarTransImage, &PolarTransImageWidth, &PolarTransImageHeight);
		Hobject JuanYuanPartitioned;
		partition_rectangle(PolarTransImage, &JuanYuanPartitioned, 2, PolarTransImageHeight+10);
		intensity(JuanYuanPartitioned, PolarTransImage, &Mean, &Deviation);
		HTuple MeanLength;
		tuple_length(Mean, &MeanLength);
		//
		HTuple MeanSorted, LocationId2, Length1, ResultID2, ResultID3, Sorted, Uniq;
		tuple_sort(Mean, &MeanSorted);
		tuple_sort_index(Mean, &LocationId2);
		tuple_length(Mean, &Length1);
		ResultID2 = HTuple();
		for (int i=0; i<=Length1-1; i+=1)
		{
			if (0 != (HTuple(MeanSorted[i]) < ThreshLow))
			{
				ResultID2[i] = HTuple(LocationId2[i]);
			}
			else
			{
				break;
			}
		}
		ResultID2 += 1;
		tuple_uniq(ResultID2, &Uniq);
		Hobject BackTransRegion, ResultDefect,DefectRegs;
		select_obj(JuanYuanPartitioned, &ResultDefect, Uniq);
		polar_trans_region_inv(ResultDefect, &BackTransRegion,  InnerCircleRow, InnerCircleCol, 0, HTuple(angleCirle).Rad(), HTuple(RegionalOut), HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1 (BackTransRegion, &DefectRegs);
		intersection(DefectRegs,RegionDiff,&DefectRegs);

		//
		//**
		union2(DefectRegs,RegionDynThresh,&RegionDynThresh);

		fill_up(RegionDynThresh, &RegionFillUp1);

		Hobject ConnectedRegions,SelectedRegions,GapRegion;
		//
		Hobject GapOpening;
		opening_circle(RegionFillUp1, &GapOpening,1.5);
		connection(GapOpening, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		closing_circle(SelectedRegions, &GapRegion, 10);
		HTuple GapArea, GapRow, GapCol;
		area_center(GapRegion, &GapArea, &GapRow, &GapCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], GapRegion, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple RegionOpeningArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionOpening, &RegionOpeningArea, &RegionOpeningRow, &RegionOpeningCol);

		if (RegionOpeningArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			//用于检测偏心
			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;

		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,InnerCircleRow, InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//是否不需要返回错误。
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapArea[0].I();
			Hobject RegionUnion;
			union2(GapLine,GapRegion,&RegionUnion);
			m_vErrorRgn[rId] = RegionUnion;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo11Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1153$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;100;0.5;50$\
					 1011;FP;1;250;0.5;50$\
					 1012;FP;1;250;0.5;35$\
					 992;LP;1;250;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo2(VARIANT* rgnId,VARIANT* pRadius,VARIANT* pBlackThresh, VARIANT* pThreshUpValue,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	float BlackThresh = (float)pBlackThresh->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageEmphasize;
		Hobject Image=m_crtImg;

		reduce_domain(Image, rgn, &ImageReduced);
		scale_image_max(ImageReduced, &ImageEmphasize);

		Hobject Region,RegionFillUp,RegionClosing,RegionOpening;
		threshold(ImageEmphasize, &Region, 0, BlackThresh);
		fill_up(Region, &RegionFillUp);
		//根据内孔半径调整
		closing_circle(RegionFillUp, &RegionClosing, 3);
		opening_circle(RegionClosing, &RegionOpening,5.5);

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionOpening, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		m_InnerCircleT=RegionOpening;
		//Hobject Circle1,Circle2;
		//HTuple Row, Column, OutRadius;
		//gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, Radius);
		//gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, Radius+15);
		//smallest_circle(Circle2, &Row, &Column, &OutRadius);
		//Hobject RegionDiff,ImageReduced1;
		//difference(Circle2, Circle1, &RegionDiff);
		//reduce_domain(ImageEmphasize, RegionDiff, &ImageReduced1);
		Hobject RegionDynThresh,RegionFillUp1;
		threshold(ImageEmphasize, &RegionDynThresh, ThreshUpValue, 255);
		fill_up(RegionDynThresh, &RegionFillUp1);

		Hobject ConnectedRegions,SelectedRegions,GapRegion,RegionOpening11;
		opening_circle(RegionFillUp1, &RegionOpening11,3.5);
		connection(RegionOpening11, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		closing_circle(SelectedRegions, &GapRegion, 10);
		HTuple GapArea, GapRow, GapCol;
		area_center(GapRegion, &GapArea, &GapRow, &GapCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], GapRegion, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple RegionOpeningArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionOpening, &RegionOpeningArea, &RegionOpeningRow, &RegionOpeningCol);

		if (RegionOpeningArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			//用于检测偏心
			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;

		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,InnerCircleRow, InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//是否不需要返回错误。
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapArea[0].I();
			Hobject RegionUnion;
			union2(GapLine,GapRegion,&RegionUnion);
			m_vErrorRgn[rId] = RegionUnion;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopAngleDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1153$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;100;0.5;50$\
					 1012;FP;1;250;0.5;50$\
					 1011;FP;1;250;0.5;35");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopCenterDetectAlgo(VARIANT* rgnId,VARIANT* pBlackThresh,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float BlackThresh = (float)pBlackThresh->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_crtImg;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		scale_image_max(Image, &ImageScaleMax);
		reduce_domain(ImageScaleMax, rgn, &ImageReduced);

		scale_image_max(ImageReduced, &ImageScaleMax);

		Hobject Regions1,RegionFillUp;
		threshold(ImageScaleMax, &Regions1, 0, BlackThresh);
		fill_up(Regions1, &RegionFillUp);
		Hobject RegionClosing, RegionOpening;
		closing_circle(RegionFillUp, &RegionClosing, 3);
		opening_circle(RegionClosing, &RegionOpening, 5.5);

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionOpening, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);
		if(m_bDebugImg)
		{
			Hobject Circle1;
			gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius);
			concat_obj(m_vRgn[rId], Circle1, &m_vRgn[rId]);
		}
		if (InnerCircleRadius>0)
		{
			//m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			//m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;
			retValue = InnerCircleRadius[0].I()*InnerCircleRadius[0].I()*3.14;
			m_vErrorRgn[rId] = RegionOpening;
		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopCenterDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1171$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1012;FP;1;250;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	if (InnerEdge>OutEdge)
	{
		InnerEdge=OutEdge-(float)0.5;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()==0 || m_InnerCircleCol.Num()==0 || m_modelAngle.Num()==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced;
		Hobject Image=m_ImageScaleMax;
		Hobject PolarTransImage;
		//scale_image_max(Image, &ImageScaleMax);

		if (m_InnerCircleRow.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		if (Selection==1)  //顶部高亮区域
		{
			polar_trans_image_ext(Image, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, Radius, (Radius*2)*3.14, Radius, "bilinear");

			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 105);
			m_TopRegsClosing=TopRegsClosing;

			polar_trans_region_inv(TopRegsClosing, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegs,ErosionSize);

			m_TopRadius=Radius;
			m_TopRegs=TopRegs;
			m_vRgn[rId] = TopRegs ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 25, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge, 1);
			polar_trans_region_inv(TopRegsDilation, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
			//gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);

			shape_trans(m_TopRegs, &Circle5, "outer_circle");
			dilation_circle(Circle5,&Circle5, InnerEdge);
			gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			difference(Circle6, Circle5, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;	
		}
		else if(Selection==3)  //顶部叉口区域
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 10, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+15, 10);

			Hobject RegionMoved1,TopRegsDilation1;
			move_region(m_TopRegsClosing, &RegionMoved1, 5, 0);
			dilation_rectangle1(RegionMoved1, &TopRegsDilation1, ForkEdge+10, 10);

			Hobject TopRegsDilation2;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation2, ForkEdge+5, 10);

			Hobject RegionMoved2,TopRegsDilation3;
			move_region(m_TopRegsClosing, &RegionMoved2, -3, 0);
			dilation_rectangle1(RegionMoved2, &TopRegsDilation3, ForkEdge, 10);

			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation1, TopRegsDilation, &RegionUnion);
			union2(RegionUnion, TopRegsDilation2, &RegionUnion);
			union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);

			//用于生成顶部缺胶检测区域
			m_RubberReg0=RegionUnion;

			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionDilation, &XYTransLowRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			//gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);

			dilation_circle(m_InnerCircleT,&Circle7, InnerEdge);
			gen_circle(&Circle8,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, XYTransLowRegs, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1074;LP;1;3;1;1$\
					 1075;LP;45;150;1;90$\
					 1076;FP;1;250;0.5;145$\
					 1077;LP;1;18000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1078;LP;1;90;1;1$\
					 1079;FP;1;50;0.5;10$\
					 1080;FP;1;200;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//区域面积判断改为 边缘长度判断，添加区域被黑线隔断处理。
STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	//AreaLimitLower 用区域极坐标变为长条形 时的最小宽度代替
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	if (InnerEdge>OutEdge)
	{
		InnerEdge=OutEdge-(float)0.5;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()==0 || m_InnerCircleCol.Num()==0 || m_modelAngle.Num()==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced;
		Hobject Image=m_ImageScaleMax;
		Hobject PolarTransImage;
		//scale_image_max(Image, &ImageScaleMax);

		if (m_InnerCircleRow.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		if (Selection==1)  //顶部高亮区域
		{
			polar_trans_image_ext(Image, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, Radius, (Radius*2)*3.14, Radius, "bilinear");

			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			//
			closing_rectangle1(RegionFillUp2,&RegionFillUp2,5,1);//避免叉口区域和顶部高亮区域被连接到一起（减横向连接参数？？ok??）
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "width", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 105);
			m_TopRegsClosing=TopRegsClosing;

			polar_trans_region_inv(TopRegsClosing, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			//
			opening_circle(TopRegs, &TopRegs, 9);
			erosion_circle(TopRegs,&TopRegs,ErosionSize);

			m_TopRadius=Radius;
			m_TopRegs=TopRegs;
			m_vRgn[rId] = TopRegs ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 25, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge, 1);
			polar_trans_region_inv(TopRegsDilation, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
			//gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);

			shape_trans(m_TopRegs, &Circle5, "outer_circle");
			dilation_circle(Circle5,&Circle5, InnerEdge);
			HTuple Area1,Row1,Col1;
			area_center(Circle5,&Area1,&Row1,&Col1);
			if (Area1>10)
			{
				gen_circle(&Circle6,Row1,Col1, OutEdge);
			}
			else
			{
				gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			}
			//gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			difference(Circle6, Circle5, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;	
		}
		else if(Selection==3)  //顶部叉口区域
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 10, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+15, 10);

			Hobject RegionMoved1,TopRegsDilation1;
			move_region(m_TopRegsClosing, &RegionMoved1, 5, 0);
			dilation_rectangle1(RegionMoved1, &TopRegsDilation1, ForkEdge+10, 10);

			Hobject TopRegsDilation2;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation2, ForkEdge+5, 10);

			Hobject RegionMoved2,TopRegsDilation3;
			move_region(m_TopRegsClosing, &RegionMoved2, -3, 0);
			dilation_rectangle1(RegionMoved2, &TopRegsDilation3, ForkEdge, 10);

			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation1, TopRegsDilation, &RegionUnion);
			union2(RegionUnion, TopRegsDilation2, &RegionUnion);
			union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);

			//用于生成顶部缺胶检测区域
			m_RubberReg0=RegionUnion;

			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionDilation, &XYTransLowRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			//gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);

			dilation_circle(m_InnerCircleT,&Circle7, InnerEdge);
			gen_circle(&Circle8,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, XYTransLowRegs, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1074;LP;1;3;1;1$\
					 1075;LP;45;150;1;90$\
					 1076;FP;1;250;0.5;145$\
					 581;LP;1;1800;1;800$\
					 1082;FP;1;20;0.5;3.5$\
					 1078;LP;1;90;1;1$\
					 1079;FP;1;50;0.5;10$\
					 1080;FP;1;200;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	if (InnerEdge>OutEdge)
	{
		InnerEdge=OutEdge-(float)0.5;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()==0 || m_InnerCircleCol.Num()==0 || m_modelAngle.Num()==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_crtImg;
		Hobject PolarTransImage;
		scale_image_max(Image, &ImageScaleMax);

		if (m_InnerCircleRow.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		double angleDiff=90.0;
		if (Selection==1)  //顶部高亮区域
		{
			polar_trans_image_ext(ImageScaleMax, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(angleDiff).Rad()), (6.28319+m_modelAngle)+(HTuple(angleDiff).Rad()), 0, Radius, (Radius*2)*3.14, Radius, "bilinear");

			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 105);
			m_TopRegsClosing=TopRegsClosing;

			polar_trans_region_inv(TopRegsClosing, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(angleDiff).Rad()), (6.28319+m_modelAngle)+(HTuple(angleDiff).Rad()), 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegs,ErosionSize);
			m_TopRadius=Radius;
			m_TopRegs=TopRegs;
			m_vRgn[rId] = TopRegs ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 16, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge, 1);
			polar_trans_region_inv(TopRegsDilation, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(angleDiff).Rad()), (6.28319+m_modelAngle)+(HTuple(angleDiff).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
			//gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);

			shape_trans(m_TopRegs, &Circle5, "outer_circle");
			dilation_circle(Circle5,&Circle5, InnerEdge);

			HTuple Area1,Row1,Col1;
			area_center(Circle5,&Area1,&Row1,&Col1);
			if (Area1>10)
			{
				gen_circle(&Circle6,Row1,Col1, OutEdge);
			}
			else
			{
				gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			}
			difference(Circle6, Circle5, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;	
		}
		else if(Selection==3)  //顶部叉口区域
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 10, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+15, 10);

			Hobject RegionMoved1,TopRegsDilation1;
			move_region(m_TopRegsClosing, &RegionMoved1, 5, 0);
			dilation_rectangle1(RegionMoved1, &TopRegsDilation1, ForkEdge+10, 10);

			Hobject TopRegsDilation2;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation2, ForkEdge+5, 10);

			Hobject RegionMoved2,TopRegsDilation3;
			move_region(m_TopRegsClosing, &RegionMoved2, -3, 0);
			dilation_rectangle1(RegionMoved2, &TopRegsDilation3, ForkEdge, 10);

			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation1, TopRegsDilation, &RegionUnion);
			union2(RegionUnion, TopRegsDilation2, &RegionUnion);
			union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);

			//用于生成顶部缺胶检测区域
			m_RubberReg0=RegionUnion;

			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionDilation, &XYTransLowRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(angleDiff).Rad()), (6.28319+m_modelAngle)+(HTuple(angleDiff).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			//dilation_circle(m_InnerCircleT,&Circle7, InnerEdge);
			gen_circle(&Circle8,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			if (OutEdge-InnerEdge>2)
			{
				gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol, OutEdge-InnerEdge);
			}
			else
			{
				gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol,2);
			}

			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, XYTransLowRegs, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 7);
			union1(TopLowRegs,&TopLowRegs);
			//剔除变形引起的多余区域
			Hobject ConnectedRegions3,ObjectSelected11,ObjectSelected22;
			HTuple  Indices,Row1, Column1, Radius3,Length;
			connection (TopLowRegs, &ConnectedRegions3);
			inner_circle (ConnectedRegions3, &Row1, &Column1, &Radius3);
			tuple_length (Radius3, &Length);
			if (Length>2)
			{
				tuple_sort_index (Radius3, &Indices);
				select_obj (ConnectedRegions3, &ObjectSelected11, Indices.Select(Length[0].I()-1)+1);
				select_obj (ConnectedRegions3, &ObjectSelected22, Indices.Select(Length[0].I()-2)+1);
				union2(ObjectSelected11,ObjectSelected22,&TopLowRegs);
			}
			//
			m_vRgn[rId] = TopLowRegs ;	
		}
		else if(Selection==4)  //内壁区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation;
			dilation_circle(m_TopRegs, &TopRegsDilation, ForkEdge);
			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			//dilation_circle(m_InnerCircleT,&Circle7, InnerEdge);
			gen_circle(&Circle8,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			if (OutEdge-InnerEdge>2)
			{
				gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol, OutEdge-InnerEdge);
			}
			else
			{
				gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol,2);
			}

			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, TopRegsDilation, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1118;LP;1;4;1;1$\
					 1075;LP;45;150;1;90$\
					 1076;FP;1;250;0.5;145$\
					 1077;LP;1;18000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1177;LP;1;90;1;1$\
					 1178;FP;1;50;1;10$\
					 1179;FP;1;200;1;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopRubberRegionLocationAlgo(VARIANT* rgnId, VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT*pAreaLimitLower)
{
	int rId = (int)rgnId->fltVal;

	int InnerEdge = (int)pInnerEdge->fltVal;
	int OutEdge = (int)pOutEdge->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_RubberReg0.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	if (m_InnerCircleRow.Num()==0 || m_InnerCircleCol.Num()==0 || m_modelAngle.Num()==0||m_TopRadius.Num()==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//边缘缺胶区域
		Hobject TopRegionDilation,RegionErosion,TopRegionErosion,RegionDiff,ConnectedRegions1;

		if (OutEdge>0)
		{
			dilation_rectangle1(m_RubberReg0,&TopRegionDilation, OutEdge, 1);

		} 
		else if(OutEdge<0)
		{
			erosion_rectangle1(m_RubberReg0,&TopRegionDilation, -OutEdge, 1);

		}
		else
		{
			TopRegionDilation=m_RubberReg0;
		}
		erosion_rectangle1(TopRegionDilation, &RegionErosion, 1, 15);
		erosion_rectangle1(m_RubberReg0,&TopRegionErosion, InnerEdge, 1);
		difference(RegionErosion, TopRegionErosion, &RegionDiff);

		connection(RegionDiff, &ConnectedRegions1);

		Hobject RubberRegs;
		select_shape (ConnectedRegions1, &RubberRegs, "area", "and", AreaLimitLower, 9999999);
		HTuple Radius;
		Radius=m_TopRadius;
		Hobject XYTransRubberRegs;
		polar_trans_region_inv(RubberRegs, &XYTransRubberRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(0).Rad()), (6.28319+m_modelAngle)+(HTuple(0).Rad()), 0, Radius, (Radius*2)*3.14, Radius,  m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1(XYTransRubberRegs,&XYTransRubberRegs);

		m_vRgn[rId] = XYTransRubberRegs ;	


#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopRubberRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1157$\
					 167;B$\
					 1158;LP;1;160;1;45$\
					 1159;LP;-60;100;1;10$\
					 1174;LP;5;1000;1;35");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_TopRubberRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT*pAreaLimitLower)
{
	int rId = (int)rgnId->fltVal;

	int InnerEdge = (int)pInnerEdge->fltVal;
	int OutEdge = (int)pOutEdge->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_RubberReg0.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	if (m_InnerCircleRow.Num()==0 || m_InnerCircleCol.Num()==0 || m_modelAngle.Num()==0||m_TopRadius.Num()==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		double angleDiff=90.0;
		//边缘缺胶区域
		Hobject TopRegionDilation,RegionErosion,TopRegionErosion,RegionDiff,ConnectedRegions1;

		if (OutEdge>0)
		{
			dilation_rectangle1(m_RubberReg0,&TopRegionDilation, OutEdge, 1);

		} 
		else if(OutEdge<0)
		{
			erosion_rectangle1(m_RubberReg0,&TopRegionDilation, -OutEdge, 1);

		}
		else
		{
			TopRegionDilation=m_RubberReg0;
		}
		erosion_rectangle1(TopRegionDilation, &RegionErosion, 1, 15);
		erosion_rectangle1(m_RubberReg0,&TopRegionErosion, InnerEdge, 1);
		difference(RegionErosion, TopRegionErosion, &RegionDiff);

		connection(RegionDiff, &ConnectedRegions1);

		Hobject RubberRegs;
		select_shape (ConnectedRegions1, &RubberRegs, "area", "and", AreaLimitLower, 9999999);
		HTuple Radius;
		Radius=m_TopRadius;
		Hobject XYTransRubberRegs;
		polar_trans_region_inv(RubberRegs, &XYTransRubberRegs, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+(HTuple(angleDiff).Rad()), (6.28319+m_modelAngle)+(HTuple(angleDiff).Rad()), 0, Radius, (Radius*2)*3.14, Radius,  m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1(XYTransRubberRegs,&XYTransRubberRegs);

		m_vRgn[rId] = XYTransRubberRegs ;	


#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_TopRubberRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1157$\
					 167;B$\
					 1158;LP;1;160;1;45$\
					 1159;LP;-60;100;1;10$\
					 1174;LP;5;1000;1;35");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**********************************************************************
**函数名：BottomDotDetectAlgo
**功  能：通过模板匹配来定位小圆的角度，用于后续的通过模板画区域
***********************************************************************/
STDMETHODIMP CPlugAlgo::BottomDotDetectAlgo(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pCirleNum,VARIANT* pMinScore,VARIANT* pAnglLineArea)
{
	//计算小圆点角度，通过模板工具画区域
	int rId = (int)rgnId->fltVal;
	double Radius = (double)pRadius->fltVal;
	int CirleNum = (int)pCirleNum->fltVal;
	float MinScore = (float)pMinScore->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pAnglLineArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		reduce_domain(Image, rgn, &ImageReduced);

		Hobject ContCircle,ModelImage,ImagerInvert,ModelImages,ModelRegions,ModelContour;
		HTuple  ModelImageHeight;
		if(m_isFirstDot)
		{
			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);
			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		if(m_oldRadiusDot!= Radius)
		{
			clear_shape_model(m_modelIdDot);

			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);

			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		HTuple ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore;
		find_scaled_shape_model (ImageReduced, m_modelIdDot, 0, 0, 0.8, 1.2, MinScore, CirleNum, 0.5, "least_squares", (HTuple(2).Append(-2)), 0.7, &ModelRow, &ModelColumn, &ModelAngle, &ModelScale, &ModelScore);

		HTuple FirstRow,FirstCol,Sorted,FirstIndice;
		HTuple Angle;
		Hobject AngleLine;
		if (0 != ((ModelScore.Num())==CirleNum))
		{
			tuple_sort(ModelRow, &Sorted);
			FirstRow = Sorted.Select((ModelRow.Num())-1);
			tuple_find(ModelRow, FirstRow, &FirstIndice);
			FirstCol = ModelColumn.Select(FirstIndice.Select(0));

			Hobject CenterCircle,FirstCircle,RegionUnion1;
			gen_circle(&CenterCircle, fCenterY, fCenterX, 10);
			gen_circle(&FirstCircle, FirstRow, FirstCol, 5);

			union2(CenterCircle, FirstCircle, &RegionUnion1);
			gen_region_line(&AngleLine, fCenterY, fCenterX, FirstRow, FirstCol);

			orientation_region(RegionUnion1, &Angle);

			if (0 != (Angle<0))
			{
				Angle += 2*PI;
			}

		}
		else
		{
			gen_empty_region(&AngleLine);

		}
		//显示
		Hobject ThreeCirclesRegion;
		if (ModelScore.Num()>=1)
		{

			Hobject  ContoursConcat,ContourAffineTrans;
			HTuple   HomMat2DIdentity,HomMat2DRotate,HomMat2DTranslate,HomMat2DScale;
			gen_empty_obj(&ContoursConcat);
			for (int i=0;i<=(ModelScore.Num()-1);i=i+1)
			{
				hom_mat2d_identity(&HomMat2DIdentity);
				hom_mat2d_rotate (HomMat2DIdentity, ModelAngle.Select(i), 0, 0, &HomMat2DRotate);
				hom_mat2d_translate (HomMat2DRotate, ModelRow.Select(i), ModelColumn.Select(i), &HomMat2DTranslate);
				hom_mat2d_scale(HomMat2DTranslate,ModelScale.Select(i),ModelScale.Select(i),ModelRow.Select(i),ModelColumn.Select(i),&HomMat2DScale);
				affine_trans_contour_xld(m_smallCircleContour,&ContourAffineTrans,HomMat2DScale);
				concat_obj(ContourAffineTrans,ContoursConcat,&ContoursConcat);
			}
			gen_region_contour_xld(ContoursConcat, &ThreeCirclesRegion, "margin");
		}
		else
		{
			gen_empty_region(&ThreeCirclesRegion);
		}
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AngleLine, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], ThreeCirclesRegion, &m_vRgn[rId]);
		}
		//
		HTuple Area,Row,Col;
		area_center(AngleLine,&Area,&Row,&Col);
		if(Area>0)
		{
			m_modelAngle=Angle;
			retValue = Area[0].I();
			m_vErrorRgn[rId] = AngleLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pAnglLineArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pAnglLineArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pAnglLineArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomDotDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1034$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 374;FP;5;30;0.5;10$\
					 1033;LP;1;4;1;3$\
					 377;FP;0.5;1.0;0.05;0.85");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************
**函数名：BottomDotRegionLocationAlgo
**功  能：寻找小圆
**思  路：通过模板匹配，直接获取小圆点检测区域
*****************************************************************************************************/
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT* pRadius,VARIANT* pCirleNum,VARIANT* pMinScore,VARIANT* pDilationSize)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	//匹配参数
	double Radius = (double)pRadius->fltVal;
	int CirleNum = (int)pCirleNum->fltVal;
	float MinScore = (float)pMinScore->fltVal;

	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn,rgnDil;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		dilation_circle(rgn,&rgnDil,7.5);

		reduce_domain(Image, rgnDil, &ImageReduced);

		Hobject ContCircle,ModelImage,ImagerInvert,ModelImages,ModelRegions,ModelContour;
		HTuple  ModelImageHeight;
		if(m_isFirstDot)
		{
			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);
			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		if(m_oldRadiusDot!= Radius)
		{
			clear_shape_model(m_modelIdDot);

			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);

			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		HTuple ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore;
		find_scaled_shape_model (ImageReduced, m_modelIdDot, 0, 0, 0.8, 1.2, MinScore, CirleNum, 0.5, "least_squares", (HTuple(2).Append(-2)), 0.7, &ModelRow, &ModelColumn, &ModelAngle, &ModelScale, &ModelScore);

		Hobject ThreeCirclesRegion;

		if(0 != (ModelScore.Num()==0))
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}
		else
		{
			Hobject  SmallCircles,ContourAffineTrans,CircleModelRegion;
			HTuple   HomMat2DIdentity,HomMat2DRotate,HomMat2DTranslate,HomMat2DScale;
			gen_empty_region(&SmallCircles);
			for (int i=0;i<=(ModelScore.Num()-1);i=i+1)
			{
				hom_mat2d_identity(&HomMat2DIdentity);
				hom_mat2d_rotate (HomMat2DIdentity, ModelAngle.Select(i), 0, 0, &HomMat2DRotate);
				hom_mat2d_translate (HomMat2DRotate, ModelRow.Select(i), ModelColumn.Select(i), &HomMat2DTranslate);
				hom_mat2d_scale(HomMat2DTranslate,ModelScale.Select(i),ModelScale.Select(i),ModelRow.Select(i),ModelColumn.Select(i),&HomMat2DScale);
				affine_trans_contour_xld(m_smallCircleContour,&ContourAffineTrans,HomMat2DScale);
				gen_region_contour_xld(ContourAffineTrans, &CircleModelRegion, "filled");
				concat_obj(CircleModelRegion,SmallCircles,&SmallCircles);
			}
			union1(SmallCircles, &ThreeCirclesRegion);
		}
		// 小圆角度
		Hobject rgnCon,rgnObj;
		HTuple dArea,dRow,dCol;
		connection( ThreeCirclesRegion ,&rgnCon);
		select_obj(rgnCon,&rgnObj,1);
		area_center(rgnObj,&dArea,&dRow,&dCol);
		
		Hobject rgnCir1,rgnCir2 ,rgnUni;
		HTuple  Angle;
		gen_circle(&rgnCir1, fCenterY, fCenterX, 5);
		gen_circle(&rgnCir2, dRow, dCol, 20);
		union2(rgnCir1, rgnCir2, &rgnUni);
		orientation_region(rgnUni, &Angle);
		if(Angle<0)
		{
			Angle=2*PI+Angle;
		}
		m_modelAngle=Angle; 
		//m_modelAngleTmp = HTuple();
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		////////////////////////////////////////////////

		Hobject ThreeCirclesRegionDilation;
		dilation_circle(ThreeCirclesRegion,&ThreeCirclesRegionDilation,DilationSize);

		if (Selection==1)
		{
			m_vRgn[rId]=ThreeCirclesRegionDilation;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,ThreeCirclesRegionDilation,&RegionDiff);
			// 减去文字区域（如果文字区域存在的话）m_rgnCharacter
			difference(RegionDiff,m_rgnCharacter,&RegionDiff);

			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1119$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208$\
					 374;FP;5;100;0.5;10$\
					 1033;LP;1;4;1;3$\
					 377;FP;0.5;1.0;0.05;0.85$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************************
** 函 数 名：BottomDotRegionLocationAlgo1 
** 功    能：通过匹配成功的一个圆点花纹，依据固定角度，扣除冠部圆点花纹,避免出现花纹不明显时，定位失败
******************************************************************************************************/
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT* pRadius,VARIANT* pCirleNum,VARIANT* pMinScore,VARIANT* pDilationSize)
{
	//通过模板匹配，直接获取小圆点检测区域
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	//匹配参数
	double Radius = (double)pRadius->fltVal;
	int CirleNum = (int)pCirleNum->fltVal;
	float MinScore = (float)pMinScore->fltVal;

	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced,rgnDil;
		Hobject Image=m_crtImg;
		dilation_circle(rgn,&rgnDil,7.5);
		reduce_domain(Image, rgnDil, &ImageReduced);

		Hobject ContCircle,ModelImage,ImagerInvert,ModelImages,ModelRegions,ModelContour;
		HTuple  ModelImageHeight;
		if(m_isFirstDot)
		{
			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,0,0,0,0,0.8,1.2,"auto","none","use_polarity","auto","auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);
			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		if(m_oldRadiusDot!= Radius)
		{
			clear_shape_model(m_modelIdDot);

			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,0,0,0,0,0.8,1.2,"auto","none","use_polarity","auto","auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);

			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		HTuple ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore;
		find_scaled_shape_model (ImageReduced, m_modelIdDot, 0, 0, 0.8, 1.2, MinScore, 1, 0.5, "least_squares", 0, 0.7, &ModelRow, &ModelColumn, &ModelAngle, &ModelScale, &ModelScore);

		Hobject ThreeCirclesRegion;

		if(0 != (ModelScore.Num()==0))
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}
		else
		{
			//Angle [0,2Pi)
			Hobject CenterCircle,ModelCenterCircle,RegionUnion;
			HTuple  UniqueCirclePhi;
			gen_circle(&CenterCircle, fCenterY,fCenterX, 20);
			gen_circle(&ModelCenterCircle, ModelRow, ModelColumn, 5);

			union2(CenterCircle, ModelCenterCircle, &RegionUnion);
			orientation_region(RegionUnion, &UniqueCirclePhi);

			if(UniqueCirclePhi<0)
			{
				UniqueCirclePhi=2*PI+UniqueCirclePhi;
			}
			//
			HTuple Dist;
			distance_pp(fCenterY,fCenterX, ModelRow, ModelColumn, &Dist);

			Hobject TopCircle;
			HTuple TopRow,TopCol;
			//Top-Circle
			TopRow = fCenterY-Dist;
			TopCol = fCenterX;
			gen_circle(&TopCircle, TopRow, TopCol, Radius);

			Hobject RightCircle;
			HTuple RightRow,RightCol;
			//Right-Circle
			RightRow = fCenterY+(Dist*(HTuple(HTuple(30).Rad()).Sin()));
			RightCol = fCenterX+(Dist*(HTuple(HTuple(30).Rad()).Cos()));
			gen_circle(&RightCircle, RightRow, RightCol, Radius);

			Hobject LeftCircle;
			HTuple LeftRow,LeftCol;
			//Left-Circle
			LeftRow = fCenterY+(Dist*(HTuple(HTuple(30).Rad()).Sin()));
			LeftCol = fCenterX-(Dist*(HTuple(HTuple(30).Rad()).Cos()));
			gen_circle(&LeftCircle, LeftRow, LeftCol, Radius);

			Hobject RegionUnion1,ThreeCircles;
			union2(TopCircle, RightCircle, &RegionUnion1);
			union2(RegionUnion1, LeftCircle, &ThreeCircles);

			HTuple HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, UniqueCirclePhi+((PI*3)/2), &HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (ThreeCircles, &ThreeCirclesRegion, HomMat2DAdapted, "bilinear");

		}

		Hobject ThreeCirclesRegionDilation;
		dilation_circle(ThreeCirclesRegion,&ThreeCirclesRegionDilation,DilationSize);
		if (Selection==1)
		{
			m_vRgn[rId]=ThreeCirclesRegionDilation;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,ThreeCirclesRegionDilation,&RegionDiff);
			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5523$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208$\
					 374;FP;5;100;0.5;10$\
					 1033;LP;3;4;1;3$\
					 377;FP;0.5;1.0;0.05;0.85$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************
** 函 数 名：BottomDotRegionLocationAlgo2 
** 功    能：通过匹配成功的一个圆点花纹，依据固定角度，扣除冠部圆点花纹,避免出现花纹不明显时，定位失败
** 修改说明：（1）内容：算子1是用来找3个小圆；该算子是用来寻找4个小圆
             （2）内容：在算子的结尾处输出了找到的第一个小圆的角度，并计算了第二个小圆角度
			      说明：在胶塞底部的内圆区域存在两排文字，不清晰时，无法匹配，故使用此方法确认文字位置
			      时间：2019年7月20日    
*****************************************************************************************************/
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT* pRadius,VARIANT* pCirleNum,VARIANT* pMinScore,VARIANT* pDilationSize)
{
	//通过模板匹配，直接获取小圆点检测区域
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	//匹配参数
	double Radius = (double)pRadius->fltVal;
	int CirleNum = (int)pCirleNum->fltVal;
	float MinScore = (float)pMinScore->fltVal;

	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		reduce_domain(Image, rgn, &ImageReduced);

		Hobject ContCircle,ModelImage,ImagerInvert,ModelImages,ModelRegions,ModelContour;
		HTuple  ModelImageHeight;
		if(m_isFirstDot)
		{
			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,0,0,0,0,0.8,1.2,"auto","none","use_polarity","auto","auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);
			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		if(m_oldRadiusDot!= Radius)
		{
			clear_shape_model(m_modelIdDot);

			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,0,0,0,0,0.8,1.2,"auto","none","use_polarity","auto","auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);

			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		HTuple ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore;
		find_scaled_shape_model (ImageReduced, m_modelIdDot, 0, 0, 0.8, 1.2, MinScore, 1, 0.5, "least_squares", 0, 0.7, &ModelRow, &ModelColumn, &ModelAngle, &ModelScale, &ModelScore);

		Hobject FourCirclesRegion,FourCirclesRegionF;

		if(0 != (ModelScore.Num()==0))
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}
		else
		{
			//Angle [0,2Pi)
			Hobject CenterCircle,ModelCenterCircle,RegionUnion;
			HTuple  UniqueCirclePhi;
			gen_circle(&CenterCircle, fCenterY,fCenterX, 20);
			gen_circle(&ModelCenterCircle, ModelRow, ModelColumn, 5);

			union2(CenterCircle, ModelCenterCircle, &RegionUnion);
			orientation_region(RegionUnion, &UniqueCirclePhi);

			m_UniqueCirclePhi = UniqueCirclePhi;

			if(UniqueCirclePhi<0)
			{
				UniqueCirclePhi=2*PI+UniqueCirclePhi;
			}
			//
			HTuple Dist;
			distance_pp(fCenterY,fCenterX, ModelRow, ModelColumn, &Dist);

			m_Dist = Dist;

			Hobject TopCircle;
			HTuple TopRow,TopCol;
			//Top-Circle
			TopRow = fCenterY-Dist;
			TopCol = fCenterX;
			gen_circle(&TopCircle, TopRow, TopCol, Radius);

		    m_TopRow = TopRow;
            m_TopCol = TopCol;

			Hobject DownCircle;
			HTuple DownRow,DownCol;
			//Down-Circle
			DownRow = fCenterY+Dist;
			DownCol = fCenterX;
			gen_circle(&DownCircle, DownRow, DownCol, Radius);

			Hobject RightCircle;
			HTuple RightRow,RightCol;
			//Right-Circle
			RightRow = fCenterY;
			RightCol = fCenterX + Dist;
			gen_circle(&RightCircle, RightRow, RightCol, Radius);

			Hobject LeftCircle;
			HTuple LeftRow,LeftCol;
			//Left-Circle
			LeftRow = fCenterY;
			LeftCol = fCenterX-Dist;
			gen_circle(&LeftCircle, LeftRow, LeftCol, Radius);

			Hobject RegionUnion1,FourCircles,RegionUnion2;
			union2(TopCircle, RightCircle, &RegionUnion1);
			union2(RegionUnion1, LeftCircle, &RegionUnion2);
			union2(RegionUnion2, DownCircle, &FourCircles);

			HTuple HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, UniqueCirclePhi+((PI*3)/2), &HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (FourCircles, &FourCirclesRegion, HomMat2DAdapted, "bilinear");

			// 正反方向各旋转2度
			HTuple HomMat2DR,HomMat2DL;
			Hobject FourCirclesRegionR,FourCirclesRegionL;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, HTuple(3).Rad(), &HomMat2DR);
			projective_trans_region (FourCirclesRegion, &FourCirclesRegionR, HomMat2DR, "bilinear");

			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, HTuple(-3).Rad(), &HomMat2DL);
			projective_trans_region (FourCirclesRegion, &FourCirclesRegionL, HomMat2DL, "bilinear");

			union2(FourCirclesRegionR,FourCirclesRegionL,&FourCirclesRegionF);
			union2(FourCirclesRegion,FourCirclesRegionF,&FourCirclesRegionF);
		}

		// 传出小圆的角度（第一个和第二个小圆）
		Hobject FourCirclesRegionFUni,FourCirclesRegionFCon,objFirst,objSecond;
		HTuple  iCirNum;
		union1(FourCirclesRegionF,&FourCirclesRegionFUni);
		connection(FourCirclesRegionFUni,&FourCirclesRegionFCon);
		count_obj(FourCirclesRegionFCon,&iCirNum);
		if ( (iCirNum > 4) || (iCirNum < 1) )
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}

		HTuple dArea1,dCenterRow1,dCenterCol1,dArea2,dCenterRow2,dCenterCol2;
		select_obj(FourCirclesRegionFCon,&objFirst,1 );
		area_center(objFirst,&dArea1,&dCenterRow1,&dCenterCol1);
		select_obj(FourCirclesRegionFCon,&objSecond,2 );
		area_center(objSecond,&dArea2,&dCenterRow2,&dCenterCol2);
		
		// 第一个小圆角度
		Hobject CenterCircle,SelectCircle1,RegionUnion1,rgnLine1;
		HTuple Angle1;
		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle1, dCenterRow1, dCenterCol1, 20);
		union2(CenterCircle, SelectCircle1, &RegionUnion1);
		orientation_region(RegionUnion1, &Angle1);

		gen_region_line(&rgnLine1,fCenterY, fCenterX,dCenterRow1, dCenterCol1);
		union2(RegionUnion1,rgnLine1,&RegionUnion1);
		union1(RegionUnion1,&RegionUnion1);
		m_rgnAngleLine1 = RegionUnion1;

		if(Angle1<0)
		{
			Angle1=2*PI+Angle1;
			m_AngleFirstCir = Angle1;
		}
		else
		{
			m_AngleFirstCir = Angle1;
		}

		m_modelAngle=Angle1; 

		// 第二个小圆角度
		Hobject SelectCircle2,RegionUnion2,rgnLine2;
		HTuple Angle2;
		gen_circle(&SelectCircle2, dCenterRow2, dCenterCol2, 20);
		union2(CenterCircle, SelectCircle2, &RegionUnion2);
		orientation_region(RegionUnion2, &Angle2);
		
		gen_region_line(&rgnLine2,fCenterY, fCenterX,dCenterRow2, dCenterCol2);
		union2(RegionUnion2,rgnLine2,&RegionUnion2);
		union1(RegionUnion2,&RegionUnion2);
		m_rgnAngleLine2 = RegionUnion2;

		if(Angle2<0)
		{
			Angle2=2*PI+Angle2;
			m_AngleSecondCir = Angle2;
		}
		else
		{
			m_AngleSecondCir = Angle2;
		}
		/////////////////////////////////////////

		Hobject FourCirclesRegionDilation;
		dilation_circle(FourCirclesRegionF,&FourCirclesRegionDilation,DilationSize);
		if (Selection==1)
		{
			m_vRgn[rId]=FourCirclesRegionDilation;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,FourCirclesRegionDilation,&RegionDiff);
			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5524$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208$\
					 374;FP;5;100;0.5;10$\
					 1033;LP;3;4;1;3$\
					 377;FP;0.5;1.0;0.05;0.85$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************************
**函数名：BottomDotRegionLocationAlgo3
**功  能：寻找小圆
**思  路：通过模板匹配，获取小圆区域，如果无法找到三个小圆，则通过旋转法定位小圆位置
**        因此，使用该算子时一般将匹配分数设置的高一点，以免冠部小圆丢失而定位到错误位置
**时  间：2019年7月20日（山东海博现场）
***************************************************************************************/
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo3(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT* pRadius,VARIANT* pCirleNum,VARIANT* pMinScore,VARIANT* pDilationSize)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	//匹配参数
	double Radius = (double)pRadius->fltVal;
	int CirleNum = (int)pCirleNum->fltVal;
	float MinScore = (float)pMinScore->fltVal;

	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif
		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn,rgnDil,rgnFil,rgnIntsct;
		rgn = RegionDetect ;	
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		dilation_circle(rgn,&rgnDil,10.5);
		fill_up(rgn,&rgnFil);
		intersection(rgnFil,rgnDil,&rgnIntsct );

		reduce_domain(Image, rgnIntsct, &ImageReduced);

		Hobject ContCircle,ModelImage,ImagerInvert,ModelImages,ModelRegions,ModelContour;
		HTuple  ModelImageHeight;
		if(m_isFirstDot)
		{
			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);
			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		if(m_oldRadiusDot!= Radius)
		{
			clear_shape_model(m_modelIdDot);

			ModelImageHeight=Radius*2+10;
			m_oldRadiusDot=Radius;
			gen_circle_contour_xld(&ContCircle,ModelImageHeight/2,ModelImageHeight/2,Radius,0,6.28318,"positive",1);
			gen_image_const(&ModelImage,"byte",ModelImageHeight,ModelImageHeight);
			paint_xld(ContCircle,ModelImage,&ModelImage,128);
			invert_image(ModelImage,&ImagerInvert);
			create_scaled_shape_model(ImagerInvert,"auto",0,0,0,0.8,1.2,"auto","none","use_polarity",40,"auto",&m_modelIdDot);
			get_shape_model_contours(&ModelContour,m_modelIdDot,1);

			m_smallCircleContour=ModelContour;
			m_isFirstDot=false;

		}
		HTuple ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore;
		find_scaled_shape_model (ImageReduced, m_modelIdDot, 0, 0, 0.8, 1.2, MinScore, CirleNum, 0.5, "least_squares", (HTuple(2).Append(-2)), 0.7, &ModelRow, &ModelColumn, &ModelAngle, &ModelScale, &ModelScore);

		Hobject ThreeCirclesRegion;

		if(0 != (ModelScore.Num()==0))
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}
		else
		{
			Hobject  SmallCircles,ContourAffineTrans,CircleModelRegion;
			HTuple   HomMat2DIdentity,HomMat2DRotate,HomMat2DTranslate,HomMat2DScale;
			gen_empty_region(&SmallCircles);
			for (int i=0;i<=(ModelScore.Num()-1);i=i+1)
			{
				hom_mat2d_identity(&HomMat2DIdentity);
				hom_mat2d_rotate (HomMat2DIdentity, ModelAngle.Select(i), 0, 0, &HomMat2DRotate);
				hom_mat2d_translate (HomMat2DRotate, ModelRow.Select(i), ModelColumn.Select(i), &HomMat2DTranslate);
				hom_mat2d_scale(HomMat2DTranslate,ModelScale.Select(i),ModelScale.Select(i),ModelRow.Select(i),ModelColumn.Select(i),&HomMat2DScale);
				affine_trans_contour_xld(m_smallCircleContour,&ContourAffineTrans,HomMat2DScale);
				gen_region_contour_xld(ContourAffineTrans, &CircleModelRegion, "filled");
				concat_obj(CircleModelRegion,SmallCircles,&SmallCircles);
			}
			union1(SmallCircles, &ThreeCirclesRegion);
		}
		
		// 判断小圆个数
		HTuple iCirNum;
		Hobject rgnCirSCon;

		connection(ThreeCirclesRegion,&rgnCirSCon );
		count_obj(rgnCirSCon,&iCirNum );
		if (iCirNum < 3 )
		{
			//Angle [0,2Pi)
			Hobject CenterCircle,ModelCenterCircle,RegionUnion;
			HTuple  UniqueCirclePhi;
			gen_circle(&CenterCircle, fCenterY,fCenterX, 20);
			gen_circle(&ModelCenterCircle, ModelRow.Select(0), ModelColumn.Select(0), 5);

			union2(CenterCircle, ModelCenterCircle, &RegionUnion);
			orientation_region(RegionUnion, &UniqueCirclePhi);

			if(UniqueCirclePhi<0)
			{
				UniqueCirclePhi=2*PI+UniqueCirclePhi;
			}
			//
			HTuple Dist;
			distance_pp(fCenterY,fCenterX, ModelRow.Select(0), ModelColumn.Select(0), &Dist);

			Hobject TopCircle;
			HTuple TopRow,TopCol;
			//Top-Circle
			TopRow = fCenterY-Dist;
			TopCol = fCenterX;
			gen_circle(&TopCircle, TopRow, TopCol, Radius);

			Hobject RightCircle;
			HTuple RightRow,RightCol;
			//Right-Circle
			RightRow = fCenterY+(Dist*(HTuple(HTuple(30).Rad()).Sin()));
			RightCol = fCenterX+(Dist*(HTuple(HTuple(30).Rad()).Cos()));
			gen_circle(&RightCircle, RightRow, RightCol, Radius);

			Hobject LeftCircle;
			HTuple LeftRow,LeftCol;
			//Left-Circle
			LeftRow = fCenterY+(Dist*(HTuple(HTuple(30).Rad()).Sin()));
			LeftCol = fCenterX-(Dist*(HTuple(HTuple(30).Rad()).Cos()));
			gen_circle(&LeftCircle, LeftRow, LeftCol, Radius);

			Hobject RegionUnion1,ThreeCircles;
			union2(TopCircle, RightCircle, &RegionUnion1);
			union2(RegionUnion1, LeftCircle, &ThreeCircles);
			
			HTuple HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			Hobject rgnThreeCirS;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, UniqueCirclePhi+((PI*3)/2), &HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (ThreeCircles, &rgnThreeCirS, HomMat2DAdapted, "bilinear");

			ThreeCirclesRegion = rgnThreeCirS;
		}

		Hobject ThreeCirclesRegionDilation;
		dilation_circle(ThreeCirclesRegion,&ThreeCirclesRegionDilation,DilationSize);

		if (Selection==1)
		{
			m_vRgn[rId]=ThreeCirclesRegionDilation;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,ThreeCirclesRegionDilation,&RegionDiff);
			// 减去文字区域（如果文字区域存在的话）m_rgnCharacter
			difference(RegionDiff,m_rgnCharacter,&RegionDiff);

			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomDotRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6120$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;208$\
					 374;FP;5;100;0.5;10$\
					 1033;LP;3;4;1;3$\
					 377;FP;0.5;1.0;0.05;0.85$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************************************************************************
***函数名：AngleSelectAlgo
***功  能：角度选择，配合 BottomDotRegionLocationAlgo2 中得到的两个角度进行角度选择，传递给通过模板匹配变化的区域算子
***时  间：2019年7月20日（华兰注射器胶塞更新）
********************************************************************************************************************/
STDMETHODIMP CPlugAlgo::AngleSelectAlgo(VARIANT* rgnId,VARIANT* pSelection )
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;

	Hobject  rgnAngleLine1,rgnAngleLine2 ;
	rgnAngleLine1 = m_rgnAngleLine1;
	rgnAngleLine2 = m_rgnAngleLine2;
	union1(rgnAngleLine1,&rgnAngleLine1);
	HTuple area1,row1,col1;
	area_center(rgnAngleLine1,&area1,&row1,&col1);

	union1(rgnAngleLine2,&rgnAngleLine2);
	HTuple area2,row2,col2;
	area_center(rgnAngleLine2,&area2,&row2,&col2);

	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if(area1 ==0 ||area2==0)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;

		if ( Selection == 1)
		{
			m_modelAngle = m_AngleFirstCir;
			m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
			m_vRgn[rId] = rgnAngleLine1;
		}
		if ( Selection == 2)
		{
			m_modelAngleTmp = HTuple();
			m_modelAngle = m_AngleSecondCir;
			m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
			m_vRgn[rId] = rgnAngleLine2;
		}

	  // my_disp_obj(rgnAngleLine1);

		//retValue = m_modelAngle[0].D();
		//m_vErrorRgn[rId] = rgn;
		
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AngleSelectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6106$\
					 167;B$\
					 6107;LP;1;2;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_BottomDotRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5525$\
					 167;B$\
					 1120;LP;1;2;1;1$\
					 194;FP;1.0;2000.0;0.5;185$\
					 413;FP;1.5;2000;0.5;30$\
					 374;FP;5;30;0.5;10$\
					 1339;FP;1;180;0.5;50$\
					 6020;FP;1;100;0.5;36$\
					 1121;FP;3;20;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/************************************************************************************************************
** 函 数 名：AB20_BottomDotRegionLocationAlgo
** 功    能：该算子配合 BottomDotRegionLocationAlgo2（四个小圆定位）算子使用；定位一种胶塞的内外两组4小圆区域
** 使用场景：针对一种胶塞的底部存在两组小圆，每组4个小圆，外圈小圆较容易定位，内圈小圆不易定位
************************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_BottomDotRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadiusE,VARIANT* pRoiWidth,VARIANT* pRadius,VARIANT* pAngleDiff,VARIANT* pRadiusDiff,VARIANT* pDilationSize)
{
	//区域开关控制获取小圆点检测区域
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	
	//环形区域
	float RoiWidth = (float)pRoiWidth->fltVal;
	float RadiusE =(float)pRadiusE->fltVal;
	float m_RadiusExt = RadiusE - RoiWidth;
	float Radius = (float)pRadius->fltVal;     // 小圆参考半径

	float AngleDiff = (float)pAngleDiff->fltVal;       // 50度
	float RadiusDiff = (float)pRadiusDiff->fltVal;    // 36

	float DilationSize = (float)pDilationSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

	Hobject  Circle1_Inner,Circle2_EXT;
	Hobject  RegionDetect;

#ifdef NDEBUG
	try
	{
#endif

		if (RoiWidth<0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, m_RadiusExt);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, RadiusE);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else if (RoiWidth==0)
		{
			gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE+1);
			gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
			difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
		}
		else
		{
			if(m_RadiusExt>0)
			{
				gen_circle(&Circle2_EXT, fCenterY, fCenterX, RadiusE);
				gen_circle(&Circle1_Inner, fCenterY, fCenterX, m_RadiusExt);
				difference(Circle2_EXT,Circle1_Inner,&RegionDetect);
			}
			else
			{
				gen_circle(&RegionDetect, fCenterY, fCenterX, RadiusE);
			}
		}
		Hobject rgn;
		rgn = RegionDetect ;	

		Hobject Image=m_crtImg;
		HTuple UniqueInnerCirclePhi,InnerDist;

		Hobject FourCirclesRegion,FourCirclesRegionF;

		UniqueInnerCirclePhi = m_UniqueCirclePhi - HTuple(AngleDiff).Rad();
		InnerDist = m_Dist - RadiusDiff;
		

		//Angle [0,2Pi)
		if(UniqueInnerCirclePhi<0)
		{
			UniqueInnerCirclePhi=2*PI+UniqueInnerCirclePhi;
		}
		
		if(UniqueInnerCirclePhi<0 || (m_Dist < 0) || (m_TopRow <0)||(m_TopCol<0))
		{
			m_vRgn[rId]=rgn;
			return S_FALSE;
		}
		else
		{
			//Top-Circle
			Hobject TopInnerCircle;
			HTuple TopInnerRow,TopInnerCol;
			TopInnerRow = m_TopRow + RadiusDiff;
			TopInnerCol = m_TopCol;
			gen_circle(&TopInnerCircle, TopInnerRow, TopInnerCol, Radius);

			Hobject DownInnerCircle;
			HTuple DownInnerRow,DownInnerCol;
			//Down-Circle
			DownInnerRow = TopInnerRow + InnerDist*2.0;
			DownInnerCol = TopInnerCol;
			gen_circle(&DownInnerCircle, DownInnerRow, DownInnerCol, Radius);

			Hobject RightInnerCircle;
			HTuple RightInnerRow,RightInnerCol;
			//Right-Circle
			RightInnerRow = TopInnerRow + InnerDist;
			RightInnerCol = TopInnerCol + InnerDist;
			gen_circle(&RightInnerCircle, RightInnerRow, RightInnerCol, Radius);

			Hobject LeftInnerCircle;
			HTuple LeftInnerRow,LeftInnerCol;
			//Left-Circle
			LeftInnerRow = TopInnerRow + InnerDist;
			LeftInnerCol = TopInnerCol - InnerDist;
			gen_circle(&LeftInnerCircle, LeftInnerRow, LeftInnerCol, Radius);

			Hobject RegionUnion1,FourCircles,RegionUnion2;
			union2(TopInnerCircle, RightInnerCircle, &RegionUnion1);
			union2(RegionUnion1, LeftInnerCircle, &RegionUnion2);
			union2(RegionUnion2, DownInnerCircle, &FourCircles);

			HTuple HomMat2D,HomMat2DTmp,HomMat2DAdapted;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, UniqueInnerCirclePhi+((PI*3)/2), &HomMat2D);
			hom_mat2d_translate(HomMat2D, 0.5, 0.5, &HomMat2DTmp);
			hom_mat2d_translate_local(HomMat2DTmp, -0.5, -0.5, &HomMat2DAdapted);
			projective_trans_region (FourCircles, &FourCirclesRegion, HomMat2DAdapted, "bilinear");

			// 正反方向各旋转2度
			HTuple HomMat2DR,HomMat2DL;
			Hobject FourCirclesRegionR,FourCirclesRegionL;
			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, HTuple(4).Rad(), &HomMat2DR);
			projective_trans_region (FourCirclesRegion, &FourCirclesRegionR, HomMat2DR, "bilinear");

			vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY,fCenterX, HTuple(-4).Rad(), &HomMat2DL);
			projective_trans_region (FourCirclesRegion, &FourCirclesRegionL, HomMat2DL, "bilinear");

			union2(FourCirclesRegionR,FourCirclesRegionL,&FourCirclesRegionF);
			union2(FourCirclesRegion,FourCirclesRegionF,&FourCirclesRegionF);	
		}

		Hobject FourCirclesRegionDilation;
		dilation_circle(FourCirclesRegionF,&FourCirclesRegionDilation,DilationSize);
		if (Selection==1)
		{
			m_vRgn[rId]=FourCirclesRegionDilation;
		}
		else if(Selection==2)
		{
			Hobject RegionDiff,RegionDiffUnion;
			difference(rgn,FourCirclesRegionDilation,&RegionDiff);
			union1(RegionDiff,&RegionDiffUnion);
			m_vRgn[rId]=RegionDiffUnion;
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D13_DerivateGaussDetectAlgo(VARIANT* rgnId,  VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDilationSize,VARIANT* pDetectArea)
{
	//13单叉口整体黑白点检测时，剔除顶部内孔内边缘的误检点 m_TopInnerRgion  剔除边缘花纹干扰m_ARegionT

	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;

	float DilationSize = (float)pDilationSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		derivate_gauss(ImageReduced, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}

		//13单叉口整体黑白点检测时，剔除顶部内孔内边缘的误检点 m_TopInnerRgion

		HTuple Rows, Columns;
		Hobject LineOpening,Region,RegionDilation;
		opening_circle(m_TopInnerRgion, &LineOpening, 2.0);
		get_region_contour(LineOpening, &Rows, &Columns);
		gen_region_polygon(&Region, Rows, Columns);
		dilation_circle(Region, &RegionDilation, DilationSize);

		Hobject Regions;
		intersection(RegionDilation,DefectRegs,&Regions);
		difference(DefectRegs,Regions,&DefectRegs);

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D13_DerivateGaussDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("678$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10$\
					 1135;FP;1;10;0.5;2");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************
** 函 数 名： AB20_TopRegDetectAlgo
** 功    能：针对AB20_侧面（20圆形）提取其顶部高亮区域和内壁区域
** 思    路：密封面椭圆平移+阈值分割
****************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pTopRegionArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		Hobject ImageScaleMax1;
		scale_image_max(ImageReducedAroi, &ImageScaleMax1);

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageScaleMax1, &Regions, ThredLower, 255);

		Hobject RegionFillUp,RegionsConnected,RegionsSelected;
		fill_up(Regions, &RegionFillUp);
		connection(RegionFillUp, &RegionsConnected);
		select_shape_std(RegionsConnected, &RegionsSelected, "max_area", 70);
		//
		Hobject TopInwallRegionDif,TopInwallRegion;
		difference(RegionsSelected,Regions,&TopInwallRegionDif);
	    m_TopInwallRegionOrigin=TopInwallRegionDif;
		//
		shape_trans(TopInwallRegionDif, &TopInwallRegion, "ellipse");
		m_TopInwallRegion=TopInwallRegion;

		//开闭运算尺寸，依据实际的图片进行调整
		Hobject TopRegionClosing,TopRegionOpening,TopRegionConnected;
		closing_circle(RegionsSelected, &TopRegionClosing, 20);
		opening_circle(TopRegionClosing, &TopRegionOpening, 20);
		Hobject TopRegion;
		connection(TopRegionOpening, &TopRegionConnected);
		select_shape_std(TopRegionConnected, &TopRegion, "max_area", 70);

		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(TopRegion, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		//顶部区域
		m_TopRegion=TopRegion;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AroiClosing, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopInwallRegion, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopRegion, &m_vRgn[rId]);
		}
		//
		if (TopRegionArea>0)
		{
			retValue = TopRegionArea[0].I();
			m_vErrorRgn[rId] = TopRegion;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopRegionArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6049$\
					 397;R;FP;1;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;300;1;150$\
					 989;FP;1;254;1;125");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************
**函 数 名：AB20_TopRegDetectAlgo1
**功    能：用于13口服液胶塞、外壁平缓倾斜，提取顶部内壁区域
**注    意：该算子只提取了顶部内壁区域，没有顶部高亮区域
*******************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThreshUpValue, VARIANT* pTopRegionArea)
{
	//用于13口服液胶塞、外壁平缓倾斜
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		Hobject ImageScaleMax1;
		scale_image_max(ImageReducedAroi, &ImageScaleMax1);

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageScaleMax1, &Regions, 0, ThreshUpValue);

		Hobject RegionFillUp,RegionsConnected,RegionsSelected;
		fill_up(Regions, &RegionFillUp);
		connection(RegionFillUp, &RegionsConnected);
		select_shape_std(RegionsConnected, &RegionsSelected, "max_area", 70);
		//
		Hobject TopInwallRegion;
		shape_trans(RegionsSelected, &TopInwallRegion, "ellipse");
		m_TopInwallRegion=TopInwallRegion;
		m_TopInwallRegionOrigin=RegionsSelected;

		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(TopInwallRegion, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		//顶部区域
		//m_TopRegion=TopRegion;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AroiClosing, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopInwallRegion, &m_vRgn[rId]);
		}
		//
		if (TopRegionArea>0)
		{
			retValue = TopRegionArea[0].I();
			m_vErrorRgn[rId] = TopInwallRegion;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopRegionArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6050$\
					 397;R;FP;1;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;300;1;150$\
					 1141;FP;1;250;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************
**函 数 名：AB20_TopRegDetectAlgo2
**功    能：提取顶部高亮区域
**注    意：该算子只提取了顶部高亮区域，没有顶部内壁区域
*******************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pTopRegionArea)
{
	//内壁倾斜胶塞
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		Hobject ImageScaleMax1;
		scale_image_max(ImageReducedAroi, &ImageScaleMax1);

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageScaleMax1, &Regions, ThredLower, 255);

		Hobject RegionFillUp,RegionsConnected,RegionsSelected;
		fill_up(Regions, &RegionFillUp);
		connection(RegionFillUp, &RegionsConnected);
		select_shape_std(RegionsConnected, &RegionsSelected, "max_area", 70);
		//
		/*Hobject TopInwallRegion;
		difference(RegionsSelected,Regions,&TopInwallRegion);
		shape_trans(TopInwallRegion, &TopInwallRegion, "ellipse");
		m_TopInwallRegion=TopInwallRegion;*/

		//开闭运算尺寸，依据实际的图片进行调整
		Hobject TopRegionClosing,TopRegionOpening,TopRegionConnected;
		closing_circle(RegionsSelected, &TopRegionClosing, 20);
		opening_circle(TopRegionClosing, &TopRegionOpening, 20);
		Hobject TopRegion;
		connection(TopRegionOpening, &TopRegionConnected);
		select_shape_std(TopRegionConnected, &TopRegion, "max_area", 70);

		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(TopRegion, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		//顶部区域
		m_TopRegion=TopRegion;
		//
		m_TopInwallRegion=TopRegion;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AroiClosing, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopRegion, &m_vRgn[rId]);
		}
		//
		if (TopRegionArea>0)
		{
			retValue = TopRegionArea[0].I();
			m_vErrorRgn[rId] = TopRegion;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopRegionArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopRegDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1014$\
					 397;R;FP;1;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;230;1;150$\
					 989;FP;1;254;1;125");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/*****************************************************************************************
// 函 数 名：AB20_TopGlueDetectAlgo 
// 功    能：圆形胶塞顶部缺胶检测 
******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopGlueDetectAlgo(VARIANT* rgnId, VARIANT*pSeriousBlackPointSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//

		Hobject OutRegion;
		difference(m_TopInwallRegionOrigin, m_TopInwallRegion, &OutRegion);
		Hobject RegionIntersction,InnerRegion,RegionUnion,DefectRegs;
		intersection(m_TopInwallRegionOrigin, m_TopInwallRegion, &RegionIntersction);
		difference(m_TopInwallRegion, RegionIntersction, &InnerRegion);
		union2(InnerRegion, OutRegion, &RegionUnion);

		Hobject ConnectedRegions,RegionOpening,SelectedRegions;
		connection(RegionUnion, &ConnectedRegions);
		opening_circle(ConnectedRegions, &RegionOpening, 1.5);
		select_shape(RegionOpening, &SelectedRegions, "area", "and", SeriousBlackPointSize, 99999999);
		union1(SelectedRegions, &DefectRegs);

		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopGlueDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1164$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/*****************************************************************************************
// 函 数 名：AB20_TopGlueDetectAlgo1 
// 功    能：圆形胶塞顶部缺胶检测（华润定制）
// 说    明：该算子设计目的是规避华润客户那边生产中带来的爪（顶部固定缺陷）
// 时    间：2018年12月24日
******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopGlueDetectAlgo1(VARIANT* rgnId,VARIANT* pClosSize, VARIANT*pSeriousBlackPointSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int ClosSize = (int) pClosSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//

		Hobject OutRegion,TopInwallRegionOriginCls,TopInwallRegionOriginDif,TopInwallRegionOriginOpn,TopInwallRegionOriginTrans;
		Hobject TopInwallRegionOriginCon,DefectRegs;

		Hobject TopInwallRegionOrigin = m_TopInwallRegionOrigin;
		closing_circle(TopInwallRegionOrigin,&TopInwallRegionOriginCls,ClosSize);
		difference(TopInwallRegionOriginCls,TopInwallRegionOrigin,&TopInwallRegionOriginDif);
		opening_circle(TopInwallRegionOriginDif,&TopInwallRegionOriginOpn,1.5);
		connection(TopInwallRegionOriginOpn,&TopInwallRegionOriginCon);
		HTuple dArea,dCenterR,dCenterC,dAreaMax;
		area_center(TopInwallRegionOriginCon,&dArea,&dCenterR,&dCenterC);
		tuple_max(dArea,&dAreaMax);
		if (dAreaMax < 20)
		{
			difference(m_TopInwallRegionOrigin, m_TopInwallRegion, &OutRegion);
			Hobject RegionIntersction,InnerRegion,RegionUnion;
			intersection(m_TopInwallRegionOrigin, m_TopInwallRegion, &RegionIntersction);
			difference(m_TopInwallRegion, RegionIntersction, &InnerRegion);
			union2(InnerRegion, OutRegion, &RegionUnion);

			Hobject ConnectedRegions,RegionOpening,SelectedRegions;
			connection(RegionUnion, &ConnectedRegions);
			opening_circle(ConnectedRegions, &RegionOpening, 1.5);
			select_shape(RegionOpening, &SelectedRegions, "area", "and", SeriousBlackPointSize, 99999999);
			union1(SelectedRegions, &DefectRegs);
		}

		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopGlueDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1164$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 865;LP;1;400;1;50$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_SlopEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pTopSlopEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdge, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); //实际情况调整膨胀搜索区域

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDilation, m_ROI, &TopSlopSearchReg);
		reduce_domain(crtImg, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow,DefinedCol;
		//PartInterval=5;LineLength:=膨胀尺寸;RemoveSize=2
		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 2, &DefinedRow, &DefinedCol);
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
		m_TopSlopEdgeRow=TopSlopEdgeRow;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_SlopEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("997$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;150;1;58$\
					 998;LP;1;100;1;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：AB20_SideSlopRegionLocationAlgo 
** 功    能：提取20圆形覆膜胶塞的斜坡区域 
** 思    路：膨胀颈部区域 - 顶部区域 - 颈部区域 =  斜坡区域 
******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_TopRegion.Id() == H_EMPTY_REGION||m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple MoveSize;
		MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;
		//ARegionT为20圆形没有截除两端区域
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(ARegionT, &ARegionTDilation, 1, 200);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(ARegionT, &ARegionTMoved, -5, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);

		//与顶部区域作差
		Hobject TopSlopRegDiff;
		difference(ObjectSelected1,m_TopRegion,&TopSlopRegDiff);
		Hobject TopSlopRegClosing,TopSlopRegOpening;
		closing_circle(TopSlopRegDiff, &TopSlopRegClosing, 15);
		opening_circle(TopSlopRegClosing, &TopSlopRegOpening, 15);

		//缩放
		Hobject RegionClip;
		clip_region_rel(TopSlopRegOpening, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject TopSlopReg;
		erosion_rectangle1(RegionClip,&TopSlopReg,1,VErosionSize);
		m_vRgn[rId] = TopSlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6051$\
					 167;B$\
					 994;LP;1;150;1;1$\
					 995;LP;1;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：AB20_SideSlopRegionLocationAlgo1 
** 功    能：提取20圆形覆膜胶塞的斜坡区域 （根据AB20_SideSlopRegionLocationAlgo修改）
** 思    路：膨胀颈部区域 - 内壁区域膨胀 - 颈部区域 =  斜坡区域 
** 修改说明：将算法中的减去的顶部区域修改为：减去内壁区域的膨胀区域
******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo1(VARIANT* rgnId, VARIANT*pDilationSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//用于20圆形覆膜、口服液圆形胶塞
	int rId           = (int)rgnId->fltVal;
	float DilationSize   = (float)pDilationSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_TopInwallRegion.Id() == H_EMPTY_REGION||m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple MoveSize;
		MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;
		//ARegionT为20圆形没有截除两端区域
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(ARegionT, &ARegionTDilation, 1, 200);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(ARegionT, &ARegionTMoved, -5, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);

		//与顶部区域作差
		Hobject TopSlopRegDiff,TopRegion;
		dilation_circle(m_TopInwallRegion,&TopRegion,DilationSize);
		difference(ObjectSelected1,TopRegion,&TopSlopRegDiff);

		Hobject TopSlopRegClosing,RegionConnected,RegionSelect;
		connection(TopSlopRegDiff,&RegionConnected);
		select_shape_std(RegionConnected,&RegionSelect,"max_area",70);
		closing_circle(RegionSelect, &TopSlopRegClosing, 10);
		//水平垂直缩放
		Hobject RegionCliped,TopSlopReg,RegionErosion,RegionConnected1;
		clip_region_rel(TopSlopRegClosing,&RegionCliped,1,1,HErosionSize,HErosionSize);
		erosion_rectangle1(RegionCliped,&RegionErosion,1,VErosionSize);
		connection(RegionErosion,&RegionConnected1);
		select_shape_std(RegionConnected1,&TopSlopReg,"max_area",70);
		m_vRgn[rId] = TopSlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6052$\
					 167;B$\
					 1019;FP;1;55;0.5;10$\
					 994;LP;1;150;1;1$\
					 995;LP;1;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：AB20_SideSlopRegionLocationAlgo2 
** 功    能：提取20圆形覆膜胶塞的斜坡区域 （根据AB20_SideSlopRegionLocationAlgo1修改）
** 思    路：膨胀颈部区域 - 顶部搜索区域 - 颈部区域 =  斜坡区域 
** 修改说明：（1）时  间：2018年08月20日 
**                修改人：吴贻峰 
**                内  容：将算法中减去膨胀内壁区域的思路修改为减去顶部搜索区域
******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pEllipseMoveSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//用于20圆形覆膜、口服液圆形胶塞
	int   rId             = (int)rgnId->fltVal;
	//float DilationSize    = (float)pDilationSize->fltVal;
	int   EllipseMoveSize = (int) pEllipseMoveSize->fltVal;
	int   HErosionSize    = (int)pHErosionSize->fltVal;
	int   VErosionSize    = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_TopInwallRegion.Id() == H_EMPTY_REGION||m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple MoveSize;
		MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;
		//ARegionT为20圆形没有截除两端区域
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(ARegionT, &ARegionTDilation, 1, 200);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(ARegionT, &ARegionTMoved, -5, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);

		//与顶部区域作差
		//m_ContEllipse=rgn;
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -EllipseMoveSize, 0);
		Hobject Aroi,AroiClosing;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);

		Hobject TopSlopRegDiff,TopRegion;
		//dilation_circle(m_TopInwallRegion,&TopRegion,DilationSize);
		difference(ObjectSelected1,AroiClosing,&TopSlopRegDiff);

		Hobject TopSlopRegClosing,RegionConnected,RegionSelect;
		connection(TopSlopRegDiff,&RegionConnected);
		select_shape_std(RegionConnected,&RegionSelect,"max_area",70);
		closing_circle(RegionSelect, &TopSlopRegClosing, 10);
		//水平垂直缩放
		Hobject RegionCliped,TopSlopReg,RegionErosion,RegionConnected1;
		clip_region_rel(TopSlopRegClosing,&RegionCliped,1,1,HErosionSize,HErosionSize);
		erosion_rectangle1(RegionCliped,&RegionErosion,1,VErosionSize);
		connection(RegionErosion,&RegionConnected1);
		select_shape_std(RegionConnected1,&TopSlopReg,"max_area",70);
		m_vRgn[rId] = TopSlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6053$\
					 167;B$\
					 1384;LP;0;300;1;120$\
					 994;LP;1;150;1;1$\
					 995;LP;1;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************
** 函 数 名：AB20_SideSlopRegionLocationAlgo3 
** 功    能：提取20圆形覆膜胶塞的斜坡区域 （根据AB20_SideSlopRegionLocationAlgo2修改）
** 思    路：膨胀颈部区域 - 颈部基准椭圆（平移） - 颈部区域 =  斜坡区域 
** 修改说明：（1）时    间：2018年12月01日 
**                修 改 人：吴贻峰   
**                内    容：将算法中减去膨胀内壁区域的思路修改为减去m_ABEllipse(颈部基准椭圆)
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo3(VARIANT* rgnId, VARIANT* pEllipseMoveSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//用于20圆形覆膜、口服液圆形胶塞
	int   rId             = (int)rgnId->fltVal;
	//float DilationSize    = (float)pDilationSize->fltVal;
	int   EllipseMoveSize = (int) pEllipseMoveSize->fltVal;
	int   HErosionSize    = (int)pHErosionSize->fltVal;
	int   VErosionSize    = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_TopInwallRegion.Id() == H_EMPTY_REGION||m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple MoveSize;
		MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;
		//ARegionT为20圆形没有截除两端区域
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(ARegionT, &ARegionTDilation, 1, 200);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(ARegionT, &ARegionTMoved, -5, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);

		//与顶部区域作差
		//m_ABEllipse=rgn;
		Hobject TopEllipse;
		move_region(m_ABEllipse, &TopEllipse, -EllipseMoveSize, 0);
		Hobject Aroi,AroiClosing;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);

		Hobject TopSlopRegDiff,TopRegion;
		//dilation_circle(m_TopInwallRegion,&TopRegion,DilationSize);
		difference(ObjectSelected1,AroiClosing,&TopSlopRegDiff);

		Hobject TopSlopRegClosing,RegionConnected,RegionSelect;
		connection(TopSlopRegDiff,&RegionConnected);
		select_shape_std(RegionConnected,&RegionSelect,"max_area",70);
		closing_circle(RegionSelect, &TopSlopRegClosing, 10);
		//水平垂直缩放
		Hobject RegionCliped,TopSlopReg,RegionErosion,RegionConnected1;
		clip_region_rel(TopSlopRegClosing,&RegionCliped,1,1,HErosionSize,HErosionSize);
		erosion_rectangle1(RegionCliped,&RegionErosion,1,VErosionSize);
		connection(RegionErosion,&RegionConnected1);
		select_shape_std(RegionConnected1,&TopSlopReg,"max_area",70);
		m_vRgn[rId] = TopSlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_SideSlopRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6054$\
					 167;B$\
					 1384;LP;0;300;1;120$\
					 994;LP;1;150;1;1$\
					 995;LP;1;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//剪切两端区域
		Hobject ARegionDiff;
		clip_region_rel(m_ARegionT,&ARegionDiff,0,0,10,10);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(ARegionDiff,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		//缩放
		Hobject RegionClip;
		clip_region_rel(ARegionIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject NeckRegion;
		erosion_rectangle1(RegionClip,&NeckRegion,1,VErosionSize);

		m_vRgn[rId] = NeckRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1015$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;50;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************
***函数名：AB20_NeckRegionLocationAlgo2
***功  能：对AB20圆形胶塞的颈部区域上、下单边单独进行缩放
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//剪切两端区域
		Hobject ARegionDiff;
		clip_region_rel(m_ARegionT,&ARegionDiff,0,0,10,10);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(ARegionDiff,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		//缩放
		Hobject RegionClip;
		clip_region_rel(ARegionIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject NeckRegion;

		//
		Hobject RegionClipMoved;
		move_region(RegionClip,&RegionClipMoved,VErosionSize,0);
		intersection(RegionClip,RegionClipMoved,&NeckRegion);

		m_vRgn[rId] = NeckRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1015$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;50;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB32_NeckRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	// 修改说明：在20的该函数的基础上修改。由于在20的函数中颈部区域的检测之间必须进行斜坡区域检测，即给 m_ARegionT 赋值
	// 但是在32中侧面 斜坡区域和颈部区域的检测是分开的，因此将 m_ARegionT 的赋值操作移动到 颈部区域检测中；
	// 仅仅限于32检测
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION || m_ABEdge.Id() == H_EMPTY_REGION || m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple ht_MoveSize;
		ht_MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-ht_MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, ht_MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;

		//剪切两端区域
		Hobject ARegionDiff;
		clip_region_rel(m_ARegionT,&ARegionDiff,0,0,10,10);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(ARegionDiff,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		//缩放
		Hobject RegionClip;
		clip_region_rel(ARegionIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject NeckRegion;
		erosion_rectangle1(RegionClip,&NeckRegion,1,VErosionSize);

		m_vRgn[rId] = NeckRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1015$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;50;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：AB32_NeckRegionLocationAlgo1
***功  能：修改了改算子在下边缘剔除使用的区域：m_ABEdgeReg
***时  间：2019年12月06日
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_NeckRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pUpSize,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	// 修改说明：在20的该函数的基础上修改。由于在20的函数中颈部区域的检测之间必须进行斜坡区域检测，即给 m_ARegionT 赋值
	// 但是在32中侧面 斜坡区域和颈部区域的检测是分开的，因此将 m_ARegionT 的赋值操作移动到 颈部区域检测中；
	// 仅仅限于32检测 
	int rId            = (int)rgnId->fltVal;
	int UpSize         = (int)pUpSize->fltVal;
	int MoveSize       = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION || m_ABEdge.Id() == H_EMPTY_REGION || m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple ht_MoveSize;
		ht_MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-ht_MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, ht_MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;

		// 控制上边缘位置
		Hobject ARegionMovedDown,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMovedDown,UpSize,0);
		intersection(m_ARegionT,ARegionMovedDown,&ARegionIntersction);

		//剪切两端区域
		Hobject ARegionDiff;
		clip_region_rel(ARegionIntersction,&ARegionDiff,0,0,10,10);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject rgnABEdgeMovD,rgnABEdgeMovU,rgnABEdgeDil,ARegionMoved;
		HTuple  tMoveSize;
		move_region(m_ABEdgeReg,&rgnABEdgeMovD,2,0 );
		tMoveSize =  MoveSize + 2;
		move_region(rgnABEdgeMovD,&rgnABEdgeMovU,-tMoveSize/2,0 );
		dilation_rectangle1(rgnABEdgeMovU,&rgnABEdgeDil,tMoveSize,1);

		//gen_empty_region(&rgnABEdgeDil );

		difference(ARegionDiff,rgnABEdgeDil,&ARegionMoved );
		connection(ARegionMoved,&ARegionMoved );
		select_shape_std(ARegionMoved,&ARegionMoved,"max_area",70 );

		//move_region(ARegionDiff,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,ARegionIntersction,&ARegionIntersction);

		//缩放
		Hobject RegionClip;
		clip_region_rel(ARegionIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject NeckRegion;
		erosion_rectangle1(RegionClip,&NeckRegion,1,VErosionSize);

		m_vRgn[rId] = NeckRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1015$\
					 167;B$\
					 6010;LP;1;50;1;8$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;50;1;10$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：AB20_NeckRegionLocationAlgo1
***功  能：对AB20圆形胶塞的颈部上、下区域进行定位
***原  理：通过覆膜上下边缘进行膨胀与颈部整体区域进行减操作，得到上下区域；pSelection控制
需要计算的是上区域还是下区域
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize1)
{
	//20圆形覆膜胶塞，G20_DownEdgeDetectAlgo
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		HTuple area,row,col,areaX,rowX,colX;
		area_center(m_DownEdge,&area,&row,&col);
		area_center(m_DownEdgeX,&areaX,&rowX,&colX);
		if (area>0 && areaX>0)
		{
			if (Selection==1)  //颈部上部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff;
				dilation_circle(m_DownEdgeX,&MidldleRegDilation,DilationSize1);
				//防止提取的下部边缘小于m_ARegionT水平宽度
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff);
				Hobject ARegionDiff1Connected,SortedRegions,ARegionDiff1;
				connection(ARegionDiff,&ARegionDiff1Connected);

				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 2.5);

				union1(RegionSelected0,&ARegionDiff1);
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff1;
				dilation_circle(m_DownEdge,&MidldleRegDilation,DilationSize1);
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
				//
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff1,&ARegionDiff1Connected);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 1);
				difference(SortedRegions,RegionSelected,&RegionSelected);
				//difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionSelected, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			//水平缩放
			clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
			opening_circle(RegionSelected0, &RegionSelected0, 5.5);
			union1(RegionSelected0,&RegionSelected0);	
			m_vRgn[rId] = RegionSelected0;	
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5527$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1113;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：AB20_NeckRegionLocationAlgo3
***功  能：对AB20圆形胶塞的颈部上、下区域进行定位
***原  理：通过覆膜上下边缘进行膨胀与颈部整体区域进行减操作，得到上下区域；pSelection控制需要计算的是上区域还是下区域
***说  明：（1）该算子是在AB20_NeckRegionLocationAlgo1 的基准上进行修改，增加了上位置控制参数
***时  间：2019年05月23日
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo3(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pUpSize,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize1)
{
	//20圆形覆膜胶塞，G20_DownEdgeDetectAlgo
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal; 
	int MoveSize   = (int)pMoveSize->fltVal;
	int UpSize   = (int)pUpSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		// 控制上边缘位置
		Hobject ARegionMovedDown ;
		move_region(m_ARegionT,&ARegionMovedDown,UpSize,0);
		intersection(ARegionMoved,ARegionMovedDown,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		HTuple area,row,col,areaX,rowX,colX;
		area_center(m_DownEdge,&area,&row,&col);
		area_center(m_DownEdgeX,&areaX,&rowX,&colX);
		if (area>0 && areaX>0)
		{
			if (Selection==1)  //颈部上部区域
			{
				//中部边缘缩放 m_DownEdge,m_DownEdgeX
				//m_ABEdgeM=ABEdgeM;
			   // m_ABEdgeRowM=ABEdgeRowM;

				Hobject ABEdgeRowMMoved;
				HTuple dArea,dCenRow,dCenCol,dMovSize;
				area_center(m_DownEdge,&dArea,&dCenRow,&dCenCol );
				HTuple dAreaX,dCenRowX,dCenColX;
				area_center(m_DownEdgeX,&dAreaX,&dCenRowX,&dCenColX );

				dMovSize = dCenRowX - dCenRow;
				move_region(m_DownEdgeX,&ABEdgeRowMMoved,-dMovSize,0 );


				Hobject MidldleRegDilation,ARegionDiff;
				dilation_circle(ABEdgeRowMMoved,&MidldleRegDilation,DilationSize1);
				//防止提取的下部边缘小于m_ARegionT水平宽度
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff);
				Hobject ARegionDiff1Connected,SortedRegions,ARegionDiff1;
				connection(ARegionDiff,&ARegionDiff1Connected);

				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 2.5);

				union1(RegionSelected0,&ARegionDiff1);
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff1;
				dilation_circle(m_DownEdge,&MidldleRegDilation,DilationSize1);
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
				//
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff1,&ARegionDiff1Connected);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 1);
				difference(SortedRegions,RegionSelected,&RegionSelected);
				//difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionSelected, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			//水平缩放
			clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
			opening_circle(RegionSelected0, &RegionSelected0, 5.5);
			union1(RegionSelected0,&RegionSelected0);	
			m_vRgn[rId] = RegionSelected0;	
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_NeckRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5527$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 6010;LP;1;50;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1113;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pABHErosionSize, VARIANT* pABVErosionSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;

	int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	int ABVErosionSize   = (int)pABVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_WholeRoi.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//剔除AB基准线附近的反光干扰区域ABEdge
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdge,&RegionDilation, ABHErosionSize, ABVErosionSize);
		move_region(RegionDilation, &ABEdgeMoved, ABVErosionSize/2-3, 0);

		Hobject TotallRoi;
		erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
		difference(TotallRoi,ABEdgeMoved,&TotallRoi);
		union1(TotallRoi,&TotallRoi);
		m_vRgn[rId] = TotallRoi ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1068;LP;1;35;1;5$\
					 1069;LP;9;35;1;10$\
					 1063;LP;1;45;1;12");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************************************
**函数名：AB20_TopInwallRegionLocationAlgo
**功  能：针对内壁工位中胶塞内壁区域定位
**思  路：从 AB32_InnerWallRegDetectAlgo 算子中传递变量m_TopInwallRegion，进行简单操作
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_TopInwallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pOpeningSize,VARIANT* pClosingSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	float OpeningSize   = (float)pOpeningSize->fltVal;
	float ClosingSize   = (float)pClosingSize->fltVal;

	int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_TopInwallRegion.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopInwallRegion,RegionFillUp,RegionOpening,RegionClosing,rgnClsCon,rgnClsSel;
		fill_up(m_TopInwallRegion, &RegionFillUp);
		opening_circle(RegionFillUp, &RegionOpening, OpeningSize);
		closing_circle(RegionOpening, &RegionClosing, ClosingSize);
		connection(RegionClosing,&rgnClsCon);
		select_shape_std(rgnClsCon,&rgnClsSel,"max_area", 70);

		erosion_circle(rgnClsSel,&TopInwallRegion, ErosionSize);
		m_vRgn[rId] = TopInwallRegion ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_TopInwallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1083$\
					 167;B$\
					 864;FP;1;35;0.5;3$\
					 1093;FP;1;35;0.5;3$\
					 718;LP;1;55;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************************************
**函数名：AB32_TopInwallRegionLocationAlgo
**功  能：针对内壁工位中胶塞内壁区域定位
**思  路：（1）AB32_InnerWallRegDetectAlgo 算子中传递变量m_TopInwallRegion（内壁区域的粗略提取）
**        （2）在该算子中进行较为精确的控制，包括上下边缘的控制
          （3）优化AB20_TopInwallRegionLocationAlgo算子在区域边缘存在缺陷导致定位遗漏的问题
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_TopInwallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pUpEdgePos,VARIANT* pDownEdgePos,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	float dUpEdgePos   = (float)pUpEdgePos->fltVal;
	float dDownEdgePos   = (float)pDownEdgePos->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_TopInwallRegion.Id()==H_EMPTY_REGION || ( m_rgnTopSel.Id() == H_EMPTY_REGION ))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnTopROISel = m_rgnTopSel;
		Hobject  rgnInnerWallSel = m_TopInwallRegion;
		Hobject rgnTopInWallDif,rgnTopROIEro,RegionBottom,RegionBottomOpn,RegionBottomCon,RegionBottomSel;
		difference(rgnTopROISel, rgnInnerWallSel, &rgnTopInWallDif);
		
		// get the bottom region 
		erosion_circle(rgnTopROISel, &rgnTopROIEro, 40.5);
		intersection(rgnTopROIEro, rgnTopInWallDif, &RegionBottom);
		opening_circle(RegionBottom, &RegionBottomOpn, 30);
		connection(RegionBottomOpn, &RegionBottomCon);
		select_shape_std(RegionBottomCon, &RegionBottomSel, "max_area", 70);

		// union the top region and the bottom region 
		Hobject rgnInner,rgnInnerTrans,RegionBottomTrans;
		union2(RegionBottomSel, rgnInnerWallSel, &rgnInner);
		shape_trans(rgnInner, &rgnInnerTrans, "convex");
		shape_trans(RegionBottomOpn, &RegionBottomTrans, "convex");

		// erosion the outer and inner edges
		Hobject rgnInnerEro,RegionBottomDil,rgnInnerWallROIOri,rgnInnerWallROIOpn,rgnInnerWallROICon,rgnInnerWallROI;
		if (dUpEdgePos >= 0 )
		{
			erosion_circle(rgnInnerTrans, &rgnInnerEro, dUpEdgePos+0.5);
		}
		else
		{
		    dilation_circle(rgnInnerTrans, &rgnInnerEro, -dUpEdgePos);
		}
		
		dilation_circle(RegionBottomTrans, &RegionBottomDil,dDownEdgePos);
		difference(rgnInnerEro, RegionBottomDil, &rgnInnerWallROIOri);

		opening_circle(rgnInnerWallROIOri, &rgnInnerWallROIOpn,10.5);
		connection(rgnInnerWallROIOpn, &rgnInnerWallROICon);
		select_shape_std(rgnInnerWallROICon, &rgnInnerWallROI, "max_area", 70);

		erosion_circle(rgnInnerWallROI,&rgnInnerWallROI, ErosionSize);
		m_vRgn[rId] = rgnInnerWallROI ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_TopInwallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5513$\
					 167;B$\
					 5509;FP;-10;100;0.5;6.0$\
					 5510;FP;1;55;0.5;6.0$\
					 5511;FP;1;50;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************************************
**函数名：AB32_TopHighLightRegionLocationAlgo
**功  能：针对内壁工位中胶塞顶部高亮区域定位
**思  路：（1）AB32_InnerWallRegDetectAlgo 算子中传递变量m_TopInwallRegion（内壁区域的粗略提取）
**        （2）AB32_TopInwallRegionLocationAlgo 传递变量 m_rgnBottom （内底区域精确定位）
**时  间：2019年5月16日
**作  者：WuYifeng
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_TopHighLightRegionLocationAlgo(VARIANT* rgnId, VARIANT* pOuterEdge,VARIANT* pInnerEdge,VARIANT* pBottomSize)
{
	int rId           = (int)rgnId->fltVal;
	float dOuterEdge   = (float)pOuterEdge->fltVal;
	float dInnerEdge   = (float)pInnerEdge->fltVal;
	float dBottomSize   = (float)pBottomSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_TopInwallRegion.Id()==H_EMPTY_REGION) || ( m_rgnBottom.Id()==H_EMPTY_REGION ) || (m_rgnTopSel.Id() ==H_EMPTY_REGION ))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnTopROISel    = m_rgnTopSel;               // 顶部整体区域（顶部高亮+内壁+内底）
		Hobject rgnInnerWallSel = m_TopInwallRegion;         // 内壁区域
		Hobject rgnBottom       = m_rgnBottom;               // 内底区域

		Hobject rgnTopROISelTrans,rgnTopROISelDil,rgnTopBottom,rgnBottomDil,rgnWallBottom,rgnWallBottomTrans;
		
		shape_trans(rgnTopROISel, &rgnTopROISelTrans, "convex");
		if (dOuterEdge > 0 )
		{
			dilation_circle(rgnTopROISelTrans, &rgnTopROISelDil, dOuterEdge);
		}
		else if(dOuterEdge < 0)
		{
			erosion_circle(rgnTopROISelTrans, &rgnTopROISelDil, abs(dOuterEdge));
		}
		else
		{
			rgnTopROISelDil = rgnTopROISelTrans;
		}
		
        difference(rgnTopROISelDil, rgnInnerWallSel, &rgnTopBottom);

		dilation_circle(rgnBottom, &rgnBottomDil, dBottomSize);
        union2(rgnInnerWallSel, rgnBottomDil, &rgnWallBottom);
        shape_trans(rgnWallBottom, &rgnWallBottomTrans, "convex");

		 //内边沿缩放
		Hobject rgnWallBottomTransDil,rgnTopOri,rgnTopOriOpn,rgnTopOriCon,rgnTopHighLight;

		if (dInnerEdge > 0 )
		{
			dilation_circle(rgnWallBottomTrans, &rgnWallBottomTransDil, dInnerEdge );
		}
		else if(dInnerEdge <  0)
		{
			erosion_circle(rgnWallBottomTrans, &rgnWallBottomTransDil, abs(dInnerEdge));
		}
		else
		{
			rgnWallBottomTransDil = rgnWallBottomTrans;
		}

        difference(rgnTopBottom, rgnWallBottomTransDil, &rgnTopOri);
        opening_circle(rgnTopOri, &rgnTopOriOpn, 3.5);
        connection(rgnTopOriOpn, &rgnTopOriCon);
        select_shape_std(rgnTopOriCon, &rgnTopHighLight, "max_area", 70);
		intersection(rgnTopHighLight,m_ROI,&rgnTopHighLight);

		m_vRgn[rId] = rgnTopHighLight ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_TopHighLightRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5514$\
					 167;B$\
					 5515;FP;-10;50;0.5;1.5$\
					 5516;FP;-10;50;0.5;3.5$\
					 5517;FP;1;55;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB32_TopHighLightRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pOuterEdge,VARIANT* pInnerEdge,VARIANT* pBottomSize,VARIANT* pUpPose,VARIANT* pDownPose)
{
	int rId           = (int)rgnId->fltVal;
	float dOuterEdge   = (float)pOuterEdge->fltVal;
	float dInnerEdge   = (float)pInnerEdge->fltVal;
	float dBottomSize   = (float)pBottomSize->fltVal;
    int   UpPose       =  (int)pUpPose->fltVal;
	int   DownPose     =  (int)pDownPose->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_TopInwallRegion.Id()==H_EMPTY_REGION) || ( m_rgnBottom.Id()==H_EMPTY_REGION ) || (m_rgnTopSel.Id() ==H_EMPTY_REGION ))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnTopROISel    = m_rgnTopSel;               // 顶部整体区域（顶部高亮+内壁+内底）
		Hobject rgnInnerWallSel = m_TopInwallRegion;         // 内壁区域
		Hobject rgnBottom       = m_rgnBottom;               // 内底区域

		Hobject rgnTopROISelTrans,rgnTopROISelDil,rgnTopBottom,rgnBottomDil,rgnWallBottom,rgnWallBottomTrans;

		shape_trans(rgnTopROISel, &rgnTopROISelTrans, "convex");
		if (dOuterEdge > 0 )
		{
			dilation_circle(rgnTopROISelTrans, &rgnTopROISelDil, dOuterEdge);
		}
		else if(dOuterEdge < 0)
		{
			erosion_circle(rgnTopROISelTrans, &rgnTopROISelDil, abs(dOuterEdge));
		}
		else
		{
			rgnTopROISelDil = rgnTopROISelTrans;
		}

		difference(rgnTopROISelDil, rgnInnerWallSel, &rgnTopBottom);

		dilation_circle(rgnBottom, &rgnBottomDil, dBottomSize);
		union2(rgnInnerWallSel, rgnBottomDil, &rgnWallBottom);
		shape_trans(rgnWallBottom, &rgnWallBottomTrans, "convex");

		//内边沿缩放
		Hobject rgnWallBottomTransDil,rgnTopOri,rgnTopOriOpn,rgnTopOriCon,rgnTopHighLight;

		if (dInnerEdge > 0 )
		{
			dilation_circle(rgnWallBottomTrans, &rgnWallBottomTransDil, dInnerEdge );
		}
		else if(dInnerEdge <  0)
		{
			erosion_circle(rgnWallBottomTrans, &rgnWallBottomTransDil, abs(dInnerEdge));
		}
		else
		{
			rgnWallBottomTransDil = rgnWallBottomTrans;
		}

		difference(rgnTopBottom, rgnWallBottomTransDil, &rgnTopOri);
		opening_circle(rgnTopOri, &rgnTopOriOpn, 3.5);
		connection(rgnTopOriOpn, &rgnTopOriCon);
		select_shape_std(rgnTopOriCon, &rgnTopHighLight, "max_area", 70);

		intersection(rgnTopHighLight,m_ROI,&rgnTopHighLight);

		HTuple dRowCenter,dColCenter,dPhi,dLen1,dLen2;
		Hobject rgnRectUp,rgnRectDown,rgnDiff1,rgnDiff1Con,rgnSel1,rgnTopHighLight1;
		// 上边缘控制
		smallest_rectangle2(rgnTopHighLight,&dRowCenter,&dColCenter,&dPhi,&dLen1,&dLen2);
		if (dLen2 > UpPose)
		{
			gen_rectangle2(&rgnRectUp,dRowCenter,dColCenter,0,dLen1,dLen2-UpPose);
		}
		else
			rgnRectUp = rgnTopHighLight;

		difference(rgnTopHighLight,rgnRectUp,&rgnDiff1);
		connection(rgnDiff1,&rgnDiff1Con);
		select_shape(rgnDiff1Con,&rgnSel1,"row","and",0,dRowCenter);
		difference(rgnTopHighLight,rgnSel1,&rgnTopHighLight1);

		// 下边缘控制

		if (dLen2 > DownPose)
		{
			gen_rectangle2(&rgnRectDown,dRowCenter,dColCenter,0,dLen1,dLen2-DownPose);
		}
		else
			rgnRectUp = rgnTopHighLight;

		Hobject rgnDiff2,rgnDiff2Con,rgnSel2,rgnTopHighLight2;
		difference(rgnTopHighLight,rgnRectDown,&rgnDiff2);
		connection(rgnDiff2,&rgnDiff2Con);
		select_shape(rgnDiff2Con,&rgnSel2,"row","and",dRowCenter,999999);
		difference(rgnTopHighLight1,rgnSel2,&rgnTopHighLight2);
		

		m_vRgn[rId] = rgnTopHighLight2 ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_TopHighLightRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6078$\
					 167;B$\
					 5515;FP;-10;50;0.5;1.5$\
					 5516;FP;-10;50;0.5;3.5$\
					 5517;FP;1;55;0.5;3.5$\
					 5509;LP;1;120;1;0$\
					 5510;LP;1;120;1;0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**********************************************************************
*** 函数名：AB32_BottomBorderRegionLocationAlgo
*** 功  能：针对32型胶塞，提取胶塞的内壁边缘区域
**  时  间： 2019年5月16日
***********************************************************************/
STDMETHODIMP CPlugAlgo::AB32_BottomBorderRegionLocationAlgo(VARIANT* rgnId,VARIANT* pLowThred, VARIANT* pUpEdgeSize,VARIANT* pDownEdgeSize,VARIANT* pHClipSize)
{
	int rId           = (int)rgnId->fltVal;
	float LowThred   = (float)pLowThred->fltVal;
	float dUpEdgeSize   = (float)pUpEdgeSize->fltVal;
	float dDownEdgeSize   = (float)pDownEdgeSize->fltVal;
	float dHClipSize   = (float)pHClipSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_TopInwallRegion.Id()==H_EMPTY_REGION) || ( m_rgnBottom.Id()==H_EMPTY_REGION ) )
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnInnerWallSel = m_TopInwallRegion;         // 内壁区域
		Hobject rgnBottom       = m_rgnBottom;               // 内底区域

		Hobject rgnBottomDil,rgnWallBottom,rgnWallBottomTrans;
		dilation_circle(rgnBottom, &rgnBottomDil, 5);
        union2(rgnInnerWallSel, rgnBottomDil, &rgnWallBottom);
        shape_trans(rgnWallBottom, &rgnWallBottomTrans, "convex");

		Hobject rgnDiff1,rgnInnerWallROIMov,rgnInnerWallROIDil;
		difference(rgnWallBottomTrans, rgnBottom, &rgnDiff1);
        move_region(rgnInnerWallSel, &rgnInnerWallROIMov, -40, 0);
        dilation_rectangle1(rgnInnerWallROIMov, &rgnInnerWallROIDil, 40, 10);

		Hobject rgnInnerBorderOri,rgnInnerBorderOpn,rgnInnerBorderCon,rgnInnerBorderSel;
		difference(rgnDiff1, rgnInnerWallROIDil, &rgnInnerBorderOri);
        opening_circle(rgnInnerBorderOri, &rgnInnerBorderOpn, 3.5);
        connection(rgnInnerBorderOpn, &rgnInnerBorderCon);
        select_shape_std(rgnInnerBorderCon, &rgnInnerBorderSel, "max_area", 70);

		// 阈值提取
		Hobject imgInnerBorderOpn,rgnBorderThr,rgnBorderOpn,rgnBorderFil,rgnBorderCon,rgnBorder;
		reduce_domain(m_ImageScaleMax, rgnInnerBorderSel, &imgInnerBorderOpn);
        threshold(imgInnerBorderOpn, &rgnBorderThr, LowThred, 255);
        fill_up(rgnBorderThr, &rgnBorderFil);
        opening_circle(rgnBorderFil, &rgnBorderOpn, 6.5);
        connection(rgnBorderOpn, &rgnBorderCon);
        select_shape_std(rgnBorderCon, &rgnBorder, "max_area", 70);

		// 上下边缘控制
		Hobject rgnBorderMov,rgnBorderMov1;
		if ( dUpEdgeSize < dDownEdgeSize)
		{
			 move_region(rgnBorder, &rgnBorderMov, (Hlong)-dDownEdgeSize, 0);
             move_region(rgnBorder, &rgnBorderMov1, (Hlong)-dUpEdgeSize, 0);
		}
		else
		{
			 move_region(rgnBorder, &rgnBorderMov, (Hlong)-dUpEdgeSize, 0);
             move_region(rgnBorder, &rgnBorderMov1, (Hlong)-dDownEdgeSize, 0);
		}

		Hobject rgnBorderUpOri,rgnBorderUpOpn,rgnBorderUpCon,rgnBorderUpClip,rgnBorderUp;
		difference(rgnBorderMov, rgnBorderMov1, &rgnBorderUpOri);
        opening_circle(rgnBorderUpOri, &rgnBorderUpOpn, 1.5);

        clip_region_rel(rgnBorderUpOpn, &rgnBorderUpClip, 0, 0, (Hlong)dHClipSize, (Hlong)dHClipSize);

		connection(rgnBorderUpClip, &rgnBorderUpCon);
        select_shape_std(rgnBorderUpCon, &rgnBorderUp, "max_area", 70);

		m_rgnBorder    = rgnBorder;

		m_vRgn[rId] = rgnBorderUp ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_BottomBorderRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6080$\
					 167;B$\
					 6079;FP;10;250;0.5;120$\
					 5509;FP;1;120;0.5;10$$\
					 5510;FP;0;30;0.5;0$$\
					 5512;FP;1;125;0.5;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB32_BottomEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pSelection, VARIANT* pUpEdgeSize,VARIANT* pDownEdgeSize,VARIANT* pHClipSize,VARIANT* pScaleSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	float dUpEdgeSize   = (float)pUpEdgeSize->fltVal;
	float dDownEdgeSize   = (float)pDownEdgeSize->fltVal;
	float dHClipSize   = (float)pHClipSize->fltVal;
	float ScaleSize   = (float)pScaleSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_rgnBottom.Id()==H_EMPTY_REGION)|| (m_TopInwallRegion.Id()==H_EMPTY_REGION) || (m_rgnBorder.Id()==H_EMPTY_REGION ) )
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnBottom = m_rgnBottom;                     // 内底区域
		Hobject TopInwallRegion = m_TopInwallRegion;         
		Hobject rgnInnerWallSel = m_TopInwallRegion;         // 内壁区域
		Hobject rgnBorder       = m_rgnBorder;               // 高亮边缘整体区域
		
		Hobject rgnBorderThr;
		// 内底边缘高亮区域
		if (Selection ==1  )
		{
			// 上下边缘控制
			Hobject rgnBorderMov,rgnBorderMov1;
			if ( dUpEdgeSize < dDownEdgeSize)
			{
				move_region(rgnBorder, &rgnBorderMov, (Hlong)dDownEdgeSize, 0);
				move_region(rgnBorder, &rgnBorderMov1, (Hlong)dUpEdgeSize, 0);
			}
			else
			{
				move_region(rgnBorder, &rgnBorderMov, (Hlong)dUpEdgeSize, 0);
				move_region(rgnBorder, &rgnBorderMov1, (Hlong)dDownEdgeSize, 0);
			}

			Hobject rgnBorderUpOri,rgnBorderUpOpn,rgnBorderUpCon,rgnBorderUpClip,rgnBorderUp;
			difference(rgnBorderMov, rgnBorderMov1, &rgnBorderUpOri);
			opening_circle(rgnBorderUpOri, &rgnBorderUpOpn, 1.5);
			clip_region_rel(rgnBorderUpOpn, &rgnBorderUpClip, 0, 0, (Hlong)dHClipSize, (Hlong)dHClipSize);
			connection(rgnBorderUpClip, &rgnBorderUpCon);
			select_shape_std(rgnBorderUpCon, &rgnBorderUp, "max_area", 70);

			erosion_circle(rgnBorderUp,&rgnBorderUp, ScaleSize );

			m_vRgn[rId] = rgnBorderUp ;
		}
		else if ( Selection == 2 )
		{
			// 内底边缘拐角区域
			Hobject rgnBottomDil,rgnWallBottom,rgnWallBottomTrans;
			dilation_circle(rgnBottom, &rgnBottomDil, 5);
			union2(rgnInnerWallSel, rgnBottomDil, &rgnWallBottom);
			shape_trans(rgnWallBottom, &rgnWallBottomTrans, "convex");

			Hobject rgnBorderClip,rgnBorderDil,rgnInwallSide,rgnBorderSideOri1 ;
			clip_region_rel(rgnBorder, &rgnBorderClip, 0, 0, (Hlong)dHClipSize, (Hlong)dHClipSize);
			dilation_rectangle1(rgnBorderClip, &rgnBorderDil, 3, 20);

			difference(rgnWallBottomTrans, rgnBottom, &rgnInwallSide);
			difference(rgnInwallSide, rgnInnerWallSel, &rgnBorderSideOri1);

			Hobject RegionDilation1,rgnBorderSideOri,rgnBorderSideOriCon,rgnBorderSide;
			dilation_circle(rgnBorderSideOri1, &RegionDilation1, 3.5);

			difference(rgnBorderSideOri1, rgnBorderDil, &rgnBorderSideOri);
			opening_circle(rgnBorderSideOri, &rgnBorderSideOri, 3.5);
			connection(rgnBorderSideOri, &rgnBorderSideOriCon);
			select_shape(rgnBorderSideOriCon, &rgnBorderSide, "area", "and", 150, 99999999);

			erosion_circle(rgnBorderSide,&rgnBorderSide,ScaleSize );

			m_vRgn[rId] = rgnBorderSide ;
		}

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_BottomEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6124$\
					 167;B$\
					 6125;LP;1;2;1;2$\
					 5509;FP;-70;30;0.5;-45$\
					 5510;FP;-70;30;0.5;-5$\
					 5512;FP;1;125;0.5;30$\
					 1063;FP;1;50;0.5;1.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/**************************************************************************************************
**函数名：SideTopHighLightRegionLocationAlgo
**功  能：针对侧面工位中胶塞顶部高亮区域定位
**思  路：（1）需要顶部高亮区域定位算子传递 m_TopRegion 参数
**时  间：2019年6月14日
**作  者：WuYifeng
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::SideTopHighLightRegionLocationAlgo(VARIANT* rgnId, VARIANT* pOuterEdge,VARIANT* pMoveSize)
{
	int rId           = (int)rgnId->fltVal;
	float dOuterEdge   = (float)pOuterEdge->fltVal;
	float MoveSize   = (float)pMoveSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_TopRegion.Id()==H_EMPTY_REGION) )
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnTop = m_TopRegion;
		Hobject rgnTopHighLightEro,rgnTopOriOpn,rgnTopOriCon,rgnTopHighLight,rgnTopOriCls;
		erosion_circle(rgnTop,&rgnTopHighLightEro,dOuterEdge);
        opening_circle(rgnTopHighLightEro, &rgnTopOriOpn, 3.5);
		closing_circle(rgnTopOriOpn,&rgnTopOriCls,15);
        connection(rgnTopOriCls, &rgnTopOriCon);
        select_shape_std(rgnTopOriCon, &rgnTopHighLight, "max_area", 70);

		if( MoveSize != 0)
		{
			move_region(rgnTopHighLight,&rgnTopHighLight,(Hlong)MoveSize,0);
		}

		m_vRgn[rId] = rgnTopHighLight ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideTopHighLightRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6055$\
					 167;B$\
					 5515;FP;1;50;0.5;1.5$\
					 5008;FP;-50;50;0.5;1.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB20_CrownCircleRegionLocationAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pRadius1, VARIANT* pRoiWidth1, VARIANT* pRadius2, VARIANT* pRoiWidth2)
{
	//得到环形区域
	int id = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;

	float Radius1 =(float)pRadius1->fltVal;
	float RoiWidth1 = (float)pRoiWidth1->fltVal;

	if(RoiWidth1>=Radius1-5)
	{
		RoiWidth1 = Radius1-5 ;
	}

	float Radius2 =(float)pRadius2->fltVal;
	float RoiWidth2 = (float)pRoiWidth2->fltVal;

	if(RoiWidth2>=Radius2-5)
	{
		RoiWidth2 = Radius2-5 ;
	}

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0)||(m_InnerCircleRow.Num()!=1)||(m_InnerCircleCol.Num()!=1))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	if((Radius1>=Radius-2)||(Radius2>=Radius-5))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

	Hobject  RegionDetect;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}

		Hobject Circle,Circle1,Circle2,Circle3,Circle4,InnerCircle,OutCircle;
		gen_circle(&Circle, fCenterY, fCenterX, Radius);

		gen_circle(&Circle1, m_InnerCircleRow, m_InnerCircleCol, Radius1);
		gen_circle(&Circle2,m_InnerCircleRow, m_InnerCircleCol, Radius1-RoiWidth1);
		difference(Circle1, Circle2, &InnerCircle);

		gen_circle(&Circle3, m_InnerCircleRow, m_InnerCircleCol, Radius2);
		gen_circle(&Circle4, m_InnerCircleRow, m_InnerCircleCol, Radius2-RoiWidth2);
		difference(Circle3, Circle4, &OutCircle);

		Hobject RegionUnion;
		union2(InnerCircle, OutCircle, &RegionUnion);
		difference(Circle,RegionUnion,&RegionDetect);

		m_vRgn[id] = RegionDetect ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_CrownCircleRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1235$\
					 167;B$\
					 1236;FP;10.0;315.0;0.5;250$\
					 1237;FP;1.0;100;0.5;85$\
					 1238;FP;1.0;60;0.5;30$\
					 1239;FP;10.0;210.0;0.5;130$\
					 1240;FP;1.0;105;0.5;30"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
**函 数 名：D20_SideTopRegAngleDetectAlgo
**功    能：D20_侧面之20三叉顶部角度定位
**作    者: Yangb
***************************************************************************/
STDMETHODIMP CPlugAlgo::D20_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pAreaLimitLower,VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		//灰度均值进行阈值分割
		Hobject ImageReducedAroiScaled;
		scale_image_max(ImageReducedAroi,&ImageReducedAroiScaled);
		HTuple Mean,Deviation;
		intensity(AroiClosing,ImageReducedAroiScaled,&Mean,&Deviation);
		if (Mean.Num()!=1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}	
		if(Mean[0].D()+ThredLower>=255.0)
		{
			ThredLower=254.0-Mean[0].D();
		}

		Hobject TopRegions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroiScaled, &TopRegions, Mean+ThredLower, 255);

		m_TopRegions=TopRegions;
		Hobject TopRegionsFillUp;
		fill_up(TopRegions,&TopRegionsFillUp);
		Hobject TopRegionOpening,TopRegionClosing,TopRegionConnected,SelectedRegions;
		opening_circle(TopRegionsFillUp, &TopRegionOpening, 3.5);
		closing_circle(TopRegionOpening, &TopRegionClosing, 3.5);
		connection(TopRegionClosing, &TopRegionConnected);
		select_shape(TopRegionConnected, &SelectedRegions, "area", "and", AreaLimitLower, 99999999);

		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(SelectedRegions, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		Hobject TopRegionUnion;
		HTuple TopCenTerArea, TopCenTerRow, TopCenTerCol;
		union1(SelectedRegions, &TopRegionUnion);
		area_center(TopRegionUnion, &TopCenTerArea, &TopCenTerRow, &TopCenTerCol);

		m_TopRegionUnion = TopRegionUnion;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopRegionUnion, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
		}

		//3个顶部区域
		if (TopRegionRow.Num()!=3)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		HTuple TopRegionRowSorted,FirstRow,FirstCol,FirstIndice;
		tuple_sort(TopRegionRow, &TopRegionRowSorted);
		FirstRow = TopRegionRowSorted.Select(2);
		tuple_find(TopRegionRow, FirstRow, &FirstIndice);
		FirstCol = TopRegionCol.Select(FirstIndice.Select(0));
		Hobject AngleRegionLine;
		gen_region_line(&AngleRegionLine, TopCenTerRow, TopCenTerCol, FirstRow, FirstCol);
		HTuple Angle;
		orientation_region(AngleRegionLine, &Angle);
		if (0 != (Angle<0))
		{
			Angle += PI;
		}
		m_Angle=Angle;

		//两个叉口，求关于中心点的对称点，TopRegionRowSorted[0]、TopRegionRowSorted[1]
		//这两个对称点处的叉口存在平台
		HTuple ProngRow1,ProngRow2,ProngRow1Indice,ProngRow2Indice;
		HTuple ProngCol1,ProngCol2;
		HTuple SymProngRowL,SymProngColL,SymProngRowR,SymProngColR;
		ProngRow1 = TopRegionRowSorted.Select(0);
		ProngRow2 = TopRegionRowSorted.Select(1);

		tuple_find(TopRegionRow, ProngRow1, &ProngRow1Indice);
		tuple_find(TopRegionRow, ProngRow2, &ProngRow2Indice);

		ProngCol1 = TopRegionCol.Select(ProngRow1Indice.Select(0));
		ProngCol2 = TopRegionCol.Select(ProngRow2Indice.Select(0));
		if (0 != (ProngCol1>TopCenTerCol))
		{
			SymProngRowL = (2*TopCenTerRow)-ProngRow1;
			SymProngColL = (2*TopCenTerCol)-ProngCol1;
			SymProngRowR = (2*TopCenTerRow)-ProngRow2;
			SymProngColR = (2*TopCenTerCol)-ProngCol2;
		}
		else
		{
			SymProngRowR = (2*TopCenTerRow)-ProngRow1;
			SymProngColR = (2*TopCenTerCol)-ProngCol1;
			SymProngRowL = (2*TopCenTerRow)-ProngRow2;
			SymProngColL = (2*TopCenTerCol)-ProngCol2;
		}
		m_TopRow=TopCenTerRow;
		m_TopCol=TopCenTerCol;
		m_SymProngRowR=SymProngRowR;
		m_SymProngColR=SymProngColR;
		m_SymProngRowL=SymProngRowL;
		m_SymProngColL=SymProngColL;


		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AngleRegionLine, &m_vRgn[rId]);
		}
		//
		HTuple AngleLineArea,AngleLineRow,AngleLineCol,Deg;
		area_center(AngleRegionLine,&AngleLineArea,&AngleLineRow,&AngleLineCol);
		tuple_deg(Angle, &Deg);
		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = Deg[0].D();
			dilation_circle(AngleRegionLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
			//
			m_TopRow=0;
			m_TopCol=0;
			m_SymProngRowR=0;
			m_SymProngColR=0;
			m_SymProngRowL=0;
			m_SymProngColL=0;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("987$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;360;1;260$\
					 989;FP;0;250;0.5;55$\
					 1072;LP;1;5000;1;1500");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5530$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;360;1;260$\
					 5531;FP;-100;250;0.5;-50.0$\
					 5532;LP;0;100;1;20$\
					 5533;LP;1;5000;1;700");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
**函 数 名：F20_SideTopRegAngleDetectAlgo
**功    能：F20_侧面之20四叉顶部角度定位
**时    间：2019年5月28日
**作    者: WuYifeng
***************************************************************************/
STDMETHODIMP CPlugAlgo::F20_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pTopEllipseMoveSize,VARIANT* pAreaLimitLower,VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;        // 260
	double ThredLower   = (double)pThredLower->fltVal; // -50
	int TopEllipseMoveSize   = (int)pTopEllipseMoveSize->fltVal; //20
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;          // 700

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		//get the top region 灰度均值进行阈值分割
		Hobject ImageReducedAroiScaled;
		scale_image_max(ImageReducedAroi,&ImageReducedAroiScaled);
		HTuple Mean,Deviation;
		intensity(AroiClosing,ImageReducedAroiScaled,&Mean,&Deviation);
		if (Mean.Num()!=1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}	
		if(Mean[0].D()+ThredLower>=255.0)
		{
			ThredLower=254.0-Mean[0].D();
		}
		if ( Mean[0].D()+ThredLower<= 0)
		{
			ThredLower = 0;
		}

		Hobject TopRegions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroiScaled, &TopRegions, Mean+ThredLower, 255);
		Hobject TopRegionsFillUp;
		fill_up(TopRegions,&TopRegionsFillUp);
		Hobject TopRegionOpening,TopRegionClosing,TopRegionConnected,TopRegionSelected;
		opening_circle(TopRegionsFillUp, &TopRegionOpening, 7);
		closing_circle(TopRegionOpening, &TopRegionClosing, 10);
		connection(TopRegionClosing, &TopRegionConnected);
		//select_shape(TopRegionConnected, &SelectedRegions, "area", "and", AreaLimitLower, 99999999);
		select_shape_std(TopRegionConnected, &TopRegionSelected, "max_area", 70);
		HTuple TopCenTerArea, TopCenTerRow, TopCenTerCol;
		area_center(TopRegionSelected, &TopCenTerArea, &TopCenTerRow, &TopCenTerCol);
		if ( TopCenTerArea[0].D() <= 0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;

		}

		// get the top black ellipse (small inner wall )
		Hobject rgnTopBlackOri,rgnTopBlackOriOpn,rgnTopBlackOriCls,rgnTopBlackOriCon,rgnTopBlack;
		
		difference(TopRegionSelected, TopRegions, &rgnTopBlackOri);
		opening_circle(rgnTopBlackOri, &rgnTopBlackOriOpn, 3.5);
		closing_circle(rgnTopBlackOriOpn, &rgnTopBlackOriCls, 3.5);
		connection(rgnTopBlackOriCls, &rgnTopBlackOriCon);
		select_shape_std(rgnTopBlackOriCon, &rgnTopBlack, "max_area", 70);
		HTuple dAreaTopBlack, dRowTopBlack, dColTopBlack;
		area_center(rgnTopBlack, &dAreaTopBlack, &dRowTopBlack, &dColTopBlack);

		// get the dowm region of high light region
		Hobject TopRegionEllipse,TopEllipseMoved,rgnTopBlackDiff,rgnTopBlackOpn,rgnTopBlackCls;
		shape_trans(TopRegionSelected, &TopRegionEllipse, "ellipse");
		move_region(TopRegionEllipse, &TopEllipseMoved, -TopEllipseMoveSize, 0);
		difference(TopRegionSelected, TopEllipseMoved, &rgnTopBlackDiff);
		opening_circle(rgnTopBlackDiff, &rgnTopBlackOpn, 7);
		closing_circle(rgnTopBlackOpn, &rgnTopBlackCls, 7);
		Hobject rgnTopBlackClsCon,rgnHighLightDown;
		connection(rgnTopBlackCls, &rgnTopBlackClsCon);

		select_shape(rgnTopBlackClsCon, &rgnHighLightDown, "area", "and", AreaLimitLower, 99999);
		HTuple iNumTopHighDown;
		count_obj(rgnHighLightDown, &iNumTopHighDown);
		if ( (iNumTopHighDown) < 1 || (iNumTopHighDown > 4))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		
		HTuple dAreaHighLightDown, dRowHighLightDown, dColHighLightDown;
		area_center(rgnHighLightDown,&dAreaHighLightDown, &dRowHighLightDown, &dColHighLightDown);

		// gen top angle line
		HTuple  tTopRowDownSorted,iLength,FirstRow,iIndicesRow,FirstCol;
		tuple_sort(dRowHighLightDown, &tTopRowDownSorted);
		tuple_length(tTopRowDownSorted, &iLength);
        FirstRow = tTopRowDownSorted.Select(iLength-1);
		tuple_find(dRowHighLightDown, FirstRow, &iIndicesRow);
        FirstCol = dColHighLightDown.Select(iIndicesRow.Select(0));

		Hobject rgnAngleLine;
		HTuple  dAngle,dAngleDeg;
		gen_region_line(&rgnAngleLine, FirstRow, FirstCol, dRowTopBlack, dColTopBlack);
		orientation_region(rgnAngleLine, &dAngle);
		if( dAngle < 0 )
            dAngle = dAngle + PI;
		
		m_Angle=dAngle;
		tuple_deg(dAngle, &dAngleDeg);
		
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], rgnAngleLine, &m_vRgn[rId]);  
			concat_obj(m_vRgn[rId], rgnHighLightDown, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
		}

		m_TopRow=TopCenTerRow;     // 顶部区域中心
		m_TopCol=TopCenTerCol;
		m_dRowTopBlack = dRowTopBlack;  // 顶部黑孔中心
		m_dColTopBlack = dColTopBlack;
		m_FirstRow     = FirstRow;      // 选取的顶部高亮下区域中心
        m_FirstCol     = FirstCol;

		m_rgnTopBlack = rgnTopBlack;     // 部瓤^域
	    m_TopRegions = TopRegionSelected; // 顶部整体区域

		// display and the parameters transfermation
		HTuple AngleLineArea,AngleLineRow,AngleLineCol;
		area_center(rgnAngleLine,&AngleLineArea,&AngleLineRow,&AngleLineCol);

		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = dAngleDeg[0].D();
			dilation_circle(rgnAngleLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
			//
			m_TopRow=0;
			m_TopCol=0;
			m_dRowTopBlack = 0;
			m_dColTopBlack = 0;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_SideTopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5534$\
					 167;B$\
					 5535;LP;1;3;1;1$\
					 5536;FP;1;35;0.5;1.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
**函 数 名：F20_TopRegionLocationAlgo
**功    能：F20_侧面之20四叉顶部区域定位
**说    明：该算子通过区域开关控制提取的顶部区域：1，顶部整体区域；2，顶部高亮区域；3，顶部内孔区域
**时    间：2019年5月28日
***************************************************************************/
STDMETHODIMP CPlugAlgo::F20_SideTopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pRgnSelection,VARIANT* pEroSize)
{
	int rId           = (int)rgnId->fltVal;
	int RgnSelection   = (int)pRgnSelection->fltVal;
	float EroSize   = (float)pEroSize->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_rgnTopBlack.Id()== H_EMPTY_REGION||m_TopRegions.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopRegions;
		if (RgnSelection == 1)  // whole top region
		{
			erosion_circle(m_TopRegions,&TopRegions,EroSize);
		}  
		else if(RgnSelection == 2)  // top high light region
		{
			Hobject rgnTopHighLightOri,rgnTopHighLightOpn,rgnTopHighLightCon,rgnTopHighLight;
			difference(m_TopRegions,m_rgnTopBlack,&rgnTopHighLightOri);
			opening_circle(rgnTopHighLightOri,&rgnTopHighLightOpn,3.5);
			connection(rgnTopHighLightOpn,&rgnTopHighLightCon);
			select_shape_std(rgnTopHighLightCon,&rgnTopHighLight,"max_area",70);
			erosion_circle(rgnTopHighLight,&TopRegions,EroSize);
		}
		else if(RgnSelection == 3)
		{
			Hobject TopInWallRegion;   
			shape_trans(m_rgnTopBlack,&TopInWallRegion,"ellipse");
			m_TopInwallRegion = TopInWallRegion ;
			m_TopInwallRegionOrigin = m_rgnTopBlack;
			erosion_circle(m_rgnTopBlack,&TopRegions,EroSize);
		}

		HTuple dArea,dRow,dCol;
		area_center(TopRegions,&dArea,&dRow,&dCol);

		if ( dArea > 0)
		{
			m_vRgn[rId] = TopRegions;
		} 
		else
		{
			m_vRgn[rId] = newRgn ;
		    return S_FALSE;
		}

	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_OutInWallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5537$\
					 167;B$\
					 5538;FP;1;100;0.5;5.0$\
					 5539;FP;1;100;0.5;5.0$\
					 5540;LP;1;3000;1;500$\
					 5557;LP;1;3000;1;500$\
					 6058;FP;1;50;0.5;12.0$\
					 994;FP;1;50;0.5;1.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
**函 数 名：F20_OutInWallRegionLocationAlgo
**功    能：F20_侧面之20四叉侧面外内壁区域定位
**说    明：该算子根据叉口平台区域与顶部叉口黑色区域提取
**时    间：2019年5月28日
***************************************************************************/
STDMETHODIMP CPlugAlgo::F20_OutInWallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pUpSizeOuterWall,VARIANT* pDownSizeOuterWall,VARIANT* pAreaSize,VARIANT* pWholeAreaSize,VARIANT* pHPlatEroSize,VARIANT* pHEroSize)
{
	int rId           = (int)rgnId->fltVal;
	float UpSizeOuterWall   = (float)pUpSizeOuterWall->fltVal;       // 5
	float DownSizeOuterWall   = (float)pDownSizeOuterWall->fltVal;   //5
	float HEroSize   = (float)pHEroSize->fltVal;                     // 3.5
	float HPlatEroSize = (float)pHPlatEroSize->fltVal;              // 15
	int   AreaSize  = (int) pAreaSize->fltVal;                       //   500
	int   WholeAreaSize  = (int) pWholeAreaSize->fltVal;             //   500

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_Platform.Id()== H_EMPTY_REGION||m_TopRegions.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		// get the initial outer inwall region 
		Hobject rgnPlatformDil,rgnTopRegionsDil,rgnDiffPlatform1,rgnOuterWallSearch,rgnOuterWallOri;
		dilation_circle(m_Platform, &rgnPlatformDil,  3.5);
		dilation_circle(m_TopRegions,&rgnTopRegionsDil, 3.5);
    
		difference(m_PlatformReg, rgnPlatformDil, &rgnDiffPlatform1);
		difference(rgnDiffPlatform1, rgnTopRegionsDil, &rgnOuterWallSearch);
  
		intersection(rgnOuterWallSearch, m_ROI, &rgnOuterWallOri);
		
		// horizontal erosion as pre-process
		Hobject rgnOuterWall1,rgnOuterWall1Con,rgnOuterWallSel;
		union1(rgnOuterWallOri,&rgnOuterWallOri);
		erosion_rectangle1(rgnOuterWallOri, &rgnOuterWall1, (Hlong)HPlatEroSize, 1);
		clip_region_rel(rgnOuterWall1,&rgnOuterWall1,0,0,(Hlong)(HPlatEroSize/3.0),(Hlong)(HPlatEroSize/3.0));

        connection(rgnOuterWall1, &rgnOuterWall1Con);
        select_shape(rgnOuterWall1Con, &rgnOuterWallSel, "area", "and", 200, 99999999);
		
		// get the top fork black region
		Hobject rgnTopConvex,rgnTopConvexDiff,rgnTopConvexOpn,rgnTopConvexCls,rgnTopForksOri;
		shape_trans(m_TopRegions, &rgnTopConvex, "convex");
		difference(rgnTopConvex, m_TopRegions, &rgnTopConvexDiff);
		opening_circle(rgnTopConvexDiff, &rgnTopConvexOpn, 3.5);
        closing_circle(rgnTopConvexOpn, &rgnTopConvexCls, 3.5);
        connection(rgnTopConvexCls, &rgnTopForksOri);
        HTuple dAreargnTopForks, dRowrgnTopForks, dColrgnTopForks;
        area_center(rgnTopForksOri, &dAreargnTopForks, &dRowrgnTopForks, &dColrgnTopForks);
		
		// get the top region center and the top black region center
		HTuple dRectTopCol1, dRectTopRow1, dRectTopRow2,dRectTopCol2;
		smallest_rectangle1(m_TopRegions, &dRectTopCol1, &dRectTopRow1, &dRectTopRow2,&dRectTopCol2 );
		HTuple dRectTopBlackRow1, dRectTopBlackRowCol1, dRectTopBlackRow2, dRectTopBlackRowCol2;
        smallest_rectangle1(m_rgnTopBlack, &dRectTopBlackRow1, &dRectTopBlackRowCol1, &dRectTopBlackRow2, &dRectTopBlackRowCol2);

		//根据叉口朝向，提取平台区域
		HTuple a,b,c;
		tuple_rad(m_AngleP, &a);
		tuple_rad(180-m_AngleP, &b);
		tuple_rad(180, &c);

		Hobject rgnTopForkL,rgnTopForkR ;
		gen_empty_obj(&rgnTopForkR);
        gen_empty_obj(&rgnTopForkL);

		if ((0 < m_Angle ) && (m_Angle < a))
		{
			 // left
			Hobject rgnTopForksSelL,rgnTopForksSelL1,rgnTopForksSelL2;
		    select_shape(rgnTopForksOri, &rgnTopForksSelL, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelL, &rgnTopForksSelL1, "column", "and", dRectTopCol1, m_TopCol);
		    select_shape(rgnTopForksSelL1, &rgnTopForksSelL2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelL2, &rgnTopForkL, "max_area", 70);
		} 
		else if(( a < m_Angle) && ( m_Angle < b)  )
		{
			// left
			Hobject rgnTopForksSelL,rgnTopForksSelL1,rgnTopForksSelL2;
		    select_shape(rgnTopForksOri, &rgnTopForksSelL, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelL, &rgnTopForksSelL1, "column", "and", dRectTopCol1, m_TopCol);
		    select_shape(rgnTopForksSelL1, &rgnTopForksSelL2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelL2, &rgnTopForkL, "max_area", 70);

			// right
			Hobject rgnTopForksSelR,rgnTopForksSelR1,rgnTopForksSelR2;
			select_shape(rgnTopForksOri, &rgnTopForksSelR, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelR, &rgnTopForksSelR1, "column", "and", m_TopCol, dRectTopCol2);
		    select_shape(rgnTopForksSelR1, &rgnTopForksSelR2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelR2, &rgnTopForkR, "max_area", 70);

		}
		else if( (b < m_Angle) && ( m_Angle < c))
		{
			// right
			Hobject rgnTopForksSelR,rgnTopForksSelR1,rgnTopForksSelR2;
			select_shape(rgnTopForksOri, &rgnTopForksSelR, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelR, &rgnTopForksSelR1, "column", "and", m_TopCol, dRectTopCol2);
		    select_shape(rgnTopForksSelR1, &rgnTopForksSelR2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelR2, &rgnTopForkR, "max_area", 70);

		}

		Hobject rgnTopFork,rgnOuterWallUni,rgnOuterWallOpn,rgnOuterWallOri2;
		union2(rgnTopForkL, rgnTopForkR, &rgnTopFork);
		union2(rgnTopFork, rgnOuterWallSel, &rgnOuterWallUni);
    
        union1(rgnOuterWallUni, &rgnOuterWallUni);
		opening_circle(rgnOuterWallUni, &rgnOuterWallOpn, 3.5);
        closing_circle(rgnOuterWallOpn, &rgnOuterWallOri2, 35);
		
		// 上下位置缩放
		Hobject rgnPlatformDilation,rgnTopRegionsDilation,rgnDiffPlatform2,rgnOuterWallFinal;
		dilation_circle(m_Platform, &rgnPlatformDilation,  DownSizeOuterWall);
		dilation_circle(m_TopRegions,&rgnTopRegionsDilation, UpSizeOuterWall);
    
		difference(rgnOuterWallOri2, rgnPlatformDilation, &rgnDiffPlatform2);
		difference(rgnDiffPlatform2, rgnTopRegionsDilation, &rgnOuterWallFinal);
  
		Hobject rgnOuterWall;
		intersection(rgnOuterWallFinal, m_ROI, &rgnOuterWall);

		// 水平缩放
		erosion_rectangle1(rgnOuterWall, &rgnOuterWall, (Hlong)HEroSize, 1);
		opening_circle(rgnOuterWall,&rgnOuterWall,2);

		// 防止经过缩放处理之后产生比较小的区域
		connection(rgnOuterWall,&rgnOuterWall);
		select_shape(rgnOuterWall, &rgnOuterWall, "area", "and", WholeAreaSize, 9999999);
		union1(rgnOuterWall,&rgnOuterWall);

		HTuple dArea,dRow,dCol;
		area_center(rgnOuterWall,&dArea,&dRow,&dCol);

		if ( dArea > 0)
		{
			m_vRgn[rId] = rgnOuterWall;
		} 
		else
		{
			m_vRgn[rId] = newRgn ;
		    return S_FALSE;
		}

	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_SideTopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	//float ThredValue   = (float)pThredValue->fltVal;
	//float ClosingSize   = (float)pClosingSize->fltVal;

	//int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);

		Hobject SideTopRegErosion;
		erosion_circle(Aroi,&SideTopRegErosion,ErosionSize);

		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SideTopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;240$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::SideTopRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pThredValue,VARIANT* pAreaLimitLower,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float ThredValue   = (float)pThredValue->fltVal;
	//float ClosingSize   = (float)pClosingSize->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;
		//
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);

		//二次提取
		Hobject SearchImage,RegionConnection,RegionSlect,Region;
		reduce_domain(crtImg, Aroi, &SearchImage);
		threshold(SearchImage,&Region,ThredValue,255);
		fill_up(Region,&Region);
		connection(Region,&RegionConnection);
		select_shape(RegionConnection,&RegionSlect,"area","and",AreaLimitLower,9999999);
		Hobject SideTopRegErosion;
		erosion_circle(RegionSlect,&SideTopRegErosion,ErosionSize);
		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideTopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;240$\
					 989;FP;1;252;0.5;15$\
					 1162;LP;1;2000;1;10$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//顶部边缘区域
STDMETHODIMP CPlugAlgo::SideTopEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pThredValue,VARIANT* pDilationSize,VARIANT* pAreaLimitLower,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float ThredValue   = (float)pThredValue->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;
		//
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);

		//二次提取
		Hobject SearchImage,RegionConnection,RegionSlect,Region;
		reduce_domain(crtImg, Aroi, &SearchImage);
		threshold(SearchImage,&Region,ThredValue,255);
		fill_up(Region,&Region);
		connection(Region,&RegionConnection);
		select_shape(RegionConnection,&RegionSlect,"area","and",AreaLimitLower,9999999);
		Hobject SideTopRegErosion;
		erosion_circle(RegionSlect,&SideTopRegErosion,ErosionSize);
		Hobject SideSlopAll;
		dilation_rectangle1(m_SideSlopRegAll,&SideSlopAll,2,DilationSize);
		difference(SideTopRegErosion,SideSlopAll,&SideTopRegErosion);
		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideTopEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;240$\
					 989;FP;1;252;0.5;15$\
					 538;LP;1;50;1;6$\
					 1162;LP;1;2000;1;10$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_RubberDetectAlgo(VARIANT* rgnId,  VARIANT* pMaskSize,VARIANT* pSmoothSize, VARIANT* pDefectType, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pOpeningSize, VARIANT* pDilationSize,VARIANT* pDetectArea)
{
	//13单叉口整体黑白点检测时，剔除顶部内孔内边缘的误检点 m_TopInnerRgion  剔除边缘花纹干扰m_ARegionT

	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	float MaskSize = (float)fabs(pMaskSize->fltVal);
	float SmoothSize = (float) fabs(pSmoothSize->fltVal);
	int DefectType = (int)pDefectType->fltVal;
	float SeriousBlackPointDynThresh = (float)(pSeriousBlackPointDynThresh->fltVal/100.0);
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	float SeriousWhitePointDynThresh = (float) (-pSeriousWhitePointDynThresh->fltVal/100.0);
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;

	float OpeningSize = (float)pOpeningSize->fltVal;
	float DilationSize = (float)pDilationSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,DerivGauss,DerivGauss1;
		Hobject BlackRegion,ConnectedRegions1,SelectedRegions1,WhiteRegion,ConnectedRegions2,SelectedRegions2,BlackUnion, WhiteUnion;
		//
		reduce_domain (Image,rgn, &ImageReduced);	
		derivate_gauss(ImageReduced, &DerivGauss, MaskSize, "kitchen_rosenfeld");
		derivate_gauss(DerivGauss, &DerivGauss1, SmoothSize, "none");

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		if (DefectType==-1)
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&DefectRegs);
		}
		else if (DefectType==1)
		{
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&DefectRegs);
		}
		else
		{
			//*找单一块极黑缺陷，适用于伤的比较深，污点比较黑的情况
			threshold(DerivGauss1, &BlackRegion,SeriousBlackPointDynThresh , 100);
			connection(BlackRegion, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", SeriousBlackPointSize, 99999);
			union1(SelectedRegions1,&BlackUnion);
			//*极白点
			threshold(DerivGauss1, &WhiteRegion, -100,SeriousWhitePointDynThresh);
			connection(WhiteRegion, &ConnectedRegions2);
			select_shape(ConnectedRegions2, &SelectedRegions2, "area", "and",SeriousWhitePointSize, 99999);
			union1(SelectedRegions2,&WhiteUnion);
			union2(BlackUnion, WhiteUnion, &DefectRegs);
		}


		//20三叉顶部缺胶检测时，剔除顶部内孔内边缘的误检点 m_TopRegions  
		Hobject RegionTrans,RegionDiff,RegionOpening;
		shape_trans(m_TopRegions, &RegionTrans, "convex");
		difference(RegionTrans, m_TopRegions, &RegionDiff);
		opening_circle(RegionDiff, &RegionOpening, OpeningSize);

		Hobject ConnectedRegions,SelectedRegions,RegionMoved1;
		connection(RegionOpening, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);

		//move_region(SelectedRegions, &RegionMoved1, 10, 0);
		HTuple Rows, Columns;
		Hobject Region,RegionDilation;
		get_region_contour(SelectedRegions, &Rows, &Columns);
		gen_region_polygon(&Region, Rows, Columns);
		dilation_circle(Region, &RegionDilation, DilationSize);

		Hobject Regions;
		intersection(RegionDilation,DefectRegs,&Regions);
		difference(DefectRegs,Regions,&DefectRegs);
		////13单叉口整体黑白点检测时，剔除顶部内孔内边缘的误检点 m_TopInnerRgion

		//HTuple Rows, Columns;
		//Hobject LineOpening,Region,RegionDilation;
		//opening_circle(m_TopInnerRgion, &LineOpening, 2.0);
		//get_region_contour(LineOpening, &Rows, &Columns);
		//gen_region_polygon(&Region, Rows, Columns);
		//dilation_circle(Region, &RegionDilation, DilationSize);

		//Hobject Regions;
		//intersection(RegionDilation,DefectRegs,&Regions);
		//difference(DefectRegs,Regions,&DefectRegs);

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_RubberDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1164$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 679;FP;0.1;5.0;0.1;1.0$\
					 680;FP;0.1;5.0;0.1;1.0$\
					 385;LP;-1;1;1;-1$\
					 407;LP;1;1000;1;200$\
					 408;LP;1;200;1;10$\
					 409;LP;1;1000;1;200$\
					 410;LP;1;200;1;10$\
					 1163;FP;1;30;0.5;9$\
					 1135;FP;1;10;0.5;2");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************
*函数名：P_20D_PlatformLocationRAlgo
*功  能：计算三叉胶塞的叉口平台（当叉口位于右边时）
*****************************************************************/
void CPlugAlgo::P_20D_PlatformLocationRAlgo (Hobject PlatformAB, Hobject PlatformRegDilation, HTuple SearchSize, HTuple TopCenTerCol, HTuple SymProngRowR, HTuple SymProngColR,Hobject *PlatformRegR, Hobject *PlatformRegRDilation, Hobject *PlatformRegRDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegDilation, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}
	gen_empty_obj(&PlatformRegs2);


	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	Hobject PlatformRegRs,PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	gen_empty_region(&PlatformRegRs);
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);
		//50为叉口宽度的一半
		if (0 != (PlatRegCol>(TopCenTerCol-70)))
		{
			union2(PlatformRegRs, PlatRegSelected, &PlatformRegRs);
		}
	}
	Hobject PlatformRegRsOpening;
	opening_rectangle1(PlatformRegRs, &PlatformRegRsOpening, 2, 2);
	connection(PlatformRegRsOpening, &PlatformRegRs);
	select_shape_std(PlatformRegRs, &(*PlatformRegR), "max_area", 70);

	//右边平台
	HTuple PlatformRegRArea, PlatformRegRRow, PlatformRegRCol;
	area_center((*PlatformRegR), &PlatformRegRArea, &PlatformRegRRow, &PlatformRegRCol);
	if (PlatformRegRArea==0)
	{
		return;
	}

	Hobject PlatformRegRDilation1,PlatformRegRDiff,PlatformRegRDiffConnected,SelectedRegionR;
	dilation_rectangle1((*PlatformRegR), &(*PlatformRegRDilation0), 1, 500);
	dilation_circle((*PlatformRegR), &PlatformRegRDilation1, 3.5);
	difference((*PlatformRegRDilation0), PlatformRegRDilation1, &PlatformRegRDiff);
	connection(PlatformRegRDiff, &PlatformRegRDiffConnected);
	select_shape(PlatformRegRDiffConnected, &SelectedRegionR, "row", "and", PlatformRegRRow, 999999);
	difference((*PlatformRegRDilation0), SelectedRegionR, &(*PlatformRegRDilation));

	return;
}
/*****************************************************************
*函数名：P_20D_PlatformLocationLRAlgo
*功  能：计算三叉胶塞的叉口平台（当左右叉口平台位于左右时）
*****************************************************************/
void CPlugAlgo::P_20D_PlatformLocationLRAlgo (Hobject PlatformAB, Hobject PlatformRegDilation, HTuple SearchSize, HTuple TopCenTerCol, HTuple SymProngRowL, HTuple SymProngColL, HTuple SymProngRowR, HTuple SymProngColR,
	Hobject *PlatformRegL, Hobject *PlatformRegR, Hobject *PlatformRegLDilation, Hobject *PlatformRegRDilation,Hobject *PlatformRegLDilation0, Hobject *PlatformRegRDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegDilation, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}

	//
	gen_empty_obj(&PlatformRegs2);

	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	/////
	Hobject PlatformRegLs,PlatformRegRs;
	gen_empty_region(&PlatformRegLs);
	gen_empty_region(&PlatformRegRs);

	Hobject PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);

		if (0 != (PlatRegCol<TopCenTerCol))
		{
			union2(PlatformRegLs, PlatRegSelected, &PlatformRegLs);
		}
		else
		{

			union2(PlatformRegRs, PlatRegSelected, &PlatformRegRs);
		}
	}
	Hobject PlatformRegLsOpening,PlatformRegRsOpening;
	opening_rectangle1(PlatformRegLs, &PlatformRegLsOpening, 2, 2);
	opening_rectangle1(PlatformRegRs, &PlatformRegRsOpening, 2, 2);
	HTuple PlatformRegLNum,PlatformRegRNum;
	connection(PlatformRegLsOpening, &PlatformRegLs);
	select_shape_std(PlatformRegLs, &(*PlatformRegL), "max_area", 70);

	connection(PlatformRegRsOpening, &PlatformRegRs);
	select_shape_std(PlatformRegRs, &(*PlatformRegR), "max_area", 70);

	Hobject PlatformRegUnion,PlatformRegUnionConnected;
	HTuple PlatformRegNum3;
	union2((*PlatformRegL), (*PlatformRegR), &PlatformRegUnion);
	connection(PlatformRegUnion, &PlatformRegUnionConnected);
	count_obj(PlatformRegUnionConnected, &PlatformRegNum3);

	//左边平台
	HTuple PlatformRegLArea, PlatformRegLRow, PlatformRegLCol;
	Hobject PlatformRegLDilation1,PlatformRegLDiff,PlatformRegLDiffConnected,SelectedRegionL;
	area_center((*PlatformRegL), &PlatformRegLArea, &PlatformRegLRow, &PlatformRegLCol);
	if (0 != (PlatformRegLArea==0))
	{
		return;
	}
	dilation_rectangle1((*PlatformRegL), &(*PlatformRegLDilation0), 1, 500);
	dilation_circle((*PlatformRegL), &PlatformRegLDilation1, 3.5);
	difference((*PlatformRegLDilation0), PlatformRegLDilation1, &PlatformRegLDiff);
	connection(PlatformRegLDiff, &PlatformRegLDiffConnected);
	select_shape(PlatformRegLDiffConnected, &SelectedRegionL, "row", "and", PlatformRegLRow, 999999);
	difference((*PlatformRegLDilation0), SelectedRegionL, &(*PlatformRegLDilation));

	//右边平台
	HTuple PlatformRegRArea, PlatformRegRRow, PlatformRegRCol;
	Hobject PlatformRegRDilation1,PlatformRegRDiff,PlatformRegRDiffConnected,SelectedRegionR;
	area_center((*PlatformRegR), &PlatformRegRArea, &PlatformRegRRow, &PlatformRegRCol);
	if (0 != (PlatformRegRArea==0))
	{
		return;
	}

	dilation_rectangle1((*PlatformRegR), &(*PlatformRegRDilation0), 1, 500);
	dilation_circle((*PlatformRegR), &PlatformRegRDilation1, 3.5);
	difference((*PlatformRegRDilation0), PlatformRegRDilation1, &PlatformRegRDiff);
	connection(PlatformRegRDiff, &PlatformRegRDiffConnected);
	select_shape(PlatformRegRDiffConnected, &SelectedRegionR, "row", "and", PlatformRegLRow, 999999);
	difference((*PlatformRegRDilation0), SelectedRegionR, &(*PlatformRegRDilation));

	return;
}
/*****************************************************************
*函数名：P_20D_PlatformLocationLAlgo
*功  能：计算三叉胶塞的叉口平台（当叉口平台位于左边时）
*****************************************************************/
void CPlugAlgo::P_20D_PlatformLocationLAlgo (Hobject PlatformAB, Hobject PlatformRegDilation, HTuple SearchSize, HTuple TopCenTerCol, HTuple SymProngRowL, HTuple SymProngColL,Hobject *PlatformRegL, Hobject *PlatformRegLDilation, Hobject *PlatformRegLDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegDilation, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}

	////
	gen_empty_obj(&PlatformRegs2);
	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	//左边区域
	Hobject PlatformRegLs,PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	gen_empty_region(&PlatformRegLs);
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);
		//50为叉口宽度的一半
		if (0 != (PlatRegCol<(TopCenTerCol+70)))
		{
			union2(PlatformRegLs, PlatRegSelected, &PlatformRegLs);
		}
	}
	Hobject PlatformRegLsOpening;
	HTuple PlatformRegLNum,PlatformDistLs;
	opening_rectangle1(PlatformRegLs, &PlatformRegLsOpening, 2, 2);
	connection(PlatformRegLsOpening, &PlatformRegLs);

	select_shape_std(PlatformRegLs, &(*PlatformRegL), "max_area", 70);

	//左边平台
	HTuple PlatformRegLArea, PlatformRegLRow, PlatformRegLCol;
	Hobject PlatformRegLDilation1,PlatformRegLDiff,PlatformRegLDiffConnected,SelectedRegionL;
	area_center((*PlatformRegL), &PlatformRegLArea, &PlatformRegLRow, &PlatformRegLCol);
	//
	if (PlatformRegLArea==0)
	{
		return;
	}
	dilation_rectangle1((*PlatformRegL), &(*PlatformRegLDilation0), 1, 500);
	dilation_circle((*PlatformRegL), &PlatformRegLDilation1, 3.5);
	difference((*PlatformRegLDilation0), PlatformRegLDilation1, &PlatformRegLDiff);
	connection(PlatformRegLDiff, &PlatformRegLDiffConnected);
	select_shape(PlatformRegLDiffConnected, &SelectedRegionL, "row", "and", PlatformRegLRow, 999999);
	difference((*PlatformRegLDilation0), SelectedRegionL, &(*PlatformRegLDilation));

	return;

}
/*****************************************************************
*函数名：D20_PlatformDetectAlgo
*功  能：计算三叉胶塞的叉口平台
*作  者：Yangb
*****************************************************************/
STDMETHODIMP CPlugAlgo::D20_PlatformDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower, VARIANT* pAngle,VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;

	int HSearchSize    =(int)pHSearchSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;
	double Angle   = (double)pAngle->fltVal;

	//int DilationSize   = (int)pDilationSize->fltVal;
	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImgReduced = m_ImageScaleMax;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT;
		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);

		Hobject PlatformSearch;
		//opening_rectangle1(PlatformRegDilationT, &PlatformSearch, 1, (SearchSize*2)/3);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);
		//灰度均值
		//HTuple Mean, Deviation;
		//intensity(PlatformSearch, PlatformImageReduced, &Mean, &Deviation);
		//if(Mean[0].D()+ThredLower>=255.0)
		//{
		//ThredLower=254.0-Mean[0].D();
		//}
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);
		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle(PlatformRegFillup, &PlatformRegErosion, 2);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 2);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}

		intersection(PlatformSearch, PlatformAB, &PlatformAB);
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_SymProngColR==0)||(m_SymProngColL==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject PlatformRegL,PlatformRegR,PlatformRegLDilation,PlatformRegRDilation,PlatformRegLDilation0,PlatformRegRDilation0;
		gen_empty_region(&PlatformRegL);
		gen_empty_region(&PlatformRegR);
		gen_empty_region(&PlatformRegLDilation);
		gen_empty_region(&PlatformRegRDilation);
		gen_empty_region(&PlatformRegLDilation0);
		gen_empty_region(&PlatformRegRDilation0);

		//用于判断侧面斜坡叉口区域
		m_AngleP=Angle;  

		//根据叉口朝向，提取平台区域
		HTuple a,b,c;
		tuple_rad(Angle, &a);
		tuple_rad(180-Angle, &b);
		tuple_rad(180, &c);

		if ((m_Angle>=0)&&(m_Angle<=a))
		{
			//右边叉口平台
			P_20D_PlatformLocationRAlgo(PlatformAB, PlatformRegDilation, SearchSize, m_TopCol, m_SymProngRowR, m_SymProngColR, &PlatformRegR, &PlatformRegRDilation,&PlatformRegRDilation0);

		}
		else if((m_Angle>a)&&(m_Angle<b))
		{
			//两个叉口平台
			P_20D_PlatformLocationLRAlgo(PlatformAB, PlatformRegDilation, SearchSize, m_TopCol, m_SymProngRowL, m_SymProngColL, m_SymProngRowR, m_SymProngColR, &PlatformRegL, &PlatformRegR, &PlatformRegLDilation, &PlatformRegRDilation,&PlatformRegLDilation0, &PlatformRegRDilation0);

		}
		else if((m_Angle>=b)&&(m_Angle<=c))
		{
			//左边叉口平台
			P_20D_PlatformLocationLAlgo(PlatformAB, PlatformRegDilation, SearchSize, m_TopCol, m_SymProngRowL, m_SymProngColL, &PlatformRegL, &PlatformRegLDilation,&PlatformRegLDilation0);

		}
		Hobject PlatformReg;
		union2(PlatformRegLDilation, PlatformRegRDilation, &PlatformReg);
		dilation_rectangle1(PlatformReg, &PlatformReg, 5, 1);
		Hobject Platform;
		union2(PlatformRegL,PlatformRegR,&Platform);
		m_Platform=Platform; //叉口平台侧面检测区域

		//dilation_rectangle1(PlatformReg,&PlatformReg,DilationSize,1);
		m_PlatformReg=PlatformReg;  //侧面区域剔除叉口平台

		Hobject Platform0;
		union2(PlatformRegLDilation0, PlatformRegRDilation0, &Platform0);
		m_Platform0=Platform0;     //AB基准线剔除叉口平台

		if(m_bDebugImg)
		{
			//dilation_rectangle1(Platform,&Platform,DilationSize,1);
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_PlatformDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;60$\
					 998;LP;1;100;1;50$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;50$\
					 1161;FP;20;60;0.1;40");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_PlatformDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;95$\
					 998;LP;1;100;1;60$\
					 1142;LP;1;50;1;7$\
					 992;FP;1;250;1;70$\
					 1161;FP;20;60;0.1;28");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************
*函数名：F20_PlatformDetectAlgo
*功  能：计算四叉胶塞的叉口平台
*作  者：WuYifeng
*时  间：2019年5月28日
*说  明：根据D20_PlatformDetectAlgo算子修改
*****************************************************************/
STDMETHODIMP CPlugAlgo::F20_PlatformDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower, VARIANT* pAngle,VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;     //  95
	int SearchSize    =(int)pVSearchSize->fltVal;  // 60
	int HSearchSize    =(int)pHSearchSize->fltVal;  // 7
	double ThredLower   = (double)pThredLower->fltVal;  //70
	double Angle   = (double)pAngle->fltVal;         // 28

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImgReduced = m_ImageScaleMax;
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		
		//the first time to extract fork platform
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT;
		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);
		Hobject PlatformSearch;
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);
		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);
	
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);
		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle(PlatformRegFillup, &PlatformRegErosion, 2);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 2);

		// the second time to extract fork platform
		Hobject  rgnPlatformDil,imgPlatformDil,PlatformSecond,rgnPlatformSecondFil,rgnPlatformSecondOpn,rgnPlatformSecondCls;
		dilation_rectangle1(PlatformRegDilation, &rgnPlatformDil, 35, 25);
		reduce_domain(crtImgReduced, rgnPlatformDil, &imgPlatformDil);
		threshold(imgPlatformDil,&PlatformSecond, ThredLower, 255);
		fill_up(PlatformSecond, &rgnPlatformSecondFil);
		opening_circle(rgnPlatformSecondFil, &rgnPlatformSecondOpn, 5.5);
		closing_circle(rgnPlatformSecondOpn, &rgnPlatformSecondCls,1.5);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}

		intersection(PlatformSearch, PlatformAB, &PlatformAB);
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_dRowTopBlack==0) || (m_FirstRow == 0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject PlatformRegL,PlatformRegR,PlatformRegLDilation,PlatformRegRDilation,PlatformRegLDilation0,PlatformRegRDilation0;
		gen_empty_region(&PlatformRegL);
		gen_empty_region(&PlatformRegR);
		gen_empty_region(&PlatformRegLDilation);
		gen_empty_region(&PlatformRegRDilation);
		gen_empty_region(&PlatformRegLDilation0);
		gen_empty_region(&PlatformRegRDilation0);

		//用于判断侧面斜坡叉口区域
		m_AngleP=Angle;  

		//根据叉口朝向，提取平台区域
		HTuple a,b,c;
		tuple_rad(Angle, &a);
		tuple_rad(180-Angle, &b);
		tuple_rad(180, &c);

		if ((m_Angle>=0)&&(m_Angle<=a))
		{
			//右边叉口平台
			P_20D_PlatformLocationRAlgo(PlatformAB, rgnPlatformSecondCls, SearchSize, m_TopCol, m_SymProngRowR, m_SymProngColR, &PlatformRegR, &PlatformRegRDilation,&PlatformRegRDilation0);

		}
		else if((m_Angle>a)&&(m_Angle<b))
		{
			//两个叉口平台
			P_20D_PlatformLocationLRAlgo(PlatformAB, rgnPlatformSecondCls, SearchSize, m_TopCol, m_SymProngRowL, m_SymProngColL, m_SymProngRowR, m_SymProngColR, &PlatformRegL, &PlatformRegR, &PlatformRegLDilation, &PlatformRegRDilation,&PlatformRegLDilation0, &PlatformRegRDilation0);

		}
		else if((m_Angle>=b)&&(m_Angle<=c))
		{
			//左边叉口平台
			P_20D_PlatformLocationLAlgo(PlatformAB, rgnPlatformSecondCls, SearchSize, m_TopCol, m_SymProngRowL, m_SymProngColL, &PlatformRegL, &PlatformRegLDilation,&PlatformRegLDilation0);

		}
		Hobject PlatformReg;
		union2(PlatformRegLDilation, PlatformRegRDilation, &PlatformReg);
		dilation_rectangle1(PlatformReg, &PlatformReg, 5, 1);
		Hobject Platform;
		union2(PlatformRegL,PlatformRegR,&Platform);
		m_Platform=Platform; //叉口平台侧面检测区域

		m_PlatformReg=PlatformReg;  //侧面区域剔除叉口平台

		Hobject Platform0;
		union2(PlatformRegLDilation0, PlatformRegRDilation0, &Platform0);
		m_Platform0=Platform0;     //AB基准线剔除叉口平台

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/*****************************************************************
*函数名：D20_SlopEdgeDetectAlgo
*功  能：计算三叉胶塞的顶部斜坡边缘
*作  者：Yangb
*****************************************************************/
STDMETHODIMP CPlugAlgo::D20_SlopEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pTopSlopEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个圆形区域
		Hobject crtImgReduced = m_crtImg;
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdge, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); 
		difference(TopSlopEdgeDilation, m_PlatformReg, &TopSlopEdgeDiff);

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
		reduce_domain(crtImgReduced, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow,DefinedCol;
		//
		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
		m_TopSlopEdgePoints=TopSlopEdgePoints;
		m_TopSlopEdgeRow=TopSlopEdgeRow;

		//ARegionT为没有提出花纹的整个颈部区域
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);

		//剔除叉口区域的AB基准线
		Hobject ABEdgeDiff;
		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		difference(m_ABEdge,m_Platform0, &ABEdgeDiff);
		area_center(ABEdgeDiff, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdgeRow=ABEdgeRow;

		//***
		HTuple DilationSize;
		DilationSize = ABEdgeRow-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-DilationSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, DilationSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//侧面缺口，密封面干扰
		if(DilationSize<=0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopSlopEdgeArea);
			return S_FALSE;
		}

		Hobject ARegionTClosing,ARegionTOpening;
		closing_rectangle1(ARegionT, &ARegionTClosing, 30, 20);
		opening_rectangle1(ARegionTClosing, &ARegionTOpening, 1, (DilationSize*2)/3);
		//无叉口平台时，剔除叉口下部区域
		HTuple PlatArea, PlatRow, PlatColumn;
		area_center(m_PlatformReg, &PlatArea, &PlatRow, &PlatColumn);
		if (0 != (PlatArea==0))
		{
			HTuple innerRow1, innerCol1, innerRow2, innerCol2,outRow1, outCol1, outRow2, outCol2;
			inner_rectangle1(ARegionTOpening, &innerRow1, &innerCol1, &innerRow2, &innerCol2);
			smallest_rectangle1(ARegionT, &outRow1, &outCol1, &outRow2, &outCol2);
			//gen_rectangle1(&Rectangle2, outRow1, outCol1, outRow2, outCol2);
			clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);

		}
		else
		{
			clip_region_rel(ARegionTOpening, &ARegionT, 1, 1, 5, 5);
		}

		m_ARegionT=ARegionT;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SlopEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("997$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;260;1;200$\
					 998;LP;1;100;1;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_SlopEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pThreshold,VARIANT* pTopSlopEdgeArea)
{
	//花纹位置波动大，靠近顶部斜坡区域时，采用本算子 
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int Threshold   = (int)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个圆形区域
		Hobject crtImgReduced = m_crtImg;
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdge, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); 
		difference(TopSlopEdgeDilation, m_PlatformReg, &TopSlopEdgeDiff);

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
		reduce_domain(crtImgReduced, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		//
		HTuple Area,Row,Col;
		area_center(TopSlopSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopSlopEdgeArea);
			return S_FALSE;
		}
		R_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 4, 1, Threshold, "positive", "last",&DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 4, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*2)/3))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
		}

		//
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
		m_TopSlopEdgePoints=TopSlopEdgePoints;
		m_TopSlopEdgeRow=TopSlopEdgeRow;

		//ARegionT为没有提出花纹的整个颈部区域
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);

		//剔除叉口区域的AB基准线
		Hobject ABEdgeDiff;
		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		difference(m_ABEdge,m_Platform0, &ABEdgeDiff);
		area_center(ABEdgeDiff, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdgeRow=ABEdgeRow;

		//***
		HTuple DilationSize;
		DilationSize = ABEdgeRow-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-DilationSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, DilationSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//侧面缺口，密封面干扰
		Hobject ARegionTClosing,ARegionTOpening;
		closing_rectangle1(ARegionT, &ARegionTClosing, 30, 20);
		opening_rectangle1(ARegionTClosing, &ARegionTOpening, 1, (DilationSize*2)/3);
		//无叉口平台时，剔除叉口下部区域
		HTuple PlatArea, PlatRow, PlatColumn;
		area_center(m_PlatformReg, &PlatArea, &PlatRow, &PlatColumn);
		if (0 != (PlatArea==0))
		{
			HTuple innerRow1, innerCol1, innerRow2, innerCol2,outRow1, outCol1, outRow2, outCol2;
			inner_rectangle1(ARegionTOpening, &innerRow1, &innerCol1, &innerRow2, &innerCol2);
			smallest_rectangle1(ARegionT, &outRow1, &outCol1, &outRow2, &outCol2);
			//gen_rectangle1(&Rectangle2, outRow1, outCol1, outRow2, outCol2);
			clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);

		}
		else
		{
			clip_region_rel(ARegionTOpening, &ARegionT, 1, 1, 5, 5);
		}

		m_ARegionT=ARegionT;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SlopEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1166$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;260;1;200$\
					 998;LP;1;100;1;30$\
					 1165;LP;1;60;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_20D_BlackRegRSelectAlgo (Hobject BlackRegsConnected, HTuple BlackRegsNumber, HTuple TopCenTerCol, HTuple SymProngRowR, HTuple SymProngColR, Hobject *BlackRegR)
{
	Hobject BlackRegRs;
	gen_empty_region(&BlackRegRs);

	if (SymProngRowR.Num() <= 0 )
	{
		return;
	}

	Hobject BlackRegSelected;
	HTuple BlackRegArea, BlackRegRow, BlackRegCol;
	for (int i=1;i<=BlackRegsNumber;i++)
	{
		select_obj(BlackRegsConnected, &BlackRegSelected, i);
		area_center(BlackRegSelected, &BlackRegArea, &BlackRegRow, &BlackRegCol);
		//50为叉口宽度的一半
		if (0 != (BlackRegCol>=(TopCenTerCol-50)))
		{
			union2(BlackRegRs, BlackRegSelected, &BlackRegRs);
		}
	}
	Hobject RegionUnion;
	HTuple Number,BlackRegDistRs,Area, Row, Column;
	union1(BlackRegRs, &RegionUnion);
	area_center(RegionUnion, &Area, &Row, &Column);
	if(Area==0)
	{
		return;
	}
	connection(RegionUnion, &BlackRegRs);
	count_obj(BlackRegRs, &Number);
	BlackRegDistRs = HTuple();

	Hobject BlackRegRSelected;
	HTuple BlackRegRArea, BlackRegRRow, BlackRegRCol,DistR;
	for(int i=1;i<=Number;i++)
	{
		select_obj(BlackRegRs, &BlackRegRSelected, i);
		area_center(BlackRegRSelected, &BlackRegRArea, &BlackRegRRow, &BlackRegRCol);
		distance_pp(BlackRegRRow, BlackRegRCol, SymProngRowR, SymProngColR, &DistR);
		BlackRegDistRs.ReplaceElements(i-1,DistR);
	}
	HTuple BlackRegDistRMin,BlackRegDistRIndice;
	tuple_min(BlackRegDistRs, &BlackRegDistRMin);
	tuple_find(BlackRegDistRs, BlackRegDistRMin, &BlackRegDistRIndice);
	if (BlackRegDistRIndice==-1)
	{
		return;
	}
	select_obj(BlackRegRs, &(*BlackRegR), (BlackRegDistRIndice.Select(0))+1);

	return;
}
void CPlugAlgo::P_20D_BlackRegLRSelectAlgo (Hobject BlackRegsConnected, HTuple BlackRegsNumber, HTuple TopCenTerCol, HTuple SymProngRowL, HTuple SymProngColL, HTuple SymProngRowR, HTuple SymProngColR, Hobject *BlackRegL, Hobject *BlackRegR)
{
	Hobject BlackRegLs,BlackRegRs;
	gen_empty_region(&BlackRegLs);
	gen_empty_region(&BlackRegRs);

	if (SymProngRowL.Num() <= 0 )
	{
		return;
	}

	Hobject BlackRegSelected;
	HTuple BlackRegArea, BlackRegRow, BlackRegCol;
	for(int i=1;i<=BlackRegsNumber;i++)
	{
		select_obj(BlackRegsConnected, &BlackRegSelected, i);
		area_center(BlackRegSelected, &BlackRegArea, &BlackRegRow, &BlackRegCol);

		if (0 != (BlackRegCol<TopCenTerCol))
		{
			union2(BlackRegLs, BlackRegSelected, &BlackRegLs);
		}
		else
		{
			union2(BlackRegRs, BlackRegSelected, &BlackRegRs);
		}
	}
	HTuple BlackRegLNum,BlackRegRNum;
	Hobject BlackRegLsUnion,BlackRegRsUnion;
	union1(BlackRegLs, &BlackRegLsUnion);
	connection(BlackRegLs, &BlackRegLs);
	count_obj(BlackRegLs, &BlackRegLNum);

	union1(BlackRegRs, &BlackRegRsUnion);
	connection(BlackRegRs, &BlackRegRs);
	count_obj(BlackRegRs, &BlackRegRNum);

	HTuple Area1, Row1, Column1,Area2, Row2, Column2;
	area_center(BlackRegLsUnion, &Area1, &Row1, &Column1);
	area_center(BlackRegRsUnion, &Area2, &Row2, &Column2);
	if ((Area1==0)||(Area2==0))
	{
		return;

	}

	HTuple BlackRegDistLs,BlackRegDistRs;
	BlackRegDistLs = HTuple();
	BlackRegDistRs = HTuple();

	Hobject BlackRegLSelected;
	HTuple BlackRegLArea, BlackRegLRow, BlackRegLCol,DistL;
	for (int i=1;i<=BlackRegLNum;i++)
	{
		select_obj(BlackRegLs, &BlackRegLSelected, i);
		area_center(BlackRegLSelected, &BlackRegLArea, &BlackRegLRow, &BlackRegLCol);
		distance_pp(BlackRegLRow, BlackRegLCol, SymProngRowL, SymProngColL, &DistL);
		BlackRegDistLs.ReplaceElements(i-1,DistL);
	}

	Hobject BlackRegRSelected;
	HTuple BlackRegRArea, BlackRegRRow, BlackRegRCol,DistR;
	for (int i=1;i<=BlackRegRNum;i++)
	{
		select_obj(BlackRegRs, &BlackRegRSelected, i);
		area_center(BlackRegRSelected, &BlackRegRArea, &BlackRegRRow, &BlackRegRCol);
		distance_pp(BlackRegRRow, BlackRegRCol, SymProngRowR, SymProngColR, &DistR);
		BlackRegDistRs.ReplaceElements(i-1,DistR);
	}

	if (0 != (HTuple((BlackRegDistLs.Num())==0).Or((BlackRegDistRs.Num())==0)))
	{
		return;
	}
	//
	HTuple Num,BlackRegDistLMin,BlackRegDistLIndice;
	Hobject BlackRegLsConnected;
	Num = BlackRegDistLs.Num();
	tuple_min(BlackRegDistLs, &BlackRegDistLMin);
	tuple_find(BlackRegDistLs, BlackRegDistLMin, &BlackRegDistLIndice);
	if (BlackRegDistLIndice==-1)
	{
		return;
	}
	connection(BlackRegLs, &BlackRegLsConnected);
	if (0 != ((BlackRegDistLIndice.Select(0))>(Num-1)))
	{
		select_obj(BlackRegLsConnected, &(*BlackRegL), BlackRegDistLIndice.Select(0));
	}
	else
	{
		select_obj(BlackRegLsConnected, &(*BlackRegL), (BlackRegDistLIndice.Select(0))+1);
	}
	//
	HTuple BlackRegDistRMin,BlackRegDistRIndice;
	Hobject BlackRegRsConnected;
	Num = BlackRegDistRs.Num();
	tuple_min(BlackRegDistRs, &BlackRegDistRMin);
	tuple_find(BlackRegDistRs, BlackRegDistRMin, &BlackRegDistRIndice);
	if (BlackRegDistRIndice==-1)
	{
		return;
	}
	connection(BlackRegRs, &BlackRegRsConnected);
	if (0 != ((BlackRegDistRIndice.Select(0))>(Num-1)))
	{
		select_obj(BlackRegRsConnected, &(*BlackRegR), BlackRegDistRIndice.Select(0));
	}
	else
	{
		select_obj(BlackRegRsConnected, &(*BlackRegR), (BlackRegDistRIndice.Select(0))+1);
	}

	return;

}
void CPlugAlgo::P_20D_BlackRegLSelectAlgo (Hobject BlackRegsConnected, HTuple BlackRegsNumber, HTuple TopCenTerCol, HTuple SymProngRowL, HTuple SymProngColL, Hobject *BlackRegL)
{
	Hobject BlackRegLs;
	gen_empty_region(&BlackRegLs);

	if (SymProngRowL.Num() <= 0 )
	{
		return;
	}

	Hobject BlackRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	for (int i=1;i<=BlackRegsNumber;i++)
	{
		select_obj(BlackRegsConnected, &BlackRegSelected, i);
		area_center(BlackRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);
		if (0 != (PlatRegCol<=(TopCenTerCol+50)))
		{
			union2(BlackRegLs, BlackRegSelected, &BlackRegLs);
		}
	}
	Hobject RegionUnion;
	union1(BlackRegLs, &RegionUnion);
	HTuple  Area, Row, Column;
	area_center(RegionUnion, &Area, &Row, &Column);
	if(Area==0)
	{
		return;
	}
	connection(RegionUnion, &BlackRegLs);
	HTuple Number,BlackRegDistLs;
	count_obj(BlackRegLs, &Number);
	BlackRegDistLs = HTuple();
	Hobject BlackRegLSelected;
	HTuple BlackRegLArea, BlackRegLRow, BlackRegLCol,DistL;
	for (int i=1;i<=Number;i++)
	{
		select_obj(BlackRegLs, &BlackRegLSelected, i);
		area_center(BlackRegLSelected, &BlackRegLArea, &BlackRegLRow, &BlackRegLCol);
		distance_pp(BlackRegLRow, BlackRegLCol, SymProngRowL, SymProngColL, &DistL);
		BlackRegDistLs.ReplaceElements(i-1,DistL);

	}
	HTuple BlackRegDistLMin,BlackRegDistLIndice;
	tuple_min(BlackRegDistLs, &BlackRegDistLMin);
	tuple_find(BlackRegDistLs, BlackRegDistLMin, &BlackRegDistLIndice);
	if (BlackRegDistLIndice==-1)
	{
		return;
	}
	select_obj(BlackRegLs, &(*BlackRegL), (BlackRegDistLIndice.Select(0))+1);

	return;

}
/***************************************************************************
**函 数 名：D20_SideSlopRegionLocationAlgo
**功    能：计算三叉胶塞的顶部斜坡区域
****************************************************************************/
STDMETHODIMP CPlugAlgo::D20_SideSlopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pBlackThred,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float BlackThred    = (float)pBlackThred->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_TopRegions.Id() == H_EMPTY_REGION||m_TopSlopEdgePoints.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 350);
		Hobject ROIClosing;
		closing_rectangle1(m_ROI, &ROIClosing, 100, 1);
		intersection(ARegionTDilation, ROIClosing, &RegionIntersection);
		erosion_circle(RegionIntersection, &RegionIntersection, 5);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -5, 0);
		HTuple ARegionTMovedArea, ARegionTMovedRow, ARegionTMovedCol;
		area_center(ARegionTMoved, &ARegionTMovedArea, &ARegionTMovedRow, &ARegionTMovedCol);

		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);

		select_shape(ConnectedRegions1, &ObjectSelected1, "row", "and", 0, ARegionTMovedRow);
		union1(ObjectSelected1, &ObjectSelected1);

		Hobject TopRegionsOpening,TopRegionsClosing;
		opening_circle(m_TopRegions, &TopRegionsOpening, 3.5);
		closing_circle(TopRegionsOpening, &TopRegionsClosing, 60);
		//
		Hobject TopRegTrans;
		shape_trans(TopRegionsClosing, &TopRegTrans, "convex");
		HTuple TopRegTransArea, TopRegTransRow, TopRegTransColumn;
		area_center(TopRegTrans, &TopRegTransArea, &TopRegTransRow, &TopRegTransColumn);

		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-TopRegTransRow)+MoveSize), -(ABEllipseColumnCenter-TopRegTransColumn));

		Hobject RegionErosion1,RegionDifference2,SelectedRegions1,ConnectedRegions5,RegionIntersection1;
		erosion_rectangle1(RegionMoved, &RegionErosion1, 20, 1);
		difference(ROIClosing, RegionErosion1, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);

		Hobject SlopRegSearch;
		connection(RegionIntersection1, &SlopRegSearch);
		select_shape_std(SlopRegSearch, &SlopRegSearch, "max_area", 70);
		Hobject SlopRegSearchMoved,SlopRegSearchDiff;
		move_region(SlopRegSearch, &SlopRegSearchMoved, -5, 0);
		difference(SlopRegSearchMoved, RegionErosion1, &SlopRegSearchDiff);

		Hobject SlopImageReduced,DynthredRegs,DynthredRegsFillUp,DynthredRegsOpening;
		HTuple Mean, Deviation;
		reduce_domain(crtImg, SlopRegSearchDiff, &SlopImageReduced);
		intensity(SlopRegSearch, SlopImageReduced, &Mean, &Deviation);
		if (Mean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		if(Mean[0].D()-BlackThred<=0)
		{
			BlackThred=(float)Mean[0].D();
		}
		threshold(SlopImageReduced, &DynthredRegs, 0, Mean-BlackThred);
		intersection(DynthredRegs,m_ROI,&DynthredRegs );
		fill_up(DynthredRegs, &DynthredRegsFillUp);
		opening_circle(DynthredRegsFillUp, &DynthredRegsOpening, 3);

		HTuple BlackRegsNumber;
		Hobject DynthredRegsClosing,BlackRegsConnected;
		closing_circle(DynthredRegsOpening, &DynthredRegsClosing, 15);
		connection(DynthredRegsClosing, &BlackRegsConnected);
		count_obj(BlackRegsConnected, &BlackRegsNumber);
		HTuple Area3, Row3, Column3;
		area_center(DynthredRegsClosing, &Area3, &Row3, &Column3);
		if (Area3==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;

		}

		//根据叉口朝向，提取斜坡叉口
		HTuple a,b,c;
		tuple_rad(m_AngleP, &a);
		tuple_rad(180-m_AngleP, &b);
		tuple_rad(180, &c);

		Hobject BlackRegL,BlackRegR;
		gen_empty_region(&BlackRegL);
		gen_empty_region(&BlackRegR);

		if (0 != (HTuple(m_Angle>=0).And(m_Angle<=a)))
		{
			//右边单叉
			P_20D_BlackRegRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowR, m_SymProngColR, &BlackRegR);


		}
		else if (0 != (HTuple(m_Angle>a).And(m_Angle<b)))
		{
			//两个叉口
			P_20D_BlackRegLRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, m_SymProngRowR, m_SymProngColR, &BlackRegL, &BlackRegR);


		}
		else if (0 != (HTuple(m_Angle>=b).And(m_Angle<=c)))
		{
			//左边单叉
			P_20D_BlackRegLSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, &BlackRegL);
		}
		Hobject BlackReg,BlackRegDilation,SlopRegDiff;
		union2(BlackRegL, BlackRegR, &BlackReg);

		dilation_circle(BlackReg, &BlackRegDilation, 10);
		difference(SlopRegSearchDiff, BlackRegDilation, &SlopRegDiff);
		//ABEdge两端裁剪
		HTuple ABClipRow1, ABClipColumn1, ABClipRow2, ABClipColumn2;
		smallest_rectangle1(m_ARegionT, &ABClipRow1, &ABClipColumn1, &ABClipRow2, &ABClipColumn2);
		Hobject TopSlopClipped;
		HTuple SlopEdgeRows, SlopEdgeCols;
		clip_region(m_TopSlopEdgePoints, &TopSlopClipped, ABClipRow1, ABClipColumn1, ABClipRow2, ABClipColumn2);
		get_region_points(TopSlopClipped, &SlopEdgeRows, &SlopEdgeCols);
		HTuple TopSlopEdgeColSorted,TopSlopEdgePointColL,ColIndice,TopSlopEdgePointRowL;
		tuple_sort(SlopEdgeCols, &TopSlopEdgeColSorted);

		if (TopSlopEdgeColSorted.Num()==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		if (HErosionSize>TopSlopEdgeColSorted.Num()-2)
		{
			HErosionSize=0;
		}

		TopSlopEdgePointColL = TopSlopEdgeColSorted.Select(HErosionSize);
		tuple_find(SlopEdgeCols, TopSlopEdgePointColL, &ColIndice);
		TopSlopEdgePointRowL = SlopEdgeRows.Select(ColIndice.Select(0));

		HTuple TopSlopEdgePointColR,TopSlopEdgePointRowR;
		TopSlopEdgePointColR = TopSlopEdgeColSorted.Select((SlopEdgeCols.Num())-1-HErosionSize);
		tuple_find(SlopEdgeCols, TopSlopEdgePointColR, &ColIndice);
		TopSlopEdgePointRowR = SlopEdgeRows.Select(ColIndice.Select(0));

		//左边点的坐标平移量：往上75，往右45；右边点的坐标平移量：往上75，往左45
		HTuple MTopSlopEdgePointRowL,MTopSlopEdgePointColL,MTopSlopEdgePointRowR,MTopSlopEdgePointColR;
		MTopSlopEdgePointRowL = TopSlopEdgePointRowL-75;
		MTopSlopEdgePointColL = TopSlopEdgePointColL+45;
		MTopSlopEdgePointRowR = TopSlopEdgePointRowR-75;
		MTopSlopEdgePointColR = TopSlopEdgePointColR-45;

		Hobject Region,RegionFillUp2,RegionIntersection2,ConnectedRegions3;
		gen_region_polygon(&Region, ((((TopSlopEdgePointRowL.Concat(ABEllipseRowCenter)).Concat(TopSlopEdgePointRowR)).Concat(MTopSlopEdgePointRowR)).Concat(MTopSlopEdgePointRowL)).Concat(TopSlopEdgePointRowL), 
			(((((TopSlopEdgePointColL+1).Concat(ABEllipseColumnCenter)).Concat(TopSlopEdgePointColR-1)).Concat(MTopSlopEdgePointColR-1)).Concat(MTopSlopEdgePointColL+1)).Concat(TopSlopEdgePointColL+1));
		fill_up(Region, &RegionFillUp2);
		//
		//Hobject RegionErosion;
		//erosion_rectangle1(RegionFillUp2,&RegionErosion,HErosionSize,1);

		intersection(SlopRegDiff, RegionFillUp2, &RegionIntersection2);
		m_SideSlopRegAll=RegionIntersection2;
		connection(RegionIntersection2, &ConnectedRegions3);
		Hobject SideSlopReg;
		select_shape(ConnectedRegions3, &SideSlopReg, "area", "and", 2000, 9999999);
		union1(SideSlopReg, &SideSlopReg);

		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,1,VErosionSize);

		// 未进行缩放的斜坡区域
		m_SlopRegDiff = SlopRegDiff;
		m_BlackReg    =   BlackReg;

		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 1022;FP;-50;70;0.5;20$\
					 994;LP;0;10;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************
**函 数 名：D20_SideSlopRegionLocationAlgo1
**功    能：计算三叉胶塞的顶部斜坡区域(根据原算子进行优化)
**修    改：（1）内容：将进行灰度提取之后与m_ROI 取交集改为与 ROIClosing 取交集
**               时间：2019.12.17
****************************************************************************/
STDMETHODIMP CPlugAlgo::D20_SideSlopRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pBlackThred,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float BlackThred    = (float)pBlackThred->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_TopRegions.Id() == H_EMPTY_REGION||m_TopSlopEdgePoints.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_ImageScaleMax;
		//Hobject crtImg = m_crtImg;
		//scale_image_max(crtImg,&crtImg);
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 350);
		Hobject ROIClosing;
		closing_rectangle1(m_ROI, &ROIClosing, 100, 1);
		intersection(ARegionTDilation, ROIClosing, &RegionIntersection);
		erosion_circle(RegionIntersection, &RegionIntersection, 5);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -5, 0);
		HTuple ARegionTMovedArea, ARegionTMovedRow, ARegionTMovedCol;
		area_center(ARegionTMoved, &ARegionTMovedArea, &ARegionTMovedRow, &ARegionTMovedCol);

		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);

		select_shape(ConnectedRegions1, &ObjectSelected1, "row", "and", 0, ARegionTMovedRow);
		union1(ObjectSelected1, &ObjectSelected1);

		Hobject TopRegionsOpening,TopRegionsClosing;
		opening_circle(m_TopRegions, &TopRegionsOpening, 3.5);
		closing_circle(TopRegionsOpening, &TopRegionsClosing, 60);
		//
		Hobject TopRegTrans;
		shape_trans(TopRegionsClosing, &TopRegTrans, "convex");
		HTuple TopRegTransArea, TopRegTransRow, TopRegTransColumn;
		area_center(TopRegTrans, &TopRegTransArea, &TopRegTransRow, &TopRegTransColumn);

		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-TopRegTransRow)+MoveSize), -(ABEllipseColumnCenter-TopRegTransColumn));

		Hobject RegionErosion1,RegionDifference2,SelectedRegions1,ConnectedRegions5,RegionIntersection1;
		erosion_rectangle1(RegionMoved, &RegionErosion1, 20, 1);
		difference(ROIClosing, RegionErosion1, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);

		Hobject SlopRegSearch;
		connection(RegionIntersection1, &SlopRegSearch);
		select_shape_std(SlopRegSearch, &SlopRegSearch, "max_area", 70);
		Hobject SlopRegSearchMoved,SlopRegSearchDiff;
		move_region(SlopRegSearch, &SlopRegSearchMoved, -5, 0);
		difference(SlopRegSearchMoved, RegionErosion1, &SlopRegSearchDiff);

		Hobject SlopImageReduced,DynthredRegs,DynthredRegsFillUp,DynthredRegsOpening;
		HTuple Mean, Deviation;
		reduce_domain(crtImg, SlopRegSearchDiff, &SlopImageReduced);
		intensity(SlopRegSearch, SlopImageReduced, &Mean, &Deviation);
		if (Mean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		if(Mean[0].D()-BlackThred<=0)
		{
			BlackThred=(float)Mean[0].D();
		}
		threshold(SlopImageReduced, &DynthredRegs, 0, Mean-BlackThred);
        intersection(DynthredRegs,ROIClosing,&DynthredRegs );
		fill_up(DynthredRegs, &DynthredRegsFillUp);
		opening_circle(DynthredRegsFillUp, &DynthredRegsOpening, 3);

		HTuple BlackRegsNumber;
		Hobject DynthredRegsClosing,BlackRegsConnected;
		closing_circle(DynthredRegsOpening, &DynthredRegsClosing, 15);
		connection(DynthredRegsClosing, &BlackRegsConnected);
		count_obj(BlackRegsConnected, &BlackRegsNumber);
		HTuple Area3, Row3, Column3;
		area_center(DynthredRegsClosing, &Area3, &Row3, &Column3);
		if (Area3==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;

		}

		//根据叉口朝向，提取斜坡叉口
		HTuple a,b,c;
		tuple_rad(m_AngleP, &a);
		tuple_rad(180-m_AngleP, &b);
		tuple_rad(180, &c);

		Hobject BlackRegL,BlackRegR;
		gen_empty_region(&BlackRegL);
		gen_empty_region(&BlackRegR);

		if (0 != (HTuple(m_Angle>=0).And(m_Angle<=a)))
		{
			//右边单叉
			P_20D_BlackRegRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowR, m_SymProngColR, &BlackRegR);


		}
		else if (0 != (HTuple(m_Angle>a).And(m_Angle<b)))
		{
			//两个叉口
			P_20D_BlackRegLRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, m_SymProngRowR, m_SymProngColR, &BlackRegL, &BlackRegR);


		}
		else if (0 != (HTuple(m_Angle>=b).And(m_Angle<=c)))
		{
			//左边单叉
			P_20D_BlackRegLSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, &BlackRegL);
		}
		Hobject BlackReg,BlackRegDilation,SlopRegDiff;
		union2(BlackRegL, BlackRegR, &BlackReg);

		dilation_circle(BlackReg, &BlackRegDilation, 10);
		difference(SlopRegSearchDiff, BlackRegDilation, &SlopRegDiff);
		//ABEdge两端裁剪
		HTuple ABClipRow1, ABClipColumn1, ABClipRow2, ABClipColumn2;
		smallest_rectangle1(m_ARegionT, &ABClipRow1, &ABClipColumn1, &ABClipRow2, &ABClipColumn2);
		Hobject TopSlopClipped;
		HTuple SlopEdgeRows, SlopEdgeCols;
		clip_region(m_TopSlopEdgePoints, &TopSlopClipped, ABClipRow1, ABClipColumn1, ABClipRow2, ABClipColumn2);
		get_region_points(TopSlopClipped, &SlopEdgeRows, &SlopEdgeCols);
		HTuple TopSlopEdgeColSorted,TopSlopEdgePointColL,ColIndice,TopSlopEdgePointRowL;
		tuple_sort(SlopEdgeCols, &TopSlopEdgeColSorted);

		if (TopSlopEdgeColSorted.Num()==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		if (HErosionSize>TopSlopEdgeColSorted.Num()-2)
		{
			HErosionSize=0;
		}

		TopSlopEdgePointColL = TopSlopEdgeColSorted.Select(HErosionSize);
		tuple_find(SlopEdgeCols, TopSlopEdgePointColL, &ColIndice);
		TopSlopEdgePointRowL = SlopEdgeRows.Select(ColIndice.Select(0));

		HTuple TopSlopEdgePointColR,TopSlopEdgePointRowR;
		TopSlopEdgePointColR = TopSlopEdgeColSorted.Select((SlopEdgeCols.Num())-1-HErosionSize);
		tuple_find(SlopEdgeCols, TopSlopEdgePointColR, &ColIndice);
		TopSlopEdgePointRowR = SlopEdgeRows.Select(ColIndice.Select(0));

		//左边点的坐标平移量：往上75，往右45；右边点的坐标平移量：往上75，往左45
		HTuple MTopSlopEdgePointRowL,MTopSlopEdgePointColL,MTopSlopEdgePointRowR,MTopSlopEdgePointColR;
		MTopSlopEdgePointRowL = TopSlopEdgePointRowL-75;
		MTopSlopEdgePointColL = TopSlopEdgePointColL+45;
		MTopSlopEdgePointRowR = TopSlopEdgePointRowR-75;
		MTopSlopEdgePointColR = TopSlopEdgePointColR-45;

		Hobject Region,RegionFillUp2,RegionIntersection2,ConnectedRegions3;
		gen_region_polygon(&Region, ((((TopSlopEdgePointRowL.Concat(ABEllipseRowCenter)).Concat(TopSlopEdgePointRowR)).Concat(MTopSlopEdgePointRowR)).Concat(MTopSlopEdgePointRowL)).Concat(TopSlopEdgePointRowL), 
			(((((TopSlopEdgePointColL+1).Concat(ABEllipseColumnCenter)).Concat(TopSlopEdgePointColR-1)).Concat(MTopSlopEdgePointColR-1)).Concat(MTopSlopEdgePointColL+1)).Concat(TopSlopEdgePointColL+1));
		fill_up(Region, &RegionFillUp2);
		//
		//Hobject RegionErosion;
		//erosion_rectangle1(RegionFillUp2,&RegionErosion,HErosionSize,1);

		intersection(SlopRegDiff, RegionFillUp2, &RegionIntersection2);
		m_SideSlopRegAll=RegionIntersection2;
		connection(RegionIntersection2, &ConnectedRegions3);
		Hobject SideSlopReg;
		select_shape(ConnectedRegions3, &SideSlopReg, "area", "and", 2000, 9999999);
		union1(SideSlopReg, &SideSlopReg);

		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,1,VErosionSize);

		// 未进行缩放的斜坡区域
		m_SlopRegDiff = SlopRegDiff;
		m_BlackReg    =   BlackReg;

		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SideSlopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6240$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 1022;FP;-50;70;0.5;20$\
					 994;LP;0;10;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_StripePatternDetectAlgo(VARIANT* rgnId,VARIANT* pSwitch,VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pWhiteThred,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int Switch    = (int)pSwitch->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	//int EliminateSize    =(int)pEliminateSize->fltVal;
	//int TriangleDist   = (int)pTriangleDist->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//条形花纹提取
		Hobject ABStripeReg;
		HTuple ABStripeArea, ABStripeRow, ABStripeColumn;
		move_region(m_ABEdge, &ABStripeReg, -MoveSize, 0);
		intersection(ABStripeReg, m_ROI, &ABStripeReg);
		area_center(ABStripeReg, &ABStripeArea, &ABStripeRow, &ABStripeColumn);

		Hobject ABStripeRegDilation,ABStripeRegIntersection;
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection(ABStripeRegDilation, m_ROI, &ABStripeRegIntersection);

		Hobject RegionDiffH2,StripeRegOpening,StripeSearchReg;
		difference(ABStripeRegIntersection, m_Platform0, &RegionDiffH2);
		opening_circle(RegionDiffH2, &StripeRegOpening, 3);
		union1(StripeRegOpening, &StripeSearchReg);

		Hobject StripeRegImage;
		reduce_domain(crtImgReduced, StripeSearchReg, &StripeRegImage);
		emphasize(StripeRegImage, &StripeRegImage, 7, 7, 1);
		//HTuple Mean, Deviation;
		/*intensity(StripeSearchReg, StripeRegImage, &Mean, &Deviation);
		if (Mean.Num()!=1)
		{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
		}	
		if(Mean[0].D()+WhiteThred>=255.0)
		{
		WhiteThred=254.0-Mean[0].D();
		}*/

		Hobject WhiteStripeRoi0,WhiteStripeRoi;
		threshold(StripeRegImage, &WhiteStripeRoi0, WhiteThred, 255);

		Hobject WhiteStripeRoiFillUp,WhiteRegionErosion;
		fill_up(WhiteStripeRoi0, &WhiteStripeRoiFillUp);
		Hobject WhiteStripeRoiOpening;

		//剔除小的干扰点
		Hobject ConnectedRegions2;
		connection(WhiteStripeRoiFillUp, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &WhiteStripeRoi, "area", "and", 20, 999999);

		Hobject StripeRoiUnion,StripeRoiConnected,PlatformRegConnected;
		union1(WhiteStripeRoi, &StripeRoiUnion);

		if(m_bDebugImg)
		{
			Hobject ABStripeRegInterscted;
			intersection(ABStripeReg,StripeSearchReg,&ABStripeRegInterscted);
			concat_obj(m_vRgn[rId], ABStripeRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], StripeSearchReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteStripeRoi0, &m_vRgn[rId]); //用于显示阈值分割情况
		}
		//
		HTuple Area8, Row8, Column8;
		area_center(StripeRoiUnion, &Area8, &Row8, &Column8);
		if(Area8==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		connection(StripeRoiUnion, &StripeRoiConnected);
		connection(m_PlatformReg, &PlatformRegConnected);
		HTuple Number1,SelectSzie;
		count_obj(PlatformRegConnected, &Number1);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑,由于存在变形，适当改小了
		SelectSzie=10;
		Hobject SortedRegions,ObjectSelected,TriangleRoiCliped,ConnectedRegions1,RegionUnion2,RegionUnionDiff;
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		if (0 != (Number1==2))
		{
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected, 1);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			select_shape(StripeRoiConnected, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiUnion, RegionUnion2, &RegionUnionDiff);

			select_obj(SortedRegions, &ObjectSelected, 2);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(RegionUnionDiff, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);

			union1(TriangleRoiCliped, &RegionUnion2);
			difference(RegionUnionDiff, RegionUnion2, &WhiteStripeRoi);
		}
		else
		{
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(StripeRoiConnected, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiConnected, RegionUnion2, &WhiteStripeRoi);
		}

		//排除白条下面的白点干扰,只选择基准线以上的白条区域
		Hobject ABStripePartitioned;
		HTuple ABStripePartitionedArea, ABStripeRegRows, ABStripeRegCols;
		partition_rectangle(ABStripeReg, &ABStripePartitioned, 1, 100);
		area_center(ABStripePartitioned, &ABStripePartitionedArea, &ABStripeRegRows, &ABStripeRegCols);

		HTuple ABrowsRound,ABcolsRound,WhiteStripeNumber;
		Hobject WhiteStripeRoiConnected;
		tuple_round(ABStripeRegRows, &ABrowsRound);
		tuple_round(ABStripeRegCols, &ABcolsRound);
		union1(WhiteStripeRoi, &WhiteStripeRoi);
		connection(WhiteStripeRoi, &WhiteStripeRoiConnected);
		count_obj(WhiteStripeRoiConnected, &WhiteStripeNumber);

		Hobject WhiteStripeUp,WhiteStripeSelected;
		HTuple StripeArea, StripeRow, StripeCol,StripeColRound,ColIndice;
		gen_empty_region(&WhiteStripeUp);
		for(int i=1;i<=WhiteStripeNumber;i++)
		{
			select_obj(WhiteStripeRoiConnected, &WhiteStripeSelected, i);
			area_center(WhiteStripeSelected, &StripeArea, &StripeRow, &StripeCol);
			tuple_round(StripeCol, &StripeColRound);
			tuple_find(ABcolsRound, StripeColRound, &ColIndice);
			//
			if (0 != (ColIndice==-1))
			{
				continue;
			}

			if (0 != (StripeRow<=(ABrowsRound.Select(ColIndice.Select(0)))))
			{
				concat_obj(WhiteStripeUp, WhiteStripeSelected, &WhiteStripeUp);

			}

		}
		Hobject WhiteStripeUpUnion;
		union1(WhiteStripeUp, &WhiteStripeUpUnion);

		////排除白条上面的白点干扰
		//Hobject RegionDilation,WhiteStripeRoiClosing;
		//dilation_rectangle1(WhiteStripeUpUnion, &RegionDilation, 1, SearchSize/2);
		//erosion_rectangle1(RegionDilation, &WhiteStripeRoiClosing, 1,  SearchSize/2);

		//Hobject WhiteStripeRgn,WhiteStripeRoiConnected1;
		//HTuple WhiteStripeRoiNum;
		//gen_empty_region(&WhiteStripeRgn);
		//connection(WhiteStripeRoiClosing, &WhiteStripeRoiConnected1);
		//count_obj(WhiteStripeRoiConnected1, &WhiteStripeRoiNum);

		//HTuple ShortLength,LongLength,WhiteStripeRow, WhiteStripeCol, WhiteStripePhi, WhiteStripeLength1, WhiteStripeLength2;
		//Hobject Rect;
		//for (int i=1;i<=WhiteStripeRoiNum;i++)
		//{
		//	select_obj(WhiteStripeRoiConnected1, &WhiteStripeSelected, i);
		//	smallest_rectangle2(WhiteStripeSelected, &WhiteStripeRow, &WhiteStripeCol, &WhiteStripePhi, &WhiteStripeLength1, &WhiteStripeLength2);
		//	ShortLength = HTuple();
		//	LongLength = HTuple();

		//	if (0 != (WhiteStripeLength1>=WhiteStripeLength2))
		//	{
		//		ShortLength = WhiteStripeLength2;
		//		LongLength = WhiteStripeLength1;
		//	}
		//	else
		//	{
		//		ShortLength = WhiteStripeLength1;
		//		LongLength = WhiteStripeLength2;
		//	}

		//	gen_rectangle2(&Rect, WhiteStripeRow, WhiteStripeCol, WhiteStripePhi, WhiteStripeLength1, WhiteStripeLength2);
		//	//实际情况调整,
		//	if (0 != ((ShortLength*2)>30))
		//	{
		//		gen_empty_region(&WhiteStripeRgn);
		//		continue;
		//	}
		//	Hobject StripeSearchRegErosion,RectIntersection;
		//	erosion_circle(StripeSearchReg, &StripeSearchRegErosion, 1);
		//	intersection(Rect, StripeSearchRegErosion, &RectIntersection);
		//	Hobject RegionDilation1,RegionErosion;
		//	dilation_rectangle1(RectIntersection, &RegionDilation1, 1, 10);
		//	erosion_rectangle1(RegionDilation1, &RegionErosion, 10, 1);

		//	Hobject RegionDiff,RegionDiffConnected,RegionDiffSelected,RegionDiffUnion;
		//	HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeColumn1;
		//	difference(RegionErosion, WhiteStripeSelected, &RegionDiff);
		//	connection(RegionDiff, &RegionDiffConnected);
		//	area_center(WhiteStripeSelected, &WhiteStripeArea1, &WhiteStripeRow1, &WhiteStripeColumn1);
		//	select_shape(RegionDiffConnected, &RegionDiffSelected, "row", "and", 0, WhiteStripeRow1);
		//	//
		//	Hobject SelectedRegions1;
		//	select_shape_std(RegionDiffSelected, &SelectedRegions1, "max_area", 70);
		//	//
		//	union1(SelectedRegions1, &RegionDiffUnion);
		//	HTuple Row, Column, Phi, Length1, Length2;
		//	smallest_rectangle2(RegionDiffUnion, &Row, &Column, &Phi, &Length1, &Length2);
		//	Hobject BalckRect,WhiteStripeDiff,ConnectedRegions,SelectedRegions;
		//	if (0 != ((Row.Num())==0))
		//	{
		//		concat_obj(WhiteStripeRgn, WhiteStripeSelected, &WhiteStripeRgn);

		//	}
		//	else
		//	{
		//		gen_rectangle2(&BalckRect, Row, Column, Phi, Length1, Length2);
		//		ShortLength = HTuple();
		//		LongLength = HTuple();
		//		if (0 != (Length1>=Length2))
		//		{
		//			ShortLength = Length2;
		//			LongLength = Length1;
		//		}
		//		else
		//		{
		//			ShortLength = Length1;
		//			LongLength = Length2;
		//		}
		//		//实际情况调整，开放此参数
		//		if (0 != (ShortLength*2>EliminateSize))
		//		{
		//			Hobject BalckRect1;
		//			gen_rectangle2(&BalckRect1, Row, Column, Phi, LongLength+ShortLength, ShortLength);
		//			difference(WhiteStripeSelected, BalckRect1, &WhiteStripeDiff);
		//			connection(WhiteStripeDiff, &ConnectedRegions);
		//			select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		//			concat_obj(WhiteStripeRgn, SelectedRegions, &WhiteStripeRgn);
		//			
		//		}
		//		else
		//		{
		//			concat_obj(WhiteStripeRgn, WhiteStripeSelected, &WhiteStripeRgn);
		//		}
		//	}
		//}

		Hobject WhiteStripeRgnUnion,WhiteStripeRegConnected,ObjectUnion,StripeRoiError;
		connection(WhiteStripeUpUnion, &WhiteStripeRegConnected);

		//根据白条之间的距离进行判断筛选
		HTuple TriangleRegNum;
		count_obj(WhiteStripeRegConnected, &TriangleRegNum);

		HTuple ObjectSelectedArea, ObjectSelectedRow, ObjectSelectedCol;
		Hobject TriangleRegL,TriangleRegR,WhiteStripeReg;
		Hobject TriangleRegLConnected,TriangleRegLeft;
		HTuple NumberL;
		Hobject TriangleRegRConnected,TriangleRegRight;
		HTuple NumberR;

		gen_empty_region(&TriangleRegL);
		gen_empty_region(&TriangleRegR);
		gen_empty_region(&TriangleRegLeft);
		gen_empty_region(&TriangleRegRight);
		gen_empty_region(&WhiteStripeReg);
		if (0 != (Number1==2))
		{
			Hobject SortedRegions,ObjectSelected1,ObjectSelected2;
			HTuple Area1, Row1, Column1;
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected1, 1);
			area_center(ObjectSelected1, &Area1, &Row1, &Column1);
			HTuple PlatformRowL1, PlatformColL1, PlatformRowR1, PlatformColR1;
			smallest_rectangle1(ObjectSelected1, &PlatformRowL1, &PlatformColL1, &PlatformRowR1, &PlatformColR1);

			HTuple Area2, Row2, Column2,PlatformRowL2, PlatformColL2, PlatformRowR2, PlatformColR2;
			select_obj(SortedRegions, &ObjectSelected2, 2);
			area_center(ObjectSelected2, &Area2, &Row2, &Column2);
			smallest_rectangle1(ObjectSelected2, &PlatformRowL2, &PlatformColL2, &PlatformRowR2, &PlatformColR2);

			if (0 != (Area1>Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL1))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR1))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}
			}
			else if (0 != (Area1<Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR2))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}

			}
			else
			{
				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
				}

			}	
			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}

			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		else
		{
			HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			for (int i=1; i<=TriangleRegNum; i++)
			{
				select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
				area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
				if (0 != (ObjectSelectedCol<PlatformColL))
				{
					concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
				}
				else if (0 != (ObjectSelectedCol>PlatformColR))
				{
					concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
				}
			}

			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}
			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}

		///////////////////////
		//Hobject StripeRegSorted,ObjectSelectedx,ObjectSelectedy;
		//HTuple ObjectSelectedAreax, ObjectSelectedRowx, ObjectSelectedColx,ObjectSelectedAreay, ObjectSelectedRowy, ObjectSelectedColy;
		//HTuple ColDiff;
		//count_obj(WhiteStripeReg, &TriangleRegNum);
		//gen_empty_region(&ObjectUnion);
		//gen_empty_obj(&StripeRoiError);
		//for (int x=1;x<=TriangleRegNum;x++)
		//{
		//	for (int y=1;y<=TriangleRegNum;y++)
		//	{
		//		sort_region(WhiteStripeReg, &StripeRegSorted, "first_point", "true", "column");
		//		select_obj(StripeRegSorted, &ObjectSelectedx, x);
		//		area_center(ObjectSelectedx, &ObjectSelectedAreax, &ObjectSelectedRowx, &ObjectSelectedColx);

		//		select_obj(StripeRegSorted, &ObjectSelectedy, y);
		//		area_center(ObjectSelectedy, &ObjectSelectedAreay, &ObjectSelectedRowy, &ObjectSelectedColy);
		//		ColDiff = (ObjectSelectedColx-ObjectSelectedColy).Abs();
		//		//实际情况调整
		//		if (0 != (HTuple(ColDiff<TriangleDist).And(ColDiff>0)))
		//		{
		//			union2(ObjectSelectedx, ObjectSelectedy, &ObjectUnion);
		//			concat_obj(ObjectUnion, StripeRoiError, &StripeRoiError);
		//			my_disp_obj(StripeRoiError);
		//		}
		//	}
		//}
		//Hobject StripeRoiErrorConnected,ObjectSelected4,TriangleRoiDiff0;
		//HTuple Num;
		//union1(StripeRoiError, &StripeRoiError);
		//connection(StripeRoiError, &StripeRoiErrorConnected);
		//count_obj(StripeRoiErrorConnected, &Num);
		//if (0 != (Num>1))
		//{
		//	select_shape_std(StripeRoiErrorConnected, &ObjectSelected4, "max_area", 70);
		//	difference(StripeRoiErrorConnected, ObjectSelected4, &TriangleRoiDiff0);
		//	difference(WhiteStripeReg, TriangleRoiDiff0, &WhiteStripeReg);
		//}

		//白条往下平移，闭合
		Hobject StripeRegConnected1,StripeRegs;
		HTuple StripeRegNum;
		connection(WhiteStripeReg, &StripeRegConnected1);
		count_obj(StripeRegConnected1, &StripeRegNum);
		gen_empty_region(&StripeRegs);
		Hobject WhiteStripeSelected1,WhiteStripeMoved0,WhiteStripeMoved,WhiteStripeUnion,WhiteStripeClosing,StripeRoiClosing1,StripeRegion;
		HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeCol1;
		for (int i=1;i<=StripeRegNum;i++)
		{
			select_obj(StripeRegConnected1, &WhiteStripeSelected1, i);
			closing_circle(WhiteStripeSelected1, &WhiteStripeSelected1, 10);

			move_region(WhiteStripeSelected1, &WhiteStripeMoved0, -3, 0);
			dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);

			move_region(StripeRegion, &WhiteStripeMoved, 15, 0);
			union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
			closing_rectangle1(WhiteStripeUnion, &WhiteStripeClosing, 2, 20);
			concat_obj(WhiteStripeClosing, StripeRegs, &StripeRegs);
		}
		union1(StripeRegs, &StripeRegs);

		Hobject StripeConnected;
		connection(StripeRegs, &StripeConnected);
		HTuple StripeNumber,StripeRegArea, StripeRegRow, StripeRegColumn;
		count_obj(StripeConnected, &StripeNumber);
		area_center(StripeRegs, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		Hobject StripeReg,EmptyRegion;
		//dilation_circle(StripeRegs,&StripeReg,DilationSize);
		if (Switch==1)
		{
			//gen_empty_region(&EmptyRegion);
			m_StripeReg1=StripeRegs;
			m_StripeReg2=StripeRegs;
		}
		else if(Switch==2)
		{
			m_StripeReg1=m_StripeReg1;
			m_StripeReg2=StripeRegs;
		}
		if(m_bDebugImg)
		{
			Hobject StripeRegInterscted;
			intersection(StripeRegs,StripeSearchReg,&StripeRegInterscted);
			concat_obj(m_vRgn[rId], StripeRegInterscted, &m_vRgn[rId]);
		}
		if (StripeNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		if (StripeRegArea>0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegs;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_StripePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 1023;LP;1;2;1;1$\
					 991;LP;0;250;1;90$\
					 998;LP;1;100;1;60$\
					 999;FP;0;250;0.5;80");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名 ： D20_StripePatternDetectAlgo1
** 功  能 ： 三叉花纹提取
**********************************************************************************/
STDMETHODIMP CPlugAlgo::D20_StripePatternDetectAlgo1(VARIANT* rgnId,VARIANT* pSwitch,VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pWhiteThred,VARIANT* pDilationSize,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int Switch    = (int)pSwitch->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	//int EliminateSize    =(int)pEliminateSize->fltVal;
	//int TriangleDist   = (int)pTriangleDist->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImgReduced = m_crtImg;
		//条形花纹提取
		Hobject ABStripeReg;
		HTuple ABStripeArea, ABStripeRow, ABStripeColumn;
		move_region(m_ABEdge, &ABStripeReg, -MoveSize, 0);
		intersection(ABStripeReg, m_ROI, &ABStripeReg);
		area_center(ABStripeReg, &ABStripeArea, &ABStripeRow, &ABStripeColumn);

		Hobject ABStripeRegDilation,ABStripeRegIntersection;
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection(ABStripeRegDilation, m_ROI, &ABStripeRegIntersection);

		Hobject RegionDiffH2,StripeRegOpening,StripeSearchReg;
		difference(ABStripeRegIntersection, m_Platform0, &RegionDiffH2);
		opening_circle(RegionDiffH2, &StripeRegOpening, 3);
		union1(StripeRegOpening, &StripeSearchReg);

		Hobject StripeRegImage;
		reduce_domain(crtImgReduced, StripeSearchReg, &StripeRegImage);
		emphasize(StripeRegImage, &StripeRegImage, 7, 7, 1);
		Hobject WhiteStripeRoi0,WhiteStripeRoi;
		threshold(StripeRegImage, &WhiteStripeRoi0, WhiteThred, 255);

		Hobject WhiteStripeRoiFillUp,WhiteRegionErosion;
		fill_up(WhiteStripeRoi0, &WhiteStripeRoiFillUp);
		Hobject WhiteStripeRoiOpening;

		//剔除小的干扰点
		Hobject ConnectedRegions2;
		connection(WhiteStripeRoiFillUp, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &WhiteStripeRoi, "area", "and", 20, 999999);

		Hobject StripeRoiUnion,StripeRoiConnected,PlatformRegConnected;
		union1(WhiteStripeRoi, &StripeRoiUnion);

		if(m_bDebugImg)
		{
			Hobject ABStripeRegInterscted;
			intersection(ABStripeReg,StripeSearchReg,&ABStripeRegInterscted);
			concat_obj(m_vRgn[rId], ABStripeRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], StripeSearchReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteStripeRoi0, &m_vRgn[rId]); //用于显示阈值分割情况
		}
		//
		HTuple Area8, Row8, Column8;
		area_center(StripeRoiUnion, &Area8, &Row8, &Column8);
		if(Area8==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		connection(StripeRoiUnion, &StripeRoiConnected);
		connection(m_PlatformReg, &PlatformRegConnected);
		HTuple Number1,SelectSzie;
		count_obj(PlatformRegConnected, &Number1);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑,由于存在变形，适当改小了
		SelectSzie=10;
		Hobject SortedRegions,ObjectSelected,TriangleRoiCliped,ConnectedRegions1,RegionUnion2,RegionUnionDiff;
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		if (0 != (Number1==2))
		{
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected, 1);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			select_shape(StripeRoiConnected, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiUnion, RegionUnion2, &RegionUnionDiff);

			select_obj(SortedRegions, &ObjectSelected, 2);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(RegionUnionDiff, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);

			union1(TriangleRoiCliped, &RegionUnion2);
			difference(RegionUnionDiff, RegionUnion2, &WhiteStripeRoi);
		}
		else
		{
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(StripeRoiConnected, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiConnected, RegionUnion2, &WhiteStripeRoi);
		}

		//排除白条下面的白点干扰,只选择基准线以上的白条区域
		Hobject ABStripePartitioned;
		HTuple ABStripePartitionedArea, ABStripeRegRows, ABStripeRegCols;
		partition_rectangle(ABStripeReg, &ABStripePartitioned, 1, 100);
		area_center(ABStripePartitioned, &ABStripePartitionedArea, &ABStripeRegRows, &ABStripeRegCols);

		HTuple ABrowsRound,ABcolsRound,WhiteStripeNumber;
		Hobject WhiteStripeRoiConnected;
		tuple_round(ABStripeRegRows, &ABrowsRound);
		tuple_round(ABStripeRegCols, &ABcolsRound);
		union1(WhiteStripeRoi, &WhiteStripeRoi);
		connection(WhiteStripeRoi, &WhiteStripeRoiConnected);
		count_obj(WhiteStripeRoiConnected, &WhiteStripeNumber);

		Hobject WhiteStripeUp,WhiteStripeSelected;
		HTuple StripeArea, StripeRow, StripeCol,StripeColRound,ColIndice;
		gen_empty_region(&WhiteStripeUp);
		for(int i=1;i<=WhiteStripeNumber;i++)
		{
			select_obj(WhiteStripeRoiConnected, &WhiteStripeSelected, i);
			area_center(WhiteStripeSelected, &StripeArea, &StripeRow, &StripeCol);
			tuple_round(StripeCol, &StripeColRound);
			tuple_find(ABcolsRound, StripeColRound, &ColIndice);
			//
			if (0 != (ColIndice==-1))
			{
				continue;
			}

			if (0 != (StripeRow<=(ABrowsRound.Select(ColIndice.Select(0)))))
			{
				concat_obj(WhiteStripeUp, WhiteStripeSelected, &WhiteStripeUp);

			}

		}
		Hobject WhiteStripeUpUnion;
		union1(WhiteStripeUp, &WhiteStripeUpUnion);
		Hobject WhiteStripeRgnUnion,WhiteStripeRegConnected,ObjectUnion,StripeRoiError;
		connection(WhiteStripeUpUnion, &WhiteStripeRegConnected);

		//根据白条之间的距离进行判断筛选
		HTuple TriangleRegNum;
		count_obj(WhiteStripeRegConnected, &TriangleRegNum);

		HTuple ObjectSelectedArea, ObjectSelectedRow, ObjectSelectedCol;
		Hobject TriangleRegL,TriangleRegR,WhiteStripeReg;
		Hobject TriangleRegLConnected,TriangleRegLeft;
		HTuple NumberL;
		Hobject TriangleRegRConnected,TriangleRegRight;
		HTuple NumberR;

		gen_empty_region(&TriangleRegL);
		gen_empty_region(&TriangleRegR);
		gen_empty_region(&TriangleRegLeft);
		gen_empty_region(&TriangleRegRight);
		gen_empty_region(&WhiteStripeReg);
		if (0 != (Number1==2))
		{
			Hobject SortedRegions,ObjectSelected1,ObjectSelected2;
			HTuple Area1, Row1, Column1;
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected1, 1);
			area_center(ObjectSelected1, &Area1, &Row1, &Column1);
			HTuple PlatformRowL1, PlatformColL1, PlatformRowR1, PlatformColR1;
			smallest_rectangle1(ObjectSelected1, &PlatformRowL1, &PlatformColL1, &PlatformRowR1, &PlatformColR1);

			HTuple Area2, Row2, Column2,PlatformRowL2, PlatformColL2, PlatformRowR2, PlatformColR2;
			select_obj(SortedRegions, &ObjectSelected2, 2);
			area_center(ObjectSelected2, &Area2, &Row2, &Column2);
			smallest_rectangle1(ObjectSelected2, &PlatformRowL2, &PlatformColL2, &PlatformRowR2, &PlatformColR2);

			if (0 != (Area1>Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL1))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR1))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}
			}
			else if (0 != (Area1<Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR2))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}

			}
			else
			{
				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
				}

			}	
			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}

			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		else
		{
			HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			for (int i=1; i<=TriangleRegNum; i++)
			{
				select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
				area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
				if (0 != (ObjectSelectedCol<PlatformColL))
				{
					concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
				}
				else if (0 != (ObjectSelectedCol>PlatformColR))
				{
					concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
				}
			}

			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}
			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		//白条往下平移，闭合
		Hobject StripeRegConnected1,StripeRegs;
		HTuple StripeRegNum;
		connection(WhiteStripeReg, &StripeRegConnected1);
		count_obj(StripeRegConnected1, &StripeRegNum);
		gen_empty_region(&StripeRegs);
		Hobject WhiteStripeSelected1,WhiteStripeMoved0,WhiteStripeMoved,WhiteStripeUnion,WhiteStripeClosing,StripeRoiClosing1,StripeRegion;
		HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeCol1;
		for (int i=1;i<=StripeRegNum;i++)
		{
			select_obj(StripeRegConnected1, &WhiteStripeSelected1, i);
			closing_circle(WhiteStripeSelected1, &WhiteStripeSelected1, 10);

			move_region(WhiteStripeSelected1, &WhiteStripeMoved0, -3, 0);
			dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);

			move_region(StripeRegion, &WhiteStripeMoved, DilationSize, 0);
			union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
			closing_rectangle1(WhiteStripeUnion, &WhiteStripeClosing, 2, 20);
			concat_obj(WhiteStripeClosing, StripeRegs, &StripeRegs);
		}
		union1(StripeRegs, &StripeRegs);

		Hobject StripeConnected;
		connection(StripeRegs, &StripeConnected);
		HTuple StripeNumber,StripeRegArea, StripeRegRow, StripeRegColumn;
		count_obj(StripeConnected, &StripeNumber);
		area_center(StripeRegs, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		Hobject StripeReg,EmptyRegion;
		//dilation_circle(StripeRegs,&StripeReg,DilationSize);
		if (Switch==1)
		{
			//gen_empty_region(&EmptyRegion);
			m_StripeReg1=StripeRegs;
			m_StripeReg2=StripeRegs;
		}
		else if(Switch==2)
		{
			m_StripeReg1=m_StripeReg1;
			m_StripeReg2=StripeRegs;
		}
		if(m_bDebugImg)
		{
			Hobject StripeRegInterscted;
			intersection(StripeRegs,StripeSearchReg,&StripeRegInterscted);
			concat_obj(m_vRgn[rId], StripeRegInterscted, &m_vRgn[rId]);
		}
		if (StripeNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		if (StripeRegArea>0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegs;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_StripePatternDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 1023;LP;1;2;1;1$\
					 991;LP;0;250;1;90$\
					 998;LP;1;100;1;60$\
					 999;FP;0;250;0.5;80$\
					 995;LP;13;26;1;18");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名 ： F20_StripePatternDetectAlgo
** 功  能 ： 四叉花纹提取
**********************************************************************************/
STDMETHODIMP CPlugAlgo::F20_StripePatternDetectAlgo(VARIANT* rgnId,VARIANT* pSwitch,VARIANT* pMoveSize,VARIANT* pHSearchSize,VARIANT* pVSearchSize,VARIANT* pWhiteThred,VARIANT* pDilationSize,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int Switch    = (int)pSwitch->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;
	int HSearchSize    =(int)pHSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImgReduced = m_crtImg;
		//条形花纹提取
		Hobject ABStripeReg;
		HTuple ABStripeArea, ABStripeRow, ABStripeColumn;
		move_region(m_ABEdge, &ABStripeReg, -MoveSize, 0);
		clip_region_rel(ABStripeReg,&ABStripeReg,0,0,HSearchSize,HSearchSize);

		intersection(ABStripeReg, m_ROI, &ABStripeReg);
		area_center(ABStripeReg, &ABStripeArea, &ABStripeRow, &ABStripeColumn);

		Hobject ABStripeRegDilation,ABStripeRegIntersection;
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection(ABStripeRegDilation, m_ROI, &ABStripeRegIntersection);

		Hobject RegionDiffH2,StripeRegOpening,StripeSearchReg;
		difference(ABStripeRegIntersection, m_Platform0, &RegionDiffH2);
		opening_circle(RegionDiffH2, &StripeRegOpening, 3);
		union1(StripeRegOpening, &StripeSearchReg);

		Hobject StripeRegImage;
		reduce_domain(crtImgReduced, StripeSearchReg, &StripeRegImage);
		emphasize(StripeRegImage, &StripeRegImage, 7, 7, 1);
		Hobject WhiteStripeRoi0,WhiteStripeRoi;
		threshold(StripeRegImage, &WhiteStripeRoi0, WhiteThred, 255);

		Hobject WhiteStripeRoiFillUp,WhiteRegionErosion;
		fill_up(WhiteStripeRoi0, &WhiteStripeRoiFillUp);
		Hobject WhiteStripeRoiOpening;

		//剔除小的干扰点
		Hobject ConnectedRegions2;
		connection(WhiteStripeRoiFillUp, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &WhiteStripeRoi, "area", "and", 20, 999999);

		Hobject StripeRoiUnion,StripeRoiConnected,PlatformRegConnected;
		union1(WhiteStripeRoi, &StripeRoiUnion);

		if(m_bDebugImg)
		{
			Hobject ABStripeRegInterscted;
			intersection(ABStripeReg,StripeSearchReg,&ABStripeRegInterscted);
			concat_obj(m_vRgn[rId], ABStripeRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], StripeSearchReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteStripeRoi0, &m_vRgn[rId]); //用于显示阈值分割情况

			// 基准线平移之后的位置
			m_PatternEdge = ABStripeReg;

		}
		//
		HTuple Area8, Row8, Column8;
		area_center(StripeRoiUnion, &Area8, &Row8, &Column8);
		if(Area8==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		connection(StripeRoiUnion, &StripeRoiConnected);
		connection(m_PlatformReg, &PlatformRegConnected);
		HTuple Number1,SelectSzie;
		count_obj(PlatformRegConnected, &Number1);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑,由于存在变形，适当改小了
		SelectSzie=10;
		Hobject SortedRegions,ObjectSelected,TriangleRoiCliped,ConnectedRegions1,RegionUnion2,RegionUnionDiff;
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		if (0 != (Number1==2))
		{
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected, 1);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			select_shape(StripeRoiConnected, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiUnion, RegionUnion2, &RegionUnionDiff);

			select_obj(SortedRegions, &ObjectSelected, 2);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(RegionUnionDiff, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);

			union1(TriangleRoiCliped, &RegionUnion2);
			difference(RegionUnionDiff, RegionUnion2, &WhiteStripeRoi);
		}
		else
		{
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(StripeRoiConnected, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiConnected, RegionUnion2, &WhiteStripeRoi);
		}

		//排除白条下面的白点干扰,只选择基准线以上的白条区域
		Hobject ABStripePartitioned;
		HTuple ABStripePartitionedArea, ABStripeRegRows, ABStripeRegCols;
		partition_rectangle(ABStripeReg, &ABStripePartitioned, 1, 100);
		area_center(ABStripePartitioned, &ABStripePartitionedArea, &ABStripeRegRows, &ABStripeRegCols);

		HTuple ABrowsRound,ABcolsRound,WhiteStripeNumber;
		Hobject WhiteStripeRoiConnected;
		tuple_round(ABStripeRegRows, &ABrowsRound);
		tuple_round(ABStripeRegCols, &ABcolsRound);
		union1(WhiteStripeRoi, &WhiteStripeRoi);
		connection(WhiteStripeRoi, &WhiteStripeRoiConnected);
		count_obj(WhiteStripeRoiConnected, &WhiteStripeNumber);

		Hobject WhiteStripeUp,WhiteStripeSelected;
		HTuple StripeArea, StripeRow, StripeCol,StripeColRound,ColIndice;
		gen_empty_region(&WhiteStripeUp);
		for(int i=1;i<=WhiteStripeNumber;i++)
		{
			select_obj(WhiteStripeRoiConnected, &WhiteStripeSelected, i);
			area_center(WhiteStripeSelected, &StripeArea, &StripeRow, &StripeCol);
			tuple_round(StripeCol, &StripeColRound);
			tuple_find(ABcolsRound, StripeColRound, &ColIndice);
			//
			if (0 != (ColIndice==-1))
			{
				continue;
			}

			if (0 != (StripeRow<=(ABrowsRound.Select(ColIndice.Select(0)))))
			{
				concat_obj(WhiteStripeUp, WhiteStripeSelected, &WhiteStripeUp);

			}

		}
		Hobject WhiteStripeUpUnion;
		union1(WhiteStripeUp, &WhiteStripeUpUnion);
		Hobject WhiteStripeRgnUnion,WhiteStripeRegConnected,ObjectUnion,StripeRoiError;
		connection(WhiteStripeUpUnion, &WhiteStripeRegConnected);

		//根据白条之间的距离进行判断筛选
		HTuple TriangleRegNum;
		count_obj(WhiteStripeRegConnected, &TriangleRegNum);

		HTuple ObjectSelectedArea, ObjectSelectedRow, ObjectSelectedCol;
		Hobject TriangleRegL,TriangleRegR,WhiteStripeReg;
		Hobject TriangleRegLConnected,TriangleRegLeft;
		HTuple NumberL;
		Hobject TriangleRegRConnected,TriangleRegRight;
		HTuple NumberR;

		gen_empty_region(&TriangleRegL);
		gen_empty_region(&TriangleRegR);
		gen_empty_region(&TriangleRegLeft);
		gen_empty_region(&TriangleRegRight);
		gen_empty_region(&WhiteStripeReg);
		if (0 != (Number1==2))
		{
			Hobject SortedRegions,ObjectSelected1,ObjectSelected2;
			HTuple Area1, Row1, Column1;
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected1, 1);
			area_center(ObjectSelected1, &Area1, &Row1, &Column1);
			HTuple PlatformRowL1, PlatformColL1, PlatformRowR1, PlatformColR1;
			smallest_rectangle1(ObjectSelected1, &PlatformRowL1, &PlatformColL1, &PlatformRowR1, &PlatformColR1);

			HTuple Area2, Row2, Column2,PlatformRowL2, PlatformColL2, PlatformRowR2, PlatformColR2;
			select_obj(SortedRegions, &ObjectSelected2, 2);
			area_center(ObjectSelected2, &Area2, &Row2, &Column2);
			smallest_rectangle1(ObjectSelected2, &PlatformRowL2, &PlatformColL2, &PlatformRowR2, &PlatformColR2);

			if (0 != (Area1>Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL1))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR1))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}
			}
			else if (0 != (Area1<Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR2))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}

			}
			else
			{
				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
				}

			}	
			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}

			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		else
		{
			HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			for (int i=1; i<=TriangleRegNum; i++)
			{
				select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
				area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
				if (0 != (ObjectSelectedCol<PlatformColL))
				{
					concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
				}
				else if (0 != (ObjectSelectedCol>PlatformColR))
				{
					concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
				}
			}

			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}
			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		
		m_WhiteStripeReg = WhiteStripeReg;

		//白条往下平移，闭合
		Hobject StripeRegConnected1,StripeRegs;
		HTuple StripeRegNum;
		connection(WhiteStripeReg, &StripeRegConnected1);
		count_obj(StripeRegConnected1, &StripeRegNum);
		gen_empty_region(&StripeRegs);
		Hobject WhiteStripeSelected1,WhiteStripeMoved0,WhiteStripeMoved,WhiteStripeUnion,WhiteStripeClosing,StripeRoiClosing1,StripeRegion;
		HTuple WhiteStripeArea1, WhiteStripeRow1, WhiteStripeCol1;
		for (int i=1;i<=StripeRegNum;i++)
		{
			select_obj(StripeRegConnected1, &WhiteStripeSelected1, i);
			closing_circle(WhiteStripeSelected1, &WhiteStripeSelected1, 10);

			move_region(WhiteStripeSelected1, &WhiteStripeMoved0, -3, 0);
			dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);

			move_region(StripeRegion, &WhiteStripeMoved, DilationSize, 0);
			union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
			closing_rectangle1(WhiteStripeUnion, &WhiteStripeClosing, 2, 20);
			concat_obj(WhiteStripeClosing, StripeRegs, &StripeRegs);
		}
		union1(StripeRegs, &StripeRegs);

		Hobject StripeConnected;
		connection(StripeRegs, &StripeConnected);
		HTuple StripeNumber,StripeRegArea, StripeRegRow, StripeRegColumn;
		count_obj(StripeConnected, &StripeNumber);
		area_center(StripeRegs, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		Hobject StripeReg,EmptyRegion;
		//dilation_circle(StripeRegs,&StripeReg,DilationSize);
		if (Switch==1)
		{
			//gen_empty_region(&EmptyRegion);
			m_StripeReg1=StripeRegs;
			m_StripeReg2=StripeRegs;
		}
		else if(Switch==2)
		{
			m_StripeReg1=m_StripeReg1;
			m_StripeReg2=StripeRegs;
		}
		if(m_bDebugImg)
		{
			Hobject StripeRegInterscted;
			intersection(StripeRegs,StripeSearchReg,&StripeRegInterscted);
			concat_obj(m_vRgn[rId], StripeRegInterscted, &m_vRgn[rId]);
		}
		if (StripeNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		if (StripeRegArea>0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegs;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_StripePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 1023;LP;1;2;1;1$\
					 991;LP;0;250;1;90$\
					 5556;LP;1;50;1;3$\
					 998;LP;1;100;1;60$\
					 999;FP;0;250;0.5;80$\
					 995;LP;13;26;1;18");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_NeckRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeH2,VARIANT* pDilationSizeT)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int DilationSizeH2   = (int)pDilationSizeH2->fltVal;
	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_StripeReg1.Id()==H_EMPTY_REGION||m_StripeReg2.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1;
		//水平缩放
		clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//垂直缩放
		erosion_rectangle1(ARegionT0,&ARegionT1,1,VErosionSize);

		//剔除平台
		Hobject PlatformReg;
		dilation_circle(m_PlatformReg,&PlatformReg,DilationSizeT);
		Hobject ARegionPlatDiff,ARegionDiff;
		difference(ARegionT1, PlatformReg, &ARegionPlatDiff);
		//剔除花纹
		Hobject StripeReg2,StripeReg1;
		dilation_circle(m_StripeReg1,&StripeReg1,DilationSizeH1);
		dilation_circle(m_StripeReg2,&StripeReg2,DilationSizeH2);

		Hobject StripeReg;
		union2(StripeReg1,StripeReg2,&StripeReg);
		union1(StripeReg,&StripeReg);
		difference(ARegionPlatDiff, StripeReg, &ARegionDiff);

		m_StripeRegD=StripeReg;
		m_vRgn[rId] = ARegionDiff ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 994;LP;1;50;1;2$\
					 995;LP;1;35;1;1$\
					 1170;LP;1;45;1;1$\
					 1167;LP;1;45;1;1$\
					 1021;LP;1;45;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
**函 数 名：D20_NeckRegionLocationAlgo1
**功    能：计算三叉胶塞的颈部区域（剔除平台，上下花纹区域）
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::D20_NeckRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pLowerEdgeMoveSize, VARIANT* pUpEdgeMoveSize,VARIANT* pHErosionSize, VARIANT* pMoveSize,VARIANT* pDilationSizeH1,VARIANT* pVDilationSizeH2,VARIANT* pHDilationSizeH2,VARIANT* pDilationSizeT)
{
	int rId           = (int)rgnId->fltVal;
	int LowerEdgeMoveSize   = (int)pLowerEdgeMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;

	int MoveSize   = (int)pMoveSize->fltVal;
	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int VDilationSizeH2   = (int)pVDilationSizeH2->fltVal;
	int HDilationSizeH2   = (int)pHDilationSizeH2->fltVal;
	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_StripeReg1.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-LowerEdgeMoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1,RegionMoved1;
		//水平缩放
		clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//垂直缩放
		//erosion_rectangle1(ARegionT0,&ARegionT1,1,VErosionSize);

		//上边缘
		move_region(ARegionT0, &RegionMoved1, UpEdgeMoveSize, 0);
		intersection(RegionMoved1, ARegionT0, &ARegionT1);

		//剔除平台
		Hobject PlatformReg;
		dilation_circle(m_PlatformReg,&PlatformReg,DilationSizeT);
		Hobject ARegionPlatDiff,ARegionDiff;
		difference(ARegionT1, PlatformReg, &ARegionPlatDiff);
		//剔除花纹
		Hobject StripeReg1;
		//下花纹缩放
		dilation_circle(m_StripeReg1,&StripeReg1,DilationSizeH1);

		Hobject StripeReg2,StripeReg22;
		move_region(m_StripeReg1, &StripeReg2, -MoveSize, 0);
		//上花纹垂直缩放
		Hobject StripeRegDilation,RegionDetect;
		dilation_rectangle1(StripeReg2,&StripeRegDilation,1,VDilationSizeH2);
		//上花纹水平缩放
		dilation_rectangle1(StripeRegDilation,&StripeReg22,HDilationSizeH2,1);

		Hobject StripeReg;
		union2(StripeReg1,StripeReg22,&StripeReg);
		union1(StripeReg,&StripeReg);
		difference(ARegionPlatDiff, StripeReg, &ARegionDiff);

		m_StripeRegD=StripeReg;
		m_vRgn[rId] = ARegionDiff ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1169$\
					 167;B$\
					 1117;LP;1;20;1;1$\
					 1126;LP;1;50;1;5$\
					 994;LP;1;50;1;2$\
					 1168;LP;20;100;1;60$\
					 1170;LP;1;45;1;1$\
					 1167;LP;1;45;1;1$\
					 1172;LP;1;45;1;1$\
					 1021;LP;1;45;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//D20_顶部（20三叉）
STDMETHODIMP CPlugAlgo::D20_TopAngleDetectAlgo(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshUpValue,VARIANT* pWhiteThresh,VARIANT*pAreaLimitLower,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	float WhiteThresh = (float)pWhiteThresh->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		reduce_domain(Image, rgn, &ImageScaleMax);

		Hobject Regions1,RegionFillUp;
		threshold(ImageScaleMax, &Regions1, 0, ThreshUpValue);
		fill_up(Regions1, &RegionFillUp);
		Hobject RegionClosing,InnerCircle;
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		closing_circle(RegionFillUp, &RegionClosing, 10);
		opening_circle(RegionClosing, &InnerCircle, Radius-5);
		smallest_circle(InnerCircle, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], InnerCircle, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple InnerCircleArea, RegionOpeningRow, RegionOpeningCol;
		area_center(InnerCircle, &InnerCircleArea, &RegionOpeningRow, &RegionOpeningCol);

		if (InnerCircleArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;
		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject Circle1,Circle2,RegionDiff,TopImageReduced,ImageScaleMax1;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius+30);
		gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, InnerCircleRadius+50);
		difference(Circle2, Circle1, &RegionDiff);
		reduce_domain(Image, RegionDiff, &TopImageReduced);
		scale_image_max(TopImageReduced, &ImageScaleMax1);

		Hobject Regions2,RegionFillUp1,RegionOpening,ConnectedRegions1;
		threshold(ImageScaleMax1, &Regions2, WhiteThresh, 255);
		fill_up(Regions2, &RegionFillUp1);
		opening_circle(RegionFillUp1, &RegionOpening, 3.5);
		connection(RegionOpening, &ConnectedRegions1);
		Hobject SelectedRegions1;
		select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", AreaLimitLower, 9999999);
		HTuple TopAngleRgnNum;
		count_obj(SelectedRegions1, &TopAngleRgnNum);

		Hobject SelectedRegionsUnion;
		union1(SelectedRegions1,&SelectedRegionsUnion);
		HTuple Area,Row,Col;
		area_center(SelectedRegionsUnion,&Area,&Row,&Col);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], SelectedRegions1, &m_vRgn[rId]);
		}

		if (0 != ((TopAngleRgnNum!=3)||(Area==0)))
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
			return S_FALSE;
		}

		HTuple TopAngleRgnArea, TopAngleRgnRow, TopAngleRgnCol,TopAngleRgnAreaSorted;
		area_center(SelectedRegions1, &TopAngleRgnArea, &TopAngleRgnRow, &TopAngleRgnCol);
		tuple_sort(TopAngleRgnArea, &TopAngleRgnAreaSorted);
		HTuple Indices;
		tuple_find(TopAngleRgnArea, TopAngleRgnAreaSorted.Select(1), &Indices); 

		HTuple RowSelect,ColSelect;
		RowSelect = TopAngleRgnRow.Select(Indices);
		ColSelect = TopAngleRgnCol.Select(Indices);
		RowSelect = RowSelect.Select(0);
		ColSelect = ColSelect.Select(0);

		Hobject GapLine,Circle3,Circle4,CircleRegionUnion;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, RowSelect, ColSelect);
		gen_circle(&Circle3, InnerCircleRow, InnerCircleCol, 10);
		gen_circle(&Circle4, RowSelect, ColSelect, 5);
		union2(Circle3, Circle4, &CircleRegionUnion);
		HTuple Angle;
		orientation_region(CircleRegionUnion, &Angle);
		if (0 != (Angle<0))
		{
			Angle += 2*PI;

		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//
		HTuple GapLineArea,GapLineRow,GapLineCol;
		area_center(GapLine,&GapLineArea,&GapLineRow,&GapLineCol);
		if(GapLineArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapLineArea[0].I();
			m_vErrorRgn[rId] = GapLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1010$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;100;0.5;65$\
					 1011;FP;1;250;0.5;100$\
					 1012;FP;1;250;0.5;150$\
					 1072;LP;1;5000;1;2000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************
**函 数 名：D20_TopAngleDetectAlgo1
**功    能：三叉胶塞顶部高亮区域角度定位
*************************************************************************/
STDMETHODIMP CPlugAlgo::D20_TopAngleDetectAlgo1(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshLowerValue, VARIANT* pAreaLimit,VARIANT*pAreaLimitLower,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshLowerValue = (float)pThreshLowerValue->fltVal;
	int AreaLimit=(int)pAreaLimit->fltVal;

	//float WhiteThresh = (float)pWhiteThresh->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		//搜索的圆形区域位于顶部高亮区域的中间位置
		reduce_domain(Image, rgn, &ImageScaleMax);

		//////////////////////////////////////////////////////////////////////////
		Hobject Regions4,RegionFillUp4,ConnectedRegions3,SelectedRegions3;
		threshold (ImageScaleMax, &Regions4, ThreshLowerValue, 255);
		fill_up(Regions4, &RegionFillUp4);
		connection(RegionFillUp4, &ConnectedRegions3);
		select_shape(ConnectedRegions3, &SelectedRegions3, "area", "and", AreaLimit, 999999999);

		Hobject RegionClosing,RegionUnion4,RegionTrans2,RegionErosion,RegionDiff2;
		closing_circle(SelectedRegions3, &RegionClosing, 10);
		union1(RegionClosing, &RegionUnion4);
		shape_trans(RegionUnion4, &RegionTrans2, "outer_circle");
		erosion_circle(RegionTrans2, &RegionErosion, 5);
		difference(RegionErosion, Regions4, &RegionDiff2);

		//开运算尺寸，根据实际的内孔进行调整
		Hobject InnerCircle;
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		opening_circle(RegionDiff2, &InnerCircle, Radius-5);
		smallest_circle(InnerCircle, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		////
		/*Hobject Regions1,RegionFillUp;
		threshold(ImageScaleMax, &Regions1, 0, ThreshUpValue);
		fill_up(Regions1, &RegionFillUp);
		Hobject RegionClosing,InnerCircle;
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		closing_circle(RegionFillUp, &RegionClosing, 10);
		opening_circle(RegionClosing, &InnerCircle, Radius-5);
		smallest_circle(InnerCircle, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);*/

		if(m_bDebugImg)
		{
			//concat_obj(m_vRgn[rId], SelectedRegions3, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], InnerCircle, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple InnerCircleArea, RegionOpeningRow, RegionOpeningCol;
		area_center(InnerCircle, &InnerCircleArea, &RegionOpeningRow, &RegionOpeningCol);

		if (InnerCircleArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow1=InnerCircleRow;
			m_InnerCircleCol1=InnerCircleCol;
			m_InnerCircleRadius1=InnerCircleRadius;
		}
		else
		{
			m_InnerCircleRow1=m_imgHeight/2;
			m_InnerCircleCol1=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject Circle1,Circle2,RegionDiff,TopImageReduced,ImageScaleMax1;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius+25);
		gen_circle(&Circle2, InnerCircleRow, InnerCircleCol, InnerCircleRadius+45);
		difference(Circle2, Circle1, &RegionDiff);
		reduce_domain(m_crtImg, RegionDiff, &TopImageReduced);
		scale_image_max(TopImageReduced, &ImageScaleMax1);

		Hobject Regions2,RegionFillUp1,RegionOpening,ConnectedRegions1;
		threshold(ImageScaleMax1, &Regions2, ThreshLowerValue, 255);
		fill_up(Regions2, &RegionFillUp1);
		opening_circle(RegionFillUp1, &RegionOpening, 3.5);
		connection(RegionOpening, &ConnectedRegions1);
		Hobject SelectedRegions1;
		select_shape(ConnectedRegions1, &SelectedRegions1, "area", "and", AreaLimitLower, 9999999);
		HTuple TopAngleRgnNum;
		count_obj(SelectedRegions1, &TopAngleRgnNum);

		Hobject SelectedRegionsUnion;
		union1(SelectedRegions1,&SelectedRegionsUnion);
		HTuple Area,Row,Col;
		area_center(SelectedRegionsUnion,&Area,&Row,&Col);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], SelectedRegions1, &m_vRgn[rId]);
		}

		if (0 != ((TopAngleRgnNum!=3)||(Area==0)))
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
			return S_FALSE;
		}

		HTuple TopAngleRgnArea, TopAngleRgnRow, TopAngleRgnCol,TopAngleRgnAreaSorted;
		area_center(SelectedRegions1, &TopAngleRgnArea, &TopAngleRgnRow, &TopAngleRgnCol);
		tuple_sort(TopAngleRgnArea, &TopAngleRgnAreaSorted);
		HTuple Indices;
		tuple_find(TopAngleRgnArea, TopAngleRgnAreaSorted.Select(1), &Indices); 

		HTuple RowSelect,ColSelect;
		RowSelect = TopAngleRgnRow.Select(Indices);
		ColSelect = TopAngleRgnCol.Select(Indices);
		RowSelect = RowSelect.Select(0);
		ColSelect = ColSelect.Select(0);

		Hobject GapLine,Circle3,Circle4,CircleRegionUnion;
		gen_region_line(&GapLine, InnerCircleRow, InnerCircleCol, RowSelect, ColSelect);
		gen_circle(&Circle3, InnerCircleRow, InnerCircleCol, 10);
		gen_circle(&Circle4, RowSelect, ColSelect, 5);
		union2(Circle3, Circle4, &CircleRegionUnion);
		HTuple Angle;
		orientation_region(CircleRegionUnion, &Angle);
		//if (0 != (Angle<0))
		//{
		//	Angle += 2*PI;
		//}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//
		HTuple GapLineArea,GapLineRow,GapLineCol;
		area_center(GapLine,&GapLineArea,&GapLineRow,&GapLineCol);
		if(GapLineArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapLineArea[0].I();
			m_vErrorRgn[rId] = GapLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopAngleDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1081$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;150;0.5;65$\
					 1011;FP;1;250;0.5;145$\
					 1173;LP;1;2500;1;350$\
					 1072;LP;1;5000;1;2000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::F20_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5541$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 5531;FP;1;250;0.5;40$\
					 5543;FP;1;50;0.5;5$\
					 5544;FP;1;50;0.5;25$\
					 5545;LP;1;2000;1;800");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************
**函 数 名：F20_TopAngleDetectAlgo
**功    能：四叉胶塞顶部高亮区域角度定位
**时    间：2019年5月29日
*************************************************************************/
STDMETHODIMP CPlugAlgo::F20_TopAngleDetectAlgo(VARIANT* rgnId, VARIANT* pThreshLowerValue, VARIANT* pOuterEdge,VARIANT* pInnerEdge,VARIANT*pAreaLimitLower,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float ThreshLowerValue = (float)pThreshLowerValue->fltVal;    // mean + 40
	float OuterEdge=(float)pOuterEdge->fltVal;                    //  5
	float InnerEdge=(float)pInnerEdge->fltVal;                   // 25
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;             // 500

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,imgScaleMax;
		Hobject Image = m_crtImg;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		Hobject img;
		reduce_domain(Image, rgn, &img);
		scale_image_max(img, &imgScaleMax);

		HTuple Mean,Deviation;
		intensity(rgn, imgScaleMax, &Mean, &Deviation);
		Hobject rgnThr,rgnFil,rgnFilOpn,rgnFilCls,rgnTopIntersect,rgnFilCon,rgnTopHight;
	    threshold(imgScaleMax, &rgnThr, Mean+ThreshLowerValue, 255);
        fill_up(rgnThr, &rgnFil);
        opening_circle(rgnFil, &rgnFilOpn, 20);
        closing_circle(rgnFilOpn, &rgnFilCls, 5);
        intersection(rgnFilCls, rgnThr, &rgnTopIntersect);
        connection(rgnTopIntersect, &rgnFilCon);
        select_shape_std(rgnFilCon, &rgnTopHight, "max_area", 70);

		 //get the outer radius and inner radius
		Hobject rgnTopHightTrans,rgnTopHightFil,rgnTopInnerOri,rgnTopInnerOriOpn,rgnTopInnerOriCon,rgnTopInner;
		HTuple dCIrcleRow,dCIrcleCol,dCIrcleR,dInnerRow,dInnerCol,dInnerRadius;
		shape_trans(rgnTopHight, &rgnTopHightTrans, "outer_circle");
	    smallest_circle(rgnTopHightTrans, &dCIrcleRow, &dCIrcleCol, &dCIrcleR);
	    fill_up(rgnTopHight, &rgnTopHightFil);
        difference(rgnTopHightFil, rgnTopHight, &rgnTopInnerOri);
        opening_circle(rgnTopInnerOri, &rgnTopInnerOriOpn, 3.5);
        connection(rgnTopInnerOriOpn, &rgnTopInnerOriCon);
        select_shape_std(rgnTopInnerOriCon, &rgnTopInner, "max_area", 70);
        smallest_circle(rgnTopInner, &dInnerRow, &dInnerCol, &dInnerRadius);

		Hobject rgnTopHigh1;
	    difference(rgnTopHightFil, rgnTopInner, &rgnTopHigh1);

		// get the interest high light bar
		Hobject rgnToppCircle,rgnTopCircleEro ;
		if ( OuterEdge > InnerEdge)
		{
			erosion_circle(rgnTopHightTrans, &rgnToppCircle, InnerEdge);
            erosion_circle(rgnTopHightTrans, &rgnTopCircleEro, OuterEdge);
		}
		else if (OuterEdge == InnerEdge)
		{
			erosion_circle(rgnTopHightTrans, &rgnToppCircle, 0.5);
            erosion_circle(rgnTopHightTrans, &rgnTopCircleEro, 2);
		}
		else if (OuterEdge< InnerEdge)
		{
			erosion_circle(rgnTopHightTrans, &rgnToppCircle, OuterEdge);
		    erosion_circle(rgnTopHightTrans, &rgnTopCircleEro, InnerEdge);
		}

		Hobject  rgnTopHighDiff,rgnTopHighBarOri,rgnTopHighBarOriFil,rgnTopHighBarOriOpn,rgnTopHighBarCon,rgnTopHighBar;
		difference(rgnToppCircle, rgnTopCircleEro, &rgnTopHighDiff);
		intersection(rgnTopHighDiff, rgnTopHight, &rgnTopHighBarOri);
	    fill_up(rgnTopHighBarOri, &rgnTopHighBarOriFil);
        opening_circle(rgnTopHighBarOriFil, &rgnTopHighBarOriOpn, 3.5);
        connection(rgnTopHighBarOriOpn, &rgnTopHighBarCon);
        select_shape(rgnTopHighBarCon, &rgnTopHighBar, "area", "and", AreaLimitLower, 9999999);

		HTuple iBarNumber;
		count_obj(rgnTopHighBar, &iBarNumber);
		if ((iBarNumber>4)||(iBarNumber<1))
        {
            m_InnerCircleRow1=m_imgHeight/2;
		    m_InnerCircleCol1=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
        }

		HTuple dAreaTopHighBar, dRowTopHighBar,dColTopHighBar,dRowTopHighBarSorted,iLength;
		area_center(rgnTopHighBar, &dAreaTopHighBar, &dRowTopHighBar, &dColTopHighBar);
	    tuple_sort(dRowTopHighBar, &dRowTopHighBarSorted);
        tuple_length(dRowTopHighBarSorted, &iLength);
		HTuple dSelectRow,dSelectCol, iRowIndices;
        dSelectRow = dRowTopHighBarSorted.Select(iLength/2);
        tuple_find(dRowTopHighBar, dSelectRow, &iRowIndices);
        dSelectCol = dColTopHighBar.Select(iRowIndices);

		Hobject  rgnAngleLine;
		HTuple dAngleLine;
        gen_region_line(&rgnAngleLine, dSelectRow, dSelectCol, dInnerRow, dInnerCol);
        orientation_region(rgnAngleLine, &dAngleLine);

		Hobject  Circle3,Circle4,CircleRegionUnion;
		gen_circle(&Circle3, dInnerRow, dInnerCol, 10);
		gen_circle(&Circle4, dSelectRow, dSelectCol, 5);
		union2(Circle3, Circle4, &CircleRegionUnion);
		HTuple Angle;
		orientation_region(CircleRegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], rgnTopHigh1, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], rgnTopHighBar, &m_vRgn[rId]);
		}

		if (dInnerRadius>0)
		{
			m_vPos[0].m_y = (float)dInnerRow[0].D();
			m_vPos[0].m_x = (float)dInnerCol[0].D();

			m_InnerCircleRow1=dInnerRow;
			m_InnerCircleCol1=dInnerCol;
			m_InnerCircleRadius1=dInnerRadius;
		}
		else
		{
			m_InnerCircleRow1=m_imgHeight/2;
			m_InnerCircleCol1=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], rgnAngleLine, &m_vRgn[rId]);
		}
		//
		HTuple GapLineArea,GapLineRow,GapLineCol;
		area_center(rgnAngleLine,&GapLineArea,&GapLineRow,&GapLineCol);
		if(GapLineArea>0)
		{
			m_modelAngle=Angle;
			retValue = GapLineArea[0].I();
			m_vErrorRgn[rId] = rgnAngleLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_TopCenterDetectAlgo(VARIANT* rgnId,VARIANT* pThreshUpValue,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		reduce_domain(Image, rgn, &ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);

		Hobject Regions1,RegionFillUp;
		threshold(ImageScaleMax, &Regions1, 0, ThreshUpValue);
		fill_up(Regions1, &RegionFillUp);
		Hobject RegionClosing, RegionOpening,RegionTrans;
		closing_circle(RegionFillUp, &RegionClosing, 25);
		opening_circle(RegionClosing, &RegionOpening, 2);

		shape_trans(RegionOpening, &RegionTrans, "outer_circle");
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionTrans, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		m_InnerCircleT=RegionTrans;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], RegionTrans, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple InnerCircleArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionTrans, &InnerCircleArea, &RegionOpeningRow, &RegionOpeningCol);

		if (InnerCircleArea>0)
		{
			//m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			//m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			m_InnerCircleRadius=InnerCircleRadius;
			retValue = InnerCircleArea[0].I();
			m_vErrorRgn[rId] = RegionTrans;
		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopCenterDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1171$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1141;FP;1;250;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/************************************************************************************************
**函 数 名：D20_TopRegionLocationAlgo
**功    能：三叉胶塞顶部区域定位
**说    明：该算子通过区域开关控制提取的区域位置：1，顶部高亮区域；2，顶部斜坡区域；3，顶部叉口区域
***************************************************************************************************/
STDMETHODIMP CPlugAlgo::D20_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	if (InnerEdge>OutEdge)
	{
		InnerEdge=OutEdge-(float)0.5;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow1.Num()!=1 || m_InnerCircleCol1.Num()!=1 || m_modelAngle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hobject PolarTransImage;

		if (Selection==1)  //顶部高亮区域
		{
			polar_trans_image_ext(Image, &PolarTransImage, m_InnerCircleRow1, m_InnerCircleCol1, m_modelAngle+(HTuple(60).Rad()), (6.28319+m_modelAngle)+(HTuple(60).Rad()), 0, Radius, (Radius*2)*3.14, Radius, "nearest_neighbor");
			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);

			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 105);
			m_TopRegsClosing=TopRegsClosing;

			polar_trans_region_inv(TopRegsClosing, &TopRegs, m_InnerCircleRow1, m_InnerCircleCol1, m_modelAngle+(HTuple(60).Rad()), (6.28319+m_modelAngle)+(HTuple(60).Rad()), 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegs,ErosionSize);

			m_TopRadius=Radius;
			m_TopRegs=TopRegs;
			m_vRgn[rId] = TopRegs ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 50, 0);
			if (ForkEdge>=0)
			{
				dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+1, 1);
			} 
			else
			{
				erosion_rectangle1(RegionMoved, &TopRegsDilation, abs(ForkEdge), 1);
			}
			polar_trans_region_inv(TopRegsDilation, &XYTransTopRegsDilation,  m_InnerCircleRow1, m_InnerCircleCol1, m_modelAngle+(HTuple(60).Rad()), (6.28319+m_modelAngle)+(HTuple(60).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			//Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
			//gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);
			//gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, InnerEdge);
			//gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			//difference(Circle6, Circle5, &CircleDiff);
			//intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			//new
			Hobject RegionUnion1,RegionTrans1,Circle9;
			union1(m_TopRegs,&RegionUnion1);
			shape_trans(RegionUnion1,&RegionTrans1, "convex");
			HTuple Row1, Column1, Radius1;
			smallest_circle(RegionTrans1, &Row1, &Column1, &Radius1);
			if (Row1.Num()!=1)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			gen_circle(&Circle9, Row1, Column1, Radius1+OutEdge);
			Hobject RegionTransDilation,RegionDifference1,TopSlopRegs;
			dilation_circle(RegionTrans1,&RegionTransDilation,InnerEdge);

			difference(Circle9, RegionTransDilation, &RegionDifference1);
			intersection(RegionDifference1, XYTransTopRegsDilation, &TopSlopRegs);

			union1(TopSlopRegs,&TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;	
		}
		else if(Selection==3)  //顶部叉口区域
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 38, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, abs(ForkEdge)+10, 10);
			Hobject TopRegsDilation1;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation1, abs(ForkEdge)+5, 10);
			Hobject RegionMoved1,TopRegsDilation2;
			move_region(m_TopRegsClosing, &RegionMoved1, -5, 0);
			dilation_rectangle1(RegionMoved1, &TopRegsDilation2, abs(ForkEdge), 10);
			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation1, TopRegsDilation, &RegionUnion);
			union2(RegionUnion, TopRegsDilation2, &RegionUnion);
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);

			//用于生成顶部缺胶检测区域
			m_RubberReg0=RegionUnion;
			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionDilation, &XYTransLowRegs, m_InnerCircleRow1, m_InnerCircleCol1, m_modelAngle+(HTuple(60).Rad()), (6.28319+m_modelAngle)+(HTuple(60).Rad()), 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			//Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			//gen_circle(&Circle7,  m_InnerCircleRow, m_InnerCircleCol, InnerEdge);
			//gen_circle(&Circle8,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			//difference(Circle8, Circle7, &CircleDiff1);
			//difference(CircleDiff1, XYTransLowRegs, &TopLowRegs);
			//opening_circle(TopLowRegs, &TopLowRegs, 3);

			//因叉口变形进行位置校正
			Hobject RegionUnion1,RegionTrans1;
			union1(m_TopRegs,&RegionUnion1);
			shape_trans(RegionUnion1,&RegionTrans1, "convex");

			HTuple Area1, Row1, Column1,HomMat2D;
			Hobject RegionAffineTrans;
			area_center(RegionTrans1,&Area1, &Row1, &Column1);
			vector_angle_to_rigid(Row1, Column1, 0, m_InnerCircleRow, m_InnerCircleCol, 0, &HomMat2D);
			affine_trans_region(XYTransLowRegs,&RegionAffineTrans, HomMat2D, "nearest_neighbor");

			Hobject RegionUnion2,RegionUnion3;
			union2(XYTransLowRegs, RegionAffineTrans, &RegionUnion2);
			union1(RegionUnion2, &RegionUnion3);
			//叉口区域m_InnerCircleCircle
			Hobject Circle10,RegionTransDilation,RegionDifference;
			gen_circle(&Circle10, m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			dilation_circle(m_InnerCircleT, &RegionTransDilation, InnerEdge);
			difference(Circle10, RegionTransDilation, &RegionDifference);

			Hobject TopLowRegs;
			difference(RegionDifference, RegionUnion3, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 3);

			union1(TopLowRegs,&TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1074;LP;1;3;1;1$\
					 1075;LP;80;250;1;150$\
					 1076;FP;1;250;0.5;130$\
					 1077;LP;1;15000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1078;LP;-100;100;1;1$\
					 1079;FP;1;80;0.5;6$\
					 1080;FP;1;300;0.5;190");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
void CPlugAlgo::AnnulusRegionLocation (Hobject *rgnAnnulus, HTuple dCenterRow, HTuple dCenterColumn, HTuple dRadius, HTuple dAnnulusWidth)
{
	Hobject  rgnCircle1, rgnCircle2;
	HTuple  rgnOuterCircleRadius, rgnInnerCircleRadius;

	//get the annulus(环形) region
	rgnOuterCircleRadius = dRadius;
	rgnInnerCircleRadius = dRadius-dAnnulusWidth;

	if (dAnnulusWidth<0)
	{
		gen_circle(&rgnCircle1, dCenterRow, dCenterColumn, rgnOuterCircleRadius);
		gen_circle(&rgnCircle2, dCenterRow, dCenterColumn, rgnInnerCircleRadius);
		difference(rgnCircle2, rgnCircle1, &(*rgnAnnulus));

	}
	else if (dAnnulusWidth==0)
	{
		gen_circle(&rgnCircle1, dCenterRow, dCenterColumn, rgnOuterCircleRadius);
		gen_circle(&rgnCircle2, dCenterRow, dCenterColumn, rgnInnerCircleRadius-1);
		difference(rgnCircle1, rgnCircle2, &(*rgnAnnulus));

	}
	else if ((dAnnulusWidth>0) && (dAnnulusWidth<dRadius))
	{
		gen_circle(&rgnCircle1, dCenterRow, dCenterColumn, rgnOuterCircleRadius);
		gen_circle(&rgnCircle2, dCenterRow, dCenterColumn, rgnInnerCircleRadius);
		difference(rgnCircle1, rgnCircle2, &(*rgnAnnulus));
	}
	else if ((dAnnulusWidth>=dRadius))
	{
		gen_circle(&rgnCircle1, dCenterRow, dCenterColumn, dRadius);
		concat_obj((*rgnAnnulus), rgnCircle1, &(*rgnAnnulus));
		union1((*rgnAnnulus), &(*rgnAnnulus));
	}
	return;
}

STDMETHODIMP CPlugAlgo::F20_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5548$\
					 167;B$\
					 5550;LP;1;4;1;1$\
					 5551;LP;50;500;1;190$\
					 5547;FP;1;500;1;120$\
					 5531;FP;1;250;0.5;20$\
					 5549;FP;1;30;0.5;8.0$\
					 5552;LP;1;5000;1;800$\
					 1103;FP;1;20;0.5;3.5$\
					 5553;FP;1;50;0.5;1.5$\
					 5554;FP;1;200;0.5;6$\
					 5555;FP;1;400;0.5;190");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************************************
**函 数 名：F20_TopRegionLocationAlgo
**功    能：四叉胶塞顶部区域定位（CH3）
**说    明：该算子通过区域开关控制提取的区域位置：1，顶部高亮区域；2，顶部边缘区域；3，顶部叉口区域；4，顶部斜坡区域
**时    间：2019年5月31日
********************************************************************************************************************/
STDMETHODIMP CPlugAlgo::F20_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius,VARIANT* pRoiWidth, VARIANT* pThredLower, VARIANT* pBlackThred,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int Radius = (int)pRadius->fltVal;                     // 190
	float RoiWidth = (float)pRoiWidth->fltVal;             // 60
	float ThredLower = (float)pThredLower->fltVal;         // 40 
	float BlackThred = (float)pBlackThred->fltVal;         // 8
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;       //800
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	float ForkEdge = (float)pForkEdge->fltVal;            // 1
	float InnerEdge = (float)pInnerEdge->fltVal;         // 10
	float OutEdge = (float)pOutEdge->fltVal;             // 10

	/*if (InnerEdge>OutEdge)
	{
		InnerEdge=OutEdge-(float)0.5;
	}*/
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 || m_modelAngle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image = m_crtImg;
	
		// get the top border bar and fork region( whole)
		HTuple RadiusStart,RadiusEnd,AngleStart,AngleEnd;
		Hobject PolarTransImage,ImageMean;
		RadiusStart = Radius - RoiWidth;
		RadiusEnd   = Radius;
		AngleStart  = m_modelAngle;
		AngleEnd = (m_modelAngle+(HTuple(60).Rad()))+6.28319;

		polar_trans_image_ext(Image, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleEnd, RadiusStart, RadiusEnd, PI*(RadiusEnd+RadiusStart), RadiusEnd-RadiusStart, "nearest_neighbor");
		mean_image(PolarTransImage, &ImageMean, 200, 10);

		Hobject  rgnBorderBlack,rgnBorderBlackCls,rgnBorderBlackOpn,rgnBorderBlackOpn1,rgnBorderBlackCon,rgnBorderBlackSel1;
		dyn_threshold(ImageMean, PolarTransImage, &rgnBorderBlack, BlackThred, "light");
		closing_rectangle1(rgnBorderBlack, &rgnBorderBlackCls, 10, 5);
		opening_rectangle1(rgnBorderBlackCls, &rgnBorderBlackOpn, 20, 10);
		opening_circle(rgnBorderBlackOpn, &rgnBorderBlackOpn1, 5);
		connection(rgnBorderBlackOpn1, &rgnBorderBlackCon);
		select_shape(rgnBorderBlackCon, &rgnBorderBlackSel1, "area", "and", AreaLimitLower, 9999999);
		
		Hobject rgnBorderBlackUni;
		HTuple dAreaBlack,dRowBlack,dColBlack;
		union1(rgnBorderBlackCon, &rgnBorderBlackUni);
		area_center(rgnBorderBlackUni, &dAreaBlack, &dRowBlack, &dColBlack);

		if (Selection==1)  //顶部高亮区域
		{
			Hobject rgnAnnulus;
			AnnulusRegionLocation(&rgnAnnulus, m_InnerCircleRow, m_InnerCircleCol, Radius, RoiWidth);
			
			Hobject img,imgScaleMax;
			reduce_domain(Image, rgnAnnulus, &img);
			scale_image_max(img, &imgScaleMax);

			HTuple Mean,Deviation;
			intensity(rgnAnnulus, imgScaleMax, &Mean, &Deviation);
			Hobject rgnThr,rgnFil,rgnFilOpn,rgnFilCls,rgnTopIntersect,rgnFilCon,rgnFilSel;
			if((Mean+ThredLower) >= 255)
			{
				ThredLower = 0;
			}
			
			threshold(imgScaleMax, &rgnThr, Mean+ThredLower, 255);
			fill_up(rgnThr, &rgnFil);
			opening_circle(rgnFil, &rgnFilOpn, 20);
			closing_circle(rgnFilOpn, &rgnFilCls, 15);
			intersection(rgnFilCls, rgnThr, &rgnTopIntersect);
			connection(rgnTopIntersect, &rgnFilCon);
			select_shape_std(rgnFilCon, &rgnFilSel, "max_area", 70);

			Hobject rgnTopHight,rgnFilSelCls,rgnFilSelCon,rgnAnnulus1;
			closing_circle(rgnFilSel,&rgnFilSelCls,10);
			
			AnnulusRegionLocation(&rgnAnnulus1, m_InnerCircleRow, m_InnerCircleCol, OutEdge, OutEdge - InnerEdge);
			intersection(rgnFilSelCls,rgnAnnulus1,&rgnFilSelCls);

			connection(	rgnFilSelCls,&rgnFilSelCon);
			select_shape_std(rgnFilSelCon, &rgnTopHight, "max_area", 70);

			m_TopRadius= Radius;
			m_TopRegs = rgnTopHight;
			m_vRgn[rId] = rgnTopHight ;
		}
		else if (Selection==2) // 高亮边缘区域(rgnTopBorder)
		{
			//get the top border black regions
			Hobject rgnBorderBlackTop;
			HTuple dBlackTopArea,dBlackTopRow,dBlackTopCol,iNumber ;
			
			select_shape(rgnBorderBlackSel1, &rgnBorderBlackTop, "row", "and", dRowBlack, m_imgHeight);
			area_center(rgnBorderBlackTop, &dBlackTopArea, &dBlackTopRow, &dBlackTopCol);
			dilation_rectangle1(rgnBorderBlackTop, &rgnBorderBlackTop, 1, 2);

			//Scale the outer edge and inner edge
			Hobject rgnBorderBlackTopMoved1,rgnBorderBlackTopIntsct,rgnBorderBlackTopMoved2,rgnBorderBlackTopUni ;
			move_region(rgnBorderBlackTop, &rgnBorderBlackTopMoved1, (Hlong)OutEdge , 0);
			intersection(rgnBorderBlackTopMoved1, rgnBorderBlackTop, &rgnBorderBlackTopIntsct);

			move_region(rgnBorderBlackTop, &rgnBorderBlackTopMoved2, (Hlong)-InnerEdge, 0);
			union2(rgnBorderBlackTopIntsct, rgnBorderBlackTopMoved2, &rgnBorderBlackTopUni);

			Hobject rgnBorderBlackTopCls,rgnTopBorderOri;
			closing_rectangle1(rgnBorderBlackTopUni, &rgnBorderBlackTopCls, 1, 30);
			union1(rgnBorderBlackTopCls, &rgnBorderBlackTopCls); 
			polar_trans_region_inv(rgnBorderBlackTopCls, &rgnTopBorderOri, m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleEnd, RadiusStart, RadiusEnd, PI*(RadiusEnd+RadiusStart), RadiusEnd-RadiusStart, m_imgWidth, m_imgHeight, "nearest_neighbor");
		    
			Hobject rgnTopBorderCon,rgnTopBorderUni,rgnTopBorderUniCon;
			connection(rgnTopBorderOri,&rgnTopBorderCon);
			union1(rgnTopBorderCon,&rgnTopBorderUni);
			connection(rgnTopBorderUni,&rgnTopBorderUniCon);
			count_obj(rgnTopBorderUniCon, &iNumber);
			if (iNumber > 4 || ( iNumber < 1))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			Hobject rgnTopBorder;
			union1(rgnTopBorderUniCon,&rgnTopBorder);
			erosion_circle(rgnTopBorder,&rgnTopBorder,ErosionSize);

			m_rgnTopBorder = rgnTopBorder;
			m_vRgn[rId] = rgnTopBorder ;

		}
		else if(Selection==3)  //顶部叉口区域
		{
			//get the initial fork region
			Hobject rgnBorderBlackFork,rgnBorderBlackForkMoved1,rgnBorderBlackForkDil1,rgnBorderBlackForkMoved;
			select_shape(rgnBorderBlackSel1, &rgnBorderBlackFork, "row", "and", 0, dRowBlack);
			move_region(rgnBorderBlackFork, &rgnBorderBlackForkMoved1, 10, 0);
			dilation_rectangle1(rgnBorderBlackForkMoved1, &rgnBorderBlackForkDil1, 7, 1);
			
			Hobject rgnBorderBlackForkDil,XYTransRegionFork;
			move_region(rgnBorderBlackFork, &rgnBorderBlackForkMoved, 35, 0);
			dilation_rectangle1(rgnBorderBlackForkMoved, &rgnBorderBlackForkDil, 20, 1);
			union2(rgnBorderBlackForkDil, rgnBorderBlackFork, &rgnBorderBlackFork);
			union2(rgnBorderBlackForkDil1, rgnBorderBlackFork, &rgnBorderBlackFork);

			polar_trans_region_inv(rgnBorderBlackFork, &XYTransRegionFork, m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleEnd, RadiusStart, RadiusEnd, PI*(RadiusEnd+RadiusStart), RadiusEnd-RadiusStart, m_imgWidth, m_imgHeight, "nearest_neighbor");
			
			Hobject rgnForkUni,rgnForkCls,rgnForkCon;
			union1(XYTransRegionFork, &rgnForkUni);
			closing_circle(rgnForkUni, &rgnForkCls, 35);
			connection(rgnForkCls, &rgnForkCon);

			HTuple dBlackForkArea,dBlackForkRow,dBlackForkCol,iNumberFork;
			area_center(rgnForkCon, &dBlackForkArea, &dBlackForkRow, &dBlackForkCol);
			count_obj(rgnForkCon, &iNumberFork);
			if ((iNumberFork > 4) || ( iNumberFork < 1))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			//according to the initial fork region to get the whole region
			Hobject rgnForkAnnlus,rgnForkOri,rgnFork,rgnTopHightDil;
			AnnulusRegionLocation(&rgnForkAnnlus, m_InnerCircleRow, m_InnerCircleCol, OutEdge, OutEdge - InnerEdge);
			intersection(rgnForkAnnlus, rgnForkCon, &rgnForkOri);
			Hobject rgnTopBorderDil;
			dilation_circle(m_rgnTopBorder,&rgnTopBorderDil,ForkEdge);
			difference(rgnForkOri, rgnTopBorderDil, &rgnFork);
			dilation_circle(m_TopRegs, &rgnTopHightDil, 3.5);
			difference(rgnFork, rgnTopHightDil, &rgnFork);
			closing_circle(rgnFork,&rgnFork,5);

			erosion_circle(rgnFork,&rgnFork,ErosionSize);
			
			union1(rgnFork,&rgnFork);
			m_rgnTopFork = rgnFork;
			m_vRgn[rId] = rgnFork ;	
		}
		else if(Selection==4)  //顶部斜坡区域
		{
			Hobject rgnForkAnnlus,rgnForkDil,rgnSlopOri,rgnSlopOriOpn,rgnSlopOriCls,rgnSlopOriCon;
			AnnulusRegionLocation(&rgnForkAnnlus, m_InnerCircleRow, m_InnerCircleCol, OutEdge, OutEdge - InnerEdge);
			dilation_circle(m_rgnTopFork, &rgnForkDil, ForkEdge);
			difference(rgnForkAnnlus, rgnForkDil, &rgnSlopOri);
			opening_circle(rgnSlopOri, &rgnSlopOriOpn, 5);
			closing_circle(rgnSlopOriOpn, &rgnSlopOriCls, 5);

			HTuple iSlopNum;
			connection(rgnSlopOriCls, &rgnSlopOriCon);
			count_obj(rgnSlopOriCon, &iSlopNum);
			if (iSlopNum > 4 || (iSlopNum < 1))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
		    
			Hobject rgnTopSlop;
			union1(rgnSlopOriCon,&rgnTopSlop);
			erosion_circle(rgnTopSlop,&rgnTopSlop,ErosionSize);
			m_vRgn[rId] = rgnTopSlop ;	
		}


#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_TopForkRegionLocationAlgo(VARIANT* rgnId, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT* pAreaLimitUp)
{
	int rId = (int)rgnId->fltVal;

	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;
	int AreaLimitUp=(int)pAreaLimitUp->fltVal;

	if (InnerEdge>OutEdge)
	{
		//4、95
		InnerEdge=OutEdge-(float)0.5;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 || m_modelAngle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		Hobject SearchReg,ImageReduced5,Region2,RegionOpening3,ConnectedRegions6,SelectedRegions5;
		if (m_locationRadius<21)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		gen_circle(&SearchReg, fCenterY, fCenterX, m_locationRadius-20);
		reduce_domain(Image, SearchReg, &ImageReduced5);
		threshold(ImageReduced5, &Region2, ThredLower, 255);
		opening_circle(Region2, &RegionOpening3, 7.5);
		connection(RegionOpening3, &ConnectedRegions6);
		select_shape(ConnectedRegions6, &SelectedRegions5, "area", "and", AreaLimitLower, 9999999);

		Hobject RegionUnion3,PolarTransImage1;
		HTuple AngleStart;
		union1(SelectedRegions5, &RegionUnion3);
		AngleStart = m_modelAngle-(HTuple(50).Rad());
		HTuple RadiusMoveSize,RadiusStart;
		RadiusMoveSize = 5;
		RadiusStart = m_InnerCircleRadius-RadiusMoveSize;
		if (RadiusStart<=0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		Hobject RegionUnion2,RegionForDist,RegionMoved3,RegionDilation6,RegionUnion1,SortedRegions;
		HTuple Number;
		polar_trans_image_ext(ImageReduced5, &PolarTransImage1, m_InnerCircleRow, m_InnerCircleCol,AngleStart, AngleStart+6.28319, RadiusStart, RadiusStart+100, (m_InnerCircleRadius+50)*6.28319, 100, "nearest_neighbor");
		union1(SelectedRegions5, &RegionUnion2);
		polar_trans_region(RegionUnion2, &RegionForDist, m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleStart+6.28319, RadiusStart, RadiusStart+100, (m_InnerCircleRadius+50)*6.28319, 100, "nearest_neighbor");
		move_region(RegionForDist, &RegionMoved3, 33, 0);
		dilation_circle(RegionMoved3, &RegionDilation6, 5.5);
		union2(RegionForDist, RegionDilation6, &RegionUnion1);
		closing_rectangle1(RegionUnion1, &RegionForDist, 3, 31);
		connection(RegionUnion1, &RegionForDist);
		sort_region(RegionForDist, &SortedRegions, "first_point", "true", "column");
		count_obj(SortedRegions, &Number);

		Hobject TopRegsCalibration,TopRegsCalibrationNew,TopRegsForCalibrationRight,TopRegsForCalibrationLeft,ObjectSelected1,Rectangle,RegionDifference7,ConnectedRegions5;
		Hobject SelectedRegions4,RegionOpening2,Partitioned,ObjectSelectedLeft,ObjectSelectedRight,RegionClippedLeft,RegionClippedRight;
		HTuple DilationSizeLeft,DilationSizeRight,Row11, Column11, Row2, Column2,ColumnCenter,Number1,AreaLeft, Row, Column,AreaRight;
		gen_empty_obj(&TopRegsCalibration);
		gen_empty_obj(&TopRegsCalibrationNew);
		gen_empty_obj(&TopRegsForCalibrationRight);
		gen_empty_obj(&TopRegsForCalibrationLeft);
		DilationSizeLeft = HTuple();
		DilationSizeRight = HTuple();
		for (int Index2=1; Index2<=Number; Index2 ++)
		{
			select_obj(SortedRegions, &ObjectSelected1, Index2);
			smallest_rectangle1(ObjectSelected1, &Row11, &Column11, &Row2, &Column2);
			ColumnCenter = (Column11+Column2)/2.0;
			gen_rectangle1(&Rectangle, 0, ColumnCenter-40, Row11+30, ColumnCenter+40);
			difference(Rectangle, ObjectSelected1, &RegionDifference7);
			connection(RegionDifference7, &ConnectedRegions5);
			select_shape_std(ConnectedRegions5, &SelectedRegions4, "max_area", 70);
			opening_rectangle1(SelectedRegions4, &RegionOpening2, 7, 3);
			partition_rectangle(RegionOpening2, &Partitioned, 1, 160);
			count_obj(Partitioned, &Number1);
			//左右分清楚
			select_obj(Partitioned, &ObjectSelectedLeft, 1);
			area_center(ObjectSelectedLeft, &AreaLeft, &Row, &Column);
			select_obj(Partitioned, &ObjectSelectedRight, Number1);
			area_center(ObjectSelectedRight, &AreaRight, &Row, &Column);
			DilationSizeLeft.ReplaceElements(Index2,AreaLeft-5);
			DilationSizeRight.ReplaceElements(Index2,AreaRight-5);

			clip_region(ObjectSelected1, &RegionClippedLeft, Row11, Column11-5, Row2+5, ColumnCenter+30);
			clip_region(ObjectSelected1, &RegionClippedRight, Row11, ColumnCenter-30, Row2+5, Column2+5);
			concat_obj(TopRegsForCalibrationLeft, RegionClippedLeft, &TopRegsForCalibrationLeft);
			concat_obj(TopRegsForCalibrationRight, RegionClippedRight, &TopRegsForCalibrationRight);
		}
		Hobject XYTransRegionCalibrationLeft,XYTransRegionCalibrationRight,RegionDilationLeft,RegionDilationRight,ObjectSelected2,TopRegsCalibrationUnion;
		HTuple CalibrationRate;
		polar_trans_region_inv(TopRegsForCalibrationLeft, &XYTransRegionCalibrationLeft, m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleStart+6.28319, RadiusStart, RadiusStart+100, (m_InnerCircleRadius+50)*6.28319, 100, m_imgWidth, m_imgHeight, "nearest_neighbor");
		polar_trans_region_inv(TopRegsForCalibrationRight, &XYTransRegionCalibrationRight,m_InnerCircleRow, m_InnerCircleCol, AngleStart, AngleStart+6.28319, RadiusStart,RadiusStart+100, (m_InnerCircleRadius+50)*6.28319, 100, m_imgWidth, m_imgHeight, "nearest_neighbor");
		CalibrationRate = 0.85;
		gen_empty_region(&RegionDilationLeft);
		gen_empty_region(&RegionDilationRight);
		for (int Index3=1; Index3<=Number; Index3++)
		{
			select_obj(XYTransRegionCalibrationLeft, &ObjectSelected2, Index3);
			if (0 != ((DilationSizeLeft.Select(Index3))>=0.5))
			{
				dilation_circle(ObjectSelected2, &RegionDilationLeft, ((DilationSizeLeft.Select(Index3))*CalibrationRate)+0.5);
			}
			else
			{
				concat_obj(RegionDilationLeft, ObjectSelected2, &RegionDilationLeft);
			}
			select_obj(XYTransRegionCalibrationRight, &ObjectSelected2, Index3);
			if (0 != ((DilationSizeRight.Select(Index3))>=0.5))
			{
				dilation_circle(ObjectSelected2, &RegionDilationRight, ((DilationSizeRight.Select(Index3))*CalibrationRate)+0.5);
			}
			else
			{
				concat_obj(RegionDilationRight, ObjectSelected2, &RegionDilationRight);
			}
			concat_obj(TopRegsCalibrationNew, RegionDilationLeft, &TopRegsCalibrationNew);
			concat_obj(TopRegsCalibrationNew, RegionDilationRight, &TopRegsCalibrationNew);
		}
		union1(TopRegsCalibrationNew, &TopRegsCalibrationUnion);
		//
		Hobject Circle11,Circle12,RegionOpening4,RegionClosing2,RegionDilation1,RegionDifference1,RegionDifference2;
		gen_circle(&Circle11, m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+InnerEdge);
		gen_circle(&Circle12, m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+OutEdge);
		opening_circle(TopRegsCalibrationUnion, &RegionOpening4, 11);
		closing_circle(RegionOpening4, &RegionClosing2, 23.5);
		dilation_circle(RegionClosing2, &RegionDilation1, ErosionSize);  //原区域叉口边缘
		difference(Circle12, Circle11, &RegionDifference1);
		difference(RegionDifference1, RegionDilation1, &RegionDifference2);

		//去掉变形引起的 多余边角区域
		Hobject RegionOpening5,RegionBorder,RegionErosion,RegionIntersection,Circle14,ConnectedRegions3;
		HTuple Row3, Column3, Phi, Length1, Length2;
		opening_circle(RegionDifference2, &RegionOpening5, 7.5);
		boundary(RegionOpening5, &RegionBorder, "outer");
		erosion_circle(RegionDifference1, &RegionErosion, 11.5);
		intersection(RegionBorder, RegionErosion, &RegionIntersection);
		gen_circle(&Circle14, m_InnerCircleRow, m_InnerCircleCol, m_InnerCircleRadius+60);
		intersection(RegionIntersection, Circle14, &RegionIntersection);
		connection(RegionIntersection, &ConnectedRegions3);
		smallest_rectangle2(ConnectedRegions3, &Row3, &Column3, &Phi, &Length1, &Length2);

		HTuple TupleLength2,MeanGray1,MeanGray2,MeanGray3,MeanGray4,MeanGray5,MeanGray6,CenterColOrg;
		HTuple CenterRow,CenterCol,Mean2, Deviation2;
		Hobject Rectangle1;
		TupleLength2 = ((Length2+2).Sgn())*1.5;
		MeanGray1 = TupleLength2*2;
		MeanGray2 = TupleLength2*2;
		MeanGray3 = TupleLength2*2;
		MeanGray4 = TupleLength2*2;
		MeanGray5 = TupleLength2*2;
		MeanGray6 = TupleLength2*2;
		CenterColOrg = (TupleLength2*2)*m_InnerCircleCol;
		for (int Index4=-5; Index4<=5; Index4+=1)
		{
			CenterRow = Row3+(Index4*(Phi.Cos()));
			CenterCol = Column3+(Index4*(Phi.Sin()));
			gen_rectangle2(&Rectangle1, CenterRow, CenterCol, Phi, Length1,TupleLength2);
			if (Phi.Num()!=6)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			//*
			intensity(Rectangle1, Image, &Mean2, &Deviation2);
			MeanGray1.ReplaceElements(Index4+5,Mean2.Select(0));
			MeanGray2.ReplaceElements(Index4+5,Mean2.Select(1));
			MeanGray3.ReplaceElements(Index4+5,Mean2.Select(2));
			MeanGray4.ReplaceElements(Index4+5,Mean2.Select(3));
			MeanGray5.ReplaceElements(Index4+5,Mean2.Select(4));
			MeanGray6.ReplaceElements(Index4+5,Mean2.Select(5));
		}
		HTuple DefineNum,Indices11;
		DefineNum = (TupleLength2*2).Round();
		tuple_sort_index(MeanGray1, &Indices11);
		DefineNum.ReplaceElements(0,Indices11.Select(0));
		tuple_sort_index(MeanGray2, &Indices11);
		DefineNum.ReplaceElements(1,Indices11.Select(0));
		tuple_sort_index(MeanGray3, &Indices11);
		DefineNum.ReplaceElements(2,Indices11.Select(0));
		tuple_sort_index(MeanGray4, &Indices11);
		DefineNum.ReplaceElements(3,Indices11.Select(0));
		tuple_sort_index(MeanGray5, &Indices11);
		DefineNum.ReplaceElements(4,Indices11.Select(0));
		tuple_sort_index(MeanGray6, &Indices11);
		DefineNum.ReplaceElements(5,Indices11.Select(0));

		CenterRow = Row3+((-5+DefineNum)*(Phi.Cos()));
		CenterCol = Column3+((-5+DefineNum)*(Phi.Sin()));

		Hobject Rectangle11,RegionUnion4,RegionDifference4,ConnectedRegions4,SelectedRegions3,RegionUnion5,RegionDilation7,RegionErosion2,RegionPlatform,RegionErosion1;
		gen_rectangle2(&Rectangle11, CenterRow, CenterCol, Phi, Length1+46, TupleLength2+ForkEdge);
		//*个别边缘提取错误，需要剔除 （使用原来的区域边缘）
		union1(Rectangle11, &RegionUnion4);
		difference(RegionDifference1, RegionUnion4, &RegionDifference4);
		connection(RegionDifference4, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions3, "area", "and", 1000, AreaLimitUp);
		union1(SelectedRegions3, &RegionUnion5);
		dilation_circle(RegionUnion5, &RegionDilation7, 2.5);
		erosion_circle(RegionDifference2, &RegionErosion2, 1.5);
		union2(RegionErosion2, RegionDilation7, &RegionPlatform);
		opening_circle(RegionPlatform, &RegionPlatform, 3.5);

		union1(RegionPlatform,&RegionPlatform);
		m_vRgn[rId] = RegionPlatform ;	

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopForkRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1076;FP;1;250;0.5;130$\
					 1077;LP;1;15000;1;6000$\
					 1103;FP;1;20;0.5;8.5$\
					 1078;LP;0;30;1;5$\
					 1079;FP;1;80;0.5;6$\
					 1080;FP;1;200;0.5;95$\
					 519;LP;1;30000;1;13000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_TopRubberRegionLocationAlgo(VARIANT* rgnId, VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT*pAreaLimitLower)
{
	int rId = (int)rgnId->fltVal;

	int InnerEdge = (int)pInnerEdge->fltVal;
	int OutEdge = (int)pOutEdge->fltVal;

	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_RubberReg0.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	if (m_InnerCircleRow1.Num()!=1 || m_InnerCircleCol1.Num()!=1 || m_modelAngle.Num()!=1||m_TopRadius.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//边缘缺胶区域
		Hobject TopRegionDilation,RegionErosion,TopRegionErosion,RegionDiff,ConnectedRegions1;

		if (OutEdge>0)
		{
			dilation_rectangle1(m_RubberReg0,&TopRegionDilation, OutEdge, 1);

		} 
		else if(OutEdge<0)
		{
			erosion_rectangle1(m_RubberReg0,&TopRegionDilation, -OutEdge, 1);

		}
		else
		{
			TopRegionDilation=m_RubberReg0;
		}
		erosion_rectangle1(TopRegionDilation, &RegionErosion, 1, 25);
		erosion_rectangle1(m_RubberReg0,&TopRegionErosion, InnerEdge, 1);
		difference(RegionErosion, TopRegionErosion, &RegionDiff);

		connection(RegionDiff, &ConnectedRegions1);

		Hobject RubberRegs;
		select_shape (ConnectedRegions1, &RubberRegs, "area", "and", AreaLimitLower, 9999999);
		HTuple Radius;
		Radius=m_TopRadius;
		Hobject XYTransRubberRegs;
		polar_trans_region_inv(RubberRegs, &XYTransRubberRegs, m_InnerCircleRow1, m_InnerCircleCol1, m_modelAngle+(HTuple(60).Rad()), (6.28319+m_modelAngle)+(HTuple(60).Rad()), 0, Radius, (Radius*2)*3.14, Radius,  m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1(XYTransRubberRegs,&XYTransRubberRegs);

		m_vRgn[rId] = XYTransRubberRegs;
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_TopRubberRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1157$\
					 167;B$\
					 1158;LP;1;160;1;45$\
					 1159;LP;-130;130;1;10$\
					 1174;LP;5;1500;1;45");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//D20_（20三叉）
STDMETHODIMP CPlugAlgo::CrownCenterRelocationAlgo(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pMaskSize,VARIANT* pThreshLowValue,VARIANT* pThreshUpValue,VARIANT* pAreaLimitSize)
{
	int rId = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;

	float maskSize    = (float)pMaskSize->fltVal;
	int ThreshLowValue = (int)pThreshLowValue->fltVal;
	int ThreshUpValue = (int)pThreshUpValue->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	m_fCenterX = fCenterX;
	m_fCenterY = fCenterY;
	if(ThreshUpValue<=ThreshLowValue)
	{
		ThreshUpValue=ThreshLowValue+3;
	}
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject Image=m_crtImg;
		//
		Hobject ROI,Circle,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		gen_circle(&ROI, fCenterY, fCenterX, Radius);
		intersection(ROI, ImageDomain, &ROI);
		m_vRgn[rId]=ROI;

		Hobject ImageReduced,ImageScaleMax,ExpandedImage;
		reduce_domain(Image, ROI, &ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		expand_domain_gray(ImageScaleMax, &ExpandedImage, 2);
		Hobject ImageSmooth,ImageReduced1;
		smooth_image(ExpandedImage, &ImageSmooth, "deriche2", 0.5);
		reduce_domain(ImageSmooth, ROI, &ImageReduced1);

		Hobject Edges,EdgesRegion;
		edges_sub_pix(ImageReduced1, &Edges, "canny", maskSize, ThreshLowValue, ThreshUpValue);
		gen_empty_region(&EdgesRegion);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], ROI, &m_vRgn[rId]);
		}

		HTuple Number;
		count_obj(Edges, &Number);

		if (Number<1)
		{
			gen_circle(&Circle,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			return S_FALSE;
		}

		Hobject ObjectSelected,Region;
		for (int i=1;i<=Number;i++)
		{
			select_obj(Edges, &ObjectSelected, i);
			gen_region_contour_xld(ObjectSelected, &Region, "margin");
			concat_obj(Region, EdgesRegion, &EdgesRegion);
		}

		Hobject SelectedRegions,RegionUnion,RegionFillUp;
		select_shape(EdgesRegion, &SelectedRegions, "area", "and", AreaLimitSize, 999999);
		union1(SelectedRegions, &RegionUnion);
		fill_up(RegionUnion, &RegionFillUp);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], SelectedRegions, &m_vRgn[rId]);
		}

		HTuple area,row,col;
		area_center(RegionFillUp,&area,&row,&col);
		if (0 != (area>0))
		{	
			HTuple CenterRow, CenterColumn, CenterRadius;
			smallest_circle(RegionFillUp, &CenterRow, &CenterColumn, &CenterRadius);
			Hobject CenterCircle;

			//
			double a =abs(CenterColumn[0].D()-fCenterX);
			double b =abs(CenterRow[0].D()-fCenterY);
			if (0 != ((a<10)&&(b<10)))
			{
				gen_circle(&CenterCircle,CenterRow, CenterColumn, CenterRadius);
				m_vPos[0].m_y = (float)CenterRow[0].D();
				m_vPos[0].m_x = (float)CenterColumn[0].D();
				if(m_bDebugImg)
				{
					concat_obj(m_vRgn[rId], CenterCircle, &m_vRgn[rId]);
				}

			}
			else
			{
				gen_circle(&Circle,fCenterY, fCenterX, Radius);
				m_vPos[0].m_x = fCenterX;
				m_vPos[0].m_y = fCenterY;
				return S_FALSE;
			}
		}
		else
		{
			gen_circle(&Circle,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownCenterRelocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1035$\
					 381;B$\
					 859;LP;20;300;1;100$\
					 643;FP;0.1;20;0.1;1.5$\
					 762;LP;1;100;1;20$\
					 763;LP;1;200;1;40$\
					 861;LP;50;1000;1;200");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************
** 函 数 名：CrownCenterRelocationAlgo1 
** 功    能： 环形图案中心二次定位。用于图案区域较淡时的区域提取，进而得到定位消息
** 修改说明：（1）时  间：2018年08月10日 
**                修改人：吴贻峰 
**                内  容：将程序最后的开运算尺寸从3.5减小至0.5
******************************************************************************************/
STDMETHODIMP CPlugAlgo::CrownCenterRelocationAlgo1(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pMaskSize,VARIANT* pThreshBlackValue,VARIANT* pAreaLimitSize)
{
	int rId = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;

	int maskSize    = (int)pMaskSize->fltVal;
	int ThreshLowValue = (int)pThreshBlackValue->fltVal;
	int AreaLimitSize = (int)pAreaLimitSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	m_fCenterX = fCenterX;
	m_fCenterY = fCenterY;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject Image=m_crtImg;
		//
		Hobject ROI,Circle,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		gen_circle(&ROI, fCenterY, fCenterX, Radius);
		intersection(ROI, ImageDomain, &ROI);
		m_vRgn[rId]=ROI;

		Hobject ImageReduced,ImageEmphasize,ExpandedImage;
		reduce_domain(Image, ROI, &ImageReduced);
		scale_image_max(ImageReduced, &ImageEmphasize);
		HTuple RadiusInner,RadiusExt,AngleRad,HeightPolar,WidthPolar;
		Hobject PolarTransImage,ImageMin;
		RadiusInner = 32;
		RadiusExt = Radius;
		AngleRad = 6.5;
		HeightPolar = RadiusExt-RadiusInner;
		WidthPolar = ((RadiusExt+RadiusInner)*AngleRad)*0.5;
		polar_trans_image_ext(ImageEmphasize, &PolarTransImage, fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, "nearest_neighbor");

		gray_erosion_rect(PolarTransImage, &ImageMin, 1, maskSize);
		Hobject ImageMean,ImageMean1,RegionDynThresh,RegionClosing1,RegionOpening2,XYTransRegion;
		mean_image(ImageMin, &ImageMean, 25, 1);

		mean_image(ImageMean, &ImageMean1, 1, 1+HeightPolar/1.5);

		dyn_threshold(ImageMean, ImageMean1, &RegionDynThresh, ThreshLowValue, "dark");

		closing_rectangle1(RegionDynThresh, &RegionClosing1, 21, 1);

		opening_rectangle1(RegionClosing1, &RegionOpening2, 15, 1);
		polar_trans_region_inv(RegionOpening2, &XYTransRegion,  fCenterY, fCenterX, 0, AngleRad, RadiusInner, RadiusExt, WidthPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");

		Hobject Circle1,Circle2,RegionDifference,RegionErosion,RegionIntersection,ConnectedRegions,SelectedRegions,RegionUnion;
		gen_circle(&Circle1,   fCenterY, fCenterX, RadiusInner);
		gen_circle(&Circle2,   fCenterY, fCenterX, RadiusExt);
		difference(Circle2, Circle1, &RegionDifference);
		erosion_circle(RegionDifference, &RegionErosion, 3.5);
		intersection(XYTransRegion, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitSize, 99999);
		union1(SelectedRegions, &RegionUnion);
		//
		Hobject RegionClosing2,RegionErosion1,RegionDifference1,RegionUnion1,RegionOpening1,RegionFillUp;
		closing_circle(RegionUnion, &RegionClosing2, 23.5);
		erosion_circle(RegionClosing2, &RegionErosion1, 3.5);
		//
		difference(RegionErosion1, RegionUnion, &RegionDifference1);
		union1(RegionDifference1, &RegionUnion1);
		opening_circle(RegionUnion1, &RegionOpening1, 0.5);	
		fill_up(RegionOpening1, &RegionFillUp);
		HTuple Row2,Column2,Radius2;
		smallest_circle(RegionFillUp, &Row2, &Column2, &Radius2);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionFillUp, &m_vRgn[rId]);
		}
		if (Radius2<10)
		{
			gen_circle(&Circle,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			return S_FALSE;
		}
		double a =abs(Column2[0].D()-fCenterX);
		double b =abs(Row2[0].D()-fCenterY);
		if (0 != ((a<12)&&(b<12)))
		{
			Hobject CenterCircle;
			gen_circle(&CenterCircle,Row2, Column2, Radius2);
			m_vPos[0].m_y = (float)Row2[0].D();
			m_vPos[0].m_x = (float)Column2[0].D();
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], CenterCircle, &m_vRgn[rId]);
			}

		}
		else
		{
			gen_circle(&Circle,fCenterY, fCenterX, Radius);
			m_vPos[0].m_x = fCenterX;
			m_vPos[0].m_y = fCenterY;
			return S_FALSE;
		}
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CrownCenterRelocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1035$\
					 381;B$\
					 859;LP;20;300;1;100$\
					 412;LP;1;101;2;3$\
					 415;LP;1;250;1;40$\
					 861;LP;50;1000;1;200");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************
**函 数 名：SidePlatformRegionLocationAlgo
**功    能：叉口区域提取
**说    明：该算子是从D20_PlatformDetectAlgo等叉口平台提取算子中传递叉口区域
**          进行相应的缩放与控制操作
**************************************************************************/
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgo(VARIANT* rgnId, VARIANT* pClosingSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	float ClosingSize   = (float)pClosingSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_Platform.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject PlatformDetectReg,PlatformDetectRegClosing;
		closing_circle(m_Platform,&PlatformDetectRegClosing, ClosingSize);
		//水平垂直缩放
		erosion_rectangle1(PlatformDetectRegClosing,&PlatformDetectReg,HErosionSize,VErosionSize);
		m_vRgn[rId] = PlatformDetectReg ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1060$\
					 167;B$\
					 1061;FP;1;20;0.5;10$\
					 994;LP;1;35;1;5$\
					 995;LP;1;35;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************************************************
**函 数 名：SidePlatformRegionLocationAlgo1
**功    能：叉口区域二次提取
**说    明：该算子是从D20_PlatformDetectAlgo等叉口平台提取算子中传递叉口区域
**           然后进行二次提取，以防止第一次提取的叉口区域不够完整，并进行相应的缩放与控制操作
**时    间：2019年7月4日
*********************************************************************************************/
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pABEdgeMov,VARIANT* pThredLow,VARIANT* pClosingSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int ABEdgeMov     = (int)pABEdgeMov->fltVal;                // 60
	int ThredLow      =  (int)pThredLow->fltVal;                // 10
	float ClosingSize   = (float)pClosingSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_Platform.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//二次提取
		Hobject rgnPlatformDil,GrayImage,imgPlatformDil,rgnPlatFormOri,rgnPlatFormOriFil,rgnPlatFormOriOpn;
		Hobject rgnPlatFormOriCon ;
		HTuple Mean, Deviation,iNum ;
		GrayImage = m_crtImg;
		dilation_rectangle1(m_Platform, &rgnPlatformDil, 30, 60);
		reduce_domain(GrayImage, rgnPlatformDil, &imgPlatformDil);
		intensity(rgnPlatformDil, GrayImage, &Mean, &Deviation);
		threshold(imgPlatformDil, &rgnPlatFormOri, Mean-ThredLow, 255);
		fill_up(rgnPlatFormOri, &rgnPlatFormOriFil);
		opening_circle(rgnPlatFormOriFil, &rgnPlatFormOriOpn, 5.5);
		/*connection(rgnPlatFormOriOpn, &rgnPlatFormOriCon);
		count_obj(rgnPlatFormOriCon, &iNum);*/

		//基准线限制筛选
		Hobject rgnPlatForm,rgnABEdgeMove,rgnABEdgeDil;
		HTuple dDilSize;
		gen_empty_obj(&rgnPlatForm);
		dDilSize =ABEdgeMov/2.0;
		move_region(m_ABEdge, &rgnABEdgeMove, -dDilSize, 0);
		dilation_rectangle1(rgnABEdgeMove,&rgnABEdgeDil,1,ABEdgeMov);
		difference(rgnPlatFormOriOpn,rgnABEdgeDil,&rgnPlatForm);

		HTuple dRow1,dCol1,dRow2,dCol2;
		Hobject rgnRect,rgnRectMov;
		smallest_rectangle1(rgnABEdgeDil, &dRow1,&dCol1,&dRow2,&dCol2);
		gen_rectangle1(&rgnRect,dRow1,dCol1,dRow2,dCol2);
		move_region(rgnRect,&rgnRectMov,-ABEdgeMov,0);
		intersection(rgnPlatForm,rgnRectMov,&rgnPlatForm);
		
		Hobject rgnPlatFormCon,rgnPlatFormSel;
		connection(rgnPlatForm,&rgnPlatFormCon);
		select_shape(rgnPlatFormCon,&rgnPlatFormSel,"area","and",50,9999999 );

		union1(rgnPlatFormSel, &rgnPlatForm);

		m_rgnPlatForm = rgnPlatForm;

		Hobject PlatformDetectReg,PlatformDetectRegClosing;
		closing_circle(rgnPlatForm,&PlatformDetectRegClosing, ClosingSize);
		//水平垂直缩放
		erosion_rectangle1(PlatformDetectRegClosing,&PlatformDetectReg,HErosionSize,VErosionSize);
		
		m_vRgn[rId] = PlatformDetectReg ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6081$\
					 167;B$\
					 6082;LP;1;150;1;60$\
					 6083;LP;-50;50;1;10$\
					 1061;FP;1;20;0.5;10$\
					 994;LP;1;35;1;5$\
					 995;LP;1;35;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************************************************
**函 数 名：SideNeckBorderRegionLocationAlgo
**功    能：侧面颈部叉口边缘拐角区域定位
**说    明：该算子可支持定位双叉和三叉胶塞的侧面叉口边缘拐角区域
**时    间：2019年7月4日
*********************************************************************************************/
STDMETHODIMP CPlugAlgo::SideNeckBorderRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6084$\
					 167;B$\
					 6090;LP;2;3;1;2$\
					 6085;LP;1;150;1;60$\
					 6086;LP;-50;50;1;1$\
					 6087;LP;1;300;1;190$\
					 6088;LP;1;150;1;40$\
					 6089;FP;-30;30;0.5;0$\
					 1021;FP;1;30;0.5;3.5$\
					 6005;LP;1;5000;1;500");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideNeckBorderRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection, VARIANT* pInnerBorderSize,VARIANT* pOuterBorderSize, VARIANT* pUpBoderSize,VARIANT* pDownBoderSize,VARIANT* pStripeScale,VARIANT* pPlatformSize,VARIANT* pAreaSize)
{
	int rId               = (int)rgnId->fltVal;
	int Selection         = (int)pSelection->fltVal;          // 2,3
	int InnerBorderSize   = (int)pInnerBorderSize->fltVal;    // 60
	int OuterBorderSize   = (int)pOuterBorderSize->fltVal;    // 50
    int UpBoderSize       = (int)pUpBoderSize->fltVal;        // 190
	int DownBoderSize     = (int)pDownBoderSize->fltVal;      // 40
	float   StripeScale   = (float)pStripeScale->fltVal;      // 3.5
	float  PlatformSize   = (float)pPlatformSize->fltVal;     // 3.5
	int     AreaSize      = (int)pAreaSize->fltVal;           // 800
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_PlatformReg.Id()== H_EMPTY_REGION) || (m_ABEdge.Id()== H_EMPTY_REGION) || (m_ARegionT.Id() == H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnStripe;
		if ( Selection == 2)
		{
			union2(m_LowerReg,m_UpReg,&rgnStripe);
		}
		else if(Selection == 3)
		{
			rgnStripe = m_StripeRegD;
		}
		else
			gen_empty_obj(&rgnStripe);

		//get teh inial border region
		Hobject rgnPlatformDil1,rgnPlatformDil2,rgnDiff ;
		HTuple dAreaBorderOri,dRowBorderOri,dColBorderOri ;
		dilation_rectangle1(m_PlatformReg, &rgnPlatformDil1, InnerBorderSize, InnerBorderSize/3+1);
		dilation_rectangle1(m_PlatformReg, &rgnPlatformDil2, 1, 100);
		difference(rgnPlatformDil1, rgnPlatformDil2, &rgnDiff);
		union1(rgnDiff, &rgnDiff);
		area_center(rgnDiff, &dAreaBorderOri, &dRowBorderOri, &dColBorderOri);

		//control the up edge
		Hobject rgnABEdgeMoved1,rgnABEdgeMovedDil1,rgnBorderSide1,rgnBorderSideCon1;
		move_region(m_ABEdge, &rgnABEdgeMoved1, -UpBoderSize, 0);
		dilation_rectangle1(rgnABEdgeMoved1, &rgnABEdgeMovedDil1, 1, 5);
		difference(rgnDiff, rgnABEdgeMovedDil1, &rgnBorderSide1);
		connection(rgnBorderSide1, &rgnBorderSideCon1);
		select_shape(rgnBorderSideCon1, &rgnBorderSide1, "row", "and", dRowBorderOri, 9999999);

		//control the down edge
		Hobject rgnABEdgeMoved2,rgnABEdgeMovedDil2,rgnBorderSide2,rgnBorderSideCon2,rgnBorderOri;
		move_region(m_ABEdge, &rgnABEdgeMoved2, -DownBoderSize/2, 0);
		dilation_rectangle1(rgnABEdgeMoved2, &rgnABEdgeMovedDil2, 1, DownBoderSize);
		difference(rgnBorderSide1, rgnABEdgeMovedDil2, &rgnBorderSide2);
		connection(rgnBorderSide2, &rgnBorderSideCon2);
		select_shape(rgnBorderSideCon2, &rgnBorderOri, (HTuple("row").Append("area")), "and", dRowBorderOri.Concat(AreaSize), (HTuple(9999999).Append(9999999)));

		//choose the region intersected with the ARegionDiff
		Hobject rgnARegionDil,rgnBorderOriCon,rgnBorder ;
		HTuple  iNumBorder ;
		if ( OuterBorderSize == 0)
		{
			rgnARegionDil = m_ARegionT;
		} 
		else if( OuterBorderSize > 0)
		{
			dilation_rectangle1(m_ARegionT, &rgnARegionDil,  OuterBorderSize,1);
		}
		else
			erosion_rectangle1(m_ARegionT, &rgnARegionDil,  -OuterBorderSize,1);
		
		connection(rgnBorderOri, &rgnBorderOriCon);
		count_obj(rgnBorderOriCon, &iNumBorder);

		gen_empty_obj(&rgnBorder);

		for (int i=1; i<= iNumBorder;i++)
		{
			Hobject objSelBorder,rgnBorderIntsct;
			HTuple dAreaTemp,dRowTemp, dColTemp;
			select_obj(rgnBorderOriCon, &objSelBorder, i);
			intersection(rgnBorderOriCon, rgnARegionDil, &rgnBorderIntsct);
			area_center(rgnBorderIntsct, &dAreaTemp, &dRowTemp, &dColTemp);
			if (dAreaTemp>0)
			{
				concat_obj(rgnBorder, rgnBorderIntsct, &rgnBorder);
			}
		}

		union1(rgnBorder, &rgnBorder);

		//difference the strip pattern and the platformReg
		Hobject rgnStripeDil,rgnStripeDownDil,PlatformRegDil,rgnBorder1,rgnBorder2;

		if ( StripeScale == 0)
		{
			rgnStripeDil = rgnStripe;
		} 
		else if( StripeScale > 0)
		{
			dilation_circle(rgnStripe, &rgnStripeDil, StripeScale);
		}
		else
			erosion_circle(rgnStripe, &rgnStripeDil, -StripeScale);

		difference(rgnBorder, rgnStripeDil, &rgnBorder1);

		dilation_rectangle1(m_PlatformReg, &PlatformRegDil, (Hlong)PlatformSize, 1);
		difference(rgnBorder1, PlatformRegDil, &rgnBorder2);

		connection(rgnBorder2, &rgnBorder2);
		select_shape(rgnBorder2, &rgnBorder2, "area", "and", AreaSize, 9999999999);

		m_vRgn[rId] = rgnBorder2 ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}

void CPlugAlgo::P_20D_SideInWallLocationL (Hobject rgnPlatForm, Hobject rgnTopUni, Hobject rgnSlopBlack, Hobject ABEdgeMoved1, Hobject *rgnInWallLeft, Hobject *rgnLineLimitL, 
	                                       HTuple m_TopRow, HTuple m_TopCol, HTuple dRowDownPos, HTuple dInnerEdgeSize, HTuple dOuterEndgeSize, HTuple dLeftUpEdgeSize)
{
	//******Left InWall Region Location****************
    Hobject  rgnPlatFormCon, xldPlatForm;
	HTuple  iNumPlatform, dRowS, dColS, dRowSMin;
	connection(rgnPlatForm, &rgnPlatFormCon);
	count_obj(rgnPlatFormCon, &iNumPlatform);
	if ( iNumPlatform == 1 )
	{
		union1(rgnPlatFormCon, &rgnPlatForm);
	}
	else if (iNumPlatform >= 2 )
	{
		select_shape(rgnPlatFormCon, &rgnPlatForm, "column", "and", 0, m_TopCol + 50);
	}
	else
	{
		gen_empty_obj(&rgnPlatForm);
		return;
	}

	Hobject rgnPlatFormLCon;
	HTuple  iNumSel;
	connection(rgnPlatForm,&rgnPlatFormLCon);
	count_obj(rgnPlatFormLCon,&iNumSel);
	if ( iNumSel != 1)
	{
		return;
	}

	gen_contour_region_xld(rgnPlatForm, &xldPlatForm, "border");
	get_contour_xld(xldPlatForm, &dRowS, &dColS);
	if (dRowS.Num() < 1)
	{
		return;
	}

	//get the left Up point of the contour
	HTuple  Indices, dColSSSel_LU, dColSSSor_LU, dColSSSelMax_LU;
	tuple_min(dRowS, &dRowSMin);
	tuple_find(dRowS, dRowSMin, &Indices);
	tuple_select(dColS, Indices, &dColSSSel_LU);
	tuple_sort(dColSSSel_LU, &dColSSSor_LU);
	tuple_min(dColSSSel_LU, &dColSSSelMax_LU);
	
	//* get the left down point
	HTuple  dColSMin, IndicesColMin, dRowSSSel_LD,dRowSSSelMax_LD;
	Hobject rgnLineL,rgnLineLDil;
    tuple_min(dColS, &dColSMin);
    tuple_find(dColS, dColSMin, &IndicesColMin);
    tuple_select(dRowS, IndicesColMin, &dRowSSSel_LD);
    tuple_max(dRowSSSel_LD, &dRowSSSelMax_LD);

	gen_region_line(&rgnLineL, dRowSMin, dColSSSelMax_LU-dInnerEdgeSize, dRowSSSelMax_LD, dColSMin+dOuterEndgeSize);
	dilation_rectangle1(rgnLineL, &rgnLineLDil, 1, 500);

	//decrease the platform
	Hobject rgnPlatFormDil, rgnInwallLOri,rgnInwallLOriCon, rgnInwallLOriSel;
	dilation_circle(rgnPlatForm, &rgnPlatFormDil, 1.5);
	difference(rgnLineLDil, rgnPlatFormDil, &rgnInwallLOri);

	connection(rgnInwallLOri, &rgnInwallLOriCon);
	select_shape(rgnInwallLOriCon, &rgnInwallLOriSel, "row", "and", 0, dRowDownPos);

	//union rgnSlopBlack
	Hobject rgnBlackCon,rgnBlackSel;
	connection(rgnSlopBlack, &rgnBlackCon);
	select_shape(rgnBlackCon, &rgnBlackSel, "column", "and", 0, m_TopCol);
	erosion_circle(rgnBlackSel, &rgnBlackSel, 3.5);
	union2(rgnBlackSel, rgnInwallLOriSel, &rgnInwallLOriSel);

	 //*截取基准线，获得左边的位置限位
	Hobject rgnLineLTemp,rgnLineLTempDil,rgnABEdgeIntsct,xldABEdgeIntsct,Cross ;
	HTuple  dRowInstctS, dColInstctS,dColInstctMin, iIndiceMin, dRowInstctSel,dRowInstctSelMax;
	gen_region_line(&rgnLineLTemp, dRowSMin, dColSSSelMax_LU, dRowSSSelMax_LD, dColSMin);
	dilation_rectangle1(rgnLineLTemp, &rgnLineLTempDil, 1, 500);

	intersection(rgnLineLTempDil, ABEdgeMoved1, &rgnABEdgeIntsct);
	gen_contour_region_xld(rgnABEdgeIntsct, &xldABEdgeIntsct, "border");
	get_contour_xld(xldABEdgeIntsct, &dRowInstctS, &dColInstctS);
	if (dRowInstctS.Num() < 1)
	{
		return;
	}
	tuple_min(dColInstctS, &dColInstctMin);
	tuple_find(dColInstctS, dColInstctMin, &iIndiceMin);
	tuple_select(dRowInstctS, iIndiceMin, &dRowInstctSel);
	tuple_max(dRowInstctSel, &dRowInstctSelMax);
	//gen_cross_contour_xld(&Cross, dRowInstctSelMax, dColInstctMin, 6, 0.78);

	//*最上边位置限位
	Hobject  rgnTopCon, rgnTopSel, xldTopSel, Cross5;
	HTuple  dAreaTop, dRowTop, dColTop,dColTopMin, iColTopMin,dTopRowS, dTopColS;
    connection(rgnTopUni, &rgnTopCon);
    area_center(rgnTopCon, &dAreaTop, &dRowTop, &dColTop);
	if (dAreaTop < 0)
	{
		return;
	}
    tuple_min(dColTop, &dColTopMin);
    tuple_find(dColTop, dColTopMin, &iColTopMin);
    select_obj(rgnTopCon, &rgnTopSel, iColTopMin+1);

	gen_contour_region_xld(rgnTopSel, &xldTopSel, "border");
	get_contour_xld(xldTopSel, &dTopRowS, &dTopColS);
	if (dTopRowS.Num() < 1)
	{
		return;
	}

	HTuple  dTopRowMax, iIndiceTopRowMax, dTopColSel;
	tuple_max(dTopRowS, &dTopRowMax);
	tuple_find(dTopRowS, dTopRowMax, &iIndiceTopRowMax);
	tuple_select(dTopColS, iIndiceTopRowMax, &dTopColSel);

	//get the mid value
	HTuple  dTopColSort, iLength, dTopColSelMid, dRowBegin, dColBegin, dRowEnd, dColEnd;
	tuple_sort(dTopColSel, &dTopColSort);
	tuple_length(dTopColSort, &iLength);
	if (iLength>=2)
	{
		dTopColSelMid = ((const HTuple&)dTopColSort)[iLength/2];
	}
	else if (iLength==1)
	{
		dTopColSelMid = ((const HTuple&)dTopColSort)[0];
	}
	else
	{
		return;
	}

	 //gen_cross_contour_xld(&Cross5, dTopRowMax, dTopColSelMid, 6, 0.78);
	dRowBegin = (dRowInstctSelMax*2)-dTopRowMax;
	dColBegin = (dColInstctMin*2)-dTopColSelMid;
	//gen_cross_contour_xld (Cross7, dRowBegin, dColBegin, 26, 0.78)
	dRowEnd = (dTopRowMax*2)-dRowInstctSelMax;
	dColEnd = (dTopColSelMid*2)-dColInstctMin;
	//gen_cross_contour_xld (Cross8, dRowEnd, dColEnd, 26, 0.78)
	Hobject  rgnLineCrossL, rgnLineCrossDil, rgnInwallL;
	gen_region_line(&rgnLineCrossL, dRowBegin, dColBegin+dLeftUpEdgeSize, dRowEnd, dColEnd+dLeftUpEdgeSize);
	dilation_rectangle1(rgnLineCrossL, &rgnLineCrossDil, 2, 2);

	//* output the left up position limit
    gen_empty_obj(&(*rgnLineLimitL));
    concat_obj((*rgnLineLimitL), rgnLineCrossDil, &(*rgnLineLimitL));
    union1((*rgnLineLimitL), &(*rgnLineLimitL));

	//decrease operation
	difference(rgnInwallLOriSel, rgnLineCrossDil, &rgnInwallL);
	connection(rgnInwallL, &rgnInwallL);
	select_shape_std(rgnInwallL, &rgnInwallL, "max_area", 70);

	gen_empty_obj(&(*rgnInWallLeft));
	concat_obj((*rgnInWallLeft), rgnInwallL, &(*rgnInWallLeft));
	union1(rgnInwallL, &rgnInwallL);

	return;
}

void CPlugAlgo::P_20D_SideInWallLocationR (Hobject rgnPlatForm, Hobject rgnTopUni, Hobject rgnSlopBlack,Hobject ABEdgeMoved1, Hobject *rgnInWallRight, Hobject *rgnLineLimitR, 
	                                       HTuple m_TopCol, HTuple dRowDownPos, HTuple dInnerEdgeSize, HTuple dOuterEndgeSize, HTuple dLeftUpEdgeSize)
{

	// Local iconic variables
	Hobject  rgnPlatFormCon, rgnPlatFormR, xldPlatFormR;
	Hobject  CrossRU, rgnLineR, rgnLineRDil, rgnPlatFormRDil;
	Hobject  rgnInwallROri, rgnInwallRCon, rgnInwallRSel;
	Hobject  rgnBlackCon, rgnBlackSel, rgnTopCon, rgnTopR;
	Hobject  xldTopR, rgnLineRTemp, rgnLineRTempDil;
	Hobject  rgnABEdgeIntsct, xldABEdgeIntsct, Cross;
	Hobject  rgnLineCrossR, rgnLineCrossDil, rgnLineCrossDiff;
	Hobject  rgnLineCrossCon, rgnInWallR;

	// Local control variables
	HTuple  iNumPlatform, dRowR, dColR, dColRMax;
	HTuple  iColMaxR, dRowSelR, dRowSelRMin, dRowRMin;
	HTuple  iRowMinR, dColSelR, dColSelRMin, dAreaTopS;
	HTuple  dRowTopS, dColTopS, dColTopMax, iColTopMax;
	HTuple  dTopRRowS, dTopRColS, dTopRRowMax, iTopRRowMax;
	HTuple  dTopRColSel, dTopRColSort, iLength, dTopRColSelMid;
	HTuple  dRowInstctS, dColInstctS, dColInstctMax;
	HTuple  iIndiceMax, dRowInstctSel, dRowInstctSelMax;
	HTuple  dRowBegin, dColBegin, dRowEnd, dColEnd;

	 //*right
	HTuple  dAreaUpPos, dRowUpPos, dColUpPos;
	area_center(ABEdgeMoved1, &dAreaUpPos, &dRowUpPos, &dColUpPos);

	connection(rgnPlatForm, &rgnPlatFormCon);
	count_obj(rgnPlatFormCon, &iNumPlatform);
	if ( iNumPlatform == 1 )
	{
		union1(rgnPlatFormCon, &rgnPlatFormR);
	}
	else if (iNumPlatform >= 2 )
	{
		select_shape(rgnPlatFormCon, &rgnPlatFormR, "column", "and", m_TopCol - 50, 999999);;
	}
	else
	{
		gen_empty_obj(&rgnPlatFormR);
		return;
	}

	Hobject rgnPlatFormRCon;
	HTuple  iNumSel;
	connection(rgnPlatFormR,&rgnPlatFormRCon);
	count_obj(rgnPlatFormRCon,&iNumSel);
	if ( iNumSel != 1)
	{
		return;
	}

	gen_contour_region_xld(rgnPlatFormR, &xldPlatFormR, "border");
	get_contour_xld(xldPlatFormR, &dRowR, &dColR);
	if (dRowR.Num() < 1)
	{
		return;
	}

	//*右边底部定位线
    //* right down
	tuple_max(dColR, &dColRMax);
	tuple_find(dColR, dColRMax, &iColMaxR);
	tuple_select(dRowR, iColMaxR, &dRowSelR);
	tuple_min(dRowSelR, &dRowSelRMin);
	//gen_cross_contour_xld (CrossRD, dRowSelRMin, dColRMax - dOuterEndgeSize, 6, 0.78)

	//right up
	tuple_min(dRowR, &dRowRMin);
	tuple_find(dRowR, dRowRMin, &iRowMinR);
	tuple_select(dColR, iRowMinR, &dColSelR);
	tuple_max(dColSelR, &dColSelRMin);
	//gen_cross_contour_xld (CrossRU, dRowRMin, dColSelRMin + dInnerEdgeSize, 6, 0.78)

	gen_region_line(&rgnLineR, dRowRMin, dColSelRMin+dInnerEdgeSize, dRowSelRMin, dColRMax-dOuterEndgeSize);
	dilation_rectangle1(rgnLineR, &rgnLineRDil, 1, 500);

	//decrease the platform
	dilation_circle(rgnPlatFormR, &rgnPlatFormRDil, 3.5);
	difference(rgnLineRDil, rgnPlatFormRDil, &rgnInwallROri);
	connection(rgnInwallROri, &rgnInwallRCon);
	select_shape(rgnInwallRCon, &rgnInwallRSel, "row", "and", 0, dRowDownPos);

	//union rgnSlopBlack
	connection(rgnSlopBlack, &rgnBlackCon);
	select_shape(rgnBlackCon, &rgnBlackSel, "column", "and", m_TopCol, 9999999);
	erosion_circle(rgnBlackSel, &rgnBlackSel, 1.5);
	union2(rgnBlackSel, rgnInwallRSel, &rgnInwallRSel);

	 //*****右上角限位
     //get the top right region
	connection(rgnTopUni, &rgnTopCon);
	area_center(rgnTopCon, &dAreaTopS, &dRowTopS, &dColTopS);
	if (dAreaTopS < 0)
	{
		return;
	}
	tuple_max(dColTopS, &dColTopMax);
	tuple_find(dColTopS, dColTopMax, &iColTopMax);
	select_obj(rgnTopCon, &rgnTopR, iColTopMax+1);

	//get the top rigth low point
	gen_contour_region_xld(rgnTopR, &xldTopR, "border");
	get_contour_xld(xldTopR, &dTopRRowS, &dTopRColS);
	if (dTopRRowS.Num() < 1)
	{
		return;
	}

	tuple_max(dTopRRowS, &dTopRRowMax);
	tuple_find(dTopRRowS, dTopRRowMax, &iTopRRowMax);
	tuple_select(dTopRColS, iTopRRowMax, &dTopRColSel);
	//tuple_min (dTopRColSel, dTopColSelMin)

	//get the mid value
	tuple_sort(dTopRColSel, &dTopRColSort);
	tuple_length(dTopRColSort, &iLength);

	if (iLength>=2)
	{
		dTopRColSelMid = ((const HTuple&)dTopRColSort)[iLength/2];
	}
	else if (iLength==1)
	{
		dTopRColSelMid = ((const HTuple&)dTopRColSort)[0];
	}
	else
	{
		return;
	}
	//gen_cross_contour_xld(&CrossRU, dTopRRowMax, dTopRColSelMid, 6, 0.78);

	//baseline limit the mid-pos
	gen_region_line(&rgnLineRTemp, dRowRMin, dColSelRMin, dRowSelRMin, dColRMax);
	dilation_rectangle1(rgnLineRTemp, &rgnLineRTempDil, 1, 500);

	intersection(rgnLineRTempDil, ABEdgeMoved1, &rgnABEdgeIntsct);
	gen_contour_region_xld(rgnABEdgeIntsct, &xldABEdgeIntsct, "border");
	get_contour_xld(xldABEdgeIntsct, &dRowInstctS, &dColInstctS);
	if (dRowInstctS.Num() < 1)
	{
		return;
	}

	tuple_max(dColInstctS, &dColInstctMax);
	tuple_find(dColInstctS, dColInstctMax, &iIndiceMax);
	tuple_select(dRowInstctS, iIndiceMax, &dRowInstctSel);
	tuple_max(dRowInstctSel, &dRowInstctSelMax);
	//gen_cross_contour_xld(&Cross, dRowInstctSelMax, dColInstctMax, 6, 0.78);

	//decrease operation
	dRowBegin = (dRowInstctSelMax*2)-dTopRRowMax;
    dColBegin = (dColInstctMax*2)-dTopRColSelMid;
    //gen_cross_contour_xld (Cross7, dRowBegin, dColBegin, 26, 0.78)
	dRowEnd = (dTopRRowMax*2)-dRowInstctSelMax;
	dColEnd = (dTopRColSelMid*2)-dColInstctMax;
    //gen_cross_contour_xld (Cross8, dRowEnd, dColEnd, 26, 0.78)
    gen_region_line(&rgnLineCrossR, dRowBegin, dColBegin-dLeftUpEdgeSize, dRowEnd, dColEnd-dLeftUpEdgeSize);

    dilation_rectangle1(rgnLineCrossR, &rgnLineCrossDil, 2, 2);

    //* output the right up position limit
    gen_empty_obj(&(*rgnLineLimitR));
    concat_obj((*rgnLineLimitR), rgnLineCrossDil, &(*rgnLineLimitR));
    union1((*rgnLineLimitR), &(*rgnLineLimitR));

    //*decrease operation
    difference(rgnInwallRSel, rgnLineCrossDil, &rgnLineCrossDiff);
    connection(rgnLineCrossDiff, &rgnLineCrossCon);

    select_shape_std(rgnLineCrossCon, &rgnInWallR, "max_area", 70);

    gen_empty_obj(&(*rgnInWallRight));

    concat_obj((*rgnInWallRight), rgnInWallR, &(*rgnInWallRight));
    union1((*rgnInWallRight), &(*rgnInWallRight));

	return;
}

/********************************************************************************************
**函数名：D20_SideInwallRegionLocationAlgo
**功  能：提取三叉胶塞内壁区域算子
**时  间: 2019年7月8日
**修  改：（1）内容：修改了P_20D_SideInWallLocationR和P_20D_SideInWallLocationL 中筛选叉口平台左上角点坐标选取位置，
               时间：2019.12.17
*********************************************************************************************/
STDMETHODIMP CPlugAlgo::D20_SideInwallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6091$\
					 167;B$\
					 1187;LP;1;250;1;50$\
					 6092;FP;1;50;0.5;3.5$\
					 6093;FP;1;50;0.5;15$\
					 6097;FP;1;70;0.5;25$\
					 6094;FP;1;50;0.5;5$\
					 5516;LP;1;35;1;5$\
					 5515;LP;1;35;1;5$\
					 6095;LP;1;35;1;5$\
					 6096;LP;1;3000;1;1000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_SideInwallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pBaseLineMoveSize,VARIANT* pROIScaleSize, VARIANT* pTopRgnScaleSize,VARIANT* pSlopScaleSize,VARIANT* pPlatformSize,VARIANT* pInnerEdgeSize,VARIANT* pOuterEndgeSize,VARIANT* pLeftUpEdgeSize,VARIANT* pAreaSize)
{
	int rId                = (int)rgnId->fltVal;
	int dBaseLineMoveSize  = (int) pBaseLineMoveSize->fltVal;         //50
	float dROIScaleSize    = (float)pROIScaleSize->fltVal;            //5.5
	float dTopRgnScaleSize = (float)pTopRgnScaleSize->fltVal;         //15
	float dSlopScaleSize   =  (float)pSlopScaleSize->fltVal;          // 25
	float dPlatformSize    = (float)pPlatformSize->fltVal;            // 5.0
	int   dInnerEdgeSize   = (int)pInnerEdgeSize->fltVal;             // 8
	int   dOuterEndgeSize  = (int)pOuterEndgeSize->fltVal;            // 8
	int   dLeftUpEdgeSize  =  (int)pLeftUpEdgeSize->fltVal;           // 8
	int   dAreaSize        = (int)pAreaSize->fltVal;                  // 1500  
	
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;   
	
	if((m_Platform.Id()== H_EMPTY_REGION) ||(m_rgnPlatForm.Id()== H_EMPTY_REGION) || (m_ABEdgeM.Id()== H_EMPTY_REGION) || (m_ABEdgeRowS.Num()!=1) || (m_TopSlopEdgeRow.Num()!=1)|| \
		(m_TopRegionUnion.Id()== H_EMPTY_REGION) || (m_BlackReg.Id()== H_EMPTY_REGION) || (m_TopCol.Num()!=1) ||(m_TopRow.Num()!=1) || (m_SlopRegDiff.Id()== H_EMPTY_REGION)  )
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		HTuple Anglep = m_AngleP ;
		HTuple Angle  = m_Angle;
		HTuple a,c,b;
		tuple_rad(Anglep, &a);
		tuple_rad(180-Anglep, &b);
		tuple_rad(180, &c);
		
		HTuple SlopeDilationSize = m_ABEdgeRowS - m_TopSlopEdgeRow;
		Hobject rgnPlatForm,TopRegionUnion,BlackReg,SlopRegDiff ;
		rgnPlatForm    = m_rgnPlatForm;
		TopRegionUnion = m_TopRegionUnion;
		BlackReg       = m_BlackReg;
		SlopRegDiff    = m_SlopRegDiff;

		HTuple  dAreaDownPos,dRowDownPos,dColDownPos;
		Hobject ABEdgeMoved ;
		move_region(m_ABEdgeM, &ABEdgeMoved, -dBaseLineMoveSize, 0);
		area_center(ABEdgeMoved, &dAreaDownPos, &dRowDownPos, &dColDownPos);

		Hobject ABEdgeMoved1;
		HTuple  dAreaUpPos,dRowUpPos,dColUpPos;
		move_region(m_ABEdgeM, &ABEdgeMoved1, -SlopeDilationSize, 0);
		dilation_rectangle1(ABEdgeMoved1, &ABEdgeMoved1, 20, 1);
		area_center(ABEdgeMoved1, &dAreaUpPos, &dRowUpPos, &dColUpPos);

		Hobject rgnInWallLeft,rgnInWallRight,rgnInWall,rgnLineLimit,rgnLineLimitR,rgnLineLimitL;
		gen_empty_obj(&rgnInWallLeft);
		gen_empty_obj(&rgnInWallRight);
		gen_empty_obj(&rgnInWall);
		gen_empty_obj(&rgnLineLimit);
		gen_empty_obj(&rgnLineLimitR);
		gen_empty_obj(&rgnLineLimitL);

		if ((Angle>=0) &&(Angle<=a))
        {
             //提取右边内壁区域
			HTuple radSml;
            gen_empty_obj(&BlackReg);
			/*tuple_rad( 15,&radSml);
			if ((Angle>=0) &&(Angle<=radSml) )
			{
			dOuterEndgeSize = dOuterEndgeSize + 15;
			}*/

            P_20D_SideInWallLocationR(rgnPlatForm, TopRegionUnion, BlackReg, ABEdgeMoved1, &rgnInWallRight, &rgnLineLimitR, m_TopCol, dRowDownPos, dInnerEdgeSize, dOuterEndgeSize, dLeftUpEdgeSize);

         }
		else if ((Angle>=a)&&(Angle<=b))
	    {
			 //左右两个内壁区域
			 //left
			 P_20D_SideInWallLocationL(rgnPlatForm, TopRegionUnion, BlackReg, ABEdgeMoved1,  &rgnInWallLeft, &rgnLineLimitL, m_TopRow, m_TopCol, dRowDownPos, dInnerEdgeSize, dOuterEndgeSize, dLeftUpEdgeSize);

			//*right
		     P_20D_SideInWallLocationR(rgnPlatForm, TopRegionUnion, BlackReg, ABEdgeMoved1, &rgnInWallRight, &rgnLineLimitR, m_TopCol, dRowDownPos, dInnerEdgeSize, dOuterEndgeSize, dLeftUpEdgeSize);

        }
        else if ((Angle>=b)&&(Angle<=c))
        {
			 //左边内壁区域
		   HTuple radBig;
		   gen_empty_obj(&BlackReg);
		   /* tuple_rad( 165,&radBig);
		   if ((Angle>=radBig) &&(Angle<=c) )
		   {
		   dInnerEdgeSize = dInnerEdgeSize + 15;
		   }*/

		   P_20D_SideInWallLocationL(rgnPlatForm, TopRegionUnion, BlackReg, ABEdgeMoved1, &rgnInWallLeft, &rgnLineLimitL, m_TopRow, m_TopCol, dRowDownPos, dInnerEdgeSize, dOuterEndgeSize, dLeftUpEdgeSize);
        }

		Hobject  rgnInWallSel;
		union2(rgnLineLimitR, rgnLineLimitL, &rgnLineLimit);
		union2(rgnInWallLeft, rgnInWallRight, &rgnInWall);
		intersection(rgnInWall, m_ROI, &rgnInWallSel);

		 //** rgnTopUp
		if ((Angle>=a)&&(Angle<=b))
        {
			Hobject rgnTopTrans,rgnTopDiff,rgnTopDiffOpn,rgnROIEro,rgnTopUp;
			shape_trans(TopRegionUnion, &rgnTopTrans, "ellipse");
            difference(rgnTopTrans, TopRegionUnion, &rgnTopDiff);
            opening_circle(rgnTopDiff, &rgnTopDiffOpn, 5.5);
            erosion_circle(m_ROI, &rgnROIEro, dROIScaleSize);

            intersection(rgnTopDiffOpn, rgnROIEro, &rgnTopUp);
            opening_circle(rgnTopUp, &rgnTopUp, 3.5);

            union2(rgnTopUp, rgnInWallSel, &rgnInWallSel);
         }

		Hobject rgnInWallCls;
        closing_circle(rgnInWallSel, &rgnInWallCls, 10.5);

		 //*decrease the platform
		Hobject  rgnPlatFormDil,rgnInWallDiff;
		dilation_circle(rgnPlatForm, &rgnPlatFormDil, dPlatformSize);
		difference(rgnInWallCls, rgnPlatFormDil, &rgnInWallDiff);

		//* difference the top region and the slop region
		Hobject rgnSlopRegDiffDil,rgnInWallDiff1;
        dilation_rectangle1(SlopRegDiff, &rgnSlopRegDiffDil, (Hlong)dSlopScaleSize, (Hlong)dSlopScaleSize);
        difference(rgnInWallDiff, rgnSlopRegDiffDil, &rgnInWallDiff1);

		Hobject rgnTopUniDil,rgnInWallDiff2,rgnInWallDiff2Con,rgnInWallROISel,rgnInWallROIUni ;
		dilation_circle(TopRegionUnion, &rgnTopUniDil, dTopRgnScaleSize);
		difference(rgnInWallDiff1, rgnTopUniDil, &rgnInWallDiff2);

		Hobject rgnInWallROICls,rgnInWallROIDif ,rgnInWallROICon,rgnInWallROI;
		connection(rgnInWallDiff2, &rgnInWallDiff2Con);
		select_shape(rgnInWallDiff2Con, &rgnInWallROISel, "area", "and", dAreaSize, 99999999);
		union1(rgnInWallROISel, &rgnInWallROIUni);
		closing_circle(rgnInWallROIUni, &rgnInWallROICls, 15);
		difference(rgnInWallROICls, rgnLineLimit, &rgnInWallROIDif);
		connection(rgnInWallROIDif, &rgnInWallROICon);
		select_shape(rgnInWallROICon, &rgnInWallROI, "area", "and", dAreaSize, 99999999);

		intersection(rgnInWallROI, m_ROI, &rgnInWallROI);
		closing_circle(rgnInWallROI,&rgnInWallROI,5.5 );

		//concat_obj(rgnInWallROI,m_vRgn[rId] ,&m_vRgn[rId] );
		//concat_obj(BlackReg,m_vRgn[rId] ,&m_vRgn[rId] );
		m_vRgn[rId] = rgnInWallROI ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
/********************************************************************************
**函数名：D20_WholeRegionLocationAlgo
**功  能：三叉胶塞整体区域提取（扣除叉口平台）
*********************************************************************************/
STDMETHODIMP CPlugAlgo::D20_WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pErosionSize,VARIANT* pMoveSize,VARIANT* pHErosionSize, VARIANT* pDilationSize,VARIANT* pUpEdgeMoveSize,VARIANT* pABHErosionSize, VARIANT* pABVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     =(int)pSelection->fltVal;

	int MoveSize   = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;
	int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	int ABVErosionSize   = (int)pABVErosionSize->fltVal;

	int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ContEllipse.Id()== H_EMPTY_REGION||m_WholeRoi.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ABEdge.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//基准椭圆
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		area_center(m_ContEllipse, &Area, &ContEllipseTransRow, &ContEllipseTransCol);

		HTuple d,e,f;  //扣除此角度下的中心区域
		tuple_rad(15,&d);
		tuple_rad(165,&e);
		tuple_rad(180,&f);

		Hobject RectDilation,RectRemoved,RectIntersection;
		gen_empty_region(&RectDilation);

		if(m_Angle>0 && m_Angle<=d)
		{
			gen_rectangle2(&RectRemoved, ContEllipseTransRow-MoveSize, ContEllipseTransCol, 0.0, 80, 40);   
			intersection(RectRemoved, m_PlatformReg, &RectIntersection) ;
			dilation_rectangle1(RectIntersection, &RectDilation, HErosionSize, 1);
		}
		else if(m_Angle>=e && m_Angle<=f)
		{
			gen_rectangle2(&RectRemoved, ContEllipseTransRow-MoveSize, ContEllipseTransCol, 0.0, 80, 40) ;
			intersection(RectRemoved, m_PlatformReg, &RectIntersection);
			dilation_rectangle1(RectIntersection, &RectDilation, HErosionSize, 1);
		}

		//基准椭圆
		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -UpEdgeMoveSize, 0);

		//剔除AB基准线附近的反光干扰区域ABEdge
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdge,&RegionDilation, ABHErosionSize, ABVErosionSize);
		move_region(RegionDilation, &ABEdgeMoved, ABVErosionSize/2-3, 0);

		if (Selection==1)
		{
			Hobject RegionSelectClosing,TotallRoi;
			//closing_rectangle1(m_WholeRoi, &RegionSelectClosing, 180, 1);
			erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
			m_vRgn[rId] = TotallRoi ;
		} 
		else if(Selection==2)
		{
			Hobject ROIErosion,TotallRoi,RegionDiff1,RegionDiff2,Platform,RegionDiff3;
			//closing_rectangle1(m_WholeRoi, &RegionSelectClosing, 180, 1);
			difference(m_WholeRoi,TopEllipse, &RegionDiff1);
			erosion_circle(RegionDiff1,&ROIErosion, ErosionSize);
			difference(ROIErosion,RectDilation, &RegionDiff2);

			dilation_circle(m_Platform,&Platform,DilationSize);
			difference(RegionDiff2, Platform, &RegionDiff3);
			difference(RegionDiff3, ABEdgeMoved, &TotallRoi);
			m_vRgn[rId] = TotallRoi ;
		}
		else if (Selection==3 )
		{
			// m_StripeRegD 
			Hobject ROIErosion,TotallRoi,RegionDiff1,RegionDiff2,Platform,RegionDiff3;
			//closing_rectangle1(m_WholeRoi, &RegionSelectClosing, 180, 1);
			difference(m_WholeRoi,TopEllipse, &RegionDiff1);
			erosion_circle(RegionDiff1,&ROIErosion, ErosionSize);
			difference(ROIErosion,RectDilation, &RegionDiff2);
			 
			dilation_circle(m_Platform,&Platform,DilationSize);
			difference(RegionDiff2, Platform, &RegionDiff3);
			difference(RegionDiff3, ABEdgeMoved, &TotallRoi);
			difference( TotallRoi,m_StripeRegD,&TotallRoi);

			m_vRgn[rId] = TotallRoi ;
		}



#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1066;LP;1;3;1;2$\
					 1063;LP;1;35;1;12$\
					 1064;LP;1;150;1;75$\
					 1062;LP;1;35;1;5$\
					 1070;LP;1;35;1;10$\
					 1067;LP;20;500;1;250$\
					 1068;LP;1;35;1;5$\
					 1069;LP;9;35;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::D20_StripePatternRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id()==H_EMPTY_REGION||m_StripeReg1.Id()==H_EMPTY_REGION||m_StripeReg2.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//花纹
		//Hobject StripeReg;
		//union2(m_StripeReg1,m_StripeReg2,&StripeReg);
		//union1(StripeReg,&StripeReg);

		//垂直缩放
		Hobject StripeRegDilation,RegionDetect;
		if (VErosionSize>=1)
		{
			dilation_rectangle1(m_StripeRegD,&StripeRegDilation,1,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			erosion_rectangle1(m_StripeRegD,&StripeRegDilation,1,-VErosionSize);
		}
		else
		{
			StripeRegDilation=m_StripeRegD;
		}
		//水平缩放
		clip_region_rel(StripeRegDilation,&RegionDetect,0,0,HErosionSize,HErosionSize);

		Hobject StripRegion;
		intersection(m_ROI,RegionDetect,&StripRegion);
		opening_circle(StripRegion,&StripRegion,3.5);
		m_vRgn[rId] = StripRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20_StripePatternRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 994;LP;1;35;1;1$\
					 995;LP;-35;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//G20_（20单叉覆膜）
void CPlugAlgo::R_EdgePointsFitCurve(Hobject SearchReg, Hobject Image,HTuple PartInterval, HTuple RemoveSize, HTuple Threshold,HTuple Transition, HTuple Select, HTuple * DefinedRow, HTuple *DefinedCol)
{
	Hobject ReinforcedRegPartitioned,SortedRegions,ReinRegPartitioned;
	HTuple PartitionedNum,SearchRegArea,SearchRegRow,SearchRegCol;
	area_center(SearchReg,&SearchRegArea,&SearchRegRow,&SearchRegCol);
	if (SearchRegArea==0||SearchRegArea.Num()==0)
	{
		return;
	}
	partition_rectangle(SearchReg, &ReinforcedRegPartitioned, PartInterval, 300);
	sort_region(ReinforcedRegPartitioned, &SortedRegions, "first_point", "true", "column");
	count_obj(SortedRegions, &PartitionedNum);
	gen_empty_obj(&ReinRegPartitioned);
	if ((RemoveSize<1)||(RemoveSize>PartitionedNum))
	{
		return;
	}
	Hobject PartitionedSelected;
	for (int i=RemoveSize[0].I();i<=(PartitionedNum-RemoveSize);i++)
	{
		select_obj(SortedRegions, &PartitionedSelected, i);
		concat_obj(PartitionedSelected, ReinRegPartitioned, &ReinRegPartitioned);

	}
	HTuple PartitionedArea, PartitionedRow, PartitionedCol;
	area_center(ReinRegPartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);

	if (PartitionedArea.Num()==0)
	{
		return;
	}
	HTuple StepNum,BeginRow,BeginCol,EndRow,EndCol;
	StepNum = PartitionedRow.Num();
	HTuple Width, Height;
	get_image_size(Image, &Width, &Height);
	(*DefinedRow) = HTuple();
	(*DefinedCol) = HTuple();
	//
	if (0 != (Transition==HTuple("negative")))
	{
		Transition = "negative";
	}
	else
	{
		if (0 != (Transition==HTuple("positive")))
		{

			Transition = "positive";
		}
		else
		{
			Transition = "all";
		}
	}

	if (0 != (Select==HTuple("first")))
	{
		Select = "first";
	}
	else
	{
		if (0 != (Select==HTuple("last")))
		{

			Select = "last";
		}
		else
		{
			Select = "all";
		}
	}

	//
	Hobject ObjectSelected;
	HTuple RowC, ColC, Phi, Length1, Length2,MsrHandle_Measure;
	for (int i=1;i<=StepNum;i++)
	{
		select_obj(ReinRegPartitioned, &ObjectSelected, i);
		smallest_rectangle2(ObjectSelected, &RowC, &ColC, &Phi, &Length1, &Length2);

		//异常
		if ((RowC.Num()==0)||(Length1<1)||(Length2<1))
		{
			continue;
		}
		gen_measure_rectangle2(RowC, ColC, Phi, Length1, Length2, Width, Height, "nearest_neighbor", &MsrHandle_Measure);
		HTuple RowEdge, ColEdge, Amplitude, Distance;

		if (Length1*0.5<=1)
		{
			continue;
		}
		measure_pos(Image, MsrHandle_Measure, 1, Threshold, Transition, Select, &RowEdge, &ColEdge, &Amplitude, &Distance);
		//measure_pos(Image, MsrHandle_Measure, 1, Threshold, "negative", "last", &RowEdge, &ColEdge, &Amplitude, &Distance);
		close_measure(MsrHandle_Measure);
		HTuple tRow = 0;
		HTuple tCol = 0;
		HTuple t = 0;
		HTuple Number;
		tuple_length(RowEdge, &Number);
		if (0 != (Number<1))
		{
			continue;
		}

		for (int j=0;j<=Number-1; j++)
		{
			if (0 != (((Amplitude.Select(j)).Abs())>t))
			{

				tRow = RowEdge.Select(j);
				tCol = ColEdge.Select(j);
				t = (Amplitude.Select(j)).Abs();
			}
		}

		if (0 != (t>0))
		{

			*DefinedRow = (*DefinedRow).Concat(tRow);
			*DefinedCol = (*DefinedCol).Concat(tCol);
		}
	}
	return;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pSearchSize, VARIANT* pHclipSize, VARIANT* pThreshold,VARIANT* pABEdgeArea)
{
	int rId         = (int)rgnId->fltVal;
	int SearchSize  =(int)pSearchSize->fltVal;
	int HclipSize  =(int)pHclipSize->fltVal;
	int Threshold   = (int)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		/*gen_contour_region_xld(rgn, &ABEllipseXld, "border");
		gen_region_contour_xld(ABEllipseXld, &ABEllipseReg, "margin");
		get_region_points(ABEllipseReg, &Rows, &Columns);
		gen_region_points(&ABEllipse, Rows, Columns);*/
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HclipSize, HclipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);
		Hobject RegionDilation;
		dilation_rectangle1(ABReg, &RegionDilation, 1, SearchSize);

		HTuple ABDefinedRow, ABDefinedCol;
		R_EdgePointsFitCurve(RegionDilation, crtImg, 5, 1, Threshold, "negative", "last",&ABDefinedRow, &ABDefinedCol);

		if (ABDefinedRow.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		Hobject Region,ABEdgeXld,ABEdgeSmoothed;
		gen_region_points(&Region, ABDefinedRow, ABDefinedCol);
		gen_contour_polygon_xld(&ABEdgeXld, ABDefinedRow, ABDefinedCol);
		smooth_contours_xld(ABEdgeXld, &ABEdgeSmoothed, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,ABDefinedRow, ABDefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], RegionDilation, &m_vRgn[rId]);
		}
		HTuple ABRow,ABCol,ABEdgeArea, ABEdgeRow, ABEdgeCol;
		Hobject ABEdge;
		get_contour_xld(ABEdgeSmoothed, &ABRow, &ABCol);
		//得到基部边缘。
		//gen_region_points(&m_ABEdgeReg,ABRow, ABCol);
		gen_region_contour_xld(ABEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		//
		gen_region_polygon(&ABEdge, ABRow, ABCol);
		area_center(ABEdge, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		if (ABEdgeArea<1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}

		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(Region, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		if(ABEdgeArea > 1)
		{
			retValue = ABEdgeArea[0].I();
			m_vErrorRgn[rId] = ABEdgeM;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pABEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6057$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1100;LP;10;80;1;40$\
					 1101;LP;0;50;1;5$\
					 1099;LP;1;60;1;15");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo3(VARIANT* rgnId, VARIANT* pSearchSize, VARIANT* pHclipSize, VARIANT* pThreshold,VARIANT* pABEdgeArea)
{
	int rId         = (int)rgnId->fltVal;
	int SearchSize  =(int)pSearchSize->fltVal;
	int HclipSize  =(int)pHclipSize->fltVal;
	int Threshold   = (int)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		/*gen_contour_region_xld(rgn, &ABEllipseXld, "border");
		gen_region_contour_xld(ABEllipseXld, &ABEllipseReg, "margin");
		get_region_points(ABEllipseReg, &Rows, &Columns);
		gen_region_points(&ABEllipse, Rows, Columns);*/
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HclipSize, HclipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);
		Hobject RegionDilation;
		dilation_rectangle1(ABReg, &RegionDilation, 1, SearchSize);

		HTuple ABDefinedRow, ABDefinedCol;
		R_EdgePointsFitCurve(RegionDilation, crtImg, 5, 1, Threshold, "negative", "first",&ABDefinedRow, &ABDefinedCol);

		if (ABDefinedRow.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		Hobject Region,ABEdgeXld,ABEdgeSmoothed;
		gen_region_points(&Region, ABDefinedRow, ABDefinedCol);
		gen_contour_polygon_xld(&ABEdgeXld, ABDefinedRow, ABDefinedCol);
		smooth_contours_xld(ABEdgeXld, &ABEdgeSmoothed, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,ABDefinedRow, ABDefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], RegionDilation, &m_vRgn[rId]);
		}
		HTuple ABRow,ABCol,ABEdgeArea, ABEdgeRow, ABEdgeCol;
		Hobject ABEdge;
		get_contour_xld(ABEdgeSmoothed, &ABRow, &ABCol);
		//得到基部边缘。
		//gen_region_points(&m_ABEdgeReg,ABRow, ABCol);
		gen_region_contour_xld(ABEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		//
		gen_region_polygon(&ABEdge, ABRow, ABCol);
		area_center(ABEdge, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		if (ABEdgeArea<1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}

		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(Region, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		if(ABEdgeArea > 1)
		{
			retValue = ABEdgeArea[0].I();
			m_vErrorRgn[rId] = ABEdgeM;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pABEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6056$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1100;LP;10;80;1;40$\
					 1101;LP;0;50;1;5$\
					 1099;LP;1;60;1;15");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**********************************************************************************
** 函数名：NeckBaseEdgeDetectFreeModelAlgo
** 功  能：提取颈部基准线
** 特  点：可自由组合搜索方向，位置选择等参数，选择自己感兴趣的点
** 时  间：2019年6月29日
**********************************************************************************/
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectFreeModelAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHclipSize, VARIANT* pSearchDirec,VARIANT* pSelect,VARIANT* pThreshold,VARIANT* pABEdgeArea)
{
	int rId         = (int)rgnId->fltVal;
    int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize  =(int)pSearchSize->fltVal;
	int SearchDirec = (int)pSearchDirec->fltVal;
	int Select      = (int)pSelect->fltVal;
	int HclipSize  =(int)pHclipSize->fltVal;
	float Threshold   = (float)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		HTuple tSearchDirec ,tSelect;
		if ( SearchDirec == 1)
			tSearchDirec = "negative";
		else if(SearchDirec == 2)
			tSearchDirec = "positive";
		else
			tSearchDirec = "all";

	    if(Select == 1)
			tSelect = "first";
		else if(Select == 2)
			tSelect = "last";
		else
			tSelect = "all";

		Hobject crtImg = m_crtImg;
		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		/*gen_contour_region_xld(rgn, &ABEllipseXld, "border");
		gen_region_contour_xld(ABEllipseXld, &ABEllipseReg, "margin");
		get_region_points(ABEllipseReg, &Rows, &Columns);
		gen_region_points(&ABEllipse, Rows, Columns);*/
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HclipSize, HclipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);

		Hobject ABRegMoved;
		move_region(ABReg, &ABRegMoved, -MoveSize, 0);

		Hobject RegionDilation;
		dilation_rectangle1(ABRegMoved, &RegionDilation, 1, SearchSize);

		HTuple ABDefinedRow, ABDefinedCol;
		R_EdgePointsFitCurve(RegionDilation, crtImg, 5, 1, Threshold, tSearchDirec, tSelect,&ABDefinedRow, &ABDefinedCol);

		if (ABDefinedRow.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		Hobject Region,ABEdgeXld,ABEdgeSmoothed;
		gen_region_points(&Region, ABDefinedRow, ABDefinedCol);
		gen_contour_polygon_xld(&ABEdgeXld, ABDefinedRow, ABDefinedCol);
		smooth_contours_xld(ABEdgeXld, &ABEdgeSmoothed, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,ABDefinedRow, ABDefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], RegionDilation, &m_vRgn[rId]);
		}
		HTuple ABRow,ABCol,ABEdgeArea, ABEdgeRow, ABEdgeCol;
		Hobject ABEdge;
		get_contour_xld(ABEdgeSmoothed, &ABRow, &ABCol);
		//得到基部边缘。
		//gen_region_points(&m_ABEdgeReg,ABRow, ABCol);
		gen_region_contour_xld(ABEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		//
		gen_region_polygon(&ABEdge, ABRow, ABCol);
		area_center(ABEdge, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		if (ABEdgeArea<1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}

		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(Region, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		if(ABEdgeArea > 1)
		{
			retValue = ABEdgeArea[0].I();
			m_vErrorRgn[rId] = ABEdgeM;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pABEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectFreeModelAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6077$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;3$\
					 1100;LP;10;80;1;40$\
					 1101;LP;0;50;1;5$\
					 6075;LP;1;3;1;1$\
					 6076;LP;1;3;1;1$\
					 1099;FP;1;60;0.5;10.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroi, &Regions, ThredLower, 255);
		Hobject RegionsFillUp;
		fill_up(Regions,&RegionsFillUp);
		connection(RegionsFillUp, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);

		m_TopRegion=RegionSelect;

		Hobject AroiTClosing,TopAngleRegDiff,TopAngleRegConnected,TopAngleRegSelected;
		HTuple TopArea, TopRow, TopCol;
		closing_circle(RegionSelect, &AroiTClosing, 200);

		m_AroiTClosing=AroiTClosing;
		area_center(AroiTClosing, &TopArea, &TopRow, &TopCol);
		difference(AroiTClosing, RegionSelect, &TopAngleRegDiff);
		connection(TopAngleRegDiff, &TopAngleRegConnected);
		select_shape_std(TopAngleRegConnected, &TopAngleRegSelected, "max_area", 70);

		m_TopInnerRgion=TopAngleRegSelected;
		Hobject RegionErosion1,RegionClosingDiff,TopAngleReg;
		erosion_circle(AroiTClosing, &RegionErosion1, 3.5);
		difference(AroiTClosing, RegionErosion1, &RegionClosingDiff);
		intersection(RegionClosingDiff, TopAngleRegSelected, &TopAngleReg);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], Regions, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
		}

		HTuple TopAngleArea, TopAngleRow, TopAngleCol,Angle;
		Hobject TopAngleLine;
		area_center(TopAngleReg, &TopAngleArea, &TopAngleRow, &TopAngleCol);
		//角度线段端点坐标
		m_TopRow=TopRow;
		m_TopCol=TopCol;
		m_TopAngleRow=TopAngleRow;
		m_TopAngleCol=TopAngleCol;

		if ((TopArea==0)||(TopAngleArea==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		gen_region_line(&TopAngleLine, TopRow, TopCol, TopAngleRow, TopAngleCol);
		HTuple AngleLineArea,LineRow,LineCol;
		area_center(TopAngleLine,&AngleLineArea,&LineRow,&LineCol);
		//line_orientation(TopRow, TopCol, TopAngleRow, TopAngleCol, &Angle);
		orientation_region(TopAngleLine, &Angle);
		if (0 != (Angle<0))
		{
			Angle += PI;
		}
		m_Angle=Angle;

		//Hobject RegionClosingMoved,ABEdgeDilation;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopAngleLine, &m_vRgn[rId]);
		}
		//
		HTuple Deg;
		tuple_deg(Angle, &Deg);
		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = Deg[0].D();
			dilation_circle(TopAngleLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("987$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 988;LP;0;350;1;185$\
					 989;FP;0;250;0.5;145");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_PlatformDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,  VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower, VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;

	int HSearchSize    =(int)pHSearchSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	//double Angle   = (double)pAngle->fltVal;
	//int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_ROI.Id() == H_EMPTY_REGION||m_TopAngleRow.Num()!=1||m_TopAngleCol.Num()!=1||m_TopRow.Num()!=1||m_TopCol.Num()!=1||m_Angle.Num()!=1)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//注意颈部基准线平移到平台的中间区域,且低于花纹区域
		move_region(m_ABEdgeM, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT,PlatformSearch;

		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);

		//opening_circle(PlatformRegDilationT, &PlatformSearch, 5);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(crtImgReduced, PlatformSearch, &PlatformImageReduced);

		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);

		Hobject PlatformRegErosion,PlatformRegDilation;
		erosion_circle (PlatformRegFillup, &PlatformRegErosion, 2);
		dilation_circle(PlatformRegErosion, &PlatformRegDilation, 2);

		//剔除小缺陷
		Hobject PlatformRegConnected,PlatformRegions;
		connection(PlatformRegDilation,&PlatformRegConnected);
		select_shape(PlatformRegConnected, &PlatformRegions, "area", "and", 10, 9999999);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}
		//叉口角度定位失败时,报错
		if ((m_TopCol==0)||(m_TopAngleCol==0))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject Platform,PlatformReg,Platform0;
		gen_empty_region(&Platform);
		gen_empty_region(&PlatformReg);
		gen_empty_region(&Platform0);

		HTuple a,b,c;
		tuple_rad(3, &a);
		tuple_rad(177, &b);
		tuple_rad(180, &c);
		if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol>=m_TopCol)&&(m_Angle<a))//第一象限
		{
			P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		}
		else if ((m_TopAngleRow<=m_TopRow)&&(m_TopAngleCol<m_TopCol)&&(m_Angle>b)&&(m_Angle<c))//第二象限
		{
			P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		}
		else if ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol))//第三象限(左)
		{
			P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);

		}
		else if ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol))//第四象限（右）
		{
			P_PlatformSelect(PlatformAB,PlatformRegions,SearchSize,m_TopRow,m_TopCol,m_TopAngleRow,m_TopAngleCol,&Platform,&PlatformReg,&Platform0);
		}
		else
		{
			//m_Platform0 剔除AB基准线
			//m_PlatformReg  剔除颈部叉口区域
			//m_Platform 侧面叉口检测区域
			m_Platform0=Platform0;
			m_PlatformReg=PlatformReg;
			m_Platform=Platform;

			retValue = 100;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_OK;
		}
		//
		//dilation_rectangle1(PlatformReg,&PlatformReg,DilationSize,1);
		m_Platform0=Platform0;
		m_PlatformReg=PlatformReg;
		m_Platform=Platform;
		if(m_bDebugImg)
		{
			//dilation_rectangle1(Platform,&Platform,DilationSize,1);
			concat_obj(m_vRgn[rId], PlatformReg, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(Platform,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(Platform, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_PlatformDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;250;1;75$\
					 998;LP;1;100;1;50$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;60");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_SlopEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pTopSlopEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImgReduced = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdgeM, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); //实际情况调整膨胀搜索区域

		Hobject PlatformDilation;
		dilation_rectangle1(m_Platform0, &PlatformDilation, 18, 1);
		difference(TopSlopEdgeDilation, PlatformDilation, &TopSlopEdgeDiff);

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
		reduce_domain(crtImgReduced, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow,DefinedCol;
		//
		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);

		if (TopSlopEdgeArea>=1)
		{
			m_TopSlopEdgeRow=TopSlopEdgeRow;
		} 
		else
		{
			Hobject PlatformDilation;
			dilation_rectangle1(m_Platform0, &PlatformDilation, 8, 1);
			difference(TopSlopEdgeDilation, PlatformDilation, &TopSlopEdgeDiff);

			Hobject TopSlopSearchReg,TopSlopImageReduced;
			intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
			reduce_domain(crtImgReduced, TopSlopSearchReg, &TopSlopImageReduced);
			HTuple DefinedRow,DefinedCol;
			//
			P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
			Hobject TopSlopEdgePoints;
			HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
			gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
			area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
			m_TopSlopEdgeRow=TopSlopEdgeRow;
		}

		//ARegionT为没有提出花纹的整个颈部区域
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);

		//剔除叉口区域的AB基准线
		Hobject ABEdgeDiff;
		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		difference(m_ABEdgeM,PlatformDilation, &ABEdgeDiff);

		union1(ABEdgeDiff,&ABEdgeDiff);
		area_center(ABEdgeDiff, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdgeRow=ABEdgeRow;

		//
		HTuple DilationSize;
		DilationSize = ABEdgeRow-m_TopSlopEdgeRow;
		move_region(m_ABEdgeM, &ABEdgeMovedCenter, (-DilationSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, DilationSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//无叉口平台时，剔除叉口下部区域
		HTuple PlatArea, PlatRow, PlatColumn;
		area_center(m_PlatformReg, &PlatArea, &PlatRow, &PlatColumn);

		HTuple innerRow1, innerCol1, innerRow2, innerCol2,outRow1, outCol1, outRow2, outCol2;
		inner_rectangle1(ARegionT, &innerRow1, &innerCol1, &innerRow2, &innerCol2);
		smallest_rectangle1(ARegionT, &outRow1, &outCol1, &outRow2, &outCol2);
		//
		HTuple a,b;
		tuple_rad(3, &a);
		tuple_rad(177, &b);

		HTuple ColDiff1,ColDiff2;
		ColDiff1=innerCol1-outCol1;
		ColDiff2=outCol2-innerCol2;
		if (0 != (PlatArea==0))
		{
			if (0 != (HTuple(ColDiff1>5).Or(ColDiff2>5)))
			{
				clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);

			}
			else if(((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle<a))||((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle>b)))
			{
				clip_region_rel(ARegionT, &ARegionT, 0, 0, 15, 15);
			}
			else
			{
				clip_region_rel(ARegionT, &ARegionT, 0, 0, 5, 5);	
			}
		}
		else
		{
			clip_region_rel(ARegionT, &ARegionT, 0, 0, 5, 5);
		}

		m_ARegionT=ARegionT;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_SlopEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("997$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;250;1;190$\
					 998;LP;1;100;1;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo:: P_G20_InWallRegionDetect (Hobject AroiTSelected, Hobject GrayImage, Hobject RegionMoved, Hobject ABEllipseAffineTrans, Hobject ROI, Hobject *InWallRegion, HTuple GrayValue, HTuple DilationSizeU, 
	HTuple DilationSizeD, HTuple ErosionSize)
{
	// Local iconic variables 
	Hobject  RegionDilation1, AroiTClosing;
	Hobject  TopAngleRegDiff, TopAngleRegConnected, TopAngleRegSelected;
	Hobject  ImageReduced3, Region1, RegionClosing1;
	Hobject  RegionDilation2, ConnectedRegions1, SelectedRegions1;
	Hobject  SelectedRegions2, RegionErosion, RegionDifference2;
	Hobject  RegionDifference3, RegionIntersection, RegionOpening;
	Hobject  RegionErosion1;
	// Local control variables 
	HTuple  Area3, Row, Column;

	dilation_circle(AroiTSelected, &RegionDilation1, DilationSizeU);

	closing_circle(AroiTSelected, &AroiTClosing, 200);
	difference(AroiTClosing, RegionDilation1, &TopAngleRegDiff);
	connection(TopAngleRegDiff, &TopAngleRegConnected);
	select_shape_std(TopAngleRegConnected, &TopAngleRegSelected, "max_area", 70);

	reduce_domain(GrayImage, RegionMoved, &ImageReduced3);
	threshold(ImageReduced3, &Region1, GrayValue, 255);

	closing_circle(Region1, &RegionClosing1, 7.5);
	dilation_circle(RegionClosing1, &RegionDilation2, 3.5);
	connection(RegionDilation2, &ConnectedRegions1);

	Hobject ABEllipseDilation;
	dilation_circle(ABEllipseAffineTrans, &ABEllipseDilation, 35);
	move_region (ABEllipseDilation, &ABEllipseAffineTrans, -30, 0);

	area_center(ABEllipseAffineTrans, &Area3, &Row, &Column);
	select_shape(ConnectedRegions1, &SelectedRegions1, (HTuple("width").Append("row")),  "and", HTuple(30).Concat(Row-60), HTuple(999999).Concat(Row+60));
	select_shape_std(SelectedRegions1, &SelectedRegions2, "max_area", 70);

	dilation_circle(SelectedRegions2, &RegionDilation2, DilationSizeD);
	erosion_circle(RegionMoved, &RegionErosion, 3.5);
	difference(RegionErosion, RegionDilation1, &RegionDifference2);
	difference(RegionDifference2, RegionDilation2, &RegionDifference3);
	intersection(RegionDifference3, ROI, &RegionIntersection);
	opening_circle(RegionIntersection, &RegionOpening, 8);
	//* opening_circle (RegionIntersection, RegionOpening, OpeningSize)
	erosion_rectangle1(RegionOpening, &RegionErosion1, ErosionSize, 1);

	union2(TopAngleRegSelected, RegionErosion1, &(*InWallRegion));
	union1((*InWallRegion),&(*InWallRegion));
	connection((*InWallRegion),&(*InWallRegion));
	select_shape_std((*InWallRegion), &(*InWallRegion), "max_area", 70);

	return;
}
/***********************************************************************************
** 函数名：G20_InWallRegionLocationAlgo
** 功  能：针对一种单叉胶塞提取其侧面工位拍摄到的内壁区域
************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pGrayValue,VARIANT* pDilationSizeU,VARIANT* pDilationSizeD,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int GrayValue   = (int)pGrayValue->fltVal;

	int DilationSizeU   = (int)pDilationSizeU->fltVal;
	int DilationSizeD   = (int)pDilationSizeD->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_TopRegion.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ABEllipse.Id()==H_EMPTY_REGION||m_TopAngleRow.Num()!=1||m_TopAngleCol.Num()!=1||m_TopRow.Num()!=1||m_TopCol.Num()!=1||m_Angle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		HTuple a,b,c;
		tuple_rad(3, &a);
		tuple_rad(177, &b);
		tuple_rad(180, &c);

		Hobject InWallRegion;
		if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a)))
		{
			P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
		}
		else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)))
		{
			P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
		}
		else
		{
			gen_empty_region(&InWallRegion);

		}
		intersection(InWallRegion,m_ROI,&InWallRegion);
		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6157$\
					 167;B$\
					 1180;LP;20;250;1;80$\
					 1181;LP;3;35;1;4$\
					 1182;LP;2;35;1;3$\
					 1183;LP;2;35;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************
** 函数名：G20_InWallRegionLocationAlgo1
** 功  能：针对一种单叉胶塞提取其侧面工位拍摄到的内壁区域
** 说  明：（1）根据算子G20_InWallRegionLocationAlgo 改进
           （2）算子1使用进行二次提取的叉口区域进行内壁区域的下边缘缩放  m_rgnPlatForm
		        原算子使用提取叉口角度时提取的叉口平台区域 m_PlatformReg
** 时  间：2019年9月16日
*******************************************************************************/
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pGrayValue,VARIANT* pDilationSizeU,VARIANT* pDilationSizeD,VARIANT* pErosionSize,VARIANT* pForkSize)
{
	int rId           = (int)rgnId->fltVal;
	int GrayValue   = (int)pGrayValue->fltVal;

	int DilationSizeU   = (int)pDilationSizeU->fltVal;
	int DilationSizeD   = (int)pDilationSizeD->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;
	int ForkSize      = (int)pForkSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_TopRegion.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ABEllipse.Id()==H_EMPTY_REGION||m_TopAngleRow.Num()!=1||m_TopAngleCol.Num()!=1||m_TopRow.Num()!=1||m_TopCol.Num()!=1||m_Angle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		HTuple a,b,c;
		tuple_rad(3, &a);
		tuple_rad(177, &b);
		tuple_rad(180, &c);

		Hobject InWallRegion;
		if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a)))
		{
			P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
		}
		else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)))
		{
			P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
		}
		else
		{
			gen_empty_region(&InWallRegion);

		}

		Hobject rgnPlatFormDil ;
		dilation_circle(m_rgnPlatForm,&rgnPlatFormDil, ForkSize);
		difference(InWallRegion,rgnPlatFormDil,&InWallRegion);

		intersection(InWallRegion,m_ROI,&InWallRegion);
		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgo1Help(BSTR* pHelpStr)  
{
	CComBSTR strHelp("6138$\
					 167;B$\
					 1180;LP;20;250;1;80$\
					 1181;LP;3;35;1;4$\
					 1182;LP;2;35;1;3$\
					 1183;LP;2;35;1;3$\
					 1070;LP;2;35;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************
** 函数名：G20_InWallRegionLocationAlgo2
** 功  能：针对一种单叉胶塞提取其侧面工位拍摄到的内壁区域
** 说  明：（1）根据算子G20_InWallRegionLocationAlgo1 改进
           （2）该算子可以实现对单叉内壁区域的叉口上内壁筛除
** 时  间：2019年9月27日
*******************************************************************************/
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pAngleSelect,VARIANT* pGrayValue,VARIANT* pDilationSizeU,VARIANT* pDilationSizeD,VARIANT* pErosionSize,VARIANT* pForkSize,VARIANT* pForkWallSize)
{
	int rId           = (int)rgnId->fltVal;
	
	float AngleSelect   = (float)pAngleSelect->fltVal;
	int GrayValue   = (int)pGrayValue->fltVal;

	int DilationSizeU   = (int)pDilationSizeU->fltVal;
	int DilationSizeD   = (int)pDilationSizeD->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;
	int ForkSize      = (int)pForkSize->fltVal;  
	int ForkWallSize      = (int)pForkWallSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_TopRegion.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ABEllipse.Id()==H_EMPTY_REGION||m_TopAngleRow.Num()!=1||m_TopAngleCol.Num()!=1||m_TopRow.Num()!=1||m_TopCol.Num()!=1||m_Angle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject crtImg = m_crtImg;
		HTuple a,b,c;
		tuple_rad(3, &a);
		tuple_rad(177, &b);
		tuple_rad(180, &c);

		HTuple tBegin,tEnd;
		tuple_rad(AngleSelect, &tBegin);
		tuple_rad(180 - AngleSelect , &tEnd);

		Hobject InWallRegion;
		if ( (m_Angle < tBegin) || ( m_Angle > tEnd  ))
		{
			gen_empty_region(&InWallRegion);
		}
		else
		{
			if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol<=m_TopCol)&&(m_Angle>a)))
			{
				P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
			}
			else if (0 != ((m_TopAngleRow>m_TopRow)&&(m_TopAngleCol>m_TopCol)&&(m_Angle<b)))
			{
				P_G20_InWallRegionDetect(m_TopRegion, crtImg, m_PlatformReg, m_ABEllipse, m_ROI, &InWallRegion, GrayValue, DilationSizeU, DilationSizeD, ErosionSize);
			}
			else
			{
				gen_empty_region(&InWallRegion);

			}
		}

		HTuple tMid,tMidSel,tMidSelL,tMidSelR,tLimit1,tLimit2;
		tuple_rad(90, &tMid);
		tuple_rad(5, &tMidSel);
		tuple_rad(85, &tMidSelL);
		tuple_rad(95, &tMidSelR);

		tuple_rad(45, &tLimit1);
		tuple_rad(135, &tLimit2);

		Hobject rgnInWallClip;
		if ( (m_Angle > tBegin) && ( m_Angle < tMidSelL))
		{
			// 左缩放为主
			clip_region_rel(InWallRegion,&rgnInWallClip,0,0,ForkWallSize*(PI-m_Angle)/tLimit2, ForkWallSize*(m_Angle/PI));
		}
		else if ((m_Angle > tMidSelR) && ( m_Angle < tEnd) )
		{
			// 右缩放为主
			clip_region_rel(InWallRegion,&rgnInWallClip,0,0,(PI-m_Angle)/PI*ForkWallSize,ForkWallSize*(m_Angle/tLimit2) );
		}
		else if ((tMidSelL <= m_Angle) && (m_Angle <=  tMidSelR) )
		{
			// 左右同时缩放
			clip_region_rel(InWallRegion,&rgnInWallClip,0,0,ForkWallSize*(PI-m_Angle)/tMid*0.6, ForkWallSize*(PI-m_Angle)/tMid*0.6);
		}
		else 
		{
			rgnInWallClip = InWallRegion;
		}

		closing_circle(rgnInWallClip,&rgnInWallClip,20);
		closing_rectangle1(rgnInWallClip,&rgnInWallClip,1,10);

		Hobject rgnPlatFormDil ;
		dilation_circle(m_rgnPlatForm,&rgnPlatFormDil, ForkSize);
		difference(rgnInWallClip,rgnPlatFormDil,&InWallRegion);

		intersection(InWallRegion,m_ROI,&InWallRegion);
		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_InWallRegionLocationAlgo2Help(BSTR* pHelpStr)  
{
	CComBSTR strHelp("6156$\
					 167;B$\
					 6154;FP;1;180;0.5;20$\
					 1180;LP;20;250;1;80$\
					 1181;LP;3;35;1;4$\
					 1182;LP;2;35;1;3$\
					 1183;LP;2;35;1;3$\
					 1070;LP;2;35;1;3$\
					 6155;LP;1;50;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_MiddleEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pHClipSize, VARIANT* pEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_Platform0.Id() == H_EMPTY_REGION||m_ABEdgeRow.Num()==0)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImg = m_crtImg;
		//Hobject crtImgReduced;
		//reduce_domain(crtImg, rgn, &crtImgReduced);
		//

		Hobject MiddleEdge,MiddleEdgeDilation,MiddleEdgeDilationCliped;
		move_region(m_ABEdgeM, &MiddleEdge, -MoveSize, 0);
		dilation_rectangle1(MiddleEdge, &MiddleEdgeDilation, 1, SearchSize);
		clip_region_rel(MiddleEdgeDilation,&MiddleEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject MiddleEdgeDiff,MiddleEdgeSearchReg,MiddleEdgeImageReduced;

		Hobject PlatformDilation;
		dilation_rectangle1(m_Platform0, &PlatformDilation, 18, 1);
		difference(MiddleEdgeDilationCliped, PlatformDilation, &MiddleEdgeDiff);
		intersection(MiddleEdgeDiff, m_ROI, &MiddleEdgeSearchReg);
		reduce_domain(crtImg, MiddleEdgeSearchReg, &MiddleEdgeImageReduced);

		HTuple DefinedRow, DefinedCol;
		P_EdgePointsFitCurve(MiddleEdgeSearchReg, MiddleEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		Hobject MiddleEdgePoints;
		gen_region_points(&MiddleEdgePoints, DefinedRow, DefinedCol);
		HTuple MiddleEdgeArea, MiddleEdgeRow, MiddleEdgeCol;
		area_center(MiddleEdgePoints, &MiddleEdgeArea, &MiddleEdgeRow, &MiddleEdgeCol);

		Hobject ABEdgeMovedCenter;
		HTuple MoveSize0;
		MoveSize0 = m_ABEdgeRow-MiddleEdgeRow;
		move_region(m_ABEdgeM, &ABEdgeMovedCenter, -MoveSize0-5, 0);
		Hobject MiddleEdgeReg;
		dilation_rectangle1(ABEdgeMovedCenter, &MiddleEdgeReg, 1, 10);

		m_MiddleEdge=MiddleEdgeReg;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], MiddleEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], MiddleEdgeSearchReg, &m_vRgn[rId]);
		}
		//
		if (MiddleEdgeArea>0)
		{
			Hobject MiddleEdgePointsDilation;
			retValue = MiddleEdgeArea[0].I();
			dilation_circle(MiddleEdgePoints, &MiddleEdgePointsDilation, 2);
			m_vErrorRgn[rId] = MiddleEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_MiddleEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1104$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;200;1;100$\
					 1107;LP;1;100;1;35$\
					 1108;LP;1;15;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject DownEdge,DownEdgeDilation,DownEdgeDilationCliped;
		move_region(m_ABEdgeM, &DownEdge, -MoveSize, 0);
		dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject PlatformRegMoved;
		move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		difference(DownEdgeDilationCliped, PlatformRegMoved, &DownEdgeDiff);
		intersection(DownEdgeDiff, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}
		//HTuple DefinedRow, DefinedCol;
		//R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		////P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		//
		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*2)/3))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);

		m_DownEdge=DownEdgeRegDilation;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1106$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;30;1;5$\
					 1105;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject DownEdge,DownEdgeDilation,DownEdgeDilationCliped;
		move_region(m_ABEdgeM, &DownEdge, -MoveSize, 0);
		dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject PlatformRegMoved;
		move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		difference(DownEdgeDilationCliped, PlatformRegMoved, &DownEdgeDiff);
		intersection(DownEdgeDiff, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}
		//HTuple DefinedRow, DefinedCol;
		//R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		////P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		//
		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		m_DownEdgePoints1=DownEdgePoints1;     //用于检测脱壳检测算子
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"positive", "first", &DefinedRow0, &DefinedCol0);

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;
		m_DownEdgePoints2=DownEdgePoints2;   //用于检测脱壳检测算子
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}

		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1106$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;30;1;5$\
					 1105;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************************
** 函 数 名： G20_DownEdgeDetectAlgo2 
** 功    能： 提取覆膜边缘（上下）
** 修改说明：（1）时  间：2018年10月28日 
**                修改人：吴贻峰 
**                内  容：将下边缘提取的measure_pose 的select 修改为 “last”，原来为first
*********************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject DownEdge,DownEdgeDilation,DownEdgeDilationCliped;
		move_region(m_ABEdgeM, &DownEdge, -MoveSize, 0);
		dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject PlatformRegMoved;
		move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		difference(DownEdgeDilationCliped, PlatformRegMoved, &DownEdgeDiff);
		intersection(DownEdgeDiff, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}
		//HTuple DefinedRow, DefinedCol;
		//R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		////P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		//
		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		m_DownEdgePoints1=DownEdgePoints1;     //用于检测脱壳检测算子
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"positive", "last", &DefinedRow0, &DefinedCol0);

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;
		m_DownEdgePoints2=DownEdgePoints2;   //用于检测脱壳检测算子
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}

		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1106$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;30;1;5$\
					 1105;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pSwitch,VARIANT* pMoveSizeH,VARIANT* pAreaThred,VARIANT* pDilationSize2)
{
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int Switch   = (int)pSwitch->fltVal;
	int MoveSizeH   = (int)pMoveSizeH->fltVal;

	int AreaThred   = (int)pAreaThred->fltVal;
	int DilationSize2   = (int)pDilationSize2->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_TopRegion.Id()==H_EMPTY_REGION||m_MiddleEdge.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_StripeReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//叉口区域缩放
		Hobject RegionUnion,RegionFillUp,RegionClosing,PlatformRegDilation,PlatformRegDilation1;
		dilation_circle(m_PlatformReg,&PlatformRegDilation,DilationSize0);
		dilation_circle(m_Platform0,&PlatformRegDilation1,DilationSize0);

		union2(m_TopRegion,PlatformRegDilation,&RegionUnion);
		fill_up(RegionUnion, &RegionFillUp);
		closing_circle(RegionFillUp, &RegionClosing, 20);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1;
		//颈部整体水平缩放
		//clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//颈部整体垂直缩放
		erosion_rectangle1(ARegionIntersction,&ARegionT1,1,VErosionSize);
		//剔除干扰点
		Hobject ARegionTOpening,ARegionTUnion,ConnectedARegionT;
		opening_circle(ARegionT1, &ARegionTOpening, 3.5);
		union1(ARegionTOpening, &ARegionTUnion);
		connection(ARegionTUnion, &ConnectedARegionT);
		select_shape_std(ConnectedARegionT, &ARegionT1, "max_area", 70);

		//中部边缘缩放
		Hobject MidldleRegDilation,ARegionDiff1;
		dilation_circle(m_MiddleEdge,&MidldleRegDilation,DilationSize1);
		difference(ARegionT1, MidldleRegDilation, &ARegionDiff1);

		//
		Hobject ARegionDiff1Connected,SortedRegions,RegionSelected0;
		connection(ARegionDiff1,&ARegionDiff1Connected);
		HTuple Number;
		count_obj(ARegionDiff1Connected, &Number);
		if (Number[0].I()!=2)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &RegionSelected0, 2);

		Hobject DownRegDilation;
		dilation_circle(m_DownEdge,&DownRegDilation,DilationSize2);
		//防止提取的下部边缘小于m_ARegionT水平宽度
		HTuple EdgeRow1, EdgeColumn1, EdgeRow2, EdgeColumn2;
		HTuple ARegionTRow1, ARegionTColumn1, ARegionTRow2, ARegionTColumn2;
		smallest_rectangle1(DownRegDilation, &EdgeRow1, &EdgeColumn1, &EdgeRow2, &EdgeColumn2);
		smallest_rectangle1(RegionSelected0,&ARegionTRow1, &ARegionTColumn1, &ARegionTRow2, &ARegionTColumn2);

		Hobject ARegionDiff2;
		if (m_DownEdgeArea>=AreaThred)
		{
			Hobject RegionClipped;
			clip_region(RegionSelected0,&RegionClipped, ARegionTRow1, EdgeColumn1, ARegionTRow2, EdgeColumn2);
			//下部边缘缩放
			difference(RegionClipped, DownRegDilation, &ARegionDiff2);
		}
		else
		{
			HTuple Area7, Row5, Column3,Area8, Row6, Column5;
			Hobject RegionMoved5;
			area_center(m_FMpoints, &Area7, &Row5, &Column3);
			area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
			move_region(m_ABEdgeM, &RegionMoved5, -(Row6-Row5), 0);
			//下部边缘缩放
			dilation_circle(RegionMoved5,&DownRegDilation,DilationSize2);
			difference(RegionSelected0, DownRegDilation, &ARegionDiff2);
		}
		//Hobject RegionClipped;
		//clip_region(RegionSelected0,&RegionClipped, ARegionTRow1, EdgeColumn1, ARegionTRow2, EdgeColumn2);
		////下部边缘缩放
		//Hobject ARegionDiff2;
		//difference(RegionClipped, DownRegDilation, &ARegionDiff2);
		Hobject ARegionDiff2Connected,SortedRegions1;
		connection(ARegionDiff2,&ARegionDiff2Connected);
		HTuple Number1;
		count_obj(ARegionDiff2Connected, &Number1);
		if (Number1[0].I()!=2)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		sort_region(ARegionDiff2Connected,&SortedRegions1, "first_point", "true", "row");
		//花纹特征
		Hobject ConRegions,ConRegionsDilation;
		gen_empty_region(&ConRegions);
		union2(m_StripeReg,ConRegions,&ConRegions);
		union1(ConRegions,&ConRegions);
		//dilation_circle(ConRegions,&ConRegionsDilation,DilationSize3);

		if (Selection==1)
		{
			Hobject ARegionDiff0;
			difference(ARegionT1, RegionClosing, &ARegionDiff0);
			union1(ARegionDiff0,&ARegionDiff0);
			//水平缩放
			clip_region_rel(ARegionDiff0, &ARegionDiff0, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = ARegionDiff0 ;	
		}
		else if(Selection==2)
		{
			Hobject RegionSelected,RegionDiff,RegionDilation,RegionOpening,RegionDiff1;
			select_obj(SortedRegions, &RegionSelected, 1);
			//水平缩放
			clip_region_rel(RegionSelected, &RegionSelected, 0, 0, HErosionSize, HErosionSize);
			//花纹扣除开关
			if (Switch)
			{
				//花纹纵向平移
				move_region(ConRegions,&ConRegions,MoveSizeH,0);
				difference(RegionSelected,ConRegions,&RegionDiff);
				difference(RegionDiff, RegionClosing, &RegionDiff);
			}
			else
			{
				difference(RegionSelected,RegionClosing,&RegionDiff);
			}
			//
			opening_circle(m_AroiTClosing,&RegionOpening, 10);
			dilation_circle(RegionOpening,&RegionDilation, 8);
			difference(RegionDiff, RegionDilation, &RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1;
		}
		else if(Selection==3)
		{
			Hobject RegionSelected1,RegionDiff,RegionDiff1;
			select_obj(SortedRegions1, &RegionSelected1, 1);
			//水平缩放
			clip_region_rel(RegionSelected1, &RegionSelected1, 0, 0, HErosionSize, HErosionSize);
			difference(RegionSelected1, RegionClosing, &RegionDiff);
			difference(RegionDiff,PlatformRegDilation1,&RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1 ;

			m_MiddleNeckRegion=RegionDiff1;
		}
		else if(Selection==4)
		{
			Hobject RegionSelected2,RegionDiff;
			select_obj(SortedRegions1, &RegionSelected2, 2);
			difference(RegionSelected2, RegionClosing, &RegionDiff);
			union1(RegionDiff,&RegionDiff);
			//水平缩放
			clip_region_rel(RegionDiff, &RegionDiff, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionDiff ;

		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1116;LP;1;4;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1231;LP;0;1;1;1$\
					 1222;LP;-10;10;1;1$\
					 1199;LP;1;200;1;50$\
					 1114;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pSwitch,VARIANT* pMoveSizeH,VARIANT* pAreaThred,VARIANT* pDilationSize2)
{
	//异常判断放在Selection==4
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int Switch   = (int)pSwitch->fltVal;
	int MoveSizeH   = (int)pMoveSizeH->fltVal;

	int AreaThred   = (int)pAreaThred->fltVal;
	int DilationSize2   = (int)pDilationSize2->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_TopRegion.Id()==H_EMPTY_REGION||m_MiddleEdge.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_StripeReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//叉口区域缩放
		Hobject RegionUnion,RegionFillUp,RegionClosing,PlatformRegDilation,PlatformRegDilation1;
		dilation_circle(m_PlatformReg,&PlatformRegDilation,DilationSize0);
		dilation_circle(m_Platform0,&PlatformRegDilation1,DilationSize0);
		//my_disp_obj(m_StripeReg);
		union2(m_TopRegion,PlatformRegDilation,&RegionUnion);
		fill_up(RegionUnion, &RegionFillUp);
		closing_circle(RegionFillUp, &RegionClosing, 20);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1;
		//颈部整体水平缩放
		//clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//颈部整体垂直缩放
		erosion_rectangle1(ARegionIntersction,&ARegionT1,1,VErosionSize);
		//剔除干扰点
		Hobject ARegionTOpening,ARegionTUnion,ConnectedARegionT;
		opening_circle(ARegionT1, &ARegionTOpening, 3.5);
		union1(ARegionTOpening, &ARegionTUnion);
		connection(ARegionTUnion, &ConnectedARegionT);
		select_shape_std(ConnectedARegionT, &ARegionT1, "max_area", 70);

		//中部边缘缩放
		Hobject MidldleRegDilation,ARegionDiff1;
		dilation_circle(m_MiddleEdge,&MidldleRegDilation,DilationSize1);
		difference(ARegionT1, MidldleRegDilation, &ARegionDiff1);
		//
		Hobject ARegionDiff1Connected,SortedRegions,RegionSelected0;
		connection(ARegionDiff1,&ARegionDiff1Connected);
		HTuple Number;
		count_obj(ARegionDiff1Connected, &Number);
		if (Number[0].I()!=2)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &RegionSelected0, 2);

		Hobject DownRegDilation;
		dilation_circle(m_DownEdge,&DownRegDilation,DilationSize2);
		//防止提取的下部边缘小于m_ARegionT水平宽度
		HTuple EdgeRow1, EdgeColumn1, EdgeRow2, EdgeColumn2;
		HTuple ARegionTRow1, ARegionTColumn1, ARegionTRow2, ARegionTColumn2;
		smallest_rectangle1(DownRegDilation, &EdgeRow1, &EdgeColumn1, &EdgeRow2, &EdgeColumn2);
		smallest_rectangle1(RegionSelected0,&ARegionTRow1, &ARegionTColumn1, &ARegionTRow2, &ARegionTColumn2);

		Hobject ARegionDiff2;
		if (m_DownEdgeArea>=AreaThred)
		{
			Hobject RegionClipped;
			clip_region(RegionSelected0,&RegionClipped, ARegionTRow1, EdgeColumn1, ARegionTRow2, EdgeColumn2);
			//下部边缘缩放
			difference(RegionClipped, DownRegDilation, &ARegionDiff2);
		}
		else
		{
			HTuple Area7, Row5, Column3,Area8, Row6, Column5;
			Hobject RegionMoved5;
			area_center(m_FMpoints, &Area7, &Row5, &Column3);
			area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
			move_region(m_ABEdgeM, &RegionMoved5, -(Row6-Row5), 0);
			//下部边缘缩放
			dilation_circle(RegionMoved5,&DownRegDilation,DilationSize2);
			difference(RegionSelected0, DownRegDilation, &ARegionDiff2);
		}
		Hobject ARegionDiff2Connected,SortedRegions1;
		connection(ARegionDiff2,&ARegionDiff2Connected);
		HTuple Number1;
		count_obj(ARegionDiff2Connected, &Number1);
		//if (Number1[0].I()!=2)
		//{
		//	m_vRgn[rId] = newRgn ;
		//	return S_FALSE;
		//}
		sort_region(ARegionDiff2Connected,&SortedRegions1, "first_point", "true", "row");
		//花纹特征
		Hobject ConRegions,ConRegionsDilation;
		gen_empty_region(&ConRegions);
		union2(m_StripeReg,ConRegions,&ConRegions);
		union1(ConRegions,&ConRegions);
		if (Selection==1)
		{
			Hobject ARegionDiff0;
			difference(ARegionT1, RegionClosing, &ARegionDiff0);
			union1(ARegionDiff0,&ARegionDiff0);
			//水平缩放
			clip_region_rel(ARegionDiff0, &ARegionDiff0, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = ARegionDiff0 ;	
		}
		else if(Selection==2)
		{
			Hobject RegionSelected,RegionDiff,RegionDilation,RegionOpening,RegionDiff1;
			select_obj(SortedRegions, &RegionSelected, 1);
			//水平缩放
			clip_region_rel(RegionSelected, &RegionSelected, 0, 0, HErosionSize, HErosionSize);
			//花纹扣除开关
			if (Switch)
			{
				//花纹纵向平移
				move_region(ConRegions,&ConRegions,MoveSizeH,0);
				difference(RegionSelected,ConRegions,&RegionDiff);
				difference(RegionDiff, RegionClosing, &RegionDiff);
			}
			else
			{
				difference(RegionSelected,RegionClosing,&RegionDiff);
			}
			//
			opening_circle(m_AroiTClosing,&RegionOpening, 10);
			dilation_circle(RegionOpening,&RegionDilation, 8);
			difference(RegionDiff, RegionDilation, &RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1;
		}
		else if(Selection==3)
		{
			Hobject RegionSelected1,RegionDiff,RegionDiff1;
			select_obj(SortedRegions1, &RegionSelected1, 1);
			//水平缩放
			clip_region_rel(RegionSelected1, &RegionSelected1, 0, 0, HErosionSize, HErosionSize);
			difference(RegionSelected1, RegionClosing, &RegionDiff);
			difference(RegionDiff,PlatformRegDilation1,&RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1 ;

			m_MiddleNeckRegion=RegionDiff1;
		}
		else if(Selection==4)
		{
			Hobject RegionSelected2,RegionDiff;
			if (Number1[0].I()!=2)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			select_obj(SortedRegions1, &RegionSelected2, 2);
			difference(RegionSelected2, RegionClosing, &RegionDiff);
			union1(RegionDiff,&RegionDiff);
			//水平缩放
			clip_region_rel(RegionDiff, &RegionDiff, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionDiff ;

		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1116;LP;1;4;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1231;LP;0;1;1;1$\
					 1222;LP;-10;10;1;1$\
					 1199;LP;1;200;1;50$\
					 1114;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pUpEdgeMoveSize,VARIANT* pDialtionSizeP,VARIANT* pABHErosionSize, VARIANT* pABVErosionSize, VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;
	int DialtionSizeP   = (int)pDialtionSizeP->fltVal;

	int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	int ABVErosionSize   = (int)pABVErosionSize->fltVal;

	int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEllipse.Id()== H_EMPTY_REGION||m_ROI.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ABEdgeM.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject ABEllipseDilation,RegionMoved,ROIErosion;
		dilation_circle(m_ABEllipse, &ABEllipseDilation, 10);
		move_region(ABEllipseDilation,&RegionMoved, -UpEdgeMoveSize, 0);
		erosion_circle(m_ROI,&ROIErosion,ErosionSize);

		Hobject RegionDiff,RegionDiffConnected,RegionDiffSelected,PlatformRegDilation;
		difference(ROIErosion,RegionMoved,&RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		select_shape_std(RegionDiffConnected, &RegionDiffSelected, "max_area", 70);
		dilation_rectangle1(m_PlatformReg,&PlatformRegDilation,DialtionSizeP,1);

		Hobject WholeRegion;
		difference(RegionDiffSelected, PlatformRegDilation, &WholeRegion);

		//剔除AB基准线附近的反光干扰区域ABEdge
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdgeM,&RegionDilation, ABHErosionSize, ABVErosionSize);
		difference(WholeRegion,RegionDilation,&WholeRegion);

		m_vRgn[rId] = WholeRegion ;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1067;LP;50;250;1;170$\
					 1070;LP;1;35;1;5$\
					 1068;LP;1;35;1;5$\
					 1069;LP;2;35;1;10$\
					 1063;LP;5;50;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ABEdgeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeM.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdgeM,&RegionDilation, 1, VErosionSize);

		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);
		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ABEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1287$\
					 167;B$\
					 994;LP;1;50;1;6$\
					 995;LP;1;50;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************
**函 数 名： ABEdgeRegionLocationAlgo
**功    能： 根据颈部基准线膨胀生成颈部拐角区域
**说    明： 该算子具有一定的通用性（颈部基准线提取到即可）
****************************************************************************************/
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeReg.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdgeReg,&RegionDilation, 1, VErosionSize);

		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);
		move_region(RegionDilation,&RegionDilation,MoveSize,0);
		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1287$\
					 167;B$\
					 991;LP;-300;100;1;0$\
					 994;LP;1;200;1;6$\
					 995;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::SealingEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ScrapEdgeReg.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ScrapEdgeReg,&RegionDilation, 1, VErosionSize);

		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);
		move_region(RegionDilation,&RegionDilation,MoveSize,0);

		difference( RegionDilation,m_CrownRegionT,&RegionDilation);

		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SealingEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6128$\
					 167;B$\
					 6129;LP;-300;100;1;-20$\
					 994;LP;1;200;1;6$\
					 995;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/***************************************************************************************
**函 数 名： ABEdgeRegionLocationAlgo1
**功    能： 根据覆膜边缘区域生成颈部拐角区域
**说    明： 该算子具有一定的通用性（覆膜上下边缘线提取到即可）
****************************************************************************************/
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int Selection   = (int)pSelection->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeReg.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMoved,RegionDilation;
		if ( Selection == 1)
		{
			// 上边缘
			dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
		}
		else if(Selection == 2)
		{
			// 下边缘
			dilation_rectangle1(m_DownEdgeX,&RegionDilation, 1, VErosionSize);
		}
		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);
		move_region(RegionDilation,&RegionDilation,MoveSize,0);
		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("5526$\
					 167;B$\
					 5529;LP;1;2;1;1$\
					 991;LP;-150;100;1;0$\
					 994;LP;1;200;1;6$\
					 995;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************
**函 数 名： ABEdgeRegionLocationAlgo2
**功    能： 根据覆膜边缘区域生成颈部拐角区域
**说    明： 该算子属于定制化算子，针对华强现场出现的覆膜边缘和颈部基准线贴合一起的情况（覆膜上下边缘线提取到即可）
****************************************************************************************/
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pMoveSize,VARIANT* pMoveDiff, VARIANT* pIntsctThred,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;
	int MoveDiff  = (int)pMoveDiff->fltVal;
	int IntsctThred = (int)pIntsctThred->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int Selection   = (int)pSelection->fltVal;
	
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeReg.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject Image = m_crtImg;
		Hobject rgnIntsct,DownEdgeReg,DownEdgeReg2;
		HTuple dArea,dRow,dCol;

		dilation_rectangle1(m_DownEdgeReg,&DownEdgeReg,2,1);
		dilation_rectangle1(m_DownEdgeReg2,&DownEdgeReg2,2,1);
		intersection(DownEdgeReg,DownEdgeReg2,&rgnIntsct);
		area_center(rgnIntsct,&dArea,&dRow,&dCol);

		Hobject ABEdgeMoved,RegionDilation;
		if ( Selection == 1)
		{
			// 上边缘
			dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
		}
		else if(Selection == 2)
		{
			// 下边缘
			dilation_rectangle1(m_DownEdgeX,&RegionDilation, 1, VErosionSize);
		}
		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);

		// 如果下边缘的row2 < 上边缘 row1 ，则相对位移也生效  
		HTuple dArea1,dRow1,dCol1,dArea2,dRow2,dCol2;
		area_center(m_DownEdge,&dArea1,&dRow1,&dCol1);
		area_center(m_DownEdgeX,&dArea2,&dRow2,&dCol2);


		if ( (dArea > IntsctThred) || ( dRow2 < dRow1))
		{
			move_region(RegionDilation,&RegionDilation,MoveSize + MoveDiff,0);
		}
		else
		{
			move_region(RegionDilation,&RegionDilation,MoveSize,0);
		}

		//my_disp_obj(DownEdgeReg);
		concat_obj(DownEdgeReg,m_vRgn[rId],&m_vRgn[rId]);
		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6068$\
					 167;B$\
					 5529;LP;1;2;1;1$\
					 991;LP;-150;100;1;0$\
					 6066;LP;-20;30;1;3$\
					 6065;LP;1;500;1;30$\
					 994;LP;1;200;1;6$\
					 995;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************
**函 数 名： ABEdgeRegionLocationAlgo3
**功    能： 根据覆膜边缘区域生成颈部拐角区域
**说    明： 该算子属于定制化算子，针对华强现场出现的覆膜边缘和颈部基准线贴合一起的情况（覆膜上下边缘线提取到即可）
**修    改： （1）内容：增加了平均灰度值判断，只在边缘选择为2时生效
**                时间：2019年6月29日
****************************************************************************************/
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo3(VARIANT* rgnId,VARIANT* pSelection,VARIANT* pGrayThred,VARIANT* pMoveSize,VARIANT* pMoveDiff, VARIANT* pIntsctThred,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;
	int MoveDiff  = (int)pMoveDiff->fltVal;
	int IntsctThred = (int)pIntsctThred->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int GrayThred   = (int)pGrayThred->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeReg.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject Image = m_crtImg;
		Hobject rgnIntsct,DownEdgeReg,DownEdgeReg2;
		HTuple dArea,dRow,dCol;

		dilation_rectangle1(m_DownEdgeReg,&DownEdgeReg,2,1);
		dilation_rectangle1(m_DownEdgeReg2,&DownEdgeReg2,2,1);
		intersection(DownEdgeReg,DownEdgeReg2,&rgnIntsct);
		area_center(rgnIntsct,&dArea,&dRow,&dCol);

		// 黑色区域定位并得到其灰度阈值
		HTuple dRowSUp,dColSUp,dRowSDown,dColSDown,dRowSDownInv,dColSDownInv;
		Hobject xldDownEdge,xld2DownEdge,rgnSknDownEdge,rgnSknDownEdge2 ;

		skeleton(m_DownEdgeReg,&rgnSknDownEdge);
		skeleton(m_DownEdgeReg2,&rgnSknDownEdge2);

		HTuple dRowSUpOri,dColSUpOri,dRowSDownOri,dColSDownOri;
		gen_contour_region_xld(rgnSknDownEdge,&xldDownEdge,"border");
		gen_contour_region_xld(rgnSknDownEdge2,&xld2DownEdge,"border");
		get_contour_xld(xldDownEdge,&dRowSUpOri,&dColSUpOri);
		get_contour_xld(xld2DownEdge,&dRowSDownOri,&dColSDownOri);

		HTuple dColSUpSort,dColIndexS,dRowSUpSel ;
		tuple_sort(dColSUpOri,&dColSUpSort);
		tuple_sort_index(dColSUpOri,&dColIndexS);
		tuple_select(dRowSUpOri,dColIndexS,&dRowSUpSel);

		HTuple dColSDownSort,dColIndexS1,dRowSDownSel ;
		tuple_sort(dColSDownOri,&dColSDownSort);
		tuple_sort_index(dColSDownOri,&dColIndexS1);
		tuple_select(dRowSDownOri,dColIndexS1,&dRowSDownSel);

		dRowSUp = dRowSUpSel;
		dColSUp = dColSUpSort;
		dRowSDown = dRowSDownSel;
		dColSDown = dColSDownSort;

		if( dRowSUp.Num() < 3 || ( dRowSDown.Num() < 3))
		{
			m_vRgn[rId] = newRgn ;
		    return S_FALSE;
		}

		tuple_inverse(dRowSDown, &dRowSDownInv);
		tuple_inverse(dColSDown, &dColSDownInv);

		HTuple dRowS,dColS;
		Hobject rgnBlackSearch;
		dRowS = HTuple();
		dColS = HTuple();
		dRowS = ((dRowS.Concat(dRowSUp)).Concat(dRowSDownInv)).Concat(dRowSUp.Select(0));
		dColS = ((dColS.Concat(dColSUp)).Concat(dColSDownInv)).Concat(dColSUp.Select(0));

		gen_region_polygon(&rgnBlackSearch,dRowS,dColS);
	
		HTuple dMean,dDe;
		intensity(rgnBlackSearch,Image,&dMean,&dDe);

		// 如果下边缘的row2 < 上边缘 row1 ，则相对位移也生效  
		HTuple dArea1,dRow1,dCol1,dArea2,dRow2,dCol2;
		area_center(m_DownEdge,&dArea1,&dRow1,&dCol1);
		area_center(m_DownEdgeX,&dArea2,&dRow2,&dCol2);

		Hobject ABEdgeMoved,RegionDilation;
		if ( Selection == 1)
		{
			// 上边缘
			dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
		}
		else if(Selection == 2)
		{
			// 下边缘
			// 当上下两条基准线第一次有交集，第二次没有交集的时候，进行覆膜区域灰度判断
			// 该算子只用于 AB32_DownEdgeDetect1和2 ，该算子提取覆膜边缘的时候加入了重合点判断，
			//  存在一个二次提取的过程
			if (( dMean <  GrayThred) && (dArea < IntsctThred ) && (dRow2 > dRow1) /*&& (m_bSecondFlag == true)*/)
			{
				dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
			}
			else if( dArea > IntsctThred*2 )
			{
				dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
			}
			else if( m_bSecondFlag== true)
			{
				dilation_rectangle1(m_DownEdge,&RegionDilation, 1, VErosionSize);
			}
			else
			{
				dilation_rectangle1(m_DownEdgeX,&RegionDilation, 1, VErosionSize);
			}
		}
		//水平缩放
		clip_region_rel(RegionDilation, &RegionDilation, 0, 0, HErosionSize, HErosionSize);

		if ( (dArea > IntsctThred) || ( dRow2 < dRow1))
		{
			move_region(RegionDilation,&RegionDilation,MoveSize + MoveDiff,0);
		}
		else
		{
			move_region(RegionDilation,&RegionDilation,MoveSize,0);
		}

		Hobject rgnUni;
		concat_obj(DownEdgeReg,DownEdgeReg2,&rgnUni);

		//my_disp_obj(rgnUni);
		concat_obj(DownEdgeReg,m_vRgn[rId],&m_vRgn[rId]);
		m_vRgn[rId] = RegionDilation;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ABEdgeRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6072$\
					 167;B$\
					 5529;LP;1;2;1;1$\
					 6071;LP;1;200;1;40$\
					 991;LP;-150;100;1;0$\
					 6066;LP;-20;30;1;3$\
					 6065;LP;1;500;1;30$\
					 994;LP;1;200;1;6$\
					 995;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************************************
***函数名：FilmEdgeRegionLocationAlgo1
***功  能：基于上下覆膜边缘生成覆膜区域
********************************************************************************************/
STDMETHODIMP CPlugAlgo::FilmEdgeRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      =  (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_DownEdgeReg.Id()== H_EMPTY_REGION) || (m_DownEdgeReg2.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		// 覆膜上下边缘区域
		HTuple dRowSUp,dColSUp,dRowSDown,dColSDown,dRowSDownInv,dColSDownInv;
		Hobject xldDownEdge,xld2DownEdge,rgnSknDownEdge,rgnSknDownEdge2 ;

		skeleton(m_DownEdgeReg,&rgnSknDownEdge);
		skeleton(m_DownEdgeReg2,&rgnSknDownEdge2);

		HTuple dRowSUpOri,dColSUpOri,dRowSDownOri,dColSDownOri;
		gen_contour_region_xld(rgnSknDownEdge,&xldDownEdge,"border");
		gen_contour_region_xld(rgnSknDownEdge2,&xld2DownEdge,"border");
		get_contour_xld(xldDownEdge,&dRowSUpOri,&dColSUpOri);
		get_contour_xld(xld2DownEdge,&dRowSDownOri,&dColSDownOri);

		HTuple dColSUpSort,dColIndexS,dRowSUpSel ;
		tuple_sort(dColSUpOri,&dColSUpSort);
		tuple_sort_index(dColSUpOri,&dColIndexS);
		tuple_select(dRowSUpOri,dColIndexS,&dRowSUpSel);

		HTuple dColSDownSort,dColIndexS1,dRowSDownSel ;
		tuple_sort(dColSDownOri,&dColSDownSort);
		tuple_sort_index(dColSDownOri,&dColIndexS1);
		tuple_select(dRowSDownOri,dColIndexS1,&dRowSDownSel);

		dRowSUp = dRowSUpSel;
		dColSUp = dColSUpSort;
		dRowSDown = dRowSDownSel;
		dColSDown = dColSDownSort;
		if( dRowSUp.Num() < 3 || ( dRowSDown.Num() < 3))
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		tuple_inverse(dRowSDown, &dRowSDownInv);
		tuple_inverse(dColSDown, &dColSDownInv);

		HTuple dRowS,dColS;
		Hobject rgnFilmEdge;
		dRowS = HTuple();
		dColS = HTuple();

		dRowS = ((dRowS.Concat(dRowSUp)).Concat(dRowSDownInv)).Concat(dRowSUp.Select(0));
		dColS = ((dColS.Concat(dColSUp)).Concat(dColSDownInv)).Concat(dColSUp.Select(0));
		gen_region_polygon(&rgnFilmEdge,dRowS,dColS);
		fill_up(rgnFilmEdge,&rgnFilmEdge );

		// 区域缩放
		Hobject  MiddleEdgeReg,MiddleEdgeRegDilation;
		move_region(rgnFilmEdge, &MiddleEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(MiddleEdgeReg,&MiddleEdgeRegDilation,1,DialtionSizeV);
		Hobject RegionClip,ImageDomain;
		clip_region_rel(MiddleEdgeRegDilation, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionClip, ImageDomain, &RegionClip);

		m_vRgn[rId] = RegionClip;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::FilmEdgeRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1389$\
					 167;B$\
					 1190;LP;-90;160;1;1$\
					 994;LP;1;70;1;10$\
					 995;LP;1;70;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************************************
****函 数 名：G20_TopAngleDetectAlgo
****功    能：单叉胶塞的叉口角度检测
注    意：该算子前先使用G20_TopSealingFaceEdgeDetectAlgo算子，获取m_InnerCircleRow，m_InnerCircleCol ,二次定位的中心坐标
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopAngleDetectAlgo(VARIANT* rgnId,VARIANT* pThreshValue,VARIANT* pGapAngle)
{
	int rId = (int)rgnId->fltVal;
	float ThreshValue = (float)pThreshValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_InnerCircleRow.Num()!=1||m_InnerCircleCol.Num()!=1)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		//scale_image_max(Image, &ImageScaleMax);
		reduce_domain(Image, rgn, &ImageScaleMax);

		Hobject Regions,RegionFillUp;
		threshold(ImageScaleMax, &Regions, ThreshValue,255);
		fill_up(Regions, &RegionFillUp);

		Hobject ConnectedRegions1,SelectedRegions1,RegionClosing1;
		connection(RegionFillUp, &ConnectedRegions1);
		select_shape_std(ConnectedRegions1, &SelectedRegions1, "max_area", 70);
		closing_circle(SelectedRegions1, &RegionClosing1, 30);

		HTuple GapArea, GapRow, GapCol;
		area_center(RegionClosing1, &GapArea, &GapRow, &GapCol);

		/*Hobject RegionTrans;
		shape_trans(RegionClosing1, &RegionTrans, "outer_circle");
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionTrans, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);*/

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionClosing1, &m_vRgn[rId]);
		}

		//
		if (GapArea.Num()==1)
		{
			if ( GapArea>0)
			{
				m_GapRow=GapRow;
				m_GapCol=GapCol;
			}
		}
		else
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapAngle);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, m_InnerCircleRow, m_InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,m_InnerCircleRow, m_InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			//
			if (0 != (Angle<0))
			{
				Angle += PI;
			}
			HTuple Deg;
			tuple_deg(Angle, &Deg);
			retValue = Deg[0].D();
			m_vErrorRgn[rId] = GapLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1081$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1176;FP;1;250;0.5;180");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************************************
***函 数 名：G20_TopSealingFaceEdgeDetectAlgo
***功    能：提取单叉胶塞的CH3 工位的密封面边缘
***修改说明：
***修改说明：内容（一）：解决边缘提取不到位问题
**                       将Closing_Rectangle1 的尺寸从500减小至250   
**           时    间：2018年08月13日
**           修 改 人：吴贻峰
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopSealingFaceEdgeDetectAlgo(VARIANT* rgnId,VARIANT* pThresh,VARIANT* pOpeningSize,VARIANT* pGapArea)
{
	//Rgn为包括颈部与密封面的拐角的环形区域
	int rId = (int)rgnId->fltVal;
	float Thresh = (float)pThresh->fltVal;
	float OpeningSize = (float)pOpeningSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_crtImg;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		HTuple Row, Column, Radius2;
		smallest_circle(rgn, &Row, &Column, &Radius2);
		Hobject RegionComplement,ConnectedRegions3,SelectedRegions4,RegionUnion3;
		complement (rgn, &RegionComplement);
		connection(RegionComplement, &ConnectedRegions3);
		select_shape (ConnectedRegions3, &SelectedRegions4, "circularity", "and", 0.99, 2);
		union1(SelectedRegions4, &RegionUnion3);
		HTuple  Row2, Column2, Radius3;
		smallest_circle(RegionUnion3, &Row2, &Column2, &Radius3);

		if (Radius3.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		HTuple RadiusExt,RadiusInner,AngleS,WithPolar,HeightPolar;

		RadiusExt = Radius2.Round();
		RadiusInner = Radius3.Round();
		AngleS = 3.1416*2.5;
		WithPolar = (((RadiusExt+RadiusInner)*AngleS)/2.0).Round();
		HeightPolar = ((RadiusExt-RadiusInner).Abs()).Round();

		Hobject PolarTransImage1;
		polar_trans_image_ext(Image, &PolarTransImage1,  fCenterY, fCenterX, 0, AngleS, RadiusInner, RadiusExt, WithPolar, HeightPolar, "nearest_neighbor");

		Hobject ImageMean1,RegionDynThresh,RegionOpening1,RegionClosing2,ConnectedRegions2,SelectedRegions2;
		mean_image(PolarTransImage1, &ImageMean1, 3, 31);
		dyn_threshold(PolarTransImage1, ImageMean1, &RegionDynThresh, Thresh, "dark");
		opening_rectangle1(RegionDynThresh, &RegionOpening1, 5, 3);
		//闭合尺寸500
		closing_rectangle1(RegionOpening1, &RegionClosing2, 250, 1);
		connection(RegionClosing2, &ConnectedRegions2);
		select_shape_std(ConnectedRegions2, &SelectedRegions2, "max_area", 70);

		Hobject RegionUnion1,RegionBorder;
		union1(SelectedRegions2, &RegionUnion1);
		boundary(RegionUnion1, &RegionBorder, "outer");
		Hobject XYTransRegion,RegionDilation1,Contours;
		polar_trans_region_inv(RegionUnion1, &XYTransRegion,  fCenterY, fCenterX, 0, AngleS, RadiusInner, RadiusExt, WithPolar, HeightPolar, Width, Height, "nearest_neighbor");
		HTuple area1,Row1,col1;
		area_center(XYTransRegion,&area1,&Row1,&col1);
		if (area1==0)
		{
			m_InnerCircleRow=Height/2.0;
			m_InnerCircleCol=Width/2.0;

			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		dilation_circle(XYTransRegion, &RegionDilation1, 3.5);
		gen_contour_region_xld(RegionDilation1, &Contours, "border");

		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius,StartPhi, EndPhi, PointOrder;
		fit_circle_contour_xld(Contours, "algebraic", -1, 0, 0, 3, 2, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius, &StartPhi, &EndPhi, &PointOrder);
		Hobject Circle1;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius);

		m_vPos[0].m_x = (float)InnerCircleCol[0].D();
		m_vPos[0].m_y = (float)InnerCircleRow[0].D();

		m_InnerCircleRow=InnerCircleRow;
		m_InnerCircleCol=InnerCircleCol;
		m_InnerCircleRadius=InnerCircleRadius;
		//
		m_OutCircle=Circle1;   //用于顶部斜坡面外边缘 G20_TopRegionLocationAlgo
		Hobject Region;
		gen_region_contour_xld(Contours, &Region, "filled");

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], Region, &m_vRgn[rId]);
		}
		//去毛刺
		Hobject RegionOpening;
		opening_circle(Region,&RegionOpening,OpeningSize);

		m_InnerEdge=RegionOpening;
		//
		if(area1>0)
		{
			retValue = area1[0].I();
			m_vErrorRgn[rId] = Region;
		}
		else
		{
			Hobject EmptyRegion;
			gen_empty_region(&EmptyRegion);
			retValue = -1;
			m_vErrorRgn[rId] = EmptyRegion;
		}
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopSealingFaceEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1232$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1175;FP;1;100;0.5;12$\
					 864;FP;1.5;200;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/************************************************************************************************************************
****函 数 名：G20_TopRegionLocationAlgo
****功    能：提取单叉胶塞第三工位的 顶部高亮、顶部斜坡区域、顶部叉口区域、内壁区域；提取的区域控制方式：区域开关Selection
**************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1||m_GapRow.Num()!=1||m_GapCol.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		HTuple Angle;
		Angle=HTuple(180).Rad()+m_modelAngle;

		if (Selection==1)  //顶部高亮区域
		{

			polar_trans_image_ext(m_ImageScaleMax, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, "nearest_neighbor");
			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 160);
			m_TopRegsClosing=TopRegsClosing;
			//两端缩放
			Hobject RegionErosion,TopRegsErosion;
			erosion_rectangle1(TopRegsClosing, &RegionErosion, (int)ErosionSize+10, 1);
			// 时间：2019年9月17日
			/*Hobject TopRegsClosingMov1,TopRegsClosingMov2 ;
			move_region(TopRegsClosing,&TopRegsClosingMov1,0, (Hlong)ErosionSize);
			move_region(TopRegsClosing,&TopRegsClosingMov2,0, (Hlong)-ErosionSize);
			intersection(TopRegsClosingMov2,TopRegsClosingMov1,&RegionErosion );*/
			//

			polar_trans_region_inv(RegionErosion, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegsErosion,ErosionSize);
			//
			//Hobject TopRegsClosingDilation,TopRegsDilationXY;
			//dilation_rectangle1(TopRegsClosing, &TopRegsClosingDilation, 60, 1);
			//polar_trans_region_inv(TopRegsClosingDilation, &TopRegsDilationXY, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");

			m_TopRegsDilationXY=TopRegs;
			m_TopRadius=Radius;
			intersection(TopRegsErosion, ImageDomain, &TopRegsErosion);
			m_vRgn[rId] = TopRegsErosion ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation,RegionDilation2,TopRegsErosion;
			move_region(m_TopRegsClosing, &RegionMoved, 30, 0);
			dilation_rectangle1(RegionMoved, &RegionDilation2, 5, 28);
			erosion_rectangle1(RegionDilation2, &TopRegsErosion, ForkEdge, 1);
			polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			if (InnerEdge>OutEdge)
			{
				InnerEdge=OutEdge-(float)0.5;
			}
			Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
			//Hobject TopRegsClosingDilation,TopRegsDilationXY;
			//dilation_rectangle1(m_TopRegsClosing, &TopRegsClosingDilation, 100, 1);
			//polar_trans_region_inv(TopRegsClosingDilation, &TopRegsDilationXY, m_InnerCircleRow, m_InnerCircleCol, m_modelAngle+Angle, (6.28319+m_modelAngle)+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius, m_imgWidth, m_imgHeight, "nearest_neighbor");    
			shape_trans(m_TopRegsDilationXY, &Circle5, "outer_circle");
			if (InnerEdge<=0)
			{
				erosion_circle(Circle5, &Circle5, abs(InnerEdge)+1.5);
			}
			else
			{
				dilation_circle(Circle5, &Circle5, InnerEdge);

			}
			erosion_circle(m_OutCircle, &Circle6,OutEdge);

			difference(Circle6, Circle5, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);

			intersection(TopSlopRegs, ImageDomain, &TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;

			/*concat_obj(m_vRgn[rId],Circle5,&m_vRgn[rId]);
			concat_obj(m_vRgn[rId],Circle6,&m_vRgn[rId]);
			*/
		}
		else if(Selection==3)  //顶部叉口区域,以外圆中心坐标
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 25, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+55, 30);

			//Hobject RegionMoved0,TopRegsDilation0;
			//move_region(m_TopRegsClosing, &RegionMoved0, 15, 0);
			//dilation_rectangle1(RegionMoved0, &TopRegsDilation0, ForkEdge+30, 15);

			Hobject TopRegsDilation1;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation1, ForkEdge+40, 20);

			//Hobject RegionMoved1,TopRegsDilation2;
			//move_region(m_TopRegsClosing, &RegionMoved1, -10, 0);
			//dilation_rectangle1(RegionMoved1, &TopRegsDilation2, ForkEdge, 20);

			Hobject RegionMoved2,TopRegsDilation3;
			move_region(m_TopRegsClosing, &RegionMoved2, -35, 0);
			dilation_rectangle1(RegionMoved2, &TopRegsDilation3, ForkEdge, 20);

			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation, TopRegsDilation1, &RegionUnion);
			union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			//union2(RegionUnion, TopRegsDilation2, &RegionUnion);
			//union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);
			Hobject RegionClosing;
			closing_rectangle1(RegionDilation, &RegionClosing, 20, 200);
			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionClosing, &XYTransLowRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			if ((abs(InnerEdge)+1.5)<=60)
			{
				InnerEdge=60;
			}
			//gen_circle(&Circle7,  m_OutCircleRow, m_OutCircleCol, InnerEdge);
			//gen_circle(&Circle8,  m_OutCircleRow, m_OutCircleCol, OutEdge);
			HTuple Phi;
			line_orientation(m_InnerCircleRow, m_InnerCircleCol, m_GapRow, m_GapCol, &Phi);
			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			if (0 != (m_GapCol<m_InnerCircleCol))
			{
				Phi += 3.1416;
			}
			HTuple OfsetDist,CenterNewX,CenterNewY;
			OfsetDist = 30-16;
			CenterNewX = m_InnerCircleCol+(OfsetDist*(Phi.Cos()));
			CenterNewY = m_InnerCircleRow-(OfsetDist*(Phi.Sin()));

			if (0 != (m_InnerCircleRadius<7))
			{
				m_InnerCircleRadius=7;
			}
			gen_circle(&Circle8, CenterNewY, CenterNewX, m_InnerCircleRadius-5);
			erosion_circle(Circle8,&Circle8,OutEdge);
			//*
			gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5);

			Hobject TopLowRegsDiff,ConnectedRegions4,SelectedRegions3;
			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, XYTransLowRegs, &TopLowRegsDiff);
			connection(TopLowRegsDiff, &ConnectedRegions4);
			select_shape_std(ConnectedRegions4, &SelectedRegions3, "max_area", 70);
			opening_circle(SelectedRegions3, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);

			//叉口边沿区域公共变量
			m_XYTransLowRegs=XYTransLowRegs;
			m_CenterNewX=CenterNewX;
			m_CenterNewY=CenterNewY;
			//m_TopLowRegs=TopLowRegs;

			intersection(TopLowRegs, ImageDomain, &TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}
		else if(Selection==4)  //内壁区域
		{
			Hobject RegionMoved,TopRegsDilation,TopRegsErosion,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, -40, 0);
			dilation_circle(RegionMoved, &TopRegsDilation, 20);
			erosion_rectangle1(TopRegsDilation, &TopRegsErosion, ForkEdge, 1);

			polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			if (OutEdge<=(abs(InnerEdge)+1.5))
			{
				OutEdge=abs(InnerEdge)+20;
			}

			Hobject Circle5,Circle6,CircleDiff,InWallRegs;
			gen_circle(&Circle5,  m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5);
			gen_circle(&Circle6,  m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			difference(Circle6, Circle5, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &InWallRegs);
			union1(InWallRegs,&InWallRegs);

			intersection(InWallRegs, ImageDomain, &InWallRegs);
			m_vRgn[rId] = InWallRegs ;	
		}
		
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1118;LP;1;4;1;1$\
					 1075;LP;100;250;1;180$\
					 1076;FP;1;250;0.5;125$\
					 1077;LP;1;19000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1177;LP;1;200;1;1$\
					 1178;FP;-100;180;1;40$\
					 1179;FP;1;200;1;25");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/************************************************************************************************************************
****函 数 名：G20_TopRegionLocationAlgo2
****功    能：提取单叉胶塞第三工位的 顶部高亮、顶部斜坡区域、顶部叉口区域、内壁区域；提取的区域控制方式：区域开关Selection
****说    明：（1）该算子根据 G20_TopRegionLocationAlgo 进行修改
              （2）修改了斜坡区域和内壁区域的内外边缘控制方式
**************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1||m_GapRow.Num()!=1||m_GapCol.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		HTuple Angle;
		Angle=HTuple(180).Rad()+m_modelAngle;

		if (Selection==1)  //顶部高亮区域
		{

			polar_trans_image_ext(m_ImageScaleMax, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, "nearest_neighbor");
			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 160);
			m_TopRegsClosing=TopRegsClosing;
			//两端缩放
			Hobject RegionErosion,TopRegsErosion;
			erosion_rectangle1(TopRegsClosing, &RegionErosion, (int)ErosionSize+10, 1);
			polar_trans_region_inv(RegionErosion, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegsErosion,ErosionSize);
			//
			//Hobject TopRegsClosingDilation,TopRegsDilationXY;
			//dilation_rectangle1(TopRegsClosing, &TopRegsClosingDilation, 60, 1);
			//polar_trans_region_inv(TopRegsClosingDilation, &TopRegsDilationXY, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");

			m_TopRegsDilationXY=TopRegs;
			m_TopRadius=Radius;
			intersection(TopRegsErosion, ImageDomain, &TopRegsErosion);
			m_vRgn[rId] = TopRegsErosion ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation,RegionDilation2,TopRegsErosion;
			move_region(m_TopRegsClosing, &RegionMoved, 30, 0);
			dilation_rectangle1(RegionMoved, &RegionDilation2, 5, 28);
			erosion_rectangle1(RegionDilation2, &TopRegsErosion, ForkEdge, 1);

			polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject rgnCirOuter,rgnCirOuterF,rgnCirInner,CircleDiff;
			shape_trans(XYTransTopRegsDilation, &rgnCirOuter, "outer_circle");
			erosion_circle(rgnCirOuter, &rgnCirOuterF,OutEdge);

			if (InnerEdge<=0)
			{
				erosion_circle(rgnCirOuterF, &rgnCirInner, abs(InnerEdge)+1.5);
			}
			else
			{
				erosion_circle(rgnCirOuterF, &rgnCirInner, InnerEdge+1.5);
			}

			Hobject TopSlopRegs;
			difference(rgnCirOuterF, rgnCirInner, &CircleDiff);

			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);

			intersection(TopSlopRegs, ImageDomain, &TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;

		}
		else if(Selection==3)  //顶部叉口区域,以外圆中心坐标
		{
			Hobject RegionMoved,TopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, 25, 0);
			dilation_rectangle1(RegionMoved, &TopRegsDilation, ForkEdge+55, 30);

			Hobject TopRegsDilation1;
			dilation_rectangle1(m_TopRegsClosing, &TopRegsDilation1, ForkEdge+40, 20);

			Hobject RegionMoved2,TopRegsDilation3;
			move_region(m_TopRegsClosing, &RegionMoved2, -35, 0);
			dilation_rectangle1(RegionMoved2, &TopRegsDilation3, ForkEdge, 20);

			Hobject RegionUnion,RegionDilation;
			union2(TopRegsDilation, TopRegsDilation1, &RegionUnion);
			union2(RegionUnion, TopRegsDilation3, &RegionUnion);
			
			union1(RegionUnion, &RegionUnion);
			dilation_circle(RegionUnion, &RegionDilation, 5);
			Hobject RegionClosing;
			closing_rectangle1(RegionDilation, &RegionClosing, 20, 200);
			Hobject XYTransLowRegs;
			polar_trans_region_inv(RegionClosing, &XYTransLowRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			if ((abs(InnerEdge)+1.5)<=60)
			{
				InnerEdge=60;
			}
		
			HTuple Phi;
			line_orientation(m_InnerCircleRow, m_InnerCircleCol, m_GapRow, m_GapCol, &Phi);
			Hobject Circle7,Circle8,CircleDiff1,TopLowRegs;
			if (0 != (m_GapCol<m_InnerCircleCol))
			{
				Phi += 3.1416;
			}
			HTuple OfsetDist,CenterNewX,CenterNewY;
			OfsetDist = 30-16;
			CenterNewX = m_InnerCircleCol+(OfsetDist*(Phi.Cos()));
			CenterNewY = m_InnerCircleRow-(OfsetDist*(Phi.Sin()));

			if (0 != (m_InnerCircleRadius<7))
			{
				m_InnerCircleRadius=7;
			}
			gen_circle(&Circle8, CenterNewY, CenterNewX, m_InnerCircleRadius-5);
			erosion_circle(Circle8,&Circle8,OutEdge);
			//*
			gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5);

			Hobject TopLowRegsDiff,ConnectedRegions4,SelectedRegions3;
			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, XYTransLowRegs, &TopLowRegsDiff);
			connection(TopLowRegsDiff, &ConnectedRegions4);
			select_shape_std(ConnectedRegions4, &SelectedRegions3, "max_area", 70);
			opening_circle(SelectedRegions3, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);

			//叉口边沿区域公共变量
			m_XYTransLowRegs=XYTransLowRegs;
			m_CenterNewX=CenterNewX;
			m_CenterNewY=CenterNewY;
			//m_TopLowRegs=TopLowRegs;

			intersection(TopLowRegs, ImageDomain, &TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}
		else if(Selection==4)  //内壁区域
		{
			Hobject RegionMoved,TopRegsDilation,TopRegsErosion,XYTransTopRegsDilation;
			move_region(m_TopRegsClosing, &RegionMoved, -40, 0);
			dilation_circle(RegionMoved, &TopRegsDilation, 20);
			erosion_rectangle1(TopRegsDilation, &TopRegsErosion, ForkEdge, 1);

			polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			Hobject rgnCirOuter,rgnCirOuterF,rgnCirInner,CircleDiff;
			shape_trans(XYTransTopRegsDilation, &rgnCirOuter, "outer_circle");
			erosion_circle(rgnCirOuter, &rgnCirOuterF,OutEdge);

			if (InnerEdge<=0)
			{
				erosion_circle(rgnCirOuterF, &rgnCirInner, abs(InnerEdge)+1.5);
			}
			else
			{
				erosion_circle(rgnCirOuterF, &rgnCirInner, InnerEdge+1.5);
			}
		
			Hobject InWallRegs;
			difference(rgnCirOuterF, rgnCirInner, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &InWallRegs);
			union1(InWallRegs,&InWallRegs);

			intersection(InWallRegs, ImageDomain, &InWallRegs);
			m_vRgn[rId] = InWallRegs ;	
		}
		
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6139$\
					 167;B$\
					 1118;LP;1;4;1;1$\
					 1075;LP;100;250;1;180$\
					 1076;FP;1;250;0.5;125$\
					 1077;LP;1;19000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1177;LP;1;200;1;1$\
					 1178;FP;-100;180;0.5;40$\
					 1179;FP;1;200;0.5;25");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/*****************************************************************************************************
** 函数名：G20_TopHLightLocationAlgo
** 功  能：针对一种单叉胶塞，定位其顶部高亮区域，该算子可以对顶部区域的两端进行缩放
** 时  间：2019年9月12日
******************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopHLightLocationAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge)
{
	int rId = (int)rgnId->fltVal;
	
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	float ForkEdge = (float)pForkEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1||m_GapRow.Num()!=1||m_GapCol.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		HTuple Angle;
		Angle=HTuple(180).Rad()+m_modelAngle;

	 //顶部高亮区域
	
		polar_trans_image_ext(m_ImageScaleMax, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, "nearest_neighbor");
		Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
		threshold(PolarTransImage, &Regions, ThredLower, 255);
		fill_up(Regions, &RegionFillUp2);
		connection(RegionFillUp2, &ConnectedRegions);
		select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
		Hobject TopRegsClosing,TopRegs;
		closing_circle(SelectedRegions, &TopRegsClosing, 160);
		m_TopRegsClosing=TopRegsClosing;
		//两端缩放
		Hobject RegionErosion,TopRegsErosion,RegionClip;
		erosion_rectangle1(TopRegsClosing, &RegionErosion, (int)ErosionSize+10, 1);
		clip_region_rel(RegionErosion,&RegionClip,0,0,(int)ForkEdge,(int)ForkEdge );

		polar_trans_region_inv(RegionClip, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1(TopRegs,&TopRegs);
		erosion_circle(TopRegs,&TopRegsErosion,ErosionSize);
		
		intersection(TopRegsErosion, ImageDomain, &TopRegsErosion);
		m_vRgn[rId] = TopRegsErosion ;	
		
				
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopHLightLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6134$\
					 167;B$\
					 1075;LP;100;250;1;180$\
					 1076;FP;1;250;0.5;105$\
					 1077;LP;1;19000;1;8000$\
					 6135;FP;1;20;0.5;3.5$\
					 6137;FP;1;200;0.5;25");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***********************************************************************************************************************
**函数名：G20_TopCornerLocationAlgo
**功  能：定位单叉胶塞顶部工位的斜坡拐角区域定位
**时  间：2019年9月11日
************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopCornerLocationAlgo(VARIANT* rgnId,VARIANT* pSlopeSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	
	float SlopeSize = (float)pSlopeSize->fltVal;
	//
	float ForkEdge = (float)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1||m_GapRow.Num()!=1||m_GapCol.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		HTuple Angle;
		Angle=HTuple(180).Rad()+m_modelAngle;

		Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation,RegionDilation2,TopRegsErosion,TopRegsErosion1,TopRegsErosion2;
		move_region(m_TopRegsClosing, &RegionMoved, 30, 0);
		dilation_rectangle1(RegionMoved, &RegionDilation2, 45, 28);
		erosion_rectangle1(RegionDilation2, &TopRegsErosion1, (int)ForkEdge, 1);
		erosion_rectangle1(TopRegsErosion1, &TopRegsErosion2, (int)(ForkEdge + SlopeSize), 1);
		difference(TopRegsErosion1,TopRegsErosion2 ,&TopRegsErosion);

		polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

		if (InnerEdge>OutEdge)
		{
			InnerEdge=OutEdge-(float)0.5;
		}
		Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;
		shape_trans(m_TopRegsDilationXY, &Circle5, "outer_circle");
		if (InnerEdge<=0)
		{
			erosion_circle(Circle5, &Circle5, abs(InnerEdge)+1.5);
		}
		else
		{
			dilation_circle(Circle5, &Circle5, InnerEdge);

		}
		erosion_circle(m_OutCircle, &Circle6,OutEdge);

		difference(Circle6, Circle5, &CircleDiff);
		intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
		union1(TopSlopRegs,&TopSlopRegs);

		intersection(TopSlopRegs, ImageDomain, &TopSlopRegs);
		m_vRgn[rId] = TopSlopRegs ;
	
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopCornerLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6131$\
					 167;B$\
					 6130;FP;1;100;0.5;40$\
					 1177;FP;1;200;0.5;5$\
					 1178;FP;-100;180;0.5;3$\
					 1179;FP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/************************************************************************************************************************
****函 数 名：G20_TopRegionLocationAlgo1
****功    能：提取单叉胶塞第三工位的 顶部高亮、顶部斜坡区域、顶部叉口区域、内壁区域；提取的区域控制方式：区域开关Selection
****              与G20_TopRegionLocationAlgo的区别：G20_TopRegionLocationAlgo使用极坐标变换
****              G20_TopRegionLocationAlgo1 直接在直角坐标系中实现
****时    间：2018年8月20日
****作    者：吴贻峰
**************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int iSelection = (int)pSelection->fltVal;
	//
	int iRadius = (int)pRadius->fltVal;
	float fThredLower = (float)pThredLower->fltVal;
	int iAreaLimitLower=(int)pAreaLimitLower->fltVal;
	float fErosionSize = (float)pErosionSize->fltVal;
	//
	int iForkEdgeSize = (int)pForkEdge->fltVal;
	float fInnerEdgeSize = (float)pInnerEdge->fltVal;
	float fOutEdgeSize = (float)pOutEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1||m_GapRow.Num()!=1||m_GapCol.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain ,rgnGap,rgnHighLight;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);

		HTuple Angle;
		Angle=HTuple(180).Rad()+m_modelAngle;

		if (iSelection==1)  //顶部高亮区域 m_InnerCircleRow
		{
			HTuple iNumber;
			Hobject rgnHighLightSech,imgHighLightSech,rgnThr,rgnFil,rgnCon,rgnSel,rgnCls,rgnOpn ;

			gen_circle(&rgnHighLightSech, fCenterY, fCenterX, iRadius);
			reduce_domain(m_crtImg, rgnHighLightSech, &imgHighLightSech);

			threshold(imgHighLightSech, &rgnThr, fThredLower, 255);
			fill_up(rgnThr, &rgnFil);
			connection(rgnFil, &rgnCon);
			select_shape(rgnCon, &rgnSel, "area", "and", iAreaLimitLower, 99999);
			closing_circle(rgnSel, &rgnCls, 100);
			opening_circle(rgnCls, &rgnOpn, 10);

			count_obj(rgnOpn, &iNumber);

			if (0 != (iNumber!=2))
			{
				Hobject newRgn;
				m_vRgn[rId] = newRgn;
				return S_FALSE;
			}

			HTuple end_val1,step_val1,dArea,dRow,dCol,iIndex;
			Hobject objSel;

			end_val1 = iNumber;
			step_val1 = 1;

			for ( iIndex=1; iIndex.Continue(end_val1, step_val1); iIndex += step_val1)
			{
				select_obj(rgnOpn, &objSel, iIndex);
				area_center(objSel, &dArea, &dRow, &dCol);

				if (0 != (dArea<30000))
				{
					gen_empty_obj(&rgnGap);
					concat_obj(rgnGap, objSel, &rgnGap);
					union1(rgnGap, &rgnGap);
				}
				else
				{
					gen_empty_obj(&rgnHighLight);
					concat_obj(rgnHighLight, objSel, &rgnHighLight);
					union1(rgnHighLight, &rgnHighLight);
				}
			}

			//// 二次阈值
			//Hobject imgHighLight,rgnThrHighLight,rgnFilHighLight,rgnConHighLight,rgnTop;

			//reduce_domain(m_crtImg, rgnHighLight, &imgHighLight);
			//threshold(imgHighLight, &rgnThrHighLight, fThredLower+30, 255);
			//fill_up(rgnThrHighLight, &rgnFilHighLight);
			//connection(rgnFilHighLight, &rgnConHighLight);
			//select_shape_std(rgnConHighLight, &rgnTop, "max_area", 70);

			// 高亮区域二次定位(内圆中心)
			Hobject  rgnHighLightTrans,rgnHighLightEro,rgnHighLightFil,rgnHighLightDif,rgnGapDilDecrs ;
			Hobject  rgnHighLightInnercir,rgnHighLightInnercirOpn,rgnCirCenter;
			HTuple   dCenterRow,dCenterCol,dCenterR;

			shape_trans(rgnHighLight, &rgnHighLightTrans, "outer_circle");
			erosion_circle(rgnHighLightTrans, &rgnHighLightEro, 5.5);
			fill_up(rgnHighLightEro, &rgnHighLightFil);
			difference(rgnHighLightFil, rgnHighLight, &rgnHighLightDif);

			dilation_circle(rgnGap, &rgnGapDilDecrs, 43.5);

			difference(rgnHighLightDif, rgnGapDilDecrs, &rgnHighLightInnercir);
			opening_circle(rgnHighLightInnercir, &rgnHighLightInnercirOpn, 15.5);
			smallest_circle(rgnHighLightInnercirOpn, &dCenterRow, &dCenterCol, &dCenterR);
			gen_circle(&rgnCirCenter, dCenterRow, dCenterCol, dCenterR);

			// 提取高亮
			Hobject rgnCir1HighLight,rgnCir2HighLight,rgnAnnularHighLight;

			gen_circle(&rgnCir1HighLight, dCenterRow, dCenterCol, fOutEdgeSize+150);     //190
			gen_circle(&rgnCir2HighLight, dCenterRow, dCenterCol,fInnerEdgeSize+70); // 132
			difference(rgnCir1HighLight, rgnCir2HighLight, &rgnAnnularHighLight);

			// 确定叉口两边的黑色小区域
			Hobject rgnHighLightDil,rgnGtapDil,rgnHighGapInsect,imgHighGapInsect,rgnHighGapThr;
			Hobject rgnHighGapCon,rgnHighGapSel,rgnRectHighGapSel,rgnHighGapInsect2   ;
			HTuple  dPhi,dLen1,dLen2 ,dRow1,dCol1 ;

			dilation_circle(rgnHighLight, &rgnHighLightDil, 25.5);   
			dilation_circle(rgnGap, &rgnGtapDil,25.5);
			intersection(rgnGtapDil, rgnHighLightDil,&rgnHighGapInsect);
			reduce_domain(m_crtImg, rgnHighGapInsect, &imgHighGapInsect);
			threshold(imgHighGapInsect, &rgnHighGapThr, 0, 80);
			connection(rgnHighGapThr, &rgnHighGapCon);
			select_shape(rgnHighGapCon, &rgnHighGapSel, "area", "and", 150, 99999);

			smallest_rectangle2(rgnHighGapSel, &dRow1, &dCol1, &dPhi, &dLen1, &dLen2);
			gen_rectangle2(&rgnRectHighGapSel, dRow1, dCol1, dPhi, dLen1, dLen2);

			intersection(rgnRectHighGapSel, rgnAnnularHighLight, &rgnHighGapInsect2);

			Hobject rgnHighGapOpn,rgnHighGapDil,rgnGapNew,rgnHighGapCon2,rgnHighGapDif;
			HTuple  iNumber2;

			opening_circle(rgnHighGapInsect2, &rgnHighGapOpn, 3.5);  
			connection(rgnHighGapOpn,&rgnHighGapCon2);
			count_obj(rgnHighGapCon2,&iNumber2);
			if (0 != (iNumber2!=2))
			{
				Hobject newRgn;
				m_vRgn[rId] = newRgn;
				return S_FALSE;
			}

			if (iForkEdgeSize < 0)
			{
				erosion_circle(rgnHighGapCon2, &rgnHighGapDil, abs(iForkEdgeSize));
			}
			else if ( iForkEdgeSize == 0)
			{
				dilation_circle(rgnHighGapCon2, &rgnHighGapDil, 0.5);
			}
			else
			{
				dilation_circle(rgnHighGapCon2, &rgnHighGapDil, iForkEdgeSize);  // // iForkEdgeSize
			}
			//*****
			Hobject  rgnHighGapInsect3,rgnHighLightSerch,rgnHighLighOri,rgnHighLighOriOpn;
			Hobject  rgnHighLighOriCon,rgnHighLighOriSel,rgnHighLightNew,rgnTop;

			intersection(rgnHighGapDil, rgnAnnularHighLight, &rgnHighGapInsect3);

			dilation_circle(rgnHighLight, &rgnHighLightSerch, 22.5);
			intersection(rgnHighLightSerch, rgnAnnularHighLight, &rgnHighLighOri);

			difference(rgnHighLighOri, rgnHighGapInsect3, &rgnHighLighOri);
			opening_circle(rgnHighLighOri, &rgnHighLighOriOpn, 5.5);
			connection(rgnHighLighOriOpn, &rgnHighLighOriCon);
			select_shape_std(rgnHighLighOriCon, &rgnHighLighOriSel, "max_area", 70);

			erosion_circle(rgnHighLighOriSel, &rgnHighLightNew, 3.5);

			intersection(rgnHighLightNew, m_crtImg, &rgnTop);

			// 缩放 
			erosion_circle(rgnTop, &rgnTop, fErosionSize);

			intersection(rgnTop, ImageDomain, &rgnTop);

			m_vRgn[rId] = rgnTop ;

			//赋值公共变量
			m_rgnHighLight = rgnHighLight;
			m_rgnGap       = rgnGap;

			m_TopRegsDilationXY=rgnTop;
			m_TopRadius=iRadius;
			/*intersection(TopRegsErosion, ImageDomain, &TopRegsErosion);
			m_vRgn[rId] = TopRegsErosion ;	*/
		}
		else if(iSelection==2)  //顶部斜坡区域
		{
			Hobject rgnHighLigtDil2,rgnGapDil2,rgnTrans,rgnCircleIner,rgnCircleOut,rgnAnnular;
			Hobject rgnOriSlop,rgnSlop,rgnGapDilTemp,rgnOriDifSlop,rgnOriOpnSlop,rgnOriConSlop,rgnOriSelSlop;

			dilation_circle(m_rgnHighLight, &rgnHighLigtDil2, 25);
			dilation_circle(m_rgnGap, &rgnGapDil2, 45);

			shape_trans(rgnHighLigtDil2, &rgnTrans, "outer_circle");

			if (fOutEdgeSize>fInnerEdgeSize)
			{
				fInnerEdgeSize = abs(fInnerEdgeSize);
				fOutEdgeSize=abs(fInnerEdgeSize)-(float)0.5;
			}

			if (fInnerEdgeSize <= 0)
			{
				fInnerEdgeSize = fOutEdgeSize+30;
			}

			erosion_circle(rgnTrans, &rgnCircleIner, fInnerEdgeSize);    // 40
			erosion_circle(m_OutCircle, &rgnCircleOut, fOutEdgeSize);        //10

			difference(rgnCircleOut, rgnCircleIner, &rgnAnnular);
			intersection(rgnAnnular, rgnHighLigtDil2, &rgnOriSlop);

			// 通过放大叉口区域对斜坡区域两端大小进行调节
			if ( iForkEdgeSize <= 0)
			{
				iForkEdgeSize = 1;
			}
			dilation_circle(rgnGapDil2, &rgnGapDilTemp, iForkEdgeSize);

			difference(rgnOriSlop, rgnGapDilTemp, &rgnOriDifSlop);

			opening_circle(rgnOriDifSlop,&rgnOriOpnSlop,3.5);
			connection(rgnOriOpnSlop,&rgnOriConSlop);
			select_shape_std(rgnOriConSlop, &rgnOriSelSlop, "max_area", 70);

			// 整体缩放 
			erosion_circle(rgnOriSelSlop, &rgnSlop, fErosionSize);
			union1(rgnSlop, &rgnSlop);

			intersection(rgnSlop, ImageDomain, &rgnSlop);

			m_vRgn[rId] = rgnSlop ;

		}
		else if(iSelection==3)  //顶部叉口区域,以外圆中心坐标
		{
			// rgnGap
			Hobject rgnCir1Gap ,rgnCir2Gap,rgnCirDifGap,rgnOriGap,rgnOriConGap,rgnOriSelGap;
			Hobject rgnHighLightDil;
			HTuple Phi;

			line_orientation(m_InnerCircleRow, m_InnerCircleCol, m_GapRow, m_GapCol, &Phi);

			if (0 != (m_GapCol<m_InnerCircleCol))
			{
				Phi += 3.1416;
			}
			HTuple OfsetDist,CenterNewX,CenterNewY;
			OfsetDist = 30-16;
			CenterNewX = m_InnerCircleCol+(OfsetDist*(Phi.Cos()));
			CenterNewY = m_InnerCircleRow-(OfsetDist*(Phi.Sin()));

			if (0 != (m_InnerCircleRadius<7))
			{
				m_InnerCircleRadius=7;
			}

			if ((abs(fInnerEdgeSize)+1.5)<=60)
			{
				fInnerEdgeSize=60;
			}

			gen_circle(&rgnCir1Gap, CenterNewY, CenterNewX, m_InnerCircleRadius-5);
			erosion_circle(rgnCir1Gap,&rgnCir1Gap,fOutEdgeSize );
			//*
			gen_circle(&rgnCir2Gap, m_InnerCircleRow, m_InnerCircleCol, abs(fInnerEdgeSize)+1.5); // 100

			//确定叉口区域,膨胀一定尺寸，防止出现大的脏污时，导致叉口区域提取不完整
			Hobject rgnGapSerch,rgnGapSerchInsect,rgnGtapDil,rgnHighGapInsect,imgHighGapInsect;
			Hobject rgnHighGapThr,rgnHighGapCon,rgnHighGapSel,rgnHighGapInsect2,rgnRectHighGapSel;
			HTuple  dRow,dCol,dPhi,dLen1,dLen2;

			difference(rgnCir1Gap, rgnCir2Gap, &rgnCirDifGap);
			dilation_circle(m_rgnGap,&rgnGapSerch,30);
			intersection(rgnGapSerch,rgnCirDifGap,&rgnGapSerchInsect);

			// 确定横向缩放区域（减操作）
			dilation_circle(m_rgnHighLight, &rgnHighLightDil, 25.5);   
			dilation_circle(m_rgnGap, &rgnGtapDil,25.5);
			intersection(rgnGtapDil, rgnHighLightDil,&rgnHighGapInsect);
			reduce_domain(m_crtImg, rgnHighGapInsect, &imgHighGapInsect);
			threshold(imgHighGapInsect, &rgnHighGapThr, 0, 80);
			connection(rgnHighGapThr, &rgnHighGapCon);
			select_shape(rgnHighGapCon, &rgnHighGapSel, "area", "and", 150, 99999);

			smallest_rectangle2(rgnHighGapSel, &dRow, &dCol, &dPhi, &dLen1, &dLen2);
			gen_rectangle2(&rgnRectHighGapSel, dRow, dCol, dPhi, dLen1, dLen2);

			intersection(rgnRectHighGapSel, rgnCirDifGap, &rgnHighGapInsect2);

			Hobject rgnHighGapOpn,rgnHighGapDil,rgnGapNew,rgnHighGapCon2,rgnHighGapDif;
			HTuple  iNumber;

			opening_circle(rgnHighGapInsect2, &rgnHighGapOpn, 3.5);  
			connection(rgnHighGapOpn,&rgnHighGapCon2);
			count_obj(rgnHighGapCon2,&iNumber);
			if (0 != (iNumber!=2))
			{
				Hobject newRgn;
				m_vRgn[rId] = newRgn;
				return S_FALSE;
			}

			if (iForkEdgeSize < 0)
			{
				erosion_circle(rgnHighGapCon2, &rgnHighGapDil, abs(iForkEdgeSize));
			}
			else if ( iForkEdgeSize == 0)
			{
				dilation_circle(rgnHighGapCon2, &rgnHighGapDil, 0.5);
			}
			else
			{
				dilation_circle(rgnHighGapCon2, &rgnHighGapDil, iForkEdgeSize);  // // iForkEdgeSize
			}

			difference(rgnGapSerchInsect, rgnHighGapDil, &rgnHighGapDif);
			opening_circle(rgnHighGapDif, &rgnGapNew, 3.5);
			connection(rgnGapNew,&rgnGapNew);
			select_shape_std(rgnGapNew, &rgnGap, "max_area", 70);
			intersection(rgnGap, m_crtImg, &rgnGap);

			// 整体缩放
			erosion_circle(rgnGap, &rgnGap, fErosionSize);
			opening_circle(rgnGap, &rgnGap, 3);
			union1(rgnGap,&rgnGap);

			//叉口边沿区域公共变量

			m_XYTransLowRegs=rgnHighLightDil;
			m_CenterNewX=CenterNewX;
			m_CenterNewY=CenterNewY;
			//m_TopLowRegs=TopLowRegs;

			intersection(rgnGap, ImageDomain, &rgnGap);
			m_vRgn[rId] = rgnGap ;	
		}
		else if(iSelection==4)  //内壁区域
		{
			Hobject rgnHighLigtDil1,rgnGapDil,rgnHighLigtDif,rgnSearchInWall,rgnConInWall,rgnHighLightEro;
			Hobject rgnSelInWall,rgnSel2InWall,rgnOriInWall,rgnCir1InWall,rgnCir2InWall,rgnCirDifInWall,rgnInWall;
			HTuple  iNum;

			dilation_circle(m_rgnHighLight, &rgnHighLigtDil1, 55);
			dilation_circle(m_rgnGap, &rgnGapDil, 42);

			erosion_circle(m_rgnHighLight, &rgnHighLightEro, 15.5);

			difference(rgnHighLigtDil1, rgnHighLightEro, &rgnHighLigtDif);
			difference(rgnHighLigtDif, rgnGapDil, &rgnSearchInWall);

			connection(rgnSearchInWall, &rgnConInWall);
			select_shape(rgnConInWall, &rgnSelInWall, "area", "and", 150, 99999);

			count_obj(rgnSelInWall, &iNum);
			if (0 != (iNum!=2))
			{
				Hobject newRgn;
				m_vRgn[rId] = newRgn;
				return S_FALSE;
			}
			select_shape_std(rgnSelInWall, &rgnSel2InWall, "max_area", 70);

			difference(rgnConInWall, rgnSel2InWall, &rgnOriInWall);


			if (fOutEdgeSize<=(abs(fInnerEdgeSize)+1.5))
			{
				fOutEdgeSize=abs(fInnerEdgeSize)+20;
			}

			gen_circle(&rgnCir1InWall, m_InnerCircleRow, m_InnerCircleCol, fInnerEdgeSize);  // 80
			gen_circle(&rgnCir2InWall, m_InnerCircleRow, m_InnerCircleCol, fOutEdgeSize);          //  115
			difference(rgnCir2InWall, rgnCir1InWall, &rgnCirDifInWall);

			intersection(rgnOriInWall, rgnCirDifInWall, &rgnOriInWall);

			//**两端缩放
			Hobject rgnGapDilTemp,rgnOriDifInWall,rgnOriConInWall  ;
			dilation_circle(m_rgnGap, &rgnGapDilTemp, iForkEdgeSize+30);
			difference(rgnOriInWall, rgnGapDilTemp, &rgnOriDifInWall);
			connection(rgnOriDifInWall, &rgnOriConInWall);
			select_shape_std(rgnOriConInWall, &rgnInWall, "max_area", 70);

			// 整体缩放
			erosion_circle(rgnInWall, &rgnInWall, fErosionSize);

			opening_circle(rgnInWall, &rgnInWall, 3.5);
			union1(rgnInWall, &rgnInWall);

			intersection(rgnInWall, ImageDomain, &rgnInWall);
			m_vRgn[rId] = rgnInWall ;	
		}

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6140$\
					 167;B$\
					 1118;LP;1;4;1;1$\
					 1075;LP;100;300;1;200$\
					 1076;FP;1;250;0.5;82$\
					 1077;LP;1;20000;1;10000$\
					 1082;FP;1;20;0.5;3.5$\
					 1177;LP;-10;200;1;1$\
					 1178;FP;-100;180;1;40$\
					 1179;FP;1;200;1;25");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************************************
** 函数名：G20_TopSideLowRegionLocationAlgo
** 功  能：叉口整体区域定位（针对一种单叉胶塞对其叉口整体区域进行定位）
******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopSideLowRegionLocationAlgo(VARIANT* rgnId,VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT* pDilationSize)
{
	int rId = (int)rgnId->fltVal;

	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;
	float DilationSize = (float)pDilationSize->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_CenterNewX.Num()!=1||m_CenterNewY.Num()!=1||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 ||m_InnerCircleRadius.Num()!=1|| m_XYTransLowRegs.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject Circle8,Circle7;
		gen_circle(&Circle8, m_CenterNewY, m_CenterNewX, m_InnerCircleRadius);
		erosion_circle(Circle8,&Circle8,OutEdge);
		gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5);

		Hobject CircleDiff,TopLowRegsDiff,TopLowRegDilation,ImageDomain;
		difference(Circle8, Circle7, &CircleDiff);
		//叉口边缘缩放
		erosion_circle(m_XYTransLowRegs,&TopLowRegDilation,DilationSize);
		difference(CircleDiff, TopLowRegDilation, &TopLowRegsDiff);

		connection(TopLowRegsDiff,&TopLowRegsDiff);
		select_shape_std(TopLowRegsDiff, &TopLowRegsDiff, "max_area", 70);
		opening_circle(TopLowRegsDiff,&TopLowRegsDiff,18);

		//Hobject TopLowRegDilation,TopLowRegsDiff1;
		//dilation_circle(m_TopLowRegs,&TopLowRegDilation,DilationSize);
		//difference(TopLowRegsDiff, TopLowRegDilation, &TopLowRegsDiff1);
		//union1(TopLowRegsDiff,&TopLowRegsDiff);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(TopLowRegsDiff, ImageDomain, &TopLowRegsDiff);
		m_vRgn[rId] = TopLowRegsDiff;
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopSideLowRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1226$\
					 167;B$\
					 1224;FP;-100;180;1;40$\
					 1225;FP;1;200;1;25$\
					 1223;FP;1;100;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************************************************
**函数名：G20_TopForkEdgeRegionLocationAlgo
**功  能：针对单叉胶塞计算其叉口边缘拐角区域
**时  间：2019年9月12日
****************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_TopForkEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT* pDilationSize,VARIANT* pRelativeWidth,VARIANT* pRelativeLength)
{
	int rId = (int)rgnId->fltVal;

	float RelativeWidth = (float)pRelativeWidth->fltVal;
	float RelativeLength = (float)pRelativeLength->fltVal;

	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;
	float DilationSize = (float)pDilationSize->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_CenterNewX.Num()!=1||m_CenterNewY.Num()!=1||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 ||m_InnerCircleRadius.Num()!=1|| m_XYTransLowRegs.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}

		Hobject Circle8,Circle7;
		gen_circle(&Circle8, m_CenterNewY, m_CenterNewX, m_InnerCircleRadius);
		erosion_circle(Circle8,&Circle8,OutEdge);
		gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5);

		Hobject CircleDiff,TopLowRegsDiff,TopLowRegDilation,ImageDomain;
		difference(Circle8, Circle7, &CircleDiff);
		//叉口边缘缩放1
		erosion_circle(m_XYTransLowRegs,&TopLowRegDilation,DilationSize);
		difference(CircleDiff, TopLowRegDilation, &TopLowRegsDiff);

		connection(TopLowRegsDiff,&TopLowRegsDiff);
		select_shape_std(TopLowRegsDiff, &TopLowRegsDiff, "max_area", 70);
		opening_circle(TopLowRegsDiff,&TopLowRegsDiff,18);

		// 叉口边缘缩放2
		Hobject TopLowRegDilation2,TopLowRegsDiff2;
		erosion_circle(m_XYTransLowRegs,&TopLowRegDilation2,DilationSize + RelativeWidth);
		difference(CircleDiff, TopLowRegDilation2, &TopLowRegsDiff2);
		connection(TopLowRegsDiff2,&TopLowRegsDiff2);
		select_shape_std(TopLowRegsDiff2, &TopLowRegsDiff2, "max_area", 70);
		opening_circle(TopLowRegsDiff2,&TopLowRegsDiff2,18);
		Hobject rgnLowRegs;
		rgnLowRegs = TopLowRegsDiff2;

	    // 差
		difference(TopLowRegsDiff2,TopLowRegsDiff,&TopLowRegsDiff);

		// RelativeLength
		Hobject Circle1,Circle2,rgnCircleDiff;
		gen_circle(&Circle1, m_CenterNewY, m_CenterNewX, m_InnerCircleRadius-OutEdge - RelativeLength+15);
		gen_circle(&Circle2, m_InnerCircleRow, m_InnerCircleCol, abs(InnerEdge)+1.5 +RelativeLength );
		difference(Circle1, Circle2, &rgnCircleDiff);
		intersection(TopLowRegsDiff, rgnCircleDiff, &TopLowRegsDiff); 
        intersection(TopLowRegsDiff, rgnLowRegs, &TopLowRegsDiff);

		opening_circle(TopLowRegsDiff,&TopLowRegsDiff,3.5 );

		m_vRgn[rId] = TopLowRegsDiff;
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_TopForkEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6136$\
					 167;B$\
					 1224;FP;-100;180;1;100$\
					 1225;FP;1;200;1;5$\
					 1223;FP;1;100;1;10$\
					 6132;FP;1;100;0.5;10$\
					 6133;FP;1;100;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pGrayThred,VARIANT* pClosingSize,VARIANT* pRadiusDiff,VARIANT* pErosionSize)
{
	//得到环形区域
	int id = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;
	double GrayThred =(double)pGrayThred->fltVal;
	float ClosingSize =(float)pClosingSize->fltVal;
	int RadiusDiff =(int)pRadiusDiff->fltVal;

	float ErosionSize =(float)pErosionSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if((fCenterX<2.0)||(fCenterY<2.0)||m_OutCircleRow.Num()!=1||m_OutCircleCol.Num()!=1||m_InnerCircleRadius.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}

		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		//scale_image_max(Image, &ImageScaleMax);

		Hobject SearchRgn;
		gen_circle(&SearchRgn, m_OutCircleRow, m_OutCircleCol, m_InnerCircleRadius+RadiusDiff+35);
		reduce_domain(Image, SearchRgn, &ImageReduced);
		HTuple Mean, Deviation;
		intensity(SearchRgn, ImageReduced, &Mean, &Deviation);

		if(Mean[0].D()-GrayThred<=1)
		{
			GrayThred=Mean[0].D()-5;
		}

		Hobject Regions1,RegionFillUp1,ConnectedRegions,SelectedRegions;
		threshold(ImageReduced, &Regions1, 0, Mean-GrayThred);
		fill_up(Regions1, &RegionFillUp1);
		connection(RegionFillUp1, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);

		//叉口边缘没有提取出来
		Hobject RegionTrans,RegionClosing1;
		HTuple Row1, Column1, Radius1;
		shape_trans(SelectedRegions, &RegionTrans, "inner_circle");
		smallest_circle(RegionTrans, &Row1, &Column1, &Radius1);

		HTuple Diff;
		Diff = Radius1-m_InnerCircleRadius;
		if (0 != (Diff<RadiusDiff))
		{
			Hobject RegionErosion,RegionDifference,RegionUnion,RegionOpening1,RegionTrans1;
			if (Diff>10)
			{
				opening_circle(SelectedRegions, &RegionOpening1, 20);
				shape_trans(RegionOpening1, &RegionTrans1, "outer_circle");
			}
			else
			{
				shape_trans(SelectedRegions, &RegionTrans1, "outer_circle");
			}

			erosion_circle(RegionTrans1, &RegionErosion, 5);
			difference(RegionErosion, SelectedRegions, &RegionDifference);
			union2(RegionDifference, SelectedRegions, &RegionUnion);
			//*根据实际情况调整
			closing_circle(RegionUnion, &RegionClosing1, 250);
		}
		else
		{
			closing_circle(SelectedRegions, &RegionClosing1, 250);
		}

		//
		Hobject RegionOpening,RegionDilation;
		opening_circle(RegionClosing1, &RegionOpening, ClosingSize);
		dilation_circle(RegionOpening, &RegionDilation, ErosionSize);

		Hobject RegionDetect,OutCircle,ImageDomain;
		gen_circle(&OutCircle, m_OutCircleRow, m_OutCircleCol, Radius);
		difference(OutCircle, RegionDilation, &RegionDetect);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionDetect, ImageDomain, &RegionDetect);
		m_vRgn[id] = RegionDetect ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1129$\
					 167;B$\
					 1130;FP;80.0;350.0;0.5;190$\
					 1131;FP;1.0;200.0;0.5;15$\
					 1132;FP;20;200.0;0.5;80$\
					 1134;LP;30;200;1;70$\
					 1133;FP;1;20;0.5;3.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************************************
****函 数 名：TopSealingFaceRegionLocationAlgo1（通用算子）
****功    能：从密封面内边缘算子中获得密封面的内边缘，该算子的搜索区域为包括密封面拐角的环形区域（内边缘拟合圆）
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;

	float ErosionSize =(float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_OutCircle.Id()==H_EMPTY_REGION||m_OutCircleRow.Num()!=1||m_OutCircleCol.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//m_OutCircle
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject OutCircle,InnerCircle,RegionDiff,ImageDomain;
		gen_circle(&OutCircle,  m_OutCircleRow, m_OutCircleCol, Radius);

		dilation_circle(m_OutCircle,&InnerCircle,ErosionSize);
		difference(OutCircle, InnerCircle, &RegionDiff);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionDiff, ImageDomain, &RegionDiff);
		m_vRgn[id] = RegionDiff ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1129$\
					 167;B$\
					 1130;FP;80.0;350.0;0.5;200$\
					 1133;FP;1;20;0.5;3.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/******************************************************************************************************************
****函 数 名：TopSealingFaceRegionLocationAlgo2（通用算子）
****功    能：从密封面内边缘算子中获得密封面的内边缘，该算子的搜索区域为包括密封面拐角的环形区域（内边缘没有拟合圆）
****修改说明：修改内容(一)：解决内边缘提取不到位问题
****         (1)增大了Closing_Rectangle1 的尺寸
****         (2)减小 mean_image 的尺寸
****         (3)增减 gen_region_contour_xld 函数
****          时    间：2018年08月13日
****修 改 人：吴贻峰
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pThresh,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;
	float RoiWidth = (float)pRoiWidth->fltVal;
	float Thresh =(float)pThresh->fltVal;
	float ErosionSize =(float)pErosionSize->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if ((fCenterX<1.0)||(fCenterY<1.0)||m_OutCircleRow.Num()!=1||m_OutCircleCol.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	if (Radius<15)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject OutCircle,InnerCircle,RegionDiff,rgn;
		gen_circle(&OutCircle, m_OutCircleRow, m_OutCircleCol, Radius);
		//
		Hobject ImageReduced;
		Hobject Image=m_crtImg;
		Hlong Width, Height;
		get_image_size(Image, &Width, &Height);
		HTuple RadiusExt,RadiusInner,AngleS,WithPolar,HeightPolar;

		RadiusExt =(int) Radius;
		if (Radius-RoiWidth>3)
		{
			RadiusInner = RadiusExt-RoiWidth;
		}
		else
		{
			RadiusInner =2;
		}
		AngleS = 3.1416*2.3;
		WithPolar = (((RadiusExt+RadiusInner)*AngleS)/2.0).Round();
		HeightPolar = ((RadiusExt-RadiusInner).Abs()).Round();

		Hobject PolarTransImage1;
		polar_trans_image_ext(Image, &PolarTransImage1,  fCenterY, fCenterX, 0, AngleS, RadiusInner, RadiusExt, WithPolar, HeightPolar, "nearest_neighbor");

		Hobject ImageMean1,RegionDynThresh,RegionOpening1,RegionClosing2,ConnectedRegions2,SelectedRegions2;
		mean_image(PolarTransImage1, &ImageMean1, 3, 91);
		//mean_image(PolarTransImage1, &ImageMean1, 3, 31);
		dyn_threshold(PolarTransImage1, ImageMean1, &RegionDynThresh, Thresh, "dark");
		Hobject RegionClosing3;
		closing_rectangle1 (RegionDynThresh, &RegionClosing3, 15, 5);
		opening_rectangle1(RegionClosing3, &RegionOpening1, 5, 3);
		closing_rectangle1(RegionOpening1, &RegionClosing2, 201, 1);
		//closing_rectangle1(RegionOpening1, &RegionClosing2, 21, 1);
		connection(RegionClosing2, &ConnectedRegions2);
		select_shape_std(ConnectedRegions2, &SelectedRegions2, "max_area", 70);

		Hobject RegionUnion1;//,RegionBorder
		union1(SelectedRegions2, &RegionUnion1);
		//boundary(RegionUnion1, &RegionBorder, "outer");
		Hobject XYTransRegion,RegionDilation1,Contours,ImageDomain;
		polar_trans_region_inv(RegionUnion1, &XYTransRegion,  fCenterY, fCenterX, 0, AngleS, RadiusInner, RadiusExt, WithPolar, HeightPolar, Width, Height, "nearest_neighbor");
		HTuple area1,Row1,col1;
		area_center(XYTransRegion,&area1,&Row1,&col1);
		if (area1==0)
		{
			m_InnerCircleRow=m_imgHeight/2.0;
			m_InnerCircleCol=m_imgWidth/2.0;

			Hobject InnerCircle,ShowErrorReg;
			gen_circle(&InnerCircle, fCenterY, fCenterX, RadiusInner);
			difference(OutCircle,InnerCircle,&ShowErrorReg);
			m_vRgn[id] = ShowErrorReg ;
			return S_FALSE;
		}
		//二次定位，获取中心点坐标
		dilation_circle(XYTransRegion, &RegionDilation1, 3.5);
		gen_contour_region_xld(RegionDilation1, &Contours, "border");
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius,StartPhi, EndPhi, PointOrder;
		fit_circle_contour_xld(Contours, "algebraic", -1, 0, 0, 3, 2, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius, &StartPhi, &EndPhi, &PointOrder);
		Hobject Circle1;
		gen_circle(&Circle1, InnerCircleRow, InnerCircleCol, InnerCircleRadius);
		m_vPos[0].m_x = (float)InnerCircleCol[0].D();
		m_vPos[0].m_y = (float)InnerCircleRow[0].D();
		m_InnerCircleRow=InnerCircleRow;
		m_InnerCircleCol=InnerCircleCol;
		//
		m_InnerCircleRadius=InnerCircleRadius;
		m_OutCircle=Circle1;   //用于顶部斜坡面外边缘 G20_TopRegionLocationAlgo

		//
		fill_up(RegionDilation1,&m_InnerEdge);
		Hobject InnerRegion,RegionOpening4;
		erosion_circle (m_InnerEdge, &InnerRegion, 3.5);
		opening_circle (InnerRegion,& m_InnerEdge, RadiusInner);
		//
		Hobject region;
		gen_region_contour_xld(Contours,&region,"filled");

		dilation_circle(region,&InnerCircle,ErosionSize);
		difference(OutCircle, InnerCircle, &RegionDiff);      // InnerCircle

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionDiff, ImageDomain, &RegionDiff);

		m_vRgn[id] = RegionDiff ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1129$\
					 167;B$\
					 1130;FP;80.0;350.0;0.5;200$\
					 413;FP;1.5;200;0.5;108$\
					 1175;FP;1;100;0.5;12$\
					 1133;FP;1;20;0.5;3.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************************************
****函 数 名：TopSealingFaceRegionLocationAlgo3
****功    能：通过提取顶部高亮区域，使用高亮区域求取最小外接圆（当密封面的内边缘对比度较低，不易提取的时候）
****注    意：该算子使用在高亮区域提取之后！
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo3(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;

	float ErosionSize =(float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_OutCircleRow.Num()!=1||m_OutCircleCol.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//m_OutCircle  m_TopRegsDilationXY
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject OutCircle,InnerCircle,RegionDiff,ImageDomain;
		gen_circle(&OutCircle,  m_OutCircleRow, m_OutCircleCol, Radius);

		Hobject rgnTopUnion,rgnTopTrans;
		union1(m_TopRegsDilationXY,&rgnTopUnion);
		shape_trans(rgnTopUnion,&rgnTopTrans,"outer_circle");

		dilation_circle(rgnTopTrans,&InnerCircle,ErosionSize);
		difference(OutCircle, InnerCircle, &RegionDiff);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionDiff, ImageDomain, &RegionDiff);
		m_vRgn[id] = RegionDiff ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopSealingFaceRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1129$\
					 167;B$\
					 1130;FP;80.0;350.0;0.5;200$\
					 1133;FP;1;50;0.5;3.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::ScrapDiameterMeasureAlgo(VARIANT* rgnId, VARIANT* pSigma,VARIANT* pThredLower, VARIANT* pThredUpper,VARIANT* pCircularityValue,VARIANT* pDiameter)
{
	int rId           = (int)rgnId->fltVal;
	//float Offset   = (float)pOffset->fltVal;
	float Sigma   = (float)pSigma->fltVal;
	int ThredLower   = (int)pThredLower->fltVal;
	int ThredUpper = (int)pThredUpper->fltVal;
	if(ThredUpper<=ThredLower)
	{
		ThredUpper=ThredLower+3;
	}
	float CircularityValue = (float)pCircularityValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDiameter);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ImageReduced,ImageGauss,ExpandedImage,ImageGaussReduced,Edges;

		reduce_domain(crtImg, rgn, &ImageReduced);
		gauss_filter(ImageReduced, &ImageGauss, 5);
		expand_domain_gray(ImageGauss, &ExpandedImage, 2);
		reduce_domain(ExpandedImage, rgn, &ImageGaussReduced);
		edges_sub_pix(ImageGaussReduced, &Edges, "canny", Sigma, ThredLower, ThredUpper);
		Hobject UnionAdjacentContour,UnionCoCircleContour;
		union_adjacent_contours_xld(Edges, &UnionAdjacentContour, 10, 1, "attr_keep");
		union_cocircular_contours_xld(UnionAdjacentContour, &UnionCoCircleContour, 0.5, 0.1, 0.2, 30, 10, 10, "true", 1);
		HTuple Number;
		Hobject SelectedXLD,ObjectSelected;
		count_obj(UnionCoCircleContour, &Number);
		if (Number[0].I()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDiameter);
			return S_FALSE;
		}
		HTuple Circularity;
		gen_empty_obj(&SelectedXLD);
		for (int i=1;i<=Number[0].I();i++)
		{
			select_obj(UnionCoCircleContour, &ObjectSelected, i);
			circularity_xld(ObjectSelected, &Circularity);
			if (0 != (Circularity<CircularityValue))
			{
				continue;
			}
			else
			{
				concat_obj(SelectedXLD, ObjectSelected, &SelectedXLD);
			}
		}
		HTuple Length,Ln,Num;
		count_obj(SelectedXLD,&Num);
		if (Num[0].I()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDiameter);
			return S_FALSE;
		}
		length_xld(SelectedXLD,&Length);
		tuple_sort_index(Length,&Ln);
		Hobject OutXld;
		select_obj(SelectedXLD,&OutXld,(Ln.Select(Num-1))+1);
		Hobject SmoothedXld;
		smooth_contours_xld(OutXld, &SmoothedXld, 5);

		//
		Hobject Region;
		gen_region_contour_xld(SmoothedXld, &Region, "margin");

		HTuple Row, Column, Radius, StartPhi, EndPhi, PointOrder;
		Hobject Circle;
		fit_circle_contour_xld(SmoothedXld, "algebraic", -1, 0, 0, 3, 2, &Row, &Column, &Radius, &StartPhi, &EndPhi, &PointOrder);
		gen_circle(&Circle, Row, Column, Radius);

		HTuple Diameter;
		Diameter = Radius*2;
		if (Diameter.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId]=Region;
			retValue.Detach(pDiameter);
			return S_FALSE;

		}

		retValue = Diameter[0].D();
		m_vErrorRgn[rId] = Circle;
		retValue.Detach(pDiameter);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDiameter);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDiameter);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::ScrapDiameterMeasureAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1139$\
					 397;R;FP;0;2000;1$\
					 381;B$\
					 680;FP;0.1;10.0;0.1;1.0$\
					 762;LP;1;200;1;20$\
					 763;LP;1;254;1;40$\
					 633;FP;0.1;1;0.1;0.7");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::WarpedMembraneDetectAlgo(VARIANT* rgnId, VARIANT* pSensitivity,VARIANT* pDetectArea)
{
	int rId           = (int)rgnId->fltVal;
	int Sensitivity = (int)pSensitivity->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	HTuple Area1, Row1, Column1;
	area_center(m_FMpoints, &Area1, &Row1, &Column1);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||Area1==0||m_ABEdgeM.Id() == H_EMPTY_REGION||m_FMrows.Num()<3)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject ABRegMoved;
		HTuple Area2, Row2, Column2;
		//area_center(m_FMpoints, &Area1, &Row1, &Column1);
		area_center(m_ABEdgeM, &Area2, &Row2, &Column2);

		//if (Area1==0||Area2==0)
		if (Area2==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		} 

		move_region(m_ABEdgeM, &ABRegMoved, -(Row2-Row1), 0);
		Hobject ABRegPartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(ABRegMoved, &ABRegPartitioned, 1, 100);
		area_center(ABRegPartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum=m_FMrows.Num();

		HTuple Rows,Cols,RowDiffs,a,Indice,RowDiff;
		Rows = HTuple();
		Cols = HTuple();
		RowDiffs = HTuple();
		a = 0;
		for (int i=0;i<=PointsNum-1; i++)
		{
			tuple_find(ColsRound, m_FMcols.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}

			RowDiff = ((m_FMrows.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff>Sensitivity))
			{
				Rows = (m_FMrows.Select(i)).Concat(Rows);
				Cols = (m_FMcols.Select(i)).Concat(Cols);
				a += 1;
			}
		}
		//
		if(a <=0||m_CutOff==0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			Hobject ErrorReg,DefectRegs;
			retValue = a[0].I();
			gen_region_points(&ErrorReg, Rows, Cols);
			dilation_circle (ErrorReg, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WarpedMembraneDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1184$\
					 397;R;FP;0;2000;1$\
					 381;B$\
					 1185;FP;1;36;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/************************************************************************
**函数名：WarpedMembraneDetectAlgo1
**功  能：计算覆膜上下边缘之间的距离，判断是否存在双眼皮缺陷
**时  间：2019年7月15日
*************************************************************************/
STDMETHODIMP CPlugAlgo::WarpedMembraneDetectAlgo1(VARIANT* rgnId, VARIANT* pNumPart,VARIANT* pSensitivity,VARIANT* pGrayLowThred,VARIANT* pDetectArea)
{
	int rId           = (int)rgnId->fltVal;
	int NumPart       = (int)pNumPart->fltVal;
	int Sensitivity   = (int)pSensitivity->fltVal;
	int GrayLowThred  = (int)pGrayLowThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	HTuple Area1, Row1, Column1;
	area_center(m_FMpoints, &Area1, &Row1, &Column1);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||Area1==0||m_DownEdgeReg.Id() == H_EMPTY_REGION||m_DownEdgeReg2.Id() == H_EMPTY_REGION)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		
		Hobject Image = m_crtImg;

		// 覆膜上下边缘
		HTuple dRowSUp,dColSUp,dRowSDown,dColSDown,dRowSDownInv,dColSDownInv;
		Hobject xldDownEdge,xld2DownEdge,rgnSknDownEdge,rgnSknDownEdge2 ;

		skeleton(m_DownEdgeReg,&rgnSknDownEdge);
		skeleton(m_DownEdgeReg2,&rgnSknDownEdge2);

		HTuple dRowSUpOri,dColSUpOri,dRowSDownOri,dColSDownOri;
		gen_contour_region_xld(rgnSknDownEdge,&xldDownEdge,"border");
		gen_contour_region_xld(rgnSknDownEdge2,&xld2DownEdge,"border");
		get_contour_xld(xldDownEdge,&dRowSUpOri,&dColSUpOri);
		get_contour_xld(xld2DownEdge,&dRowSDownOri,&dColSDownOri);

		HTuple dColSUpSort,dColIndexS,dRowSUpSel ;
		tuple_sort(dColSUpOri,&dColSUpSort);
		tuple_sort_index(dColSUpOri,&dColIndexS);
		tuple_select(dRowSUpOri,dColIndexS,&dRowSUpSel);

		HTuple dColSDownSort,dColIndexS1,dRowSDownSel ;
		tuple_sort(dColSDownOri,&dColSDownSort);
		tuple_sort_index(dColSDownOri,&dColIndexS1);
		tuple_select(dRowSDownOri,dColIndexS1,&dRowSDownSel);

		dRowSUp = dRowSUpSel;
		dColSUp = dColSUpSort;
		dRowSDown = dRowSDownSel;
		dColSDown = dColSDownSort;
		if( dRowSUp.Num() < 3 || ( dRowSDown.Num() < 3))
		{
			retValue = 0.0;
		    m_vErrorRgn[rId].Reset();
		    retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		tuple_inverse(dRowSDown, &dRowSDownInv);
		tuple_inverse(dColSDown, &dColSDownInv);

		HTuple dRowS,dColS;
		Hobject rgnFilmEdge;
		dRowS = HTuple();
		dColS = HTuple();

		dRowS = ((dRowS.Concat(dRowSUp)).Concat(dRowSDownInv)).Concat(dRowSUp.Select(0));
		dColS = ((dColS.Concat(dColSUp)).Concat(dColSDownInv)).Concat(dColSUp.Select(0));
		gen_region_polygon(&rgnFilmEdge,dRowS,dColS);
		fill_up(rgnFilmEdge,&rgnFilmEdge);

		HTuple dArea,dRow,dCol ;
		area_center(rgnFilmEdge, &dArea, &dRow, &dCol);
		if ( dArea <= 0)
		{
			retValue = 0.0;
		    m_vErrorRgn[rId].Reset();
		    retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		Hobject  rgnFilmEdgePart;
		HTuple   dRectRowS,dRectColS,dRectPhi,dRectLen1,dRectLen2,dRectRow,dRectCol,dRectP,dLen1,dLen2;
		smallest_rectangle2(rgnFilmEdge, &dRectRow,&dRectCol,&dRectP,&dLen1,&dLen2);
		partition_rectangle(rgnFilmEdge, &rgnFilmEdgePart, dLen1*2.0/NumPart, 100);
		smallest_rectangle2(rgnFilmEdgePart, &dRectRowS,&dRectColS,&dRectPhi,&dRectLen1,&dRectLen2);

		HTuple  Num,len;
		count_obj(rgnFilmEdgePart,&Num);
		tuple_length(dRectLen1,&len);

		//my_disp_obj(rgnFilmEdgePart);

		HTuple  dLessS,dIndiceS;
		Hobject  rgnRectSel;
		tuple_less_elem(dRectLen1*2,Sensitivity,&dLessS);
		tuple_find(dLessS,0,&dIndiceS );
		if ( dIndiceS == -1)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
			return S_OK;
		}
		select_obj(rgnFilmEdgePart,&rgnRectSel,dIndiceS+1);

		// 对每一块区域的灰度值进行判断 GrayLowThred
		// 20190820
		Hobject rgnRectSelCon,rgnSelFin;
		HTuple iNum;
		gen_empty_obj(&rgnSelFin );
		connection(rgnRectSel,&rgnRectSelCon );
		count_obj( rgnRectSelCon,&iNum);
		for ( int i = 1;i <= iNum;i++)
		{
			Hobject rgnSel  ;
			HTuple dMean,dDevi;
			select_obj(rgnRectSelCon,&rgnSel,i );
			intensity(rgnSel,Image, &dMean,&dDevi);
			if ( dMean >  GrayLowThred)
			{
				concat_obj(rgnSelFin,rgnSel,&rgnSelFin);
			}
		}

		Hobject rgnError ;
		HTuple dAreaError,dRowError,dColError;
		union1(rgnSelFin,&rgnError);
		area_center(rgnError,&dAreaError,&dRowError,&dColError);

		//m_vErrorRgn[rId] = rgnError;
	
		if(dAreaError <=0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = dAreaError[0].I();
			m_vErrorRgn[rId] = rgnError;
		}	

		//m_vRgn[rId]  =rgnError;
	
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WarpedMembraneDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6100$\
					 397;R;FP;0;2000;1$\
					 381;B$\
					 748;LP;1;500;1;30$\
					 1185;LP;1;250;1;15$\
					 842;LP;1;250;1;30");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternCoordAlgo(VARIANT* rgnId, VARIANT* pEllipseMoveSize,VARIANT* pEdgeMoveSize,VARIANT* pOpeningSize,VARIANT* pSearchSize,VARIANT* pGrayValue, VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int EllipseMoveSize    = (int)pEllipseMoveSize->fltVal;
	int OpeningSize    = (int)pOpeningSize->fltVal;

	int EdgeMoveSize    = (int)pEdgeMoveSize->fltVal;

	int SearchSize    =(int)pSearchSize->fltVal;
	float GrayValue    =(float)pGrayValue->fltVal;

	//float WidthRadiusSet    =(float)pWidthRadiusSet->fltVal;
	//int AngleT1    =(int)pAngleT1->fltVal;
	//int AngleT2    =(int)pAngleT2->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_WholeRoi.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个囊括整个颈部的矩形区域
		Hobject crtImg = m_crtImg;
		Hobject crtImgReduced;
		reduce_domain(crtImg, rgn, &crtImgReduced);

		//基准椭圆
		Hobject RegionMoved4,Rectangle,RegionIntersection;
		HTuple Area1, Row1, Column1;
		move_region(m_ABEllipse, &RegionMoved4, -EllipseMoveSize, 0);
		area_center(RegionMoved4, &Area1, &Row1, &Column1);
		gen_rectangle1(&Rectangle, Row1-70, 10, Row1+120, m_imgWidth-10);
		intersection(Rectangle, m_WholeRoi, &RegionIntersection);

		Hobject RegionOpening,Rectangle1;
		HTuple Row11, Column11, Row2, Column2;
		opening_rectangle1(RegionIntersection, &RegionOpening, 3, 31);
		smallest_rectangle1(RegionOpening, &Row11, &Column11, &Row2, &Column2);
		gen_rectangle1(&Rectangle1, Row11, Column11, Row2, Column2);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
		}
		//基准线
		Hobject RegionMoved,RegionDilation1,ImageReduced;
		move_region(m_ABEdgeM, &RegionMoved, -EdgeMoveSize, 0);
		dilation_rectangle1(RegionMoved, &RegionDilation1, 3, SearchSize);
		reduce_domain(crtImgReduced, RegionDilation1, &ImageReduced);

		Hobject Region1,RegionDilation2,RegionOpening2;
		HTuple Row12, Column12, Row21, Column21;
		threshold(ImageReduced, &Region1, GrayValue, 255);
		dilation_rectangle1(Region1, &RegionDilation2, 3, 7);
		opening_rectangle1(RegionDilation2, &RegionOpening2, 3, 21);
		Hobject ConnectedRegions2,SelectedRegions1;
		connection(RegionOpening2, &ConnectedRegions2);
		select_shape_std(ConnectedRegions2, &SelectedRegions1, "max_area", 70);
		smallest_rectangle1(SelectedRegions1, &Row12, &Column12, &Row21, &Column21);
		//空区域也有数值
		Hobject Rectangle2;
		gen_empty_region(&Rectangle2);
		HTuple area,row,col;
		area_center(SelectedRegions1,&area,&row,&col);
		if (area!=0 ||area.Num()!=0)
		{
			gen_rectangle1(&Rectangle2, Row12, Column12, Row21, Column21);
		}

		HTuple Rect1CenterCol,Rect2CenterCol;
		Rect1CenterCol = (Column11+Column2)/2.0;
		Rect2CenterCol = (Column12+Column21)/2.0;

		HTuple WidthRadiusSet;
		WidthRadiusSet = 164.5;
		//开口角度 89.5,边缘到凸点角度18.4  边缘到凸点右侧、左侧角度68.
		HTuple GapAngle,EdgePointAngleDiff1,EdgePointAngleDiff2;
		GapAngle = 90.5;
		EdgePointAngleDiff1 = 18.5;
		EdgePointAngleDiff2 = 68.5;

		HTuple ColCenterSet,WidthEdgeDist,EdgeAngle,EdgeAngle360,EdgeAngleT1,EdgeAngleT2,ColT1,ColT2;
		if (0 != ((Column21-Column12)>25))
		{
			//调试显示
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], SelectedRegions1, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], Rectangle2, &m_vRgn[rId]);
			}

			if (0 != (Rect1CenterCol>=Rect2CenterCol))
			{
				ColCenterSet = Column2-WidthRadiusSet;
				WidthEdgeDist = Column21-ColCenterSet;
				if (WidthEdgeDist.Abs()>WidthRadiusSet)
				{
					m_ColT1=m_imgWidth/2.0;
					m_ColT2=m_imgWidth/2.0;
					//
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pStripeArea);
					return S_FALSE;
				}
				EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
				EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
				EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;
				EdgeAngleT2 = EdgeAngle360+EdgePointAngleDiff2;
				if (0 != (EdgeAngleT1>90.0))
				{
					EdgeAngleT1 = 90.0;
				}
				if (0 != (EdgeAngleT2>90.0))
				{
					EdgeAngleT2 = 90.0;
				}
				if (0 != (EdgeAngleT1<-90.0))
				{
					EdgeAngleT1 = -90.0;
				}
				if (0 != (EdgeAngleT2<-90.0))
				{
					EdgeAngleT2 = -90.0;
				}
				ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
				ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
			}
			else if (0 != (Rect1CenterCol<Rect2CenterCol))
			{
				ColCenterSet = Column11+WidthRadiusSet;
				WidthEdgeDist = Column12-ColCenterSet;
				if (WidthEdgeDist.Abs()>WidthRadiusSet)
				{
					m_ColT1=m_imgWidth/2.0;
					m_ColT2=m_imgWidth/2.0;
					//
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pStripeArea);
					return S_FALSE;
				}
				EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
				EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
				EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;
				EdgeAngleT2 = EdgeAngle360-EdgePointAngleDiff2;
				if (0 != (EdgeAngleT1>90.0))
				{
					EdgeAngleT1 = 90.0;
				}
				if (0 != (EdgeAngleT2>90.0))
				{
					EdgeAngleT2 = 90.0;
				}
				if (0 != (EdgeAngleT1<-90.0))
				{
					EdgeAngleT1 = -90.0;
				}
				if (0 != (EdgeAngleT2<-90.0))
				{
					EdgeAngleT2 = -90.0;
				}
				ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
				ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
			}
		}
		else
		{
			Hobject RegionDifference,RegionOpening3,ConnectedRegions1,SelectedRegions,RegionOpening2;
			HTuple Row13, Column12, Row22, Column21,ColDiff;
			difference(RegionMoved4, m_WholeRoi, &RegionDifference);
			opening_rectangle1(RegionDifference, &RegionOpening3, 3, OpeningSize);
			connection(RegionOpening3, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions, "width", "and", 60, 99999);
			select_shape_std(SelectedRegions, &RegionOpening2, "max_area", 70);

			smallest_rectangle1(RegionOpening2, &Row13, &Column12, &Row22, &Column21);
			area_center(RegionOpening2,&area,&row,&col);
			if (area!=0 && area.Num()!=0)
			{
				gen_rectangle1(&Rectangle2, Row13, Column12, Row22, Column21);

			}

			Rect2CenterCol = (Column12+Column21)/2.0;
			ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
			//*area
			HTuple Area3, Row4, Column6,offset;
			area_center(RegionOpening2, &Area3, &Row4, &Column6);

			//调试显示
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], RegionOpening2, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], Rectangle2, &m_vRgn[rId]);
			}
			if (0 != (Area3>2))
			{
				if (0 != (Rect1CenterCol>=Rect2CenterCol))
				{
					//413.5
					ColCenterSet = Column2-WidthRadiusSet;
					if (0 != (ColDiff<10.0))
					{
						offset = 30.0;
					}
					else if (0 != (ColDiff<20.0))
					{
						offset = 20.0;
					}
					else if (0 != (ColDiff<30.0))
					{
						offset = 10.0;
					}
					else
					{
						offset = 0.0;
					}
					WidthEdgeDist = (Column21-ColCenterSet)+offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					//右边缘
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156)-GapAngle;
					EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360-EdgePointAngleDiff2;

					if (0 != (EdgeAngleT1>-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -(180.0+EdgeAngleT1);
					}
					if (0 != (EdgeAngleT2<-90.0))
					{
						EdgeAngleT2 = -(180.0+EdgeAngleT2);
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
				}
				else if (0 != (Rect1CenterCol<Rect2CenterCol))
				{
					//413.5
					ColCenterSet = Column11+WidthRadiusSet;
					if (0 != (ColDiff<10.0))
					{
						offset = 30.0;
					}
					else if (0 != (ColDiff<20.0))
					{
						offset = 20.0;
					}
					else if (0 != (ColDiff<30.0))
					{
						offset = 10.0;
					}
					else
					{
						offset = 0.0;
					}
					WidthEdgeDist = (Column12-ColCenterSet)-offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156)+GapAngle;
					EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360+EdgePointAngleDiff2;

					if (0 != (EdgeAngleT1<90.0))
					{
						EdgeAngleT1 = 90.0;
					}
					if (0 != (EdgeAngleT2>90.0))
					{
						EdgeAngleT2 = 180.0-EdgeAngleT2;
					}
					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 180.0-EdgeAngleT1;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
				}

			}
			else
			{
				ColT1 = -1;
				//ColT2 = 500;
			}
		}
		//gen_region_line(&RegionLines1, 160, ColT1, 380, ColT1);
		//gen_region_line(&RegionLines2, 160, ColT2, 380, ColT2);

		Hobject ConPatternRect,RegionLines1,RegionLines2;
		if (ColT1==-1)
		{
			gen_empty_region(&ConPatternRect);
			m_ColT1=m_imgWidth/2.0;
			m_ColT2=m_imgWidth/2.0;
		} 
		else
		{
			gen_region_line(&RegionLines1, 160, ColT1, 380, ColT1);
			gen_region_line(&RegionLines2, 160, ColT2, 380, ColT2);
			union2(RegionLines1,RegionLines2,&ConPatternRect);
			union1(ConPatternRect,&ConPatternRect);

			m_ColT1=ColT1;
			m_ColT2=ColT2;
		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], ConPatternRect, &m_vRgn[rId]);
		}
		//
		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(ConPatternRect, &StripeRegArea, &StripeRegRow, &StripeRegColumn);
		if (StripeRegArea>=0)
		{
			retValue = ColT1[0].I();
			m_vErrorRgn[rId] = ConPatternRect;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternCoordAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1193$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1186;LP;0;250;1;190$\
					 1187;LP;1;150;1;30$\
					 1206;LP;1;100;1;21$\
					 998;LP;1;50;1;80$\
					 992;FP;1;250;0.5;60");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternSearchRegAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pHDilationSize, VARIANT* pSearchSize,VARIANT* pClipSizeD,VARIANT* pClipSizeU)
{
	int id = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HDilationSize   = (int)pHDilationSize->fltVal;
	int SearchSize =(int)pSearchSize->fltVal;

	int ClipSizeD   = (int)pClipSizeD->fltVal;
	int ClipSizeU   = (int)pClipSizeU->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_ABEdgeM.Id()==H_EMPTY_REGION||m_WholeRoi.Id()==H_EMPTY_REGION||m_TopRegion.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ColT1.Num()==0||m_ColT2.Num()==0)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		HTuple area,row,col;
		area_center(m_WholeRoi,&area,&row,&col);
		if (area==0 ||area.Num()==0)
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		HTuple LeftCol,RightCol;
		HTuple RoiRow1,RoiColumn1,RoiRow2,RoiColumn2;
		smallest_rectangle1(m_WholeRoi,&RoiRow1, &RoiColumn1, &RoiRow2, &RoiColumn2);

		if(m_ColT1>m_ColT2)
		{
			LeftCol=m_ColT2;
			RightCol=m_ColT1;
		}
		else if((m_ColT1<m_ColT2))
		{
			LeftCol=m_ColT1;
			RightCol=m_ColT2;
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		Hobject ConPatternRect;
		gen_rectangle1(&ConPatternRect, RoiRow1, LeftCol, RoiRow2, RightCol);

		Hobject ABStripeReg,ABStripeRegDilation,ABStripeRegIntersection,ConReg;
		move_region(m_ABEdgeM, &ABStripeReg, -MoveSize, 0);
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection (ABStripeRegDilation, ConPatternRect, &ABStripeRegIntersection);
		dilation_rectangle1(ABStripeRegIntersection, &ABStripeRegIntersection, HDilationSize, 1);

		//剔除中部边缘区域
		Hobject ABStripeRegDiff,MiddleEdgeDilation;
		dilation_rectangle1(m_MiddleEdge,&MiddleEdgeDilation,1,ClipSizeD);
		difference(ABStripeRegIntersection,MiddleEdgeDilation,&ABStripeRegDiff);

		//剔除顶部高亮区域 m_TopRegion  m_PlatformReg
		Hobject TopRegion,ABStripeRegDiff1;
		dilation_circle(m_TopRegion,&TopRegion,ClipSizeU);
		difference(ABStripeRegDiff,TopRegion,&ABStripeRegDiff1);
		difference(ABStripeRegDiff1,m_PlatformReg,&ABStripeRegDiff1);

		opening_circle(ABStripeRegDiff1, &ConReg, 8);
		intersection (ConReg, m_WholeRoi, &ConReg);

		Hobject ConRegConnected,ConRegSelected;
		connection(ConReg,&ConRegConnected);
		select_shape_std(ConRegConnected,&ConRegSelected,"max_area",70);
		//m_StripeReg=ConReg;
		m_vRgn[id] = ConRegSelected;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternSearchRegAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1216$\
					 167;B$\
					 1190;LP;50;350;1;135$\
					 994;LP;1;70;1;10$\
					 995;LP;10;100;1;40$\
					 1127;LP;1;60;1;30$\
					 1126;LP;1;60;1;5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize1, VARIANT* pHErosionSize2,VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize1   = (int)pHErosionSize1->fltVal;
	int HErosionSize2   = (int)pHErosionSize2->fltVal;

	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id()==H_EMPTY_REGION||m_StripeReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//花纹
		Hobject TriangleReg;
		union1(m_StripeReg,&TriangleReg);

		//缩放
		Hobject TriangleRegDilation,TriangleRegion;
		dilation_rectangle1(TriangleReg,&TriangleRegDilation,HErosionSize1,VErosionSize);

		Hobject RoiErosion;
		erosion_rectangle1(m_ROI,&RoiErosion,HErosionSize2,1);
		intersection(RoiErosion,TriangleRegDilation,&TriangleRegion);

		opening_circle(TriangleRegion,&TriangleRegion,3.5);
		m_vRgn[rId] = TriangleRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 1217;LP;1;35;1;1$\
					 1218;LP;1;60;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternDetectAlgo(VARIANT* rgnId,VARIANT* pAreaLimit,VARIANT* pGrayValue,VARIANT* pOpeningSize,VARIANT* pDilationSizeH,VARIANT* pDialtionSizeV,VARIANT* pErosionSizeH,VARIANT* pErosionSizeV,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int AreaLimit    = (int)pAreaLimit->fltVal;
	double GrayValue   = (double)pGrayValue->fltVal;
	double OpeningSize   = (double)pOpeningSize->fltVal;

	int DilationSizeH   = (int)pDilationSizeH->fltVal;
	int DilationSizeV   = (int)pDialtionSizeV->fltVal;

	int ErosionSizeH   = (int)pErosionSizeH->fltVal;
	int ErosionSizeV   = (int)pErosionSizeV->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ABEdgeM.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION||m_TopRegion.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//

		//矩形框中再进行花纹提取，只针对矩形框面积超过一定值的情况，如果矩形框处于边界时，不进行花纹提取
		HTuple ConArea,ConRow,ConCol;
		union1(rgn,&rgn);
		area_center(rgn,&ConArea,&ConRow,&ConCol);

		Hobject StripeRegOpening;
		if (ConArea>=AreaLimit)
		{
			Hobject ImageReduced3,ImageClosing,Regions1,RegionFillUp1,RegionClosing1,ConnectedRegions3,SelectedRegions2,ImageMedian;
			reduce_domain(ImageScaleMax, rgn, &ImageReduced3);
			median_image(ImageReduced3, &ImageMedian, "circle", 2, "continued");
			gray_closing_rect(ImageMedian, &ImageClosing, 7, 7);

			Hobject ExpandedImage,ImageMean,ImageReduced4,RegionDynThresh;
			expand_domain_gray(ImageClosing, &ExpandedImage, 20);
			mean_image(ExpandedImage, &ImageMean, 3, 30);
			reduce_domain(ImageMean, rgn, &ImageReduced4);
			dyn_threshold(ImageClosing, ImageReduced4, &RegionDynThresh, GrayValue, "light");

			//threshold (ImageClosing, &Regions1, GrayValue, 225);
			fill_up(RegionDynThresh, &RegionFillUp1);
			Hobject RegionOpening;
			opening_circle(RegionFillUp1,&RegionOpening,OpeningSize);
			//closing_rectangle1(RegionOpening, &RegionClosing1, 10, 1);
			connection(RegionOpening, &ConnectedRegions3);
			select_shape_std(ConnectedRegions3, &SelectedRegions2, "max_area", 70);
			//上下闭合
			Hobject WhiteStripeSelected1,WhiteStripeMoved0,StripeRegion,WhiteStripeMoved,WhiteStripeUnion,StripeReg;
			closing_circle(SelectedRegions2, &WhiteStripeSelected1, 10);
			move_region(WhiteStripeSelected1, &WhiteStripeMoved0, -3, 0);
			dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 1, 1);
			move_region(StripeRegion, &WhiteStripeMoved, 13, 0);
			union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
			closing_rectangle1(WhiteStripeUnion, &StripeReg, 2, 20);
			union1(StripeReg, &StripeReg);

			//当花纹没有提取完全时，以当前搜索区域作为花纹区域
			HTuple Row11, Column11, Row22, Column22,Row33, Column33, Row44, Column44,StripeLength,RgnLength;
			smallest_rectangle1(StripeReg, &Row11, &Column11, &Row22, &Column22);
			StripeLength=Column22-Column11;
			smallest_rectangle1(rgn, &Row33, &Column33, &Row44, &Column44);
			RgnLength=Column44-Column33;

			double factor;
			factor=0.35;
			if(StripeLength<(RgnLength*factor))
			{
				StripeReg=rgn;
			}

			//区域膨胀
			Hobject StripeRegDilation,StripeRegIntersection;
			dilation_rectangle1(StripeReg,&StripeRegDilation,DilationSizeH,DilationSizeV);
			intersection(m_ROI,StripeRegDilation,&StripeRegIntersection);
			opening_circle(StripeRegIntersection,&StripeRegOpening,3.5);

			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], Regions1, &m_vRgn[rId]); //用于显示阈值分割情况
				concat_obj(m_vRgn[rId], StripeRegOpening, &m_vRgn[rId]);
			}
		} 
		else
		{
			//区域缩小
			Hobject StripeRegErosion,StripeRegIntersection;
			erosion_rectangle1(rgn,&StripeRegErosion,ErosionSizeH,ErosionSizeV);
			intersection(m_ROI,StripeRegErosion,&StripeRegIntersection);
			opening_circle(StripeRegIntersection,&StripeRegOpening,3.5);

			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], StripeRegOpening, &m_vRgn[rId]); 
			}

		}

		m_StripeReg=StripeRegOpening;

		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(StripeRegOpening, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegOpening;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1208;LP;700;15000;1;2000$\
					 1209;FP;1;250;0.5;45$\
					 864;FP;1;20;0.5;2$\
					 1210;LP;1;35;1;5$\
					 1211;LP;1;35;1;5$\
					 1212;LP;1;30;1;5$\
					 1213;LP;1;30;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	//int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_DownEdge.Id()== H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject PlatformRegMoved,DownEdgeRegDilation;
		//move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeReg,DownEdgeRegIntersction;
		move_region(m_DownEdge, &DownEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(DownEdgeReg,&DownEdgeRegDilation,1,DialtionSizeV);

		intersection(DownEdgeRegDilation,m_ARegionT,&DownEdgeRegIntersction);
		//水平缩放
		Hobject RegionClip;
		clip_region_rel(DownEdgeRegIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject DownEdgeRegion,ImageDomain;
		difference(RegionClip,m_Platform0,&DownEdgeRegion);
		connection(DownEdgeRegion,&DownEdgeRegion);
		select_shape_std(DownEdgeRegion, &DownEdgeRegion, "max_area", 70);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(DownEdgeRegion, ImageDomain, &DownEdgeRegion);

		m_vRgn[rId] = DownEdgeRegion ;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1194$\
					 167;B$\
					 1190;LP;-20;20;1;3$\
					 994;LP;1;70;1;10$\
					 995;LP;1;50;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************************************
****函 数 名：G20_DownEdgeRegionLocationAlgo2
****功    能：覆膜边缘上区域
****修    改：（一）将m_DownEdge修改为m_DownEdgeX，即使用覆膜下边缘定位覆膜边缘上区域，修改前使用的是上边缘
*******************************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	//不剔除叉口区域，针对华兰单叉覆膜胶塞
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	//int ErosionSize   = (int)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_DownEdgeX.Id()== H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject PlatformRegMoved,DownEdgeRegDilation;
		//move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeReg,DownEdgeRegIntersction;
		move_region(m_DownEdgeX, &DownEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(DownEdgeReg,&DownEdgeRegDilation,1,DialtionSizeV);

		intersection(DownEdgeRegDilation,m_ARegionT,&DownEdgeRegIntersction);
		//水平缩放
		Hobject RegionClip;
		clip_region_rel(DownEdgeRegIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject DownEdgeRegion,ImageDomain;
		//difference(RegionClip,m_Platform0,&DownEdgeRegion);
		//connection(DownEdgeRegion,&DownEdgeRegion);
		//select_shape_std(DownEdgeRegion, &DownEdgeRegion, "max_area", 70);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionClip, ImageDomain, &DownEdgeRegion);

		m_vRgn[rId] = DownEdgeRegion ;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1194$\
					 167;B$\
					 1190;LP;-60;60;1;3$\
					 994;LP;1;70;1;10$\
					 995;LP;1;50;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_SideSlopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pLowerEdgeMoveSize, VARIANT* pUpEdgeMoveSize, VARIANT* pForkEdge,VARIANT* pHErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int LowerEdgeMoveSize   = (int)pLowerEdgeMoveSize->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;
	int ForkEdge = (int)pForkEdge->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_AroiTClosing.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_TopInnerRgion.Id() == H_EMPTY_REGION||m_TopRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject RegionMoved2,RegionMoved3,RegionDiff;
		move_region(m_AroiTClosing, &RegionMoved2, -LowerEdgeMoveSize, 0);
		move_region(m_AroiTClosing, &RegionMoved3, -UpEdgeMoveSize, 0);
		difference(RegionMoved2, RegionMoved3, &RegionDiff);
		Hobject ConnectedRegions5,SelectedRegions2;
		connection(RegionDiff, &ConnectedRegions5);
		select_shape(ConnectedRegions5, &SelectedRegions2, "row", "and", m_TopRow, 999999);

		Hobject RegionUnion1,RegionClosing1,RegionDilation3,RegionDiff1;
		union2(m_TopInnerRgion, m_PlatformReg, &RegionUnion1);
		closing_circle(RegionUnion1, &RegionClosing1, 50);
		dilation_circle(RegionClosing1, &RegionDilation3, 4);
		difference(SelectedRegions2, RegionDilation3, &RegionDiff1);

		//叉口边缘缩放
		Hobject PlatformRegDilation,RegionDiff2,SideSlopRegUnion;
		dilation_rectangle1(m_PlatformReg,&PlatformRegDilation,ForkEdge,1);
		difference(RegionDiff1,PlatformRegDilation,&RegionDiff2);
		union1(RegionDiff2,&SideSlopRegUnion);
		//水平缩放
		Hobject SideSlopRegClipped,ImageDomain;
		clip_region_rel(SideSlopRegUnion, &SideSlopRegClipped, 0, 0, HErosionSize, HErosionSize);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(SideSlopRegClipped, ImageDomain, &SideSlopRegClipped);

		m_vRgn[rId] = SideSlopRegClipped ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1127;LP;-60;50;1;2$\
					 1126;LP;1;60;1;30$\
					 1205;LP;1;90;1;10$\
					 1110;LP;1;50;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//缺膜检测
STDMETHODIMP CPlugAlgo::SlotDetectAlgo(VARIANT* rgnId, VARIANT* pNumPart, VARIANT* pThresholdValue, VARIANT* pGrayValue,VARIANT* pMeanGrayValue,VARIANT* pDetectArea)
{   
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area<=350)
	{
		//为空/面积小于350，不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int NumPart = (int)pNumPart->fltVal;
	float ThresholdValue = (float)pThresholdValue->fltVal;
	int GrayValue = (int)pGrayValue->fltVal;
	int MeanGrayValue=(int)pMeanGrayValue->fltVal;

	Hobject Image = m_crtImg;
	Hobject ImageROI,JuanYuanPartitioned, ResultDefect;
	HTuple PolarTransImageWidth, PolarTransImageHeight, Mean, Deviation, MeanLength, Exp, MeanDeviation;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//int angleCirle=370;//重复一定角度，避免起始角度位置缺陷被忽略。
		//polar_trans_image_ext(Image, &PolarTransImage, fCenterY, fCenterX, 0, HTuple(angleCirle).Rad(), HTuple(RegionalOut), HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), "nearest_neighbor");
		change_domain(Image,rgn,&ImageROI);
		scale_image_max(ImageROI,&ImageROI);

		if (ImageROI.Id()==H_EMPTY_REGION)
		{
			//为空不报错
			retValue = 0.0;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		get_image_size(ImageROI, &PolarTransImageWidth, &PolarTransImageHeight);
		partition_rectangle(ImageROI, &JuanYuanPartitioned, PolarTransImageWidth/NumPart, PolarTransImageHeight);
		intensity(JuanYuanPartitioned, ImageROI, &Mean, &Deviation);
		tuple_length(Mean, &MeanLength);
		MeanDeviation = HTuple();
		for (int i=0; i<=MeanLength-2; i+=1)
		{
			tuple_deviation(HTuple(Mean[i]).Concat(HTuple(Mean[i+1])), &Exp);
			MeanDeviation[i] = Exp; 
		}

		HTuple Abs, AbsSorted, LocationId, Length, errorValue, ResultID;
		tuple_abs(MeanDeviation, &Abs);
		tuple_sort(Abs, &AbsSorted);
		tuple_sort_index(Abs, &LocationId);
		tuple_length(Abs, &Length);
		for (int i=Length[0].I()-1; i>=0; i+=-1)
		{
			if (0 != (HTuple(AbsSorted[i])<ThresholdValue))
			{
				if (0 != (i==(Length-1)))
				{
					ResultID = HTuple();
					break;
				}
				else
				{
					tuple_last_n(LocationId, i+1, &ResultID);
					break;
				}
			}
		}
		ResultID += 1;

		HTuple MeanSorted, LocationId2, Length1, ResultID2, ResultID3, Sorted, Uniq;
		tuple_sort(Mean, &MeanSorted);
		tuple_sort_index(Mean, &LocationId2);
		tuple_length(Mean, &Length1);
		ResultID2 = HTuple();
		for (int i=0; i<=Length1-1; i+=1)
		{
			if (0 != (HTuple(MeanSorted[i]) < GrayValue))
			{
				ResultID2[i] = HTuple(LocationId2[i]);
			}
			else
			{
				break;
			}
		}
		ResultID2 += 1;

		tuple_concat(ResultID, ResultID2, &ResultID3);
		tuple_sort(ResultID3, &Sorted);
		tuple_uniq(Sorted, &Uniq);
		Hobject BackTransRegion, DefectRegs;
		select_obj(JuanYuanPartitioned, &ResultDefect, Uniq);
		//polar_trans_region_inv(ResultDefect, &BackTransRegion, fCenterY, fCenterX, 0, HTuple(angleCirle).Rad(), HTuple(RegionalOut), HTuple(RegionalIn), (HTuple(angleCirle).Rad())*HTuple(RegionalOut), HTuple(RegionalOut-RegionalIn), WidthOri, HeightOri, "nearest_neighbor");
		union1 (ResultDefect, &DefectRegs);
		intersection(DefectRegs,rgn,&DefectRegs);
		//
		HTuple Mean1, Deviation1;
		intensity(rgn, Image, &Mean1, &Deviation1);
		if (Mean1<MeanGrayValue)
		{
			union2 (rgn,DefectRegs, &DefectRegs);
		}
		//
		HTuple Area, Row_test, Column_test;
		area_center (DefectRegs, &Area, &Row_test, &Column_test);
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn;
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;	
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SlotDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1200$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 403;LP;5;500;1;300$\
					 404;FP;1;100;0.1;30$\
					 405;LP;1;255;1;50$\
					 608;LP;1;255;1;60");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_OutEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pDilationSize1,VARIANT* pDilationSize2)
{
	int rId           = (int)rgnId->fltVal;
	int DilationSize1 =(int)pDilationSize1->fltVal;
	int DilationSize2   = (int)pDilationSize2->fltVal;

	if (DilationSize1>=DilationSize2)
	{
		DilationSize1=DilationSize2-1;
	}

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id()== H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject RoiDilation1,RoiDilation2,RegionDiff;
		dilation_circle(m_ROI, &RoiDilation1, DilationSize1);
		dilation_circle(m_ROI, &RoiDilation2, DilationSize2);
		difference(RoiDilation2, RoiDilation1, &RegionDiff);

		m_vRgn[rId] = RegionDiff;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_OutEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1201$\
					 167;B$\
					 1203;LP;2;60;1;5$\
					 1202;LP;3;80;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternDynThresholdAlgo(VARIANT* rgnId, VARIANT* pAreaLimit,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	//20单叉覆膜胶塞，在有条纹的胶塞中检测混有无条纹的胶塞
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	int AreaLimit    = (int)pAreaLimit->fltVal;
	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||area<=AreaLimit)
	{
		//为空不报错，花纹区域面积小于一定值返回OK
		retValue = 1000.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, 1, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, 1, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternDynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1215$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 1208;LP;10;15000;1;3000$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV,VARIANT* pDilationSizeP)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	int DilationSizeP   = (int)pDilationSizeP->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeM.Id()== H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION||m_ARegionT.Id()== H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject PlatformRegMoved,DownEdgeRegDilation;
		//move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeReg;
		move_region(m_ABEdgeM, &DownEdgeReg, -MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(DownEdgeReg,&DownEdgeRegDilation,1,DialtionSizeV);

		//与颈部中间区域合并，检测双眼皮
		Hobject RegionUnion,RegionDiff;
		union2(DownEdgeRegDilation,m_MiddleNeckRegion,&RegionUnion);
		union1(RegionUnion,&RegionUnion);
		//水平缩放
		Hobject RegionClip,ARegionIntersction;
		intersection(RegionUnion,m_ARegionT,&ARegionIntersction);
		clip_region_rel(ARegionIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		//剔除叉口
		Hobject PlatformRegDilation1,RegionDiff1;
		dilation_circle(m_Platform0,&PlatformRegDilation1,DilationSizeP);
		difference(RegionClip,PlatformRegDilation1,&RegionDiff1);

		//中部边缘
		Hobject MiddleEdgeReg,RegionDiff2,ImageDomain;
		dilation_rectangle1(m_MiddleEdge, &MiddleEdgeReg, 1, 35);
		difference(RegionDiff1,MiddleEdgeReg,&RegionDiff2);
		union1(RegionDiff2,&RegionDiff2);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionDiff2, ImageDomain, &RegionDiff2);

		m_vRgn[rId] = RegionDiff2;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_DownEdgeRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1219$\
					 167;B$\
					 1190;LP;10;100;1;50$\
					 994;LP;1;70;1;10$\
					 995;LP;1;70;1;5$\
					 1112;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************
***函数名：DoubleFoldDetectAlgo
***功  能：双眼皮检测
***思  路：动态阈值 + 剔除覆膜边缘
*****************************************************************/
STDMETHODIMP CPlugAlgo::DoubleFoldDetectAlgo(VARIANT* rgnId, VARIANT* pAreaLimit,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pMoveSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	int AreaLimit    = (int)pAreaLimit->fltVal;
	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||area<=AreaLimit)
	{
		//为空不报错，花纹区域面积小于一定值返回OK
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	if(m_FMpoints.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int MoveSize =(int)pMoveSize->fltVal;
	//
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		//m_FMpoints  m_ABEdgeM ，剔除覆膜边缘干扰
		HTuple Area7, Row5, Column3,Area8, Row6, Column5;
		Hobject RegionMoved,RegionDilation;
		area_center(m_FMpoints, &Area7, &Row5, &Column3);
		area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
		move_region(m_ABEdgeM, &RegionMoved, -(Row6-Row5), 0);
		dilation_rectangle1(RegionMoved, &RegionDilation, 1, 20);

		Hobject RemovedReg;
		move_region(RegionDilation,&RemovedReg,MoveSize,0);
		//
		union1(DefectRegs,&DefectRegs);
		Hobject DefectRegs1;
		difference(DefectRegs,RemovedReg,&DefectRegs1);
		area_center(DefectRegs1, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs1, &DefectRegs1, 2.5);
			m_vErrorRgn[rId] = DefectRegs1;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DoubleFoldDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1228$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 1208;LP;10;15000;1;100$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10$\
					 1227;LP;-50;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::DoubleFoldDetectAlgo1(VARIANT* rgnId, VARIANT* pAreaLimit,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pMoveSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	int AreaLimit    = (int)pAreaLimit->fltVal;
	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||area<=AreaLimit)
	{
		//为空不报错，花纹区域面积小于一定值返回OK
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	if(m_FMpoints.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int MoveSize =(int)pMoveSize->fltVal;
	//
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		//m_FMpoints  m_ABEdgeM ，剔除覆膜边缘干扰
		HTuple Area7, Row5, Column3,Area8, Row6, Column5;
		Hobject RegionMoved,RegionDilation;
		area_center(m_FMpoints, &Area7, &Row5, &Column3);
		area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
		move_region(m_ABEdgeM, &RegionMoved, -(Row6-Row5), 0);
		dilation_rectangle1(RegionMoved, &RegionDilation, 1, 20);

		Hobject RemovedReg;
		move_region(RegionDilation,&RemovedReg,MoveSize,0);
		//
		union1(DefectRegs,&DefectRegs);
		Hobject DefectRegs1;
		difference(DefectRegs,RemovedReg,&DefectRegs1);
		area_center(DefectRegs1, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs1, &DefectRegs1, 2.5);
			m_vErrorRgn[rId] = DefectRegs1;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DoubleFoldDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1228$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 1208;LP;10;15000;1;100$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10$\
					 1227;LP;-50;50;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_MiddleEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	//int DilationSizeP   = (int)pDilationSizeP->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_MiddleEdge.Id()== H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject MiddleEdgeReg,MiddleEdgeRegDilation,PlatformRegDilation,MiddleRegion;
		move_region(m_MiddleEdge, &MiddleEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(MiddleEdgeReg,&MiddleEdgeRegDilation,1,DialtionSizeV);
		//dilation_circle(m_PlatformReg,&PlatformRegDilation,DilationSizeP);
		dilation_rectangle1(m_PlatformReg, &PlatformRegDilation, 1, 5);
		//
		intersection(m_ARegionT,MiddleEdgeRegDilation,&MiddleEdgeRegDilation);
		difference(MiddleEdgeRegDilation,PlatformRegDilation,&MiddleRegion);
		connection(MiddleRegion,&MiddleRegion);
		select_shape_std (MiddleRegion, &MiddleRegion, "max_area", 70);
		//水平缩放
		Hobject RegionClip,ImageDomain;
		clip_region_rel(MiddleRegion, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionClip, ImageDomain, &RegionClip);
		m_vRgn[rId] = RegionClip;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_MiddleEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1229$\
					 167;B$\
					 1190;LP;-90;160;1;1$\
					 994;LP;1;70;1;10$\
					 995;LP;1;70;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_MiddleEdgeRegionLocationAlgo1(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV,VARIANT*pDilationSizeP)
{
	//针对华兰单叉覆膜胶塞，中部边缘区域处存在三角花纹的高亮区域
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	int DilationSizeP   = (int)pDilationSizeP->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_MiddleEdge.Id()== H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject MiddleEdgeReg,MiddleEdgeRegDilation,PlatformRegDilation,MiddleRegion;
		move_region(m_MiddleEdge, &MiddleEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(MiddleEdgeReg,&MiddleEdgeRegDilation,1,DialtionSizeV);
		//dilation_circle(m_PlatformReg,&PlatformRegDilation,DilationSizeP);
		dilation_rectangle1(m_PlatformReg, &PlatformRegDilation, 1, 5);
		//剔除花纹
		Hobject StripeReg;
		dilation_circle(m_StripeReg,&StripeReg,DilationSizeP);
		difference(MiddleEdgeRegDilation,StripeReg,&MiddleEdgeRegDilation);
		//
		intersection(m_ARegionT,MiddleEdgeRegDilation,&MiddleEdgeRegDilation);
		difference(MiddleEdgeRegDilation,PlatformRegDilation,&MiddleRegion);
		connection(MiddleRegion,&MiddleRegion);
		//select_shape_std (MiddleRegion, &MiddleRegion, "max_area", 70);
		union1(MiddleRegion,&MiddleRegion);
		//水平缩放
		Hobject RegionClip,ImageDomain;
		clip_region_rel(MiddleRegion, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionClip, ImageDomain, &RegionClip);
		m_vRgn[rId] = RegionClip;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_MiddleEdgeRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1229$\
					 167;B$\
					 1190;LP;-90;160;1;1$\
					 994;LP;1;70;1;10$\
					 995;LP;1;70;1;5$\
					 1020;LP;1;20;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_ConPatternDynThresholdAlgo1(VARIANT* rgnId, VARIANT* pAreaLimit,VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	//20单叉覆膜胶塞，在无条纹的胶塞中检测混有有条纹的胶塞
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	int AreaLimit    = (int)pAreaLimit->fltVal;
	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||area<=AreaLimit)
	{
		//为空不报错，花纹区域面积小于一定值返回OK
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, 1, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, 1, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternDynThresholdAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1230$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 1208;LP;700;15000;1;3000$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************
***函数名：FilmHairDetectAlgo
***功  能：膜毛检测
***思  路：区域扩充+动态阈值
*******************************************************************/
STDMETHODIMP CPlugAlgo::FilmHairDetectAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	//检测四周的膜毛缺陷，剔除玻璃上的脏污干扰
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||m_ABEdgeRowS.Num()!=1)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 25);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, BlackMaskSize);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 25);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, WhiteMaskSize);
		}
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);

		//检测四周的膜毛缺陷
		union1(DefectRegs,&DefectRegs);
		connection(DefectRegs,&DefectRegs);
		select_shape(DefectRegs, &DefectRegs, "row", "and", 0, m_ABEdgeRowS);

		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::FilmHairDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1234$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************************
**函数名：G20_ConPatternDetectProfileAlgo
**功  能：检测花纹膜不贴合时、剔除花纹的端点干扰m_StripeReg，即晒出花纹左右两边的端点干扰（pClipSize）
**场  景：华强现场更新
****************************************************************************************************/
STDMETHODIMP CPlugAlgo::G20_ConPatternDetectProfileAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize,VARIANT* pClipSize,VARIANT* pAreaLimit,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;
	int AreaLimit    = (int)pAreaLimit->fltVal;
	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||area<=AreaLimit)
	{
		//为空不报错，用于特殊区域检测
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
	int ClipSize = (int) pClipSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//检测花纹膜不贴合时、剔除花纹的端点干扰m_StripeReg
		HTuple Row1,Col1,Row2,Col2;
		smallest_rectangle1(m_StripeReg,&Row1,&Col1,&Row2,&Col2);
		if (Col2-ClipSize<0)
		{
			ClipSize=Col2[0].I();
		}
		clip_region(rgn,&rgn,0,Col1+ClipSize,m_imgHeight,Col2-ClipSize);

		Hobject Image = m_crtImg;
		Hobject ImageReduced, ImageReduceMean,ExpandedImage,ImageDetectNew;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		expand_domain_gray (ImageReduced, &ExpandedImage, 45);
		reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
		mean_image(ImageDetectNew, &ImageReduceMean, BlackMaskSize, 1);
		//
		Hobject SeriousPointDynThredImg,SeriousConnected,RegionErosion,RegionIntersection,SeriousPointReg;	
		erosion_circle (rgn, &RegionErosion, 2.5);
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousBlackPointDynThresh, "dark");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousBlackPointSize, 99999);
		union1(SeriousPointReg, &BlackUnion);
		//
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		if(abs(WhiteMaskSize-BlackMaskSize)>=1)
		{
			ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
			expand_domain_gray (ImageReduced, &ExpandedImage, 45);
			reduce_domain (ExpandedImage, rgn, &ImageDetectNew); 
			mean_image(ImageDetectNew, &ImageReduceMean, WhiteMaskSize, 1);
		}
		//
		dyn_threshold(ImageReduced, ImageReduceMean, &SeriousPointDynThredImg, SeriousWhitePointDynThresh, "light");	
		intersection (SeriousPointDynThredImg, RegionErosion, &RegionIntersection);
		connection(RegionIntersection, &SeriousConnected); 
		select_shape(SeriousConnected, &SeriousPointReg, "area", "and", SeriousWhitePointSize, 99999);
		union1(SeriousPointReg, &WhiteUnion);
		//
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_ConPatternDetectProfileAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1289$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;150;2;45$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;150;2;45$\
					 420;LP;1;250;1;20$\
					 421;LP;1;250;1;10$\
					 1288;LP;3;50;1;10$\
					 1214;LP;10;15000;1;200");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//T20_侧面（20双叉）
void CPlugAlgo:: P_SideDetectAngle (Halcon::Hobject Region, Halcon::HTuple Row1, Halcon::HTuple Col1, Halcon::HTuple Row2, Halcon::HTuple Col2, Halcon::HTuple *Angle,Halcon::Hobject *LineRegion)
{

	// Local iconic variables 
	Hobject  Cross, Rect, RegionIntersection;
	Hobject  LineReg, LineObject, ObjectSelected1, ObjectSelected2;
	Hobject  LineRegSelected, Rectangle1, Line, LineRegSorted;

	// Local control variables 
	HTuple  MidRow, MidCol, Length0, Row;
	HTuple  Column, Phi, Length11, Length21, LongLength;
	HTuple  ShortLength, Num1, i, LineArea, LineRow;
	HTuple  LineColumn, Sorted, Indices2, Indices3;
	HTuple  shortL, Column1, Phi1, Length1, Length2;
	HTuple  LoneLength, shortLength, shortLMin, Indices;

	//*求线段中点
	HTuple  RowFirst,ColFirst, RowSecond, ColSecond,Angle0;
	Hobject RegionLine0;
	gen_region_line(&RegionLine0, Row1, Col1, Row2, Col2);
	distance_pp(Row1, Col1, Row2, Col2, &Length0);
	orientation_region(RegionLine0, &Angle0);

	if (0 != (HTuple(Row1<=Row2).And(Col1<=Col2)))
	{
		RowFirst = Row1;
		ColFirst = Col1;
		RowSecond = Row2;
		ColSecond = Col2;

		MidRow = RowSecond-((RowSecond-RowFirst)/2);
		MidCol = ColSecond-((ColSecond-ColFirst)/2);

	}
	else if (0 != (HTuple(Row1>Row2).And(Col1>Col2)))
	{
		RowFirst = Row1;
		ColFirst = Col1;
		RowSecond = Row2;
		ColSecond = Col2;

		MidRow = RowSecond+((RowFirst-RowSecond)/2);
		MidCol = ColSecond+((ColFirst-ColSecond)/2);

	}
	else if (0 != (HTuple(Row1<=Row2).And(Col1>Col2)))
	{
		RowFirst = Row1;
		ColFirst = Col1;
		RowSecond = Row2;
		ColSecond = Col2;

		MidRow = RowSecond-((RowSecond-RowFirst)/2);
		MidCol = ColSecond+((ColFirst-ColSecond)/2);
	}
	else
	{
		RowFirst = Row1;
		ColFirst = Col1;
		RowSecond = Row2;
		ColSecond = Col2;

		MidRow = RowSecond+((RowFirst-RowSecond)/2);
		MidCol = ColSecond-((ColSecond-ColFirst)/2);

	}
	//
	smallest_rectangle2(Region, &Row, &Column, &Phi, &Length11, &Length21);
	if (0 != (Length11>=Length21))
	{
		LongLength = Length11;
		ShortLength = Length21;
	}
	else
	{
		LongLength = Length21;
		ShortLength = Length11;
	}
	if (0 != (ShortLength<10))
	{
		ShortLength = 15;
	}
	gen_rectangle2(&Rect, MidRow, MidCol, Angle0, Length0, ShortLength/2);
	intersection(Rect, Region, &RegionIntersection);
	connection(RegionIntersection, &LineReg);
	count_obj(LineReg, &Num1);
	*LineRegion=LineReg;

	if (0 != (Num1>2))
	{
		area_center(LineReg, &LineArea, &LineRow, &LineColumn);
		tuple_sort(LineArea, &Sorted);

		tuple_find(LineArea, Sorted.Select(Num1-1), &Indices2);
		tuple_find(LineArea, Sorted.Select(Num1-2), &Indices3);

		select_obj(LineReg, &ObjectSelected1, Indices2+1);
		select_obj(LineReg, &ObjectSelected2, Indices3+1);
		concat_obj(ObjectSelected1, ObjectSelected2, &LineReg);
	}
	shortL = HTuple();
	for (i=1; i<=2; i+=1)
	{
		select_obj(LineReg, &LineRegSelected, i);
		smallest_rectangle2(LineRegSelected, &Row2, &Column1, &Phi1, &Length1, &Length2);
		gen_rectangle2(&Rectangle1, Row2, Column1, Phi1, Length1, Length2);

		if (0 != (Length1>=Length2))
		{
			LoneLength = Length1;
			shortLength = Length2;
		}
		else
		{
			LoneLength = Length2;
			shortLength = Length1;
		}
		shortL.ReplaceElements(i-1,shortLength);
	}

	if (0 != ((shortL.Select(0))==(shortL.Select(1))))
	{
		select_obj(LineReg, &Line, 1);
	}
	else
	{
		tuple_min(shortL, &shortLMin);
		tuple_find(shortL, shortLMin, &Indices);
		select_obj(LineReg, &Line, Indices+1);
	}
	orientation_region(Line, &(*Angle));
	if (0 != ((*Angle)<0))
	{
		(*Angle) = PI+(*Angle);
	}

	return;
}
STDMETHODIMP CPlugAlgo::T20_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pAreaLimitLower,VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		//
		m_ImageReducedAroi=ImageReducedAroi;

		Hobject TopRegions,ConnectedRegions,RegionSelect;
		threshold(ImageReducedAroi, &TopRegions, ThredLower, 255);

		//m_TopRegions=TopRegions;
		Hobject TopRegionsFillUp;
		fill_up(TopRegions,&TopRegionsFillUp);
		Hobject TopRegionOpening,TopRegionClosing,TopRegionConnected,SelectedRegions;
		opening_circle(TopRegionsFillUp, &TopRegionOpening, 3.5);
		closing_circle(TopRegionOpening, &TopRegionClosing, 3.5);
		connection(TopRegionClosing, &TopRegionConnected);
		select_shape(TopRegionConnected, &SelectedRegions, "area", "and", AreaLimitLower, 99999999);

		m_TopRegions=SelectedRegions;
		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(SelectedRegions, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		Hobject TopRegionUnion;
		HTuple TopCenTerArea, TopCenTerRow, TopCenTerCol;
		union1(SelectedRegions, &TopRegionUnion);
		area_center(TopRegionUnion, &TopCenTerArea, &TopCenTerRow, &TopCenTerCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopRegionUnion, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
		}

		//2个顶部区域
		if (TopRegionRow.Num()!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}

		//顶部区域AroiTClosing
		Hobject AroiTClosing;
		HTuple TopArea, TopRow, TopCol;
		shape_trans(TopRegionUnion, &AroiTClosing, "convex");
		area_center(AroiTClosing, &TopArea, &TopRow, &TopCol);
		Hobject RegionErosion,TopRect,TopRectBorder;
		erosion_circle(AroiTClosing, &RegionErosion, 5);
		difference(RegionErosion, TopRegionUnion, &TopRect);
		Hobject ConnectedTopRect;
		connection(TopRect, &ConnectedTopRect);
		select_shape_std(ConnectedTopRect, &TopRect,"max_area", 70);

		HTuple Row1,Col1,Row2,Col2;
		Row1 = TopRegionRow.Select(0);
		Col1 = TopRegionCol.Select(0);
		Row2 = TopRegionRow.Select(1);
		Col2 = TopRegionCol.Select(1);
		boundary(TopRect, &TopRectBorder, "outer");

		m_AroiTClosing=AroiTClosing;
		m_TopRect=TopRect; //用于侧面内壁区域提取
		HTuple Angle;
		Hobject LinReg;
		P_SideDetectAngle(TopRectBorder, Row1, Col1, Row2, Col2, &Angle,&LinReg);

		m_Angle=Angle;
		Hobject AngleRegionLine;
		gen_region_line(&AngleRegionLine, Row1, Col1, Row2, Col2);

		m_TopRow=TopCenTerRow;
		m_TopCol=TopCenTerCol;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AngleRegionLine, &m_vRgn[rId]);
		}
		//
		HTuple AngleLineArea,AngleLineRow,AngleLineCol,Deg;
		area_center(LinReg,&AngleLineArea,&AngleLineRow,&AngleLineCol);
		tuple_deg(Angle, &Deg);
		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = Deg[0].D();
			dilation_circle(LinReg, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
			//
			m_TopRow=0;
			m_TopCol=0;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("987$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;360;1;260$\
					 989;FP;0;250;0.5;55$\
					 1273;LP;1;5000;1;1500");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_20T_PlatformLocationLRAlgo (Hobject PlatformAB, Hobject PlatformRegs, HTuple SearchSize, HTuple TopCenTerCol,Hobject *PlatformReg, Hobject *PlatformRegDilation, Hobject *PlatformRegDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegs, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}

	//
	gen_empty_obj(&PlatformRegs2);

	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	/////
	Hobject PlatformRegLs,PlatformRegRs;
	gen_empty_region(&PlatformRegLs);
	gen_empty_region(&PlatformRegRs);

	Hobject PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);

		if (0 != (PlatRegCol<TopCenTerCol))
		{
			union2(PlatformRegLs, PlatRegSelected, &PlatformRegLs);
		}
		else
		{

			union2(PlatformRegRs, PlatRegSelected, &PlatformRegRs);
		}
	}
	Hobject PlatformRegLsOpening,PlatformRegRsOpening,PlatformRegL,PlatformRegR;
	opening_rectangle1(PlatformRegLs, &PlatformRegLsOpening, 2, 2);
	opening_rectangle1(PlatformRegRs, &PlatformRegRsOpening, 2, 2);
	HTuple PlatformRegLNum,PlatformRegRNum;
	connection(PlatformRegLsOpening, &PlatformRegLs);
	select_shape_std(PlatformRegLs, &PlatformRegL, "max_area", 70);

	connection(PlatformRegRsOpening, &PlatformRegRs);
	select_shape_std(PlatformRegRs, &PlatformRegR, "max_area", 70);

	Hobject PlatformRegUnion,PlatformRegUnionConnected;
	union2(PlatformRegL, PlatformRegR, &PlatformRegUnion);
	connection(PlatformRegUnion, &PlatformRegUnionConnected);
	//count_obj(PlatformRegUnionConnected, &PlatformRegNum3);
	//筛选最大的叉口平台
	select_shape_std(PlatformRegUnionConnected, &(*PlatformReg), "max_area", 70);
	HTuple PlatformRegArea, PlatformRegRow, PlatformRegCol;
	Hobject PlatformRegDilation1,PlatformRegDiff,PlatformRegDiffConnected,SelectedRegion;
	area_center((*PlatformReg), &PlatformRegArea, &PlatformRegRow, &PlatformRegCol);
	if (0 != (PlatformRegArea==0))
	{
		return;
	}
	dilation_rectangle1((*PlatformReg), &(*PlatformRegDilation0), 1, 500);
	dilation_circle((*PlatformReg), &PlatformRegDilation1, 3.5);
	difference((*PlatformRegDilation0), PlatformRegDilation1, &PlatformRegDiff);
	connection(PlatformRegDiff, &PlatformRegDiffConnected);
	select_shape(PlatformRegDiffConnected, &SelectedRegion, "row", "and", PlatformRegRow, 999999);
	difference((*PlatformRegDilation0), SelectedRegion, &(*PlatformRegDilation));
	return;
}
void CPlugAlgo::P_20T_PlatformLocationRAlgo (Hobject PlatformAB, Hobject PlatformRegs, HTuple SearchSize, HTuple TopCenTerCol,Hobject *PlatformRegR, Hobject *PlatformRegRDilation, Hobject *PlatformRegRDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegs, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}
	gen_empty_obj(&PlatformRegs2);


	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	Hobject PlatformRegRs,PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	gen_empty_region(&PlatformRegRs);
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);
		//50为叉口宽度的一半
		if (0 != (PlatRegCol>(TopCenTerCol-70)))
		{
			union2(PlatformRegRs, PlatRegSelected, &PlatformRegRs);
		}
	}
	Hobject PlatformRegRsOpening;
	opening_rectangle1(PlatformRegRs, &PlatformRegRsOpening, 2, 2);
	connection(PlatformRegRsOpening, &PlatformRegRs);
	select_shape_std(PlatformRegRs, &(*PlatformRegR), "max_area", 70);

	//右边平台
	HTuple PlatformRegRArea, PlatformRegRRow, PlatformRegRCol;
	area_center((*PlatformRegR), &PlatformRegRArea, &PlatformRegRRow, &PlatformRegRCol);
	if (PlatformRegRArea==0)
	{
		return;
	}

	Hobject PlatformRegRDilation1,PlatformRegRDiff,PlatformRegRDiffConnected,SelectedRegionR;
	dilation_rectangle1((*PlatformRegR), &(*PlatformRegRDilation0), 1, 500);
	dilation_circle((*PlatformRegR), &PlatformRegRDilation1, 3.5);
	difference((*PlatformRegRDilation0), PlatformRegRDilation1, &PlatformRegRDiff);
	connection(PlatformRegRDiff, &PlatformRegRDiffConnected);
	select_shape(PlatformRegRDiffConnected, &SelectedRegionR, "row", "and", PlatformRegRRow, 999999);
	difference((*PlatformRegRDilation0), SelectedRegionR, &(*PlatformRegRDilation));

	return;
}
void CPlugAlgo::P_20T_PlatformLocationLAlgo (Hobject PlatformAB, Hobject PlatformRegs, HTuple SearchSize, HTuple TopCenTerCol,Hobject *PlatformRegL, Hobject *PlatformRegLDilation, Hobject *PlatformRegLDilation0)
{
	Hobject PlatformABPartitioned;
	HTuple PlatformABAreas, PlatformABRows, PlatformABCols;
	partition_rectangle(PlatformAB, &PlatformABPartitioned, 1, 100);
	area_center(PlatformABPartitioned, &PlatformABAreas, &PlatformABRows, &PlatformABCols);

	HTuple PlatformABRowsRound,PlatformABColsRound;
	tuple_round(PlatformABRows, &PlatformABRowsRound);
	tuple_round(PlatformABCols, &PlatformABColsRound);

	Hobject PlatformRegConnected,PlatformRegs2;
	HTuple PlatformRegNum;
	connection(PlatformRegs, &PlatformRegConnected);
	count_obj(PlatformRegConnected, &PlatformRegNum);
	if (PlatformRegNum<1)
	{
		return;
	}

	////
	gen_empty_obj(&PlatformRegs2);
	Hobject PlatformRegSelected1,PlatformABIntersection,PlatformABMoved;
	HTuple Area, Row, Column;
	for (int i=1;i<=PlatformRegNum;i++)
	{
		select_obj(PlatformRegConnected, &PlatformRegSelected1, i);
		//PlatformAB往上平移半个SearchSize
		move_region(PlatformAB,&PlatformABMoved, -SearchSize/4, 0);
		intersection (PlatformRegSelected1, PlatformABMoved, &PlatformABIntersection);
		area_center (PlatformABIntersection, &Area, &Row, &Column);
		if(Area>0)
		{
			concat_obj(PlatformRegs2, PlatformRegSelected1, &PlatformRegs2);
		}

	}
	HTuple PlatformRegNum2;
	union1(PlatformRegs2,&PlatformRegs2);
	connection(PlatformRegs2, &PlatformRegs2);
	count_obj(PlatformRegs2, &PlatformRegNum2);

	if (PlatformRegNum2<1)
	{
		return;
	}
	//左边区域
	Hobject PlatformRegLs,PlatRegSelected;
	HTuple PlatRegArea, PlatRegRow, PlatRegCol;
	gen_empty_region(&PlatformRegLs);
	for (int i=1;i<=PlatformRegNum2;i++)
	{
		select_obj(PlatformRegs2, &PlatRegSelected, i);
		area_center(PlatRegSelected, &PlatRegArea, &PlatRegRow, &PlatRegCol);
		//50为叉口宽度的一半
		if (0 != (PlatRegCol<(TopCenTerCol+70)))
		{
			union2(PlatformRegLs, PlatRegSelected, &PlatformRegLs);
		}
	}
	Hobject PlatformRegLsOpening;
	HTuple PlatformRegLNum,PlatformDistLs;
	opening_rectangle1(PlatformRegLs, &PlatformRegLsOpening, 2, 2);
	connection(PlatformRegLsOpening, &PlatformRegLs);

	select_shape_std(PlatformRegLs, &(*PlatformRegL), "max_area", 70);

	//左边平台
	HTuple PlatformRegLArea, PlatformRegLRow, PlatformRegLCol;
	Hobject PlatformRegLDilation1,PlatformRegLDiff,PlatformRegLDiffConnected,SelectedRegionL;
	area_center((*PlatformRegL), &PlatformRegLArea, &PlatformRegLRow, &PlatformRegLCol);
	//
	if (PlatformRegLArea==0)
	{
		return;
	}
	dilation_rectangle1((*PlatformRegL), &(*PlatformRegLDilation0), 1, 500);
	dilation_circle((*PlatformRegL), &PlatformRegLDilation1, 3.5);
	difference((*PlatformRegLDilation0), PlatformRegLDilation1, &PlatformRegLDiff);
	connection(PlatformRegLDiff, &PlatformRegLDiffConnected);
	select_shape(PlatformRegLDiffConnected, &SelectedRegionL, "row", "and", PlatformRegLRow, 999999);
	difference((*PlatformRegLDilation0), SelectedRegionL, &(*PlatformRegLDilation));

	return;

}
STDMETHODIMP CPlugAlgo::T20_PlatformDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pVSearchSize,VARIANT* pHSearchSize,VARIANT* pThredLower, VARIANT* pOpeningSize,VARIANT* pAngle,VARIANT* pPlatformArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;

	int HSearchSize    =(int)pHSearchSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;
	int OpeningSize   = (int)pOpeningSize->fltVal;
	double Angle   = (double)pAngle->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_ABEdge.Id() == H_EMPTY_REGION)||(m_ROI.Id() == H_EMPTY_REGION))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_ImageScaleMax;
		//
		Hobject PlatformAB;
		HTuple PlatformABArea, PlatformABCenterRow, PlatformABCenterCol;
		//
		move_region(m_ABEdge, &PlatformAB, -MoveSize, 0);
		area_center(PlatformAB, &PlatformABArea, &PlatformABCenterRow, &PlatformABCenterCol);
		Hobject PlatformRegDilationT;
		dilation_rectangle1(PlatformAB, &PlatformRegDilationT, 1, SearchSize);
		intersection(PlatformRegDilationT, m_ROI, &PlatformRegDilationT);

		Hobject PlatformSearch;
		//opening_rectangle1(PlatformRegDilationT, &PlatformSearch, 1, (SearchSize*2)/3);
		clip_region_rel(PlatformRegDilationT,&PlatformSearch,0,0,HSearchSize,HSearchSize);

		Hobject PlatformImageReduced,Platforms,PlatformRegFillup;
		reduce_domain(Image, PlatformSearch, &PlatformImageReduced);
		//
		threshold(PlatformImageReduced, &Platforms, ThredLower, 255);
		fill_up(Platforms, &PlatformRegFillup);
		Hobject PlatformRegErosion,PlatformRegsDilated,PlatformRegConnected;
		erosion_circle(PlatformRegFillup, &PlatformRegErosion, 2);
		dilation_circle(PlatformRegErosion, &PlatformRegsDilated, 2);

		//筛选
		connection(PlatformRegsDilated, &PlatformRegConnected);
		Hobject PlatformRegs;
		select_shape(PlatformRegConnected, &PlatformRegs, "area", "and", 10, 9999999);
		//剔除中间条纹
		opening_rectangle1(PlatformRegs, &PlatformRegs, 1, OpeningSize);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformAB, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformSearch, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], PlatformRegFillup, &m_vRgn[rId]);
		}

		intersection(PlatformSearch, PlatformAB, &PlatformAB);
		//叉口角度定位失败时,报错
		if (m_TopCol==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pPlatformArea);
			return S_FALSE;
		}
		Hobject PlatformReg,PlatformRegDilation,PlatformRegDilation0;
		gen_empty_region(&PlatformReg);
		gen_empty_region(&PlatformRegDilation);
		gen_empty_region(&PlatformRegDilation0);

		//根据叉口朝向，提取平台区域
		HTuple a,b,c;
		tuple_rad(Angle, &a);
		tuple_rad(90, &b);
		tuple_rad(180-Angle, &c);

		if ((m_Angle>=a)&&(m_Angle<=b))
		{
			//左边叉口平台
			P_20T_PlatformLocationLAlgo(PlatformAB, PlatformRegs, SearchSize, m_TopCol, &PlatformReg, &PlatformRegDilation,&PlatformRegDilation0);

		}
		else if((m_Angle>b)&&(m_Angle<=c))
		{
			//右边叉口平台
			P_20T_PlatformLocationRAlgo(PlatformAB, PlatformRegs, SearchSize, m_TopCol, &PlatformReg, &PlatformRegDilation,&PlatformRegDilation0);

		}
		else
		{
			//当左右叉口平台位于两侧，筛选最大的作为叉口平台
			P_20T_PlatformLocationLRAlgo(PlatformAB, PlatformRegs, SearchSize, m_TopCol, &PlatformReg, &PlatformRegDilation, &PlatformRegDilation0);
		}

		m_Platform=PlatformReg; //叉口平台侧面检测区域

		dilation_rectangle1(PlatformRegDilation, &PlatformRegDilation, 5, 1);
		m_PlatformReg=PlatformRegDilation;  //侧面区域剔除叉口平台
		m_Platform0=PlatformRegDilation0;     //AB基准线剔除叉口平台

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], PlatformRegDilation, &m_vRgn[rId]);
		}
		//
		HTuple PlatformArea,PlatformRow,PlatformCol;
		area_center(PlatformReg,&PlatformArea,&PlatformRow,&PlatformCol);
		if (PlatformArea>0)
		{
			Hobject PlatformDilation;
			retValue = PlatformArea[0].I();
			dilation_circle(PlatformReg, &PlatformDilation, 2);
			m_vErrorRgn[rId] = PlatformDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pPlatformArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pPlatformArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_PlatformDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("990$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;60$\
					 998;LP;1;100;1;50$\
					 1142;LP;1;50;1;5$\
					 992;FP;1;250;1;50$\
					 1274;LP;1;30;1;1$\
					 1161;FP;0;10;0.1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//侧面斜坡倒角边缘
void CPlugAlgo::P_AsideConeBiasDection (Halcon::Hobject RegsConnected, Halcon::Hobject ConeReg, Halcon::Hobject Platform, Halcon::Hobject *ConeEdge, Halcon::HTuple TopCenTerRow)
{

	Hobject  AroiTSorted, AroiTSelected, RegionBorder;
	Hobject  ConeLine;

	HTuple  Rows, Columns, Sorted, Indices;
	HTuple  ConeCol1, ConeRow1, ConeLineRows, ConeLineColumns;
	HTuple  ConeLineColMax, ColMaxIndex, ConeCol2;
	HTuple  ConeRow2, ConeLinePhi;

	sort_region(RegsConnected, &AroiTSorted, "first_point", "true", "row");
	select_shape(AroiTSorted, &AroiTSelected, "row", "and", TopCenTerRow, 999999);
	//获得区域边界左端点
	boundary(AroiTSelected, &RegionBorder, "outer");
	get_region_points(RegionBorder, &Rows, &Columns);
	tuple_sort(Columns, &Sorted);
	tuple_find(Columns, Sorted.Select(0), &Indices);
	ConeCol1 = Sorted.Select(0);
	ConeRow1 = Rows.Select(Indices);
	ConeCol1 = ConeCol1.Select(0);
	ConeRow1 = ConeRow1.Select(0);
	//获得区域边界右端点
	boundary(AroiTSelected, &RegionBorder, "outer");
	get_region_points(RegionBorder, &Rows, &Columns);
	tuple_sort(Columns, &Sorted);
	tuple_find(Columns, Sorted.Select((Columns.Num())-1), &Indices);
	HTuple ConeCol11,ConeRow11,Dist1,Dist2;
	ConeCol11 = Sorted.Select((Columns.Num())-1);
	ConeRow11 = Rows.Select(Indices);
	ConeCol11 = ConeCol11.Select(0);
	ConeRow11 = ConeRow11.Select(0);

	intersection(ConeReg, Platform, &ConeLine);
	HTuple area,row,col;
	area_center(ConeLine,&area,&row,&col);
	if (area<1)
	{
		return;
	}
	get_region_points(ConeLine, &ConeLineRows, &ConeLineColumns);
	tuple_max(ConeLineColumns, &ConeLineColMax);
	tuple_find(ConeLineColumns, ConeLineColMax, &ColMaxIndex);
	ConeCol2 = ConeLineColMax;
	ConeRow2 = ConeLineRows.Select(ColMaxIndex);
	ConeCol2 = ConeCol2.Select(0);
	ConeRow2 = ConeRow2.Select(0);
	//New
	distance_pp(ConeRow1,ConeCol1,ConeRow2,ConeCol2,&Dist1);
	distance_pp(ConeRow11,ConeCol11,ConeRow2,ConeCol2,&Dist2);
	if (Dist1<=Dist2)
	{
		gen_region_line(&(*ConeEdge), ConeRow1, ConeCol1, ConeRow2, ConeCol2);
	} 
	else
	{
		gen_region_line(&(*ConeEdge), ConeRow11, ConeCol11, ConeRow2, ConeCol2);
	}
	//orientation_region((*ConeEdge), &ConeLinePhi);

	return;
}
void CPlugAlgo::P_BsideConeBiasDection (Halcon::Hobject RegsConnected, Halcon::Hobject ConeReg, Halcon::Hobject Platform, Halcon::Hobject *ConeEdge, Halcon::HTuple TopCenTerRow)
{

	Hobject  AroiTSorted, AroiTSelected, RegionBorder;
	Hobject  ConeLine;

	HTuple  Rows, Columns, Sorted, Indices;
	HTuple  ConeCol1, ConeRow1, ConeLineRows, ConeLineColumns;
	HTuple  ConeLineColMin, ColMaxIndex, ConeCol2;
	HTuple  ConeRow2, ConeLinePhi;

	sort_region(RegsConnected, &AroiTSorted, "first_point", "true", "row");
	select_shape(AroiTSorted, &AroiTSelected, "row", "and", TopCenTerRow, 9999999);
	HTuple iNum;
	count_obj(AroiTSelected,&iNum);
	if (iNum != 1)
	{
		return;
	}

	//获得区域边界右端点
	boundary(AroiTSelected, &RegionBorder, "outer");
	get_region_points(RegionBorder, &Rows, &Columns);
	tuple_sort(Columns, &Sorted);
	tuple_find(Columns, Sorted.Select((Columns.Num())-1), &Indices);
	ConeCol1 = Sorted.Select((Columns.Num())-1);
	ConeRow1 = Rows.Select(Indices);
	ConeCol1 = ConeCol1.Select(0);
	ConeRow1 = ConeRow1.Select(0);
	//获得区域边界左端点
	boundary(AroiTSelected, &RegionBorder, "outer");
	get_region_points(RegionBorder, &Rows, &Columns);
	tuple_sort(Columns, &Sorted);
	tuple_find(Columns, Sorted.Select(0), &Indices);
	HTuple ConeCol11,ConeRow11,Dist1,Dist2;
	ConeCol11 = Sorted.Select(0);
	ConeRow11 = Rows.Select(Indices);
	ConeCol11 = ConeCol11.Select(0);
	ConeRow11 = ConeRow11.Select(0);

	intersection(ConeReg, Platform, &ConeLine);
	HTuple area,row,col;
	area_center(ConeLine,&area,&row,&col);
	if (area<1)
	{
		return;
	}

	get_region_points(ConeLine, &ConeLineRows, &ConeLineColumns);
	tuple_min(ConeLineColumns, &ConeLineColMin);
	tuple_find(ConeLineColumns, ConeLineColMin, &ColMaxIndex);
	ConeCol2 = ConeLineColMin;
	ConeRow2 = ConeLineRows.Select(ColMaxIndex);
	ConeCol2 = ConeCol2.Select(0);
	ConeRow2 = ConeRow2.Select(0);

	//New
	distance_pp(ConeRow1,ConeCol1,ConeRow2,ConeCol2,&Dist1);
	distance_pp(ConeRow11,ConeCol11,ConeRow2,ConeCol2,&Dist2);
	if (Dist1<=Dist2)
	{
		gen_region_line(&(*ConeEdge), ConeRow1, ConeCol1, ConeRow2, ConeCol2);
	} 
	else
	{
		gen_region_line(&(*ConeEdge), ConeRow11, ConeCol11, ConeRow2, ConeCol2);
	}

	return;
}
void CPlugAlgo::P_ABsideConeBiasDection (Halcon::Hobject RegsConnected, Halcon::Hobject ConeReg, Halcon::Hobject Platform, Halcon::Hobject *ConeEdge, Halcon::HTuple TopCenTerCol)
{

	Hobject  AroiTSorted, AroiTSelected, RegionBorder;
	Hobject  ConeLine, ConeEdgeR, ConeEdgeL, ConeEdgeL1;

	HTuple  AroiTNum, i, AroiTArea, AroiTRow;
	HTuple  AroiTCol, Rows, Columns, Sorted, Indices;
	HTuple  ConeRow1, ConeCol1, ConeLineRows, ConeLineColumns;
	HTuple  ConeLineColMax, ColMaxIndex, ConeCol2;
	HTuple  ConeRow2, ConeLinePhiR, ConeLineColMin;
	HTuple  ColMinIndex, ConeLinePhiL;

	sort_region(RegsConnected, &AroiTSorted, "first_point", "true", "column");
	count_obj(AroiTSorted, &AroiTNum);
	for (int i=1; i<=AroiTNum; i++)
	{
		select_obj(AroiTSorted, &AroiTSelected, i);
		area_center(AroiTSelected, &AroiTArea, &AroiTRow, &AroiTCol);
		if (0 != (AroiTCol>TopCenTerCol))
		{
			//获得区域边界端点
			boundary(AroiTSelected, &RegionBorder, "outer");
			get_region_points(RegionBorder, &Rows, &Columns);
			tuple_sort(Rows, &Sorted);
			tuple_find(Rows, Sorted.Select((Rows.Num())-1), &Indices);
			ConeRow1 = Sorted.Select((Rows.Num())-1);
			ConeCol1 = Columns.Select(Indices.Select(0));
			ConeRow1 = ConeRow1.Select(0);
			ConeCol1 = ConeCol1.Select(0);

			intersection(ConeReg, Platform, &ConeLine);
			HTuple area,row,col;
			area_center(ConeLine,&area,&row,&col);
			if (area<1)
			{
				return;
			}

			get_region_points(ConeLine, &ConeLineRows, &ConeLineColumns);

			tuple_max(ConeLineColumns, &ConeLineColMax);
			tuple_find(ConeLineColumns, ConeLineColMax, &ColMaxIndex);
			ConeCol2 = ConeLineColMax;
			ConeRow2 = ConeLineRows.Select(ColMaxIndex.Select(0));

			gen_region_line(&ConeEdgeR, ConeRow1-10, ConeCol1+15, ConeRow2, ConeCol2+10);
			//orientation_region(ConeEdgeR, &ConeLinePhiR);
		}
		else
		{
			//获得区域边界端点
			boundary(AroiTSelected, &RegionBorder, "outer");
			get_region_points(RegionBorder, &Rows, &Columns);
			tuple_sort(Rows, &Sorted);
			tuple_find(Rows, Sorted.Select((Rows.Num())-1), &Indices);
			ConeRow1 = Sorted.Select((Rows.Num())-1);
			ConeCol1 = Columns.Select(Indices.Select(0));
			ConeRow1 = ConeRow1.Select(0);
			ConeCol1 = ConeCol1.Select(0);

			intersection(ConeReg, Platform, &ConeLine);
			HTuple area,row,col;
			area_center(ConeLine,&area,&row,&col);
			if (area<1)
			{
				return;
			}

			get_region_points(ConeLine, &ConeLineRows, &ConeLineColumns);
			tuple_min(ConeLineColumns, &ConeLineColMin);
			tuple_find(ConeLineColumns, ConeLineColMin, &ColMinIndex);
			ConeCol2 = ConeLineColMin;
			ConeRow2 = ConeLineRows.Select(ColMinIndex.Select(0));

			gen_region_line(&ConeEdgeL, ConeRow1-10, ConeCol1-10, ConeRow2, 
				ConeCol2-10);
			gen_region_line(&ConeEdgeL1, ConeRow1, ConeCol1+10, ConeRow2, ConeCol2+5);
			//orientation_region(ConeEdgeL, &ConeLinePhiL);
		}
	}
	union2(ConeEdgeL, ConeEdgeR, &(*ConeEdge));
	return;
}
/********************************************************************
**函数名：T20_SideConeBiasDetectAlgo
**功  能：针对双叉胶塞拐角边缘提取
********************************************************************/
STDMETHODIMP CPlugAlgo::T20_SideConeBiasDetectAlgo(VARIANT* rgnId, VARIANT* pConeDeepth, VARIANT* pConeArea)
{
	int rId           = (int)rgnId->fltVal;
	int ConeDeepth    = (int)pConeDeepth->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||(m_PlatformReg.Id() == H_EMPTY_REGION)||(m_ABEdgeM.Id() == H_EMPTY_REGION)||(m_TopRegions.Id() == H_EMPTY_REGION)||(m_TopRow.Num()!=1))
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pConeArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		HTuple Area1, Row, Column;
		Hobject ConeEllipse,ConeReg;;
		area_center(m_PlatformReg, &Area1, &Row, &Column);
		if (0 != (Area1>0))
		{

			//叉口角度判断
			HTuple a,b,c;
			tuple_rad(20, &a);
			tuple_rad(160, &b);
			tuple_rad(180, &c);

			//*锥口深度
			HTuple ConeArea, ConeRow, ConeCol;
			move_region(m_ABEdgeM, &ConeReg, -ConeDeepth, 0);
			//*锥口基准线Row坐标
			area_center(ConeReg, &ConeArea, &ConeRow, &ConeCol);
			if (0 != ((m_Angle>=0)&&(m_Angle<=a)))
			{
				P_AsideConeBiasDection(m_TopRegions, ConeReg, m_PlatformReg, &ConeEllipse, m_TopRow);
			}
			else if (0 != ((m_Angle>a)&&(m_Angle<=b)))
			{
				P_ABsideConeBiasDection(m_TopRegions, ConeReg, m_PlatformReg, &ConeEllipse, m_TopCol);
			}
			else if (0 != ((m_Angle>b)&&(m_Angle<=c)))
			{
				P_BsideConeBiasDection(m_TopRegions, ConeReg, m_PlatformReg, &ConeEllipse, m_TopRow);
			}
		}
		else
		{
			gen_empty_region(&ConeEllipse);
		}
		m_ConeEllipse=ConeEllipse;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], ConeReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], ConeEllipse, &m_vRgn[rId]);
		}
		//
		HTuple ConeArea,ConeRow,ConeCol;
		area_center(ConeEllipse,&ConeArea,&ConeRow,&ConeCol);

		retValue = ConeArea[0].I();
		m_vErrorRgn[rId] = ConeEllipse;
		retValue.Detach(pConeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pConeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pConeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_SideConeBiasDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1262$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 1263;LP;0;250;1;60");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/************************************************************************
**函数名：T20_SlopEdgeDetectAlgo
**功  能：（1）双叉20胶塞的斜坡边缘提取；（2）得到整个颈部区域（未剔除花纹的）
************************************************************************/
STDMETHODIMP CPlugAlgo::T20_SlopEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pThreshold,VARIANT* pTopSlopEdgeArea)
{
	//花纹位置波动大，靠近顶部斜坡区域时，采用本算子 
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int Threshold   = (int)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_Platform0.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//画一个圆形区域
		Hobject Image = m_crtImg;
		//
		Hobject TopSlopEdge,TopSlopEdgeDilation,TopSlopEdgeDiff;
		move_region(m_ABEdgeM, &TopSlopEdge, -MoveSize, 0);
		dilation_rectangle1(TopSlopEdge, &TopSlopEdgeDilation, 1, SearchSize); 
		difference(TopSlopEdgeDilation, m_PlatformReg, &TopSlopEdgeDiff);

		Hobject TopSlopSearchReg,TopSlopImageReduced;
		intersection(TopSlopEdgeDiff, m_ROI, &TopSlopSearchReg);
		reduce_domain(Image, TopSlopSearchReg, &TopSlopImageReduced);
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;;
		//
		HTuple Area,Row,Col;
		area_center(TopSlopSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopSlopEdgeArea);
			return S_FALSE;
		}
		R_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 4, 1, Threshold, "positive", "last",&DefinedRow1, &DefinedCol1);

		P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 4, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*2)/3))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
		}

		//
		Hobject TopSlopEdgePoints;
		HTuple TopSlopEdgeArea, TopSlopEdgeRow, TopSlopEdgeCol;
		gen_region_points(&TopSlopEdgePoints, DefinedRow, DefinedCol);
		area_center(TopSlopEdgePoints, &TopSlopEdgeArea, &TopSlopEdgeRow, &TopSlopEdgeCol);
		m_TopSlopEdgePoints=TopSlopEdgePoints;
		m_TopSlopEdgeRow=TopSlopEdgeRow;

		//ARegionT为没有提出花纹的整个颈部区域
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);

		//剔除叉口区域的AB基准线
		Hobject ABEdgeDiff;
		HTuple ABEdgeArea, ABEdgeRow, ABEdgeCol;
		difference(m_ABEdgeM,m_Platform0, &ABEdgeDiff);
		area_center(ABEdgeDiff, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		m_ABEdgeRow=ABEdgeRow;

		//***
		HTuple DilationSize;
		DilationSize = ABEdgeRow-m_TopSlopEdgeRow-5;
		move_region(m_ABEdgeM, &ABEdgeMovedCenter, (-DilationSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, DilationSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//侧面缺口，密封面干扰
		if(DilationSize<=0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopSlopEdgeArea);
			return S_FALSE;
		}
		Hobject ARegionTClosing,ARegionTOpening;
		closing_rectangle1(ARegionT, &ARegionTClosing, 20, 20);
		opening_rectangle1(ARegionTClosing, &ARegionTOpening, 1, (DilationSize*1)/3);

		//无叉口平台时，剔除叉口下部区域
		HTuple PlatArea, PlatRow, PlatColumn;
		area_center(m_PlatformReg, &PlatArea, &PlatRow, &PlatColumn);
		if (0 != (PlatArea==0))
		{
			HTuple innerRow1, innerCol1, innerRow2, innerCol2,outRow1, outCol1, outRow2, outCol2;
			inner_rectangle1(ARegionTOpening, &innerRow1, &innerCol1, &innerRow2, &innerCol2);
			smallest_rectangle1(ARegionT, &outRow1, &outCol1, &outRow2, &outCol2);
			//gen_rectangle1(&Rectangle2, outRow1, outCol1, outRow2, outCol2);
			clip_region(ARegionT, &ARegionT, outRow1, innerCol1, outRow2, innerCol2);
		}
		else
		{
			clip_region_rel(ARegionTOpening, &ARegionT, 1, 1, 5, 5);
		}

		m_ARegionT=ARegionT;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TopSlopEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopSlopSearchReg, &m_vRgn[rId]);
		}
		//
		if (TopSlopEdgeArea>0)
		{
			Hobject TopSlopEdgePointsDilation;
			retValue = TopSlopEdgeArea[0].I();
			dilation_circle(TopSlopEdgePoints, &TopSlopEdgePointsDilation, 2);
			m_vErrorRgn[rId] = TopSlopEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopSlopEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopSlopEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_SlopEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1166$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;260;1;200$\
					 998;LP;1;100;1;30$\
					 1165;LP;1;60;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/********************************************************************
**函数名：T20_ConPatternCoordAlgo
**功  能：计算双叉胶塞的花纹位置
********************************************************************/
STDMETHODIMP CPlugAlgo::T20_ConPatternCoordAlgo(VARIANT* rgnId, VARIANT* pEllipseMoveSize,VARIANT* pEdgeMoveSize,VARIANT* pSearchSize,VARIANT* pGrayValue,VARIANT* pWidthRadiusSet,VARIANT* pAngleT1,VARIANT* pAngleT2, VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int EllipseMoveSize    = (int)pEllipseMoveSize->fltVal;
	//int OpeningSize    = (int)pOpeningSize->fltVal;

	int EdgeMoveSize    = (int)pEdgeMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	float GrayValue    =(float)pGrayValue->fltVal;

	float WidthRadiusSet    =(float)pWidthRadiusSet->fltVal;
	float AngleT1    =(float)pAngleT1->fltVal;
	float AngleT2    =(float)pAngleT2->fltVal;

	if((int)WidthRadiusSet-WidthRadiusSet==0)
	{
		WidthRadiusSet=WidthRadiusSet+(float)0.5;
	}
	if((int)AngleT1-AngleT1==0)
	{
		AngleT1=AngleT1+(float)0.5;
	}
	if((int)AngleT2-AngleT2==0)
	{
		AngleT2=AngleT2+(float)0.5;
	}

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_WholeRoi.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{   
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//圆形区域
		Hobject crtImg = m_crtImg;
		Hobject crtImgReduced;
		reduce_domain(crtImg, rgn, &crtImgReduced);

		//基准椭圆
		Hobject RegionMoved4,Rectangle,RegionIntersection;
		HTuple Area1, Row1, Column1;
		move_region(m_ABEllipse, &RegionMoved4, -EllipseMoveSize, 0);
		area_center(RegionMoved4, &Area1, &Row1, &Column1);
		gen_rectangle1(&Rectangle, Row1-70, 10, Row1+150, m_imgWidth-10);
		intersection(Rectangle, m_WholeRoi, &RegionIntersection);

		Hobject RegionOpening,Rectangle1;
		HTuple Row11, Column11, Row2, Column2;
		opening_rectangle1(RegionIntersection, &RegionOpening, 3, 60);
		smallest_rectangle1(RegionOpening, &Row11, &Column11, &Row2, &Column2);
		gen_rectangle1(&Rectangle1, Row11, Column11, Row2, Column2);
		//
		m_WholeColumnL=Column11;
		m_WholeColumnR=Column2;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
		}
		//基准线
		Hobject RegionMoved,RegionDilation1,ImageReduced;
		move_region(m_ABEdgeM, &RegionMoved, -EdgeMoveSize, 0);
		dilation_rectangle1(RegionMoved, &RegionDilation1, 3, SearchSize);
		reduce_domain(crtImgReduced, RegionDilation1, &ImageReduced);

		Hobject Region1,RegionDilation2,RegionOpening2;
		HTuple Row12, Column12, Row21, Column21;
		threshold(ImageReduced, &Region1, GrayValue, 255);
		dilation_rectangle1(Region1, &RegionDilation2, 3, 7);
		opening_rectangle1(RegionDilation2, &RegionOpening2, 3, 21);
		Hobject ConnectedRegions2,SelectedRegions1;
		connection(RegionOpening2, &ConnectedRegions2);
		select_shape_std(ConnectedRegions2, &SelectedRegions1, "max_area", 70);
		smallest_rectangle1(SelectedRegions1, &Row12, &Column12, &Row21, &Column21);
		//
		m_PlatColumnL=Column12;
		m_PlatColumnR=Column21;
		//空区域也有数值
		Hobject Rectangle2;
		gen_empty_region(&Rectangle2);
		HTuple area,row,col;
		area_center(SelectedRegions1,&area,&row,&col);
		if (area!=0 ||area.Num()!=0)
		{
			gen_rectangle1(&Rectangle2, Row12, Column12, Row21, Column21);
		}

		HTuple Rect1CenterCol,Rect2CenterCol;
		Rect1CenterCol = (Column11+Column2)/2.0;
		Rect2CenterCol = (Column12+Column21)/2.0;

		//开口角度 22.5,边缘到凸点1角度42.5  边缘到凸点2角度91.5.胶塞在图片中的所占比例，以下的三个值需要根据实际情况设定。
		//HTuple WidthRadiusSet;
		//WidthRadiusSet = 170.5;
		//GapAngle = 22.5;
		//EdgePointAngleDiff1 = 42.5;
		//EdgePointAngleDiff2 = 91.5;

		float EdgePointAngleDiff1,EdgePointAngleDiff2;
		EdgePointAngleDiff1 = AngleT1;
		EdgePointAngleDiff2 = AngleT2;

		HTuple ColCenterSet,WidthEdgeDist,EdgeAngle,EdgeAngle360,EdgeAngleT1,EdgeAngleT2,ColT1,ColT2,Switch;
		HTuple EdgeAngle1,EdgeAngle360_1,EdgeAngleT3,EdgeAngleT4,ColT3,ColT4,WidthEdgeDist1,ColDiff,offset;
		Hobject RegionLines1,RegionLines2,RegionLines3,RegionLines4;

		//标记m_Switch
		if (0 != ((Column21-Column12)>5))
		{
			//调试显示
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], SelectedRegions1, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], Rectangle2, &m_vRgn[rId]);
			}
			if (0 != (((Rect1CenterCol-Rect2CenterCol).Abs())>65))
			{
				//双叉口，存在半径变小的情况!
				ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
				if (0 != (ColDiff>WidthRadiusSet-20))
				{
					offset = 10;
				}
				else if(0 != (ColDiff>WidthRadiusSet-30))
				{
					offset = 5;
				}
				else
				{
					offset = 0;
				}
				if (0 != (Rect1CenterCol>=Rect2CenterCol))
				{
					m_Switch = 1;
					ColCenterSet = Column2-WidthRadiusSet;
					WidthEdgeDist = Column21-ColCenterSet-offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360+EdgePointAngleDiff2;
					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 90.0;
					}
					if (0 != (EdgeAngleT2>90.0))
					{
						EdgeAngleT2 = 90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					if (0 != (EdgeAngleT2<-90.0))
					{
						EdgeAngleT2 = -90.0;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines2, Row2, ColT2, Row2+130, ColT2);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT2=EdgeAngleT2;

					m_ColT1=ColT1;
					m_ColT2=ColT2;
					//
					gen_empty_region(&RegionLines3);
					gen_empty_region(&RegionLines4);
				}
				else if (0 != (Rect1CenterCol<Rect2CenterCol))
				{
					m_Switch = 2;
					ColCenterSet = Column11+WidthRadiusSet;
					WidthEdgeDist = Column12-ColCenterSet+offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360-EdgePointAngleDiff2;
					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 90.0;
					}
					if (0 != (EdgeAngleT2>90.0))
					{
						EdgeAngleT2 = 90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					if (0 != (EdgeAngleT2<-90.0))
					{
						EdgeAngleT2 = -90.0;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines2, Row2, ColT2, Row2+130, ColT2);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT2=EdgeAngleT2;

					m_ColT1=ColT1;
					m_ColT2=ColT2;
					//
					gen_empty_region(&RegionLines3);
					gen_empty_region(&RegionLines4);
				}
			}
			else
			{

				if (0 != (Rect1CenterCol>=Rect2CenterCol))
				{
					m_Switch = 3;

					ColCenterSet = Column2-WidthRadiusSet;
					//补偿
					ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
					if (0 != (ColDiff<10))
					{
						offset = 30;
					}
					else if (0 != (ColDiff<30))
					{
						offset = 20;
					}
					else if (0 != (ColDiff<55))
					{
						offset = 10;
					}
					else
					{
						offset = 0;
					}

					//1
					WidthEdgeDist = (Column21-ColCenterSet)+offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						m_ColT3=m_imgWidth/2.0;
						m_ColT4=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360+EdgePointAngleDiff2;
					if (0 != (EdgeAngleT1>90))
					{
						EdgeAngleT1 = 90;
					}
					if (0 != (EdgeAngleT2>90))
					{
						EdgeAngleT2 = 90;
					}
					if (0 != (EdgeAngleT1<-90))
					{
						EdgeAngleT1 = -90;
					}
					if (0 != (EdgeAngleT2<-90))
					{
						EdgeAngleT2 = -90;
					}

					//补偿
					if (0 != (ColDiff<10))
					{
						offset = 30;
					}
					else if (0 != (ColDiff<30))
					{
						offset = 20;
					}
					else if (0 != (ColDiff<55))
					{
						offset = 10;
					}
					else
					{
						offset = 0;
					}

					//2
					WidthEdgeDist = (Column12-ColCenterSet)-offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						m_ColT3=m_imgWidth/2.0;
						m_ColT4=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle1 = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360_1 = (180*EdgeAngle1)/3.14156;
					EdgeAngleT3 = EdgeAngle360_1-EdgePointAngleDiff1;
					EdgeAngleT4 = EdgeAngle360_1-EdgePointAngleDiff2;
					if (0 != (EdgeAngleT3>90))
					{
						EdgeAngleT3 = 90;
					}
					if (0 != (EdgeAngleT4>90))
					{
						EdgeAngleT4 = 90;
					}
					if (0 != (EdgeAngleT3<-90))
					{
						EdgeAngleT3 = -90;
					}
					if (0 != (EdgeAngleT4<-90))
					{
						EdgeAngleT4 = -90;
					}

					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
					ColT3 = (WidthRadiusSet*((EdgeAngleT3.Rad()).Sin()))+ColCenterSet;
					ColT4 = (WidthRadiusSet*((EdgeAngleT4.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines2, Row2, ColT2, Row2+130, ColT2);
					//
					gen_region_line(&RegionLines3, Row2, ColT3, Row2+130, ColT3);
					gen_region_line(&RegionLines4, Row2, ColT4, Row2+130, ColT4);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT2=EdgeAngleT2;
					m_EdgeAngleT3=EdgeAngleT3;
					m_EdgeAngleT4=EdgeAngleT4;

					m_ColT1=ColT1;
					m_ColT2=ColT2;
					m_ColT3=ColT3;
					m_ColT4=ColT4;

				}
				else if (0 != (Rect1CenterCol<Rect2CenterCol))
				{
					m_Switch = 4;

					ColCenterSet = Column11+WidthRadiusSet;
					//补偿
					ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
					if (0 != (ColDiff<10))
					{
						offset = 30;
					}
					else if (0 != (ColDiff<30))
					{
						offset = 20;
					}
					else if (0 != (ColDiff<55))
					{
						offset = 10;
					}
					else
					{
						offset = 0;
					}
					//1
					WidthEdgeDist = (Column12-ColCenterSet)-offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						m_ColT3=m_imgWidth/2.0;
						m_ColT4=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;
					EdgeAngleT2 = EdgeAngle360-EdgePointAngleDiff2;

					if (0 != (EdgeAngleT1>90))
					{
						EdgeAngleT1 = 90;
					}
					if (0 != (EdgeAngleT2>90))
					{
						EdgeAngleT2 = 90;
					}
					if (0 != (EdgeAngleT1<-90))
					{
						EdgeAngleT1 = -90;
					}
					if (0 != (EdgeAngleT2<-90))
					{
						EdgeAngleT2 = -90;
					}

					//补偿
					if (0 != (ColDiff<10))
					{
						offset = 30;
					}
					else if (0 != (ColDiff<30))
					{
						offset = 20;
					}
					else if (0 != (ColDiff<55))
					{
						offset = 10;
					}
					else
					{
						offset = 0;
					}
					//2
					WidthEdgeDist1 = (Column21-ColCenterSet)+offset;
					if (WidthEdgeDist1.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						m_ColT2=m_imgWidth/2.0;
						m_ColT3=m_imgWidth/2.0;
						m_ColT4=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle1 = (WidthEdgeDist1/WidthRadiusSet).Asin();
					EdgeAngle360_1 = (180*EdgeAngle1)/3.14156;
					EdgeAngleT3 = EdgeAngle360_1+EdgePointAngleDiff1;
					EdgeAngleT4 = EdgeAngle360_1+EdgePointAngleDiff2;
					//
					if (0 != (EdgeAngleT3>90))
					{
						EdgeAngleT3 = 90;
					}
					if (0 != (EdgeAngleT4>90))
					{
						EdgeAngleT4 = 90;
					}
					if (0 != (EdgeAngleT3<-90))
					{
						EdgeAngleT3 = -90;
					}
					if (0 != (EdgeAngleT4<-90))
					{
						EdgeAngleT4 = -90;
					}

					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					ColT2 = (WidthRadiusSet*((EdgeAngleT2.Rad()).Sin()))+ColCenterSet;
					ColT3 = (WidthRadiusSet*((EdgeAngleT3.Rad()).Sin()))+ColCenterSet;
					ColT4 = (WidthRadiusSet*((EdgeAngleT4.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines2, Row2, ColT2, Row2+130, ColT2);
					//
					gen_region_line(&RegionLines3, Row2, ColT3, Row2+130, ColT3);
					gen_region_line(&RegionLines4, Row2, ColT4, Row2+130, ColT4);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT2=EdgeAngleT2;
					m_EdgeAngleT3=EdgeAngleT3;
					m_EdgeAngleT4=EdgeAngleT4;

					m_ColT1=ColT1;
					m_ColT2=ColT2;
					m_ColT3=ColT3;
					m_ColT4=ColT4;
				}

			}
		}
		else
		{
			ColT1 = -1;
			m_Switch=0;
		}
		Hobject ConPatternRect;
		if (ColT1==-1)
		{
			gen_empty_region(&ConPatternRect);
			m_ColT1=m_imgWidth/2.0;
			m_ColT2=m_imgWidth/2.0;
			m_ColT3=m_imgWidth/2.0;
			m_ColT4=m_imgWidth/2.0;
		} 
		else
		{
			union2(RegionLines1,RegionLines2,&ConPatternRect);
			union2(ConPatternRect,RegionLines3,&ConPatternRect);
			union2(ConPatternRect,RegionLines4,&ConPatternRect);
			union1(ConPatternRect,&ConPatternRect);

		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], ConPatternRect, &m_vRgn[rId]);
		}
		//
		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(ConPatternRect, &StripeRegArea, &StripeRegRow, &StripeRegColumn);
		if (StripeRegArea>0)
		{
			retValue = ColT1[0].I();
			m_vErrorRgn[rId] = ConPatternRect;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_ConPatternCoordAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1193$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1186;LP;0;300;1;190$\
					 1187;LP;1;150;1;30$\
					 998;LP;1;50;1;80$\
					 992;FP;1;250;0.5;60$\
					 1191;FP;1.5;300.5;0.5;170.5$\
					 1188;FP;1.5;300.5;0.5;42.5$\
					 1189;FP;1.5;300.5;0.5;91.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_ConPatternSearchRegUpAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pHDilationSize,VARIANT* pSearchSize,VARIANT*pClipSize)
{
	//上排圆形花纹搜索区域
	int id = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;
	int HDilationSize   = (int)pHDilationSize->fltVal;
	int SearchSize =(int)pSearchSize->fltVal;

	int ClipSize =(int)pClipSize->fltVal;//靠近边缘的搜索区域、进行剔除

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_ABEdgeM.Id()==H_EMPTY_REGION||m_ROI.Id()==H_EMPTY_REGION||m_Switch==0||m_ColT1.Num()!=1||m_ColT2.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		HTuple area,row,col;
		area_center(m_ROI,&area,&row,&col);
		if (area==0 ||area.Num()==0)
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		HTuple LeftCol,RightCol;
		HTuple RoiRow1,RoiColumn1,RoiRow2,RoiColumn2;
		smallest_rectangle1(m_ROI,&RoiRow1, &RoiColumn1, &RoiRow2, &RoiColumn2);

		Hobject ABEdgeMoved,SearchReg,SearchRegDiff;
		move_region(m_ABEdgeM, &ABEdgeMoved, -MoveSize, 0);
		//垂向膨胀
		dilation_rectangle1(ABEdgeMoved, &SearchReg, 1, SearchSize);
		intersection(SearchReg, m_ROI, &SearchReg);
		m_PatternEdge=ABEdgeMoved;

		Hobject Rect1,Rect2,ObjectsConcat;
		gen_rectangle1(&Rect1, RoiRow1, m_ColT1-50, RoiRow2, m_ColT1+50);
		if (HDilationSize>=0)
		{
			dilation_rectangle1(Rect1,&Rect1,HDilationSize+1,1);
		} 
		else
		{
			erosion_rectangle1(Rect1,&Rect1,abs(HDilationSize),1);
		}
		intersection(Rect1, SearchReg, &Rect1);

		gen_rectangle1(&Rect2, RoiRow1, m_ColT2-50, RoiRow2, m_ColT2+50);
		if (HDilationSize>=0)
		{
			dilation_rectangle1(Rect2,&Rect2,HDilationSize+1,1);
		} 
		else
		{
			erosion_rectangle1(Rect2,&Rect2,abs(HDilationSize),1);
		}
		intersection(Rect2, SearchReg, &Rect2);

		if (0 != ((m_Switch==1)||(m_Switch==2)))
		{
			//剔除90、-90度附近的角度
			gen_empty_region(&ObjectsConcat);
			if (0 != (m_EdgeAngleT1<0))
			{
				if (0 != (((m_EdgeAngleT1+90).Abs())>=ClipSize))
				{

					concat_obj(Rect1, ObjectsConcat, &ObjectsConcat);
				}
			}
			else
			{
				if (0 != (((m_EdgeAngleT1-90).Abs())>=ClipSize))
				{

					concat_obj(Rect1, ObjectsConcat, &ObjectsConcat);
				}
			}

			if (0 != (m_EdgeAngleT2<0))
			{
				if (0 != (((m_EdgeAngleT2+90).Abs())>=ClipSize))
				{

					concat_obj(Rect2, ObjectsConcat, &ObjectsConcat);
				}
			}
			else
			{
				if (0 != (((m_EdgeAngleT2-90).Abs())>=ClipSize))
				{

					concat_obj(Rect2, ObjectsConcat, &ObjectsConcat);
				}
			}

		}
		else if (0 != (m_Switch==3||(m_Switch==4)))
		{
			//剔除90、-90度及其附近的角度
			HTuple ColT;
			ColT = HTuple();
			if (0 != (HTuple(m_EdgeAngleT1!=90).And(m_EdgeAngleT1!=-90)))
			{
				if (0 != (m_EdgeAngleT1<0))
				{
					if (0 != (((m_EdgeAngleT1+90).Abs())>=ClipSize))
					{
						ColT = m_ColT1.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT1-90).Abs())>=ClipSize))
					{
						ColT = m_ColT1.Concat(ColT);
					}
				}
			}
			if (0 != (HTuple(m_EdgeAngleT2!=90).And(m_EdgeAngleT2!=-90)))
			{
				if (0 != (m_EdgeAngleT2<0))
				{
					if (0 != (((m_EdgeAngleT2+90).Abs())>=ClipSize))
					{
						ColT = m_ColT2.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT2-90).Abs())>=ClipSize))
					{
						ColT = m_ColT2.Concat(ColT);
					}
				}
			}
			if (0 != (HTuple(m_EdgeAngleT3!=90).And(m_EdgeAngleT3!=-90)))
			{
				if (0 != (m_EdgeAngleT3<0))
				{
					if (0 != (((m_EdgeAngleT3+90).Abs())>=ClipSize))
					{
						ColT = m_ColT3.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT3-90).Abs())>=ClipSize))
					{
						ColT = m_ColT3.Concat(ColT);
					}
				}
			}
			if (0 != (HTuple(m_EdgeAngleT4!=90).And(m_EdgeAngleT4!=-90)))
			{
				if (0 != (m_EdgeAngleT4<0))
				{
					if (0 != (((m_EdgeAngleT4+90).Abs())>=ClipSize))
					{
						ColT = m_ColT4.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT4-90).Abs())>=ClipSize))
					{
						ColT = m_ColT4.Concat(ColT);
					}
				}
			}
			HTuple Num;
			Num = ColT.Num();
			if (0 != (Num<1))
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}
			Hobject Rect;
			gen_empty_region(&ObjectsConcat);
			for (int i=0; i<=Num-1; i ++)
			{
				gen_rectangle1(&Rect, RoiRow1, (ColT.Select(i))-50, RoiRow2, (ColT.Select(i))+50);
				if (HDilationSize>=0)
				{
					dilation_rectangle1(Rect,&Rect,HDilationSize+1,1);
				} 
				else
				{
					erosion_rectangle1(Rect,&Rect,abs(HDilationSize),1);
				}
				intersection(Rect, SearchReg, &Rect);
				concat_obj(Rect, ObjectsConcat, &ObjectsConcat);
			}
		}
		//m_StripeReg=ConReg;
		m_vRgn[id] = ObjectsConcat;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_ConPatternSearchRegUpAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1269$\
					 167;B$\
					 1190;LP;50;350;1;135$\
					 994;LP;-30;30;1;1$\
					 995;LP;10;160;1;90$\
					 1286;LP;2;15;1;11"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_CirclePatternDetectAlgo(VARIANT* rgnId,VARIANT* pMaskSize,VARIANT* pSeriousBlackPointDynThresh,VARIANT* pSeriousWhitePointDynThresh,VARIANT* pThredValue,VARIANT* pStripeArea)
{
	//圆形花纹提取 mean_image
	int rId           = (int)rgnId->fltVal;
	int MaskSize = (int)pMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float) pSeriousBlackPointDynThresh->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;

	int ThredValue = (int) pThredValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		Hobject EmptyRegion;
		gen_empty_region(&EmptyRegion);
		m_UpReg=EmptyRegion;
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject CircleRegions,RectSelected,ImageReduced5,ExpandedImage1,ImageReduced6,ImageMean1,BlackRegion,BlackRegionFillUp,BlackRegionConnected,SelectedRegions1;
		Hobject WhiteRegionDyn,WhiteRegionDynFillUp,WhiteRegionConnected,SelectedRegions2,RegionUnion,RegionTrans,RegionTransDilation;
		HTuple Number,RectArea, RectRow, RectColumn,BlackMean, BlackDeviation,WhiteMean, WhiteDeviation,MeanDiff;
		gen_empty_region(&CircleRegions);
		count_obj(rgn, &Number);

		for (int i=1; i<=Number; i++)
		{
			select_obj(rgn, &RectSelected, i);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if (0 != (RectArea>0))
			{
				reduce_domain(ImageScaleMax, RectSelected, &ImageReduced5);

				expand_domain_gray(ImageReduced5, &ExpandedImage1, 3);
				reduce_domain(ExpandedImage1, RectSelected, &ImageReduced6);
				mean_image(ImageReduced6, &ImageMean1, 5, MaskSize);
				//black
				dyn_threshold(ImageReduced6, ImageMean1, &BlackRegion, SeriousBlackPointDynThresh, "dark");
				fill_up(BlackRegion, &BlackRegionFillUp);
				connection(BlackRegionFillUp, &BlackRegionConnected);
				select_shape_std(BlackRegionConnected, &SelectedRegions1, "max_area", 70);
				//white
				dyn_threshold(ImageReduced6, ImageMean1, &WhiteRegionDyn, SeriousWhitePointDynThresh, "light");
				fill_up(WhiteRegionDyn, &WhiteRegionDynFillUp);
				connection(WhiteRegionDynFillUp, &WhiteRegionConnected);
				select_shape_std(WhiteRegionConnected, &SelectedRegions2, "max_area", 70);

				//依据圆形花纹上下白黑区域的灰度差，进行筛选
				intensity(SelectedRegions1, ImageScaleMax, &BlackMean, &BlackDeviation);
				intensity(SelectedRegions2, ImageScaleMax, &WhiteMean, &WhiteDeviation);
				MeanDiff = WhiteMean-BlackMean;

				if (0 != (MeanDiff>ThredValue))
				{
					union2(SelectedRegions1, SelectedRegions2, &RegionUnion);
					shape_trans(RegionUnion, &RegionTrans, "ellipse");
					dilation_rectangle1(RegionTrans, &RegionTransDilation, 10, 1);
				}
				else
				{
					gen_empty_region(&RegionTransDilation);
				}
				concat_obj(RegionTransDilation, CircleRegions, &CircleRegions);

			}		
		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], CircleRegions, &m_vRgn[rId]); 
		}
		union1(CircleRegions,&CircleRegions);
		m_UpReg=CircleRegions;

		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(CircleRegions, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = CircleRegions;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_CirclePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1264$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1265;LP;3;150;2;85$\
					 1266;LP;1;250;1;5$\
					 1267;LP;1;250;1;30$\
					 1268;LP;1;100;1;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_CirclePatternDetectAlgo1(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pSeriousBlackPointDynThresh,VARIANT* pSeriousWhitePointDynThresh,VARIANT* pThredValue,VARIANT* pStripeArea)
{
	//圆形花纹提取 move_image
	int rId           = (int)rgnId->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;
	float SeriousBlackPointDynThresh = (float) pSeriousBlackPointDynThresh->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;

	int ThredValue = (int) pThredValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		Hobject EmptyRegion;
		gen_empty_region(&EmptyRegion);
		m_UpReg=EmptyRegion;
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject CircleRegions,RectSelected,ImageReduced5,ExpandedImage1,ImageReduced6;
		Hobject RegionUnion,RegionTrans,RegionTransDilation;
		HTuple Number,RectArea, RectRow, RectColumn,BlackMean, BlackDeviation,WhiteMean, WhiteDeviation,MeanDiff;
		HTuple HomMat2D;
		Hobject ImageAffinTrans,BlackRegion,BlackRegionFillUp,RegionMoved1,BlackRegionIntersection,BlackRegionConnected,SelectedRegions1;
		HTuple HomMat2D1;
		Hobject WhiteRegionDyn,WhiteRegionDynFillUp,WhiteRegionIntersection,WhiteRegionConnected,SelectedRegions2; 
		gen_empty_region(&CircleRegions);
		count_obj(rgn, &Number);
		for (int i=1; i<=Number; i++)
		{
			select_obj(rgn, &RectSelected, i);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if (0 != (RectArea>0))
			{
				reduce_domain(ImageScaleMax, RectSelected, &ImageReduced5);
				median_image(ImageReduced5, &ImageReduced5, "circle", 2, "mirrored");
				expand_domain_gray(ImageReduced5, &ExpandedImage1, 3);
				reduce_domain(ExpandedImage1, RectSelected, &ImageReduced6);

				//*method2
				//black
				vector_angle_to_rigid(RectRow, RectColumn, 0, RectRow+MoveSize, RectColumn, 0, &HomMat2D);
				affine_trans_image(ImageReduced6, &ImageAffinTrans, HomMat2D, "constant", "false");
				dyn_threshold(ImageReduced6, ImageAffinTrans, &BlackRegion, SeriousBlackPointDynThresh, "dark");
				fill_up(BlackRegion, &BlackRegionFillUp);
				move_region(RectSelected, &RegionMoved1, MoveSize, 0);
				intersection(BlackRegionFillUp, RegionMoved1, &BlackRegionIntersection);
				connection(BlackRegionIntersection, &BlackRegionConnected);
				select_shape_std(BlackRegionConnected, &SelectedRegions1, "max_area", 70);
				//white
				vector_angle_to_rigid(RectRow, RectColumn, 0, RectRow-MoveSize, RectColumn, 0, &HomMat2D1);
				affine_trans_image(ImageReduced6, &ImageAffinTrans, HomMat2D1, "constant", "false");
				dyn_threshold(ImageReduced6, ImageAffinTrans, &WhiteRegionDyn, SeriousWhitePointDynThresh, "light");
				fill_up(WhiteRegionDyn, &WhiteRegionDynFillUp);
				move_region(RectSelected, &RegionMoved1, -MoveSize, 0);
				intersection(WhiteRegionDynFillUp, RegionMoved1, &WhiteRegionIntersection);
				connection(WhiteRegionIntersection, &WhiteRegionConnected);
				select_shape_std(WhiteRegionConnected, &SelectedRegions2, "max_area", 70);

				//依据圆形花纹上下白黑区域的灰度差，进行筛选
				intensity(SelectedRegions1, ImageScaleMax, &BlackMean, &BlackDeviation);
				intensity(SelectedRegions2, ImageScaleMax, &WhiteMean, &WhiteDeviation);
				MeanDiff = WhiteMean-BlackMean;

				if (0 != (MeanDiff>ThredValue))
				{
					union2(SelectedRegions1, SelectedRegions2, &RegionUnion);
					shape_trans(RegionUnion, &RegionTrans, "ellipse");
					dilation_rectangle1(RegionTrans, &RegionTransDilation, 10, 1);
				}
				else
				{
					gen_empty_region(&RegionTransDilation);
				}
				concat_obj(RegionTransDilation, CircleRegions, &CircleRegions);

			}		
		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], CircleRegions, &m_vRgn[rId]); 
		}
		union1(CircleRegions,&CircleRegions);
		m_UpReg=CircleRegions;

		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(CircleRegions, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = CircleRegions;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_CirclePatternDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1264$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1280;LP;3;65;1;35$\
					 1281;LP;1;250;1;15$\
					 1282;LP;1;250;1;30$\
					 1268;LP;1;100;1;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_ConPatternSearchRegDownAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize)
{
	//下排花纹搜索区域
	int id = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;
	//int HDilationSize   = (int)pHDilationSize->fltVal;
	int SearchSize =(int)pSearchSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_ABEdgeM.Id()==H_EMPTY_REGION||m_ROI.Id()==H_EMPTY_REGION||m_Switch==0||m_PlatColumnR.Num()!=1||m_ColT1.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		HTuple area,row,col;
		area_center(m_ROI,&area,&row,&col);
		if (area==0 ||area.Num()==0)
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		HTuple LeftCol,RightCol;
		HTuple RoiRow1,RoiColumn1,RoiRow2,RoiColumn2;
		smallest_rectangle1(m_ROI,&RoiRow1, &RoiColumn1, &RoiRow2, &RoiColumn2);

		Hobject ABtriangleEdge,SearchReg,SearchRegDiff;
		move_region(m_ABEdgeM, &ABtriangleEdge, -MoveSize, 0);
		//垂向膨胀
		dilation_rectangle1(ABtriangleEdge, &SearchReg, 1, SearchSize);
		intersection(SearchReg, m_ROI, &SearchReg);
		intersection(ABtriangleEdge, SearchReg, &ABtriangleEdge);
		m_PatternEdge=ABtriangleEdge;

		Hobject ObjectsConcat,Rect1,Rect2,Rect3,Rect4;
		HTuple ColDiff,ColDiff1,ColDiff2;
		gen_empty_region(&ObjectsConcat);
		if (0 != (m_Switch==1))
		{
			if (m_PlatColumnR>m_ColT1||m_ColT1>m_ColT2||m_ColT2>m_WholeColumnR)
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}	
			gen_rectangle1(&Rect1, RoiRow1, m_PlatColumnR, RoiRow2, m_ColT1);
			intersection(Rect1, SearchReg, &Rect1);

			gen_rectangle1(&Rect2, RoiRow1, m_ColT1, RoiRow2, m_ColT2);
			intersection(Rect2, SearchReg, &Rect2);

			gen_rectangle1(&Rect3, RoiRow1, m_ColT2, RoiRow2, m_WholeColumnR);
			intersection(Rect3, SearchReg, &Rect3);
			ColDiff = m_WholeColumnR-m_ColT2;
			if (0 != (ColDiff<20))
			{
				gen_empty_region(&Rect3);

			}
			concat_obj(Rect1, Rect2, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect3, &ObjectsConcat);
		}
		else if (0 != (m_Switch==2))
		{
			if (m_ColT1>m_PlatColumnL||m_ColT2>m_ColT1||m_WholeColumnL>m_ColT2)
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}	
			gen_rectangle1(&Rect1, RoiRow1, m_ColT1, RoiRow2, m_PlatColumnL);
			intersection(Rect1, SearchReg, &Rect1);

			gen_rectangle1(&Rect2, RoiRow1, m_ColT2, RoiRow2, m_ColT1);
			intersection(Rect2, SearchReg, &Rect2);

			gen_rectangle1(&Rect3, RoiRow1, m_WholeColumnL, RoiRow2, m_ColT2);
			intersection(Rect3, SearchReg, &Rect3);
			ColDiff = m_ColT2-m_WholeColumnL;
			if (0 != (ColDiff<20))
			{
				gen_empty_region(&Rect3);

			}
			concat_obj(Rect1, Rect2, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect3, &ObjectsConcat);
		}
		else if (0 != (m_Switch==3))
		{
			if (m_PlatColumnR>m_ColT1||m_ColT1>m_ColT2||m_ColT3>m_PlatColumnL||m_ColT4>m_ColT3)
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}	
			gen_rectangle1(&Rect1, RoiRow1, m_PlatColumnR, RoiRow2, m_ColT1);
			intersection(Rect1, SearchReg, &Rect1);

			gen_rectangle1(&Rect2, RoiRow1, m_ColT1, RoiRow2, m_ColT2);
			intersection(Rect2, SearchReg, &Rect2);
			ColDiff1 = m_ColT2-m_ColT1;
			if (0 != (ColDiff1<20))
			{
				gen_empty_region(&Rect2);
			}
			gen_rectangle1(&Rect3, RoiRow1, m_ColT3, RoiRow2, m_PlatColumnL);
			intersection(Rect3, SearchReg, &Rect3);

			gen_rectangle1(&Rect4, RoiRow1, m_ColT4, RoiRow2, m_ColT3);
			intersection(Rect4, SearchReg, &Rect4);
			ColDiff2 = m_ColT3-m_ColT4;
			if (0 != (ColDiff2<20))
			{
				gen_empty_region(&Rect4);
			}
			concat_obj(Rect1, Rect2, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect3, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect4, &ObjectsConcat);
		}
		else if (0 != (m_Switch==4))
		{
			if (m_ColT1>m_PlatColumnL||m_ColT2>m_ColT1||m_PlatColumnR>m_ColT3||m_ColT3>m_ColT4)
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}	
			gen_rectangle1(&Rect1, RoiRow1, m_ColT1, RoiRow2, m_PlatColumnL);
			intersection(Rect1, SearchReg, &Rect1);

			gen_rectangle1(&Rect2, RoiRow1, m_ColT2, RoiRow2, m_ColT1);
			intersection(Rect2, SearchReg, &Rect2);
			ColDiff1 = m_ColT1-m_ColT2;
			if (0 != (ColDiff1<20))
			{
				gen_empty_region(&Rect2);
			}
			gen_rectangle1(&Rect3, RoiRow1, m_PlatColumnR, RoiRow2, m_ColT3);
			intersection(Rect3, SearchReg, &Rect3);

			gen_rectangle1(&Rect4, RoiRow1, m_ColT3, RoiRow2, m_ColT4);
			intersection(Rect4, SearchReg, &Rect4);
			ColDiff2 = m_ColT4-m_ColT3;
			if (0 != (ColDiff2<20))
			{
				gen_empty_region(&Rect4);
			}
			concat_obj(Rect1, Rect2, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect3, &ObjectsConcat);
			concat_obj(ObjectsConcat, Rect4, &ObjectsConcat);
		}
		//m_StripeReg=ConReg;
		m_vRgn[id] = ObjectsConcat;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_ConPatternSearchRegDownAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1270$\
					 167;B$\
					 1190;LP;50;350;1;135$\
					 995;LP;10;160;1;90"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_TrianglePatternDetectAlgo(VARIANT* rgnId,VARIANT* pGrayValue,VARIANT* pTriangleSize,VARIANT* pStripeArea)
{
	//三角花纹提取
	int rId           = (int)rgnId->fltVal;
	float GrayValue = (float) pGrayValue->fltVal;
	int TriangleSize = (int) pTriangleSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_PatternEdge.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject RectSelected,ImageReduced5,Regions1,ConnectedRegions1,ABEdgePartitioned,TriangleObject,WhiteTriangleRegSelected,TriangleObjectConnected;
		Hobject TriangleRoi,TReg,TriangleConcat,TriangleReg,TriangleRoi1;
		HTuple Number,RectArea, RectRow, RectColumn,Number1,PartitionedArea, PartitionedRow, PartitionedCol,WhiteTriangleArea, WhiteTriangleRow,WhiteTriangleCol,RowRound,ColRound,Indice;
		HTuple TriangleArea, TriangleRow, TriangleColumn,MidRow, MidCol, phi, Length1, Length2,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2,RowDiff;

		gen_empty_region(&TriangleReg);
		count_obj(rgn, &Number);
		for (int x=1; x<=Number; x++)
		{
			select_obj(rgn, &RectSelected, x);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if (0 != (RectArea>0))
			{
				reduce_domain(ImageScaleMax, RectSelected, &ImageReduced5);
				threshold(ImageReduced5, &Regions1, GrayValue, 255);
				connection(Regions1, &ConnectedRegions1);
				count_obj(ConnectedRegions1, &Number1);
				//排除白条下面的白点干扰,只选择基准线以上的白条区域
				partition_rectangle(m_PatternEdge, &ABEdgePartitioned, 1, 100);
				area_center(ABEdgePartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);

				gen_empty_obj(&TriangleObject);
				for (int y=1; y<=Number1; y ++)
				{
					select_obj(ConnectedRegions1, &WhiteTriangleRegSelected, y);
					area_center(WhiteTriangleRegSelected, &WhiteTriangleArea, &WhiteTriangleRow,&WhiteTriangleCol);
					tuple_round(WhiteTriangleRow, &RowRound);
					tuple_round(WhiteTriangleCol, &ColRound);
					tuple_find(PartitionedCol, ColRound, &Indice);
					if (0 != (Indice==-1))
					{
						continue;
					}
					RowDiff = (PartitionedRow.Select(Indice.Select(0)))-WhiteTriangleRow;

					if (0 != (RowDiff>=0))
					{
						concat_obj(TriangleObject, WhiteTriangleRegSelected, &TriangleObject);
					}
				}
				union1(TriangleObject, &TriangleObject);
				connection(TriangleObject, &TriangleObjectConnected);
				select_shape_std(TriangleObjectConnected, &TriangleRoi, "max_area", 70);
				area_center(TriangleRoi, &TriangleArea, &TriangleRow, &TriangleColumn);
				smallest_rectangle2(TriangleRoi, &MidRow, &MidCol, &phi, &Length1, &Length2);
				if (0 != (Length1>Length2))
				{
					LengthLong = Length1;
					LengthShort = Length2;
				}
				else
				{
					LengthLong = Length2;
					LengthShort = Length1;
				}
				Row1 = MidRow+(LengthLong*(phi.Sin()));
				Col1 = MidCol-(LengthLong*(phi.Cos()));

				Row2 = MidRow-(LengthLong*(phi.Sin()));
				Col2 = MidCol+(LengthLong*(phi.Cos()));

				gen_region_polygon(&TReg, ((Row1.Concat(Row2)).Concat(MidRow+TriangleSize)).Concat(Row1),((Col1.Concat(Col2)).Concat(MidCol)).Concat(Col1));
				fill_up(TReg, &TReg);
				//m_TriangleRoi  用于整体区域
				concat_obj(TriangleRoi, TReg, &TriangleConcat);
			}
			concat_obj(TriangleReg, TriangleConcat, &TriangleReg);
			concat_obj(TriangleRoi,TriangleRoi1,&TriangleRoi1);
		}
		Hobject TriangleRegFillUp,TriangleRegUnion,TriangleRoiFillUp,TriangleRoi1Union;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);
		gen_empty_region(&TriangleRoiFillUp);
		union1(TriangleRoi1, &TriangleRoi1Union);
		fill_up(TriangleRoi1Union,&TriangleRoiFillUp);
		m_TriangleRoi=TriangleRoiFillUp;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], m_PatternEdge, &m_vRgn[rId]); 
			concat_obj(m_vRgn[rId], TriangleReg, &m_vRgn[rId]); 
		}
		m_LowerReg=TriangleRegFillUp;
		m_StripeReg=TriangleRegFillUp;    //用于单叉覆膜胶塞花纹扣除

		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(TriangleRegFillUp, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TrianglePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 999;FP;0;250;0.5;90$\
					 1018;LP;5;80;1;45");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_StripePatternDetectAlgo(VARIANT* rgnId,VARIANT* pGrayValue,VARIANT* pStripeArea)
{
	//上下都是条形花纹提取
	int rId           = (int)rgnId->fltVal;
	float GrayValue = (float) pGrayValue->fltVal;
	//int TriangleSize = (int) pTriangleSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_PatternEdge.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject RectSelected,ImageReduced5,Regions1,ConnectedRegions1,ABEdgePartitioned,TriangleObject,WhiteTriangleRegSelected,TriangleObjectConnected;
		Hobject TriangleRoi,TReg,TriangleConcat,TriangleReg,StripeReg;
		HTuple Number,RectArea, RectRow, RectColumn,Number1,PartitionedArea, PartitionedRow, PartitionedCol,WhiteTriangleArea, WhiteTriangleRow,WhiteTriangleCol,RowRound,ColRound,Indice;
		HTuple TriangleArea, TriangleRow, TriangleColumn,MidRow, MidCol, phi, Length1, Length2,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2,RowDiff;

		gen_empty_region(&TriangleReg);
		count_obj(rgn, &Number);
		for (int x=1; x<=Number; x++)
		{
			select_obj(rgn, &RectSelected, x);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if (0 != (RectArea>0))
			{
				reduce_domain(ImageScaleMax, RectSelected, &ImageReduced5);
				threshold(ImageReduced5, &Regions1, GrayValue, 255);
				connection(Regions1, &ConnectedRegions1);
				count_obj(ConnectedRegions1, &Number1);
				//排除白条下面的白点干扰,只选择基准线以上的白条区域
				partition_rectangle(m_PatternEdge, &ABEdgePartitioned, 1, 100);
				area_center(ABEdgePartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);

				gen_empty_obj(&TriangleObject);
				for (int y=1; y<=Number1; y ++)
				{
					select_obj(ConnectedRegions1, &WhiteTriangleRegSelected, y);
					area_center(WhiteTriangleRegSelected, &WhiteTriangleArea, &WhiteTriangleRow,&WhiteTriangleCol);
					tuple_round(WhiteTriangleRow, &RowRound);
					tuple_round(WhiteTriangleCol, &ColRound);
					tuple_find(PartitionedCol, ColRound, &Indice);
					if (0 != (Indice==-1))
					{
						continue;
					}
					RowDiff = (PartitionedRow.Select(Indice.Select(0)))-WhiteTriangleRow;

					if (0 != (RowDiff>=0))
					{
						concat_obj(TriangleObject, WhiteTriangleRegSelected, &TriangleObject);
					}
				}
				union1(TriangleObject, &TriangleObject);
				connection(TriangleObject, &TriangleObjectConnected);
				select_shape_std(TriangleObjectConnected, &TriangleRoi, "max_area", 70);

				//白条往下平移，闭合
				Hobject WhiteStripeMoved0,StripeRegion,WhiteStripeMoved,WhiteStripeUnion;
				closing_circle(TriangleRoi, &TriangleRoi, 10);
				//两端膨胀需要实际调整
				move_region(TriangleRoi, &WhiteStripeMoved0, -3, 0);
				dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);
				move_region(StripeRegion, &WhiteStripeMoved, 15, 0);
				union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
				closing_rectangle1(WhiteStripeUnion, &StripeReg, 2, 20);
			}
			concat_obj(TriangleReg, StripeReg, &TriangleReg);
		}
		Hobject TriangleRegFillUp,TriangleRegUnion;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], m_PatternEdge, &m_vRgn[rId]); 
			concat_obj(m_vRgn[rId], TriangleReg, &m_vRgn[rId]); 
		}
		//用于区分上下排花纹提取
		if (m_Pswitch==1)
		{
			m_UpReg=TriangleRegFillUp;
			m_Pswitch=2;
		} 
		else
		{
			m_LowerReg=TriangleRegFillUp;
			m_Pswitch=1;
			//整体区域中剔除花纹亮斑
			m_TriangleRoi=TriangleRegFillUp;
		}
		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(TriangleRegFillUp, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 999;FP;0;250;0.5;90");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternDetectAlgo1(VARIANT* rgnId,VARIANT* pGrayValue,VARIANT* pDilationSize,VARIANT* pStripeArea)
{
	//上下都是条形花纹提取
	int rId           = (int)rgnId->fltVal;
	float GrayValue = (float) pGrayValue->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;
	//int TriangleSize = (int) pTriangleSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_PatternEdge.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
		Hobject ImageScaleMax,Ellipse,ImageReduced;
		gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		reduce_domain(crtImg,Ellipse,&ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject RectSelected,ImageReduced5,Regions1,ConnectedRegions1,ABEdgePartitioned,TriangleObject,WhiteTriangleRegSelected,TriangleObjectConnected;
		Hobject TriangleRoi,TReg,TriangleConcat,TriangleReg,StripeReg;
		HTuple Number,RectArea, RectRow, RectColumn,Number1,PartitionedArea, PartitionedRow, PartitionedCol,WhiteTriangleArea, WhiteTriangleRow,WhiteTriangleCol,RowRound,ColRound,Indice;
		HTuple TriangleArea, TriangleRow, TriangleColumn,MidRow, MidCol, phi, Length1, Length2,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2,RowDiff;

		gen_empty_region(&TriangleReg);
		count_obj(rgn, &Number);
		for (int x=1; x<=Number; x++)
		{
			select_obj(rgn, &RectSelected, x);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if (0 != (RectArea>0))
			{
				reduce_domain(ImageScaleMax, RectSelected, &ImageReduced5);
				threshold(ImageReduced5, &Regions1, GrayValue, 255);
				connection(Regions1, &ConnectedRegions1);
				count_obj(ConnectedRegions1, &Number1);
				//排除白条下面的白点干扰,只选择基准线以上的白条区域
				partition_rectangle(m_PatternEdge, &ABEdgePartitioned, 1, 100);
				area_center(ABEdgePartitioned, &PartitionedArea, &PartitionedRow, &PartitionedCol);

				gen_empty_obj(&TriangleObject);
				for (int y=1; y<=Number1; y ++)
				{
					select_obj(ConnectedRegions1, &WhiteTriangleRegSelected, y);
					area_center(WhiteTriangleRegSelected, &WhiteTriangleArea, &WhiteTriangleRow,&WhiteTriangleCol);
					tuple_round(WhiteTriangleRow, &RowRound);
					tuple_round(WhiteTriangleCol, &ColRound);
					tuple_find(PartitionedCol, ColRound, &Indice);
					if (0 != (Indice==-1))
					{
						continue;
					}
					RowDiff = (PartitionedRow.Select(Indice.Select(0)))-WhiteTriangleRow;

					if (0 != (RowDiff>=0))
					{
						concat_obj(TriangleObject, WhiteTriangleRegSelected, &TriangleObject);
					}
				}
				union1(TriangleObject, &TriangleObject);
				connection(TriangleObject, &TriangleObjectConnected);
				select_shape_std(TriangleObjectConnected, &TriangleRoi, "max_area", 70);

				//白条往下平移，闭合
				Hobject WhiteStripeMoved0,StripeRegion,WhiteStripeMoved,WhiteStripeUnion;
				closing_circle(TriangleRoi, &TriangleRoi, 10);
				//两端膨胀需要实际调整
				move_region(TriangleRoi, &WhiteStripeMoved0, -3, 0);
				dilation_rectangle1(WhiteStripeMoved0, &StripeRegion, 20, 1);
				move_region(StripeRegion, &WhiteStripeMoved, DilationSize, 0);
				union2(StripeRegion, WhiteStripeMoved, &WhiteStripeUnion);
				closing_rectangle1(WhiteStripeUnion, &StripeReg, 2, 20);
			}
			concat_obj(TriangleReg, StripeReg, &TriangleReg);
		}
		Hobject TriangleRegFillUp,TriangleRegUnion;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], m_PatternEdge, &m_vRgn[rId]); 
			concat_obj(m_vRgn[rId], TriangleReg, &m_vRgn[rId]); 
		}
		//用于区分上下排花纹提取
		if (m_Pswitch==1)
		{
			m_UpReg=TriangleRegFillUp;
			m_Pswitch=2;
		} 
		else
		{
			m_LowerReg=TriangleRegFillUp;
			m_Pswitch=1;
			//整体区域中剔除花纹亮斑
			m_TriangleRoi=TriangleRegFillUp;
		}
		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(TriangleRegFillUp, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 999;FP;0;250;0.5;90$\
					 995;LP;13;30;1;18");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_MiddleEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize,VARIANT* pHClipSize, VARIANT* pEdgeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_Platform0.Id() == H_EMPTY_REGION||m_ABEdgeRow.Num()==0)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//圆形区域
		Hobject crtImg = m_crtImg;

		Hobject MiddleEdge,MiddleEdgeDilation,MiddleEdgeDilationCliped;
		move_region(m_ABEdgeM, &MiddleEdge, -MoveSize, 0);
		dilation_rectangle1(MiddleEdge, &MiddleEdgeDilation, 1, SearchSize);
		clip_region_rel(MiddleEdgeDilation,&MiddleEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject MiddleEdgeDiff,MiddleEdgeSearchReg,MiddleEdgeImageReduced;

		Hobject PlatformDilation;
		dilation_rectangle1(m_Platform0, &PlatformDilation, 18, 1);
		difference(MiddleEdgeDilationCliped, PlatformDilation, &MiddleEdgeDiff);
		intersection(MiddleEdgeDiff, m_ROI, &MiddleEdgeSearchReg);
		reduce_domain(crtImg, MiddleEdgeSearchReg, &MiddleEdgeImageReduced);

		HTuple DefinedRow, DefinedCol;
		P_EdgePointsFitCurve(MiddleEdgeSearchReg, MiddleEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		Hobject MiddleEdgePoints;
		gen_region_points(&MiddleEdgePoints, DefinedRow, DefinedCol);
		HTuple MiddleEdgeArea, MiddleEdgeRow, MiddleEdgeCol;
		area_center(MiddleEdgePoints, &MiddleEdgeArea, &MiddleEdgeRow, &MiddleEdgeCol);

		Hobject ABEdgeMovedCenter;
		HTuple MoveSize0;
		MoveSize0 = m_ABEdgeRow-MiddleEdgeRow;
		move_region(m_ABEdgeM, &ABEdgeMovedCenter, -MoveSize0-5, 0);
		Hobject MiddleEdgeReg;
		dilation_rectangle1(ABEdgeMovedCenter, &MiddleEdgeReg, 1, 10);

		m_MiddleEdge=MiddleEdgeReg;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], MiddleEdgePoints, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], MiddleEdgeSearchReg, &m_vRgn[rId]);
		}
		//
		if (MiddleEdgeArea>0)
		{
			Hobject MiddleEdgePointsDilation;
			retValue = MiddleEdgeArea[0].I();
			dilation_circle(MiddleEdgePoints, &MiddleEdgePointsDilation, 2);
			m_vErrorRgn[rId] = MiddleEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_MiddleEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1104$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;200;1;100$\
					 1107;LP;1;100;1;35$\
					 1108;LP;1;15;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeH2)
{
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int DilationSizeH2   = (int)pDilationSizeH2->fltVal;

	//int AreaThred   = (int)pAreaThred->fltVal;
	//int DilationSize2   = (int)pDilationSize2->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ConeEllipse.Id()==H_EMPTY_REGION||m_MiddleEdge.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		HTuple area,row,col;
		area_center(m_MiddleEdge,&area,&row,&col);
		if (area>0)
		{
			//中部边缘缩放
			Hobject MidldleRegDilation,ARegionDiff1;
			dilation_circle(m_MiddleEdge,&MidldleRegDilation,DilationSize1);
			difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
			//
			Hobject ARegionDiff1Connected,SortedRegions;
			connection(ARegionDiff1,&ARegionDiff1Connected);
			HTuple Number;
			count_obj(ARegionDiff1Connected, &Number);
			if (Number[0].I()!=2)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");

			if (Selection==1)  //颈部上部区域
			{
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);

				union1(ARegionDiff1,&ARegionDiff1);
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//叉口缩放
				Hobject PlatformRegDilation;
				dilation_circle(m_Platform,&PlatformRegDilation,DilationSize0);

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 2);
				difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			//水平缩放
			clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
			opening_circle(RegionSelected0, &RegionSelected0, 5.5);

			//叉口+斜坡倒角区域缩放
			Hobject RegionUnion2,ConePlatformClosing;
			union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
			closing_circle(RegionUnion2, &ConePlatformClosing, 65);
			Hobject PlatformRegDilation;
			dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
			Hobject ARegionDiff0;
			difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

			//花纹缩放
			Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
			dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
			dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
			Hobject PatternUnion;
			union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
			difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
			//斜坡倒角
			//Hobject RegionUnion2,ConePlatformClosing;
			//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
			//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
			//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);
			union1(ARegionDiff1,&ARegionDiff1);	
			m_vRgn[rId] = ARegionDiff1;	
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1272;LP;1;45;1;1$\
					 1170;LP;1;45;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo1(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeH2)
{
	//双叉覆膜胶塞，G20_DownEdgeDetectAlgo
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int DilationSizeH2   = (int)pDilationSizeH2->fltVal;

	//int AreaThred   = (int)pAreaThred->fltVal;
	//int DilationSize2   = (int)pDilationSize2->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ConeEllipse.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		HTuple area,row,col,areaX,rowX,colX;
		area_center(m_DownEdge,&area,&row,&col);
		area_center(m_DownEdgeX,&areaX,&rowX,&colX);
		if (area>0 && areaX>0)
		{
			if (Selection==1)  //颈部上部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff;
				dilation_circle(m_DownEdgeX,&MidldleRegDilation,DilationSize1);
				//防止提取的下部边缘小于m_ARegionT水平宽度
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff);
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff,&ARegionDiff1Connected);
				//HTuple Number;
				//count_obj(ARegionDiff1Connected, &Number);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);
				union1(ARegionDiff1,&ARegionDiff1);
				m_ARegionDiff1 = ARegionDiff1;
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff1;
				dilation_circle(m_DownEdge,&MidldleRegDilation,DilationSize1);
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
				//
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff1,&ARegionDiff1Connected);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				//叉口缩放
				Hobject PlatformRegDilation;
				dilation_circle(m_Platform,&PlatformRegDilation,DilationSize0);

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 1);
				difference(SortedRegions,RegionSelected,&RegionSelected);
				difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			//水平缩放
			clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
			opening_circle(RegionSelected0, &RegionSelected0, 5.5);

			//叉口+斜坡倒角区域缩放
			Hobject RegionUnion2,ConePlatformClosing;
			union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
			closing_circle(RegionUnion2, &ConePlatformClosing, 65);
			Hobject PlatformRegDilation;
			dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
			Hobject ARegionDiff0;
			difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

			//花纹缩放
			Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
			dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
			dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
			Hobject PatternUnion;
			union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
			difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
			//斜坡倒角
			//Hobject RegionUnion2,ConePlatformClosing;
			//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
			//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
			//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);
			union1(ARegionDiff1,&ARegionDiff1);	
			m_vRgn[rId] = ARegionDiff1;	
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1272;LP;1;45;1;1$\
					 1170;LP;1;45;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************************************************************
**函数名：T20_NeckCornerRegionLocationAlgo
**功  能：定位颈部区域的靠近叉口的拐角边缘区域
**注  意：该算子使用了顶部区域(m_AroiTClosing)、颈部区域(m_ARegionDiff1)、整体RO(m_ROI)、叉口平台(m_PlatformReg)、叉口区域m_Platform 五个公共变量
****************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_NeckCornerRegionLocationAlgo(VARIANT* rgnId, VARIANT* pNeckErosionSize,VARIANT* pDilSizePlatform,VARIANT* pDilSizePlatform1,VARIANT* pDilSizeTriangle,VARIANT* pUpRegionPos, VARIANT* pDownRegionPos,VARIANT*pOpeningSize)
{
	int rId                = (int)rgnId->fltVal;

	float NeckErosionSize  = (float)pNeckErosionSize->fltVal;    // 3  -10~50  0.5 
	float DilSizePlatform  =(float)pDilSizePlatform->fltVal;     // 1~50 10 0.5
	float DilSizePlatform1  =(float)pDilSizePlatform1->fltVal;     // 1~50 10 0.5
	float DilSizeTriangle  =(float)pDilSizeTriangle->fltVal;     // 1~50 10 0.5

	int UpRegionPos      = (int)pUpRegionPos->fltVal;           // 65  0~150   0.5
	int DownRegionPos    = (int)pDownRegionPos->fltVal;       //  30 0~150    0.5
	int OpeningSize    = (int)pOpeningSize->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_AroiTClosing.Id()==H_EMPTY_REGION||m_ARegionDiff1.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject ARegionDiff1Dil,PlatformRegDil,PlatFormIntst,AroiTClosingDil;
		Hobject ARegionDiff1Opn,ARegionDiff1OpnSel;

		//opening_rectangle1(m_ARegionT,&ARegionDiff1Opn,1,OpeningSize);
		//difference(m_ARegionT,m_Platform0,&ARegionDiff1Opn);
		opening_rectangle1(m_ARegionDiff1,&ARegionDiff1Opn,1,OpeningSize);

		if (NeckErosionSize<0)
		{
			dilation_rectangle1(ARegionDiff1Opn, &ARegionDiff1Dil, -(Hlong)NeckErosionSize,1);
		}
		else if(NeckErosionSize>0)
		{
			dilation_rectangle1(ARegionDiff1Opn, &ARegionDiff1Dil, (Hlong)NeckErosionSize,1);
		}
		else
		{
			NeckErosionSize = (float)(NeckErosionSize+0.5);
			dilation_rectangle1(ARegionDiff1Opn, &ARegionDiff1Dil, (Hlong)NeckErosionSize,1);
		}

		// 叉口平台膨胀
		Hobject rgnPlatformRegDil,rgnPlatformRegDif,rgnIntersect,rgnIntsctMoved1,rgnIntsctMoved2;
		Hobject rgnPlatformRegDil1;

		dilation_rectangle1(m_PlatformReg,&rgnPlatformRegDil,1,40);
		dilation_rectangle1(rgnPlatformRegDil,&rgnPlatformRegDil1,(Hlong)DilSizePlatform,1);
		difference(rgnPlatformRegDil1,rgnPlatformRegDil,&rgnPlatformRegDif);

		intersection(ARegionDiff1Dil,rgnPlatformRegDif,&rgnIntersect);
		move_region(rgnIntersect,&rgnIntsctMoved1,UpRegionPos,0);
		move_region(rgnIntersect,&rgnIntsctMoved2,-DownRegionPos,0);

		Hobject rgnCorner,rgnCornerOri;
		intersection(rgnIntsctMoved1,rgnIntsctMoved2,&rgnCornerOri);

		// 去除三角花纹区域
		Hobject rgnStripeReg,rgnStripeRegDil;
		union1(m_LowerReg,&rgnStripeReg);
		dilation_circle(rgnStripeReg,&rgnStripeRegDil,DilSizeTriangle);
		difference(rgnCornerOri,rgnStripeRegDil,&rgnCornerOri);
		union1(rgnCornerOri,&rgnCornerOri);

		// 去除叉口区域
		HTuple dAreaUnion, dRowUnion, dColUnion;
		Hobject rgnPlatformDil,rgnCornerCon,rgnCornerSel,rgnUnion,rgnCornerDif,rgnCornerOpn;

		dilation_circle(m_Platform,&rgnPlatformDil,DilSizePlatform1);
		difference(rgnCornerOri,rgnPlatformDil,&rgnCornerDif);
		opening_circle(rgnCornerDif,&rgnCornerOpn,0.5);
		connection(rgnCornerOpn,&rgnCornerCon);
		select_shape(rgnCornerCon,&rgnCornerSel,"area","and",100,999999);
		union1(rgnCornerSel,&rgnCorner);

		area_center(rgnCorner, &dAreaUnion, &dRowUnion, &dColUnion);
		if (dAreaUnion<0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		m_vRgn[rId] = rgnCorner;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckCornerRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6008$\
					 167;B$\
					 6009;FP;-80;80;0.5;-10$\
					 1112;FP;1;100;0.5;50$\
					 1021;FP;1;50;0.5;3$\
					 1020;FP;1;50;0.5;3$\
					 6010;LP;0;150;1;0$\
					 6012;LP;0;150;1;0$\
					 864;LP;1;150;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************
**函数名：T20_NeckRegionLocationAlgo2
**功  能：提取双叉覆膜侧壁区域，如果覆膜边缘没有时，侧壁区域不依赖于覆膜边缘
********************************************************************/
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeH2,VARIANT*pAreaThred)
{
	//双叉覆膜胶塞，G20_DownEdgeDetectAlgo

	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int DilationSizeH2   = (int)pDilationSizeH2->fltVal;

	int AreaThred   = (int)pAreaThred->fltVal;
	//int DilationSize2   = (int)pDilationSize2->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ConeEllipse.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		HTuple area,row,col,areaX,rowX,colX;
		area_center(m_DownEdge,&area,&row,&col);
		area_center(m_DownEdgeX,&areaX,&rowX,&colX);
		if (area>AreaThred && areaX>AreaThred)
		{
			if (Selection==1)  //颈部上部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff;
				dilation_circle(m_DownEdgeX,&MidldleRegDilation,DilationSize1);
				//防止提取的下部边缘小于m_ARegionT水平宽度
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff);
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff,&ARegionDiff1Connected);
				//HTuple Number;
				//count_obj(ARegionDiff1Connected, &Number);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);

				union1(ARegionDiff1,&ARegionDiff1);
				m_ARegionDiff1 = ARegionDiff1;
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff1;
				dilation_circle(m_DownEdge,&MidldleRegDilation,DilationSize1);
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
				//
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff1,&ARegionDiff1Connected);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				//叉口缩放
				Hobject PlatformRegDilation;
				dilation_circle(m_Platform,&PlatformRegDilation,DilationSize0);

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 1);
				difference(SortedRegions,RegionSelected,&RegionSelected);
				difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			if (Selection==1)  //颈部上部区域
			{
				//水平缩放
				clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);
				union1(ARegionDiff1,&ARegionDiff1);	
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				Hobject EmptyRegion;
				gen_empty_region(&EmptyRegion);
				m_vRgn[rId] = EmptyRegion;
			}
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;200;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1272;LP;1;45;1;1$\
					 1170;LP;1;45;1;1$\
					 1390;LP;1;99999;1;2000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************
**函数名：T20_NeckRegionLocationAlgo3
**功  能：提取双叉覆膜侧壁区域，如果覆膜边缘没有时，侧壁区域不依赖于覆膜边缘
********************************************************************/
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo3(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeH2,VARIANT*pAreaThred)
{
	//双叉覆膜胶塞，G20_DownEdgeDetectAlgo

	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;
	int DilationSizeH2   = (int)pDilationSizeH2->fltVal;

	int AreaThred   = (int)pAreaThred->fltVal;
	//int DilationSize2   = (int)pDilationSize2->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ConeEllipse.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,RegionSelected0,ARegionDiff2;
		//erosion_rectangle1(ARegionIntersction,&ARegionT0,1,VErosionSize);
		////////////
		move_region(ARegionIntersction,&ARegionT0,VErosionSize,0);
		intersection(ARegionT0,ARegionIntersction,&ARegionT0);
		///////////
		HTuple area,row,col,areaX,rowX,colX;
		area_center(m_DownEdge,&area,&row,&col);
		area_center(m_DownEdgeX,&areaX,&rowX,&colX);
		if (area>AreaThred && areaX>AreaThred)
		{
			if (Selection==1)  //颈部上部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff;
				dilation_circle(m_DownEdgeX,&MidldleRegDilation,DilationSize1);
				//防止提取的下部边缘小于m_ARegionT水平宽度
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff);
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff,&ARegionDiff1Connected);
				//HTuple Number;
				//count_obj(ARegionDiff1Connected, &Number);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				select_obj(SortedRegions, &RegionSelected0, 1);
				//水平缩放
				clip_region_rel(RegionSelected0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);

				union1(ARegionDiff1,&ARegionDiff1);
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				//中部边缘缩放
				Hobject MidldleRegDilation,ARegionDiff1;
				dilation_circle(m_DownEdge,&MidldleRegDilation,DilationSize1);
				HTuple row1,col1,row2,col2;
				smallest_rectangle1(MidldleRegDilation,&row1,&col1,&row2,&col2);
				clip_region(ARegionT0,&ARegionT0,0,col1,m_imgHeight,col2);
				difference(ARegionT0, MidldleRegDilation, &ARegionDiff1);
				//
				Hobject ARegionDiff1Connected,SortedRegions;
				connection(ARegionDiff1,&ARegionDiff1Connected);
				sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
				//叉口缩放
				Hobject PlatformRegDilation;
				dilation_circle(m_Platform,&PlatformRegDilation,DilationSize0);

				Hobject RegionSelected,RegionDiff,RegionClip;
				select_obj(SortedRegions, &RegionSelected, 1);
				difference(SortedRegions,RegionSelected,&RegionSelected);
				difference(RegionSelected,PlatformRegDilation,&RegionDiff);
				//水平缩放
				clip_region_rel(RegionDiff, &RegionClip, 0, 0, HErosionSize, HErosionSize);
				m_vRgn[rId] = RegionClip;
			}
		}
		else
		{
			if (Selection==1)  //颈部上部区域
			{
				//水平缩放
				clip_region_rel(ARegionT0, &RegionSelected0, 0, 0, HErosionSize, HErosionSize);
				opening_circle(RegionSelected0, &RegionSelected0, 5.5);

				//叉口+斜坡倒角区域缩放
				Hobject RegionUnion2,ConePlatformClosing;
				union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				Hobject PlatformRegDilation;
				dilation_circle(ConePlatformClosing,&PlatformRegDilation,DilationSize0);
				Hobject ARegionDiff0;
				difference(RegionSelected0, PlatformRegDilation, &ARegionDiff0);

				//花纹缩放
				Hobject CirclePatternDilation,TrianglePatternDilation,ARegionDiff1;
				dilation_circle(m_UpReg,&CirclePatternDilation,DilationSizeH1);
				dilation_circle(m_LowerReg,&TrianglePatternDilation,DilationSizeH2);
				Hobject PatternUnion;
				union2(CirclePatternDilation,TrianglePatternDilation,&PatternUnion);
				difference(ARegionDiff0,PatternUnion,&ARegionDiff1);
				//斜坡倒角
				//Hobject RegionUnion2,ConePlatformClosing;
				//union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
				//closing_circle(RegionUnion2, &ConePlatformClosing, 65);
				//difference(ARegionDiff1, ConePlatformClosing, &ARegionDiff2);
				union1(ARegionDiff1,&ARegionDiff1);	
				m_vRgn[rId] = ARegionDiff1;	
			}
			else if(Selection==2)   //颈部下部区域
			{
				Hobject EmptyRegion;
				gen_empty_region(&EmptyRegion);
				m_vRgn[rId] = EmptyRegion;
			}
		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_NeckRegionLocationAlgo3Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1271;LP;1;2;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;200;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1272;LP;1;45;1;1$\
					 1170;LP;1;45;1;1$\
					 1390;LP;1;99999;1;2000");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::P_20T_InWallRegionDetect (Halcon::HTuple Pos,Halcon::Hobject TopRect, Halcon::Hobject PlatformReg, Halcon::Hobject ARegionM, Halcon::Hobject ROI, Halcon::Hobject ABEllipseAffineTrans, 
	Halcon::Hobject ImageReducedAroi,Halcon::HTuple ThredLower,Halcon::HTuple AreaLimitLower, Halcon::HTuple Angle,Halcon::Hobject *InWallRegion)
{
	// Local iconic variables 
	Hobject  TopRectMoved, Rectangle1, RegionDilation4;
	Hobject  RegionMoved, ARegionMDilation, RegionUnion1;
	Hobject  RegionUnion3, RoiOpening, RegionErosion1;
	Hobject  RegionDifference3, ConnectedRegions2, SelectedRegions3;
	Hobject  SelectedRegions2;
	// Local control variables 
	HTuple  PlatformRow, PlatformColumn, phi;
	HTuple  Length1, Length2, Area4;
	HTuple  BaseRow, BaseColumn, Row1, Column1;
	HTuple  Row2, Column2;
	//下边缘位置
	move_region(TopRect, &TopRectMoved, Pos, 1);
	smallest_rectangle2(PlatformReg, &PlatformRow, &PlatformColumn, &phi, &Length1, &Length2);

	gen_rectangle2(&Rectangle1, PlatformRow, PlatformColumn, Angle, Length1, Length2);
	dilation1(TopRectMoved, Rectangle1, &RegionDilation4, 2);

	//下边缘位置
	HTuple Rad1,Rad2,Rad3,Rad4,Rad5,Rad6;
	tuple_rad(10, &Rad1);
	tuple_rad(50, &Rad2);
	tuple_rad(90, &Rad3);
	tuple_rad(130, &Rad4);
	tuple_rad(170, &Rad5);
	tuple_rad(180, &Rad6);

	if (0 != (HTuple(HTuple(Angle>0).And(Angle<Rad1)).Or(HTuple(Angle>Rad5).And(Angle<Rad6))))
	{
		move_region(RegionDilation4, &RegionMoved, 20, 0);
	}
	else if (0 != (HTuple(HTuple(Angle>Rad1).And(Angle<Rad2)).Or(HTuple(Angle>Rad4).And(Angle<Rad5))))
	{
		move_region(RegionDilation4, &RegionMoved, 45, 0);
	}
	else if (0 != (HTuple(HTuple(Angle>Rad2).And(Angle<Rad3)).Or(HTuple(Angle>Rad3).And(Angle<Rad4))))
	{
		move_region(RegionDilation4, &RegionMoved, 90, 0);
	}
	//
	dilation_rectangle1(ARegionM, &ARegionMDilation, 10, 45);
	//20180128
	Hobject TopRegions;
	threshold(ImageReducedAroi, &TopRegions, ThredLower, 255);
	Hobject TopRegionsFillUp;
	fill_up(TopRegions,&TopRegionsFillUp);
	Hobject TopRegionOpening,TopRegionClosing,TopRegionConnected,SelectedRegions;
	opening_circle(TopRegionsFillUp, &TopRegionOpening, 3.5);
	closing_circle(TopRegionOpening, &TopRegionClosing, 3.5);
	connection(TopRegionClosing, &TopRegionConnected);
	select_shape(TopRegionConnected, &SelectedRegions, "area", "and", AreaLimitLower, 99999999);

	Hobject RegionFillUp;
	union2(SelectedRegions, ARegionMDilation, &RegionUnion1);
	union2(RegionUnion1, RegionMoved, &RegionUnion3);
	fill_up(RegionUnion3, &RegionFillUp);

	opening_rectangle1(ROI, &RoiOpening, 1, 45);
	erosion_circle(RoiOpening, &RegionErosion1, 8.5);
	difference(RegionErosion1, RegionFillUp, &RegionDifference3);

	connection(RegionDifference3, &ConnectedRegions2);
	select_shape(ConnectedRegions2, &SelectedRegions3, "row", "and", 0, PlatformRow);
	area_center(ABEllipseAffineTrans, &Area4, &BaseRow, &BaseColumn);
	smallest_rectangle1(PlatformReg, &Row1, &Column1, &Row2, &Column2);

	if (0 != (HTuple(BaseColumn>=Column1).And(BaseColumn<=Column2)))
	{

		select_shape(SelectedRegions3, &SelectedRegions2, "column", "and", Column1, Column2);

	}
	else if (0 != (BaseColumn<Column1))
	{

		select_shape(SelectedRegions3, &SelectedRegions2, "column", "and", BaseColumn, Column2);

	}
	else if (0 != (BaseColumn>Column2))
	{

		select_shape(SelectedRegions3, &SelectedRegions2, "column", "and", Column1, BaseColumn);
	}
	opening_circle(SelectedRegions2, &SelectedRegions2, 8.5);
	connection(SelectedRegions2,&SelectedRegions2);
	select_shape_std(SelectedRegions2, &(*InWallRegion), "max_area", 70);
	return;
}
STDMETHODIMP CPlugAlgo::T20_InWallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pPos,VARIANT* pGrayThred,VARIANT* pAreaLimitLower,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	float GrayThred   = (float)pGrayThred->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	int Pos   = (int)pPos->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_Platform.Id() == H_EMPTY_REGION||m_ConeEllipse.Id()==H_EMPTY_REGION||m_WholeRoi.Id()==H_EMPTY_REGION||m_ContEllipse.Id()==H_EMPTY_REGION||m_ImageReducedAroi.Id()==H_EMPTY_REGION||m_Angle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//剔除平台
		Hobject ARegionPlatDiff;
		difference(m_ARegionT, m_PlatformReg, &ARegionPlatDiff);

		//倒角
		Hobject RegionUnion,ConePlatformClosing;
		union2(m_ConeEllipse, m_PlatformReg, &RegionUnion);
		closing_circle(RegionUnion, &ConePlatformClosing, 65);
		Hobject ARegionM,InWallRegion,ConePlatformErosion;
		erosion_rectangle1(ConePlatformClosing,&ConePlatformErosion, 10, 1);
		difference(ARegionPlatDiff,ConePlatformErosion,&ARegionM);

		HTuple a,b,c,d;
		tuple_rad(2, &a);
		tuple_rad(80, &b);
		tuple_rad(100, &c);
		tuple_rad(178, &d);
		if(0 != (HTuple(HTuple(m_Angle>=a).And(m_Angle<=b)).Or(HTuple(m_Angle>=c).And(m_Angle<=d))))
		{
			P_20T_InWallRegionDetect(Pos,m_TopRect, m_Platform, ARegionM, m_WholeRoi, m_ContEllipse, m_ImageReducedAroi,GrayThred,AreaLimitLower, m_Angle, &InWallRegion);
		}
		else
		{
			gen_empty_region(&InWallRegion);
		}
		erosion_circle(InWallRegion,&InWallRegion,ErosionSize);
		m_vRgn[rId] = InWallRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_InWallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1102$\
					 167;B$\
					 1137;LP;10;280;1;195$\
					 1125;FP;20;250;0.5;70$\
					 1273;LP;1;5000;1;1500$\
					 1103;FP;3;35;0.5;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
//通用
STDMETHODIMP CPlugAlgo::SideTopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	//float ThredValue   = (float)pThredValue->fltVal;
	//float ClosingSize   = (float)pClosingSize->fltVal;

	//int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize   = (float)pErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ContEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopEllipse;
		move_region(m_ContEllipse, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);

		Hobject SideTopRegErosion;
		erosion_circle(Aroi,&SideTopRegErosion,ErosionSize);

		m_vRgn[rId] = SideTopRegErosion;
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideTopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1160$\
					 167;B$\
					 1019;LP;0;350;1;240$\
					 443;FP;1;20.5;0.5;2.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pABHErosionSize, VARIANT* pABVErosionSize,VARIANT* pDilationSize,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;

	int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	int ABVErosionSize   = (int)pABVErosionSize->fltVal;
	int DilationSize =(int)pDilationSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_WholeRoi.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//剔除AB基准线附近的反光干扰区域ABEdge
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdge,&RegionDilation, ABHErosionSize, ABVErosionSize);
		move_region(RegionDilation, &ABEdgeMoved, ABVErosionSize/2-3, 0);

		Hobject TotallRoi;
		erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
		//剔除叉口
		Hobject Platform;
		dilation_circle(m_Platform,&Platform,DilationSize);
		difference(TotallRoi, Platform, &TotallRoi);

		difference(TotallRoi,ABEdgeMoved,&TotallRoi);
		union1(TotallRoi,&TotallRoi);
		m_vRgn[rId] = TotallRoi ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1068;LP;1;35;1;5$\
					 1069;LP;9;35;1;10$\
					 1070;LP;1;35;1;10$\
					 1063;LP;1;45;1;12");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopCenterDetectAlgo(VARIANT* rgnId,VARIANT* pThreshUpValue,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float ThreshUpValue = (float)pThreshUpValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;
		//scale_image_max(Image, &ImageScaleMax);
		reduce_domain(Image, rgn, &ImageReduced);
		scale_image_max(ImageReduced, &ImageScaleMax);

		Hobject Regions1,RegionFillUp;
		threshold(ImageScaleMax, &Regions1, 0, ThreshUpValue);
		fill_up(Regions1, &RegionFillUp);
		Hobject RegionClosing, RegionOpening,RegionTrans;
		closing_circle(RegionFillUp, &RegionClosing, 25);
		opening_circle(RegionClosing, &RegionOpening, 2);

		shape_trans(RegionOpening, &RegionTrans, "outer_circle");
		HTuple InnerCircleRow, InnerCircleCol, InnerCircleRadius;
		smallest_circle(RegionTrans, &InnerCircleRow, &InnerCircleCol, &InnerCircleRadius);

		m_InnerCircleT=RegionTrans;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], RegionTrans, &m_vRgn[rId]);
		}

		//内孔圆的二次定位
		HTuple InnerCircleArea, RegionOpeningRow, RegionOpeningCol;
		area_center(RegionTrans, &InnerCircleArea, &RegionOpeningRow, &RegionOpeningCol);

		if (InnerCircleArea>0)
		{
			m_vPos[0].m_x = (float)InnerCircleCol[0].D();
			m_vPos[0].m_y = (float)InnerCircleRow[0].D();

			m_InnerCircleRow=InnerCircleRow;
			m_InnerCircleCol=InnerCircleCol;
			//m_InnerCircleRadius=InnerCircleRadius;
			retValue = InnerCircleArea[0].I();
			m_vErrorRgn[rId] = RegionTrans;
		}
		else
		{
			m_InnerCircleRow=m_imgHeight/2;
			m_InnerCircleCol=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopCenterDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1171$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1141;FP;1;250;0.5;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************************************
****函 数 名：T20_TopAngleDetectAlgo
****功    能：双叉胶塞的叉口角度检测
****注    意：该算子前先使用TopSealingFaceRegionLocationAlgo2算子,获取m_InnerCircleRow,m_InnerCircleCol ,二次定位的中心坐标
*****************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopAngleDetectAlgo(VARIANT* rgnId,VARIANT* pThreshValue,VARIANT* pGapAngle)
{
	int rId = (int)rgnId->fltVal;
	float ThreshValue = (float)pThreshValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_InnerCircleRow.Num()!=1||m_InnerCircleCol.Num()!=1)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject Image=m_crtImg; 
		Hobject ImageReduced,ImageEmphasize;
		reduce_domain(Image, rgn, &ImageReduced);
		emphasize(ImageReduced, &ImageEmphasize, 7, 7, 1);
		Hobject Regions2,RegionFillUp1,RegionOpening;
		threshold(ImageEmphasize, &Regions2, ThreshValue, 255);
		fill_up(Regions2, &RegionFillUp1);
		opening_circle(RegionFillUp1, &RegionOpening, 3.5);

		Hobject ConnectedRegions,SelectedRegions,GapRegion;
		HTuple GapArea, GapRow, GapCol;
		connection(RegionOpening, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &SelectedRegions, "max_area", 70);
		closing_circle(SelectedRegions, &GapRegion, 30);
		area_center(GapRegion, &GapArea, &GapRow, &GapCol);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapRegion, &m_vRgn[rId]);
		}

		//
		if (GapArea.Num()==1)
		{
			if ( GapArea>0)
			{
				m_GapRow=GapRow;
				m_GapCol=GapCol;
			}
		}
		else
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapAngle);
			return S_FALSE;
		}

		Hobject GapLine,GapCircle,CenterCircle,RegionUnion;
		HTuple Angle;
		gen_region_line(&GapLine, m_InnerCircleRow, m_InnerCircleCol, GapRow, GapCol);
		gen_circle(&GapCircle,GapRow, GapCol,5);
		gen_circle(&CenterCircle,m_InnerCircleRow, m_InnerCircleCol,10);
		union2(GapCircle,CenterCircle,&RegionUnion);
		orientation_region(RegionUnion, &Angle);

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], GapLine, &m_vRgn[rId]);
		}
		//
		if(GapArea>0)
		{
			m_modelAngle=Angle;
			//
			if (0 != (Angle<0))
			{
				Angle += PI;
			}
			HTuple Deg;
			tuple_deg(Angle, &Deg);
			retValue = Deg[0].D();
			m_vErrorRgn[rId] = GapLine;
		}
		else
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
		}
		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1081$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1176;FP;1;250;0.5;180");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************************************
****函 数 名：T20_TopRegionLocationAlgo
****功    能：双叉胶塞的顶部区域定位：顶部高亮区域、顶部斜坡区域、叉口平台区域 内壁区域
****注    意：该算子通过 pSelection 控制定位产生的区域（1，2，3，4）
****修    改： （一）针对一种双叉裸塞存在顶部小圆，对其进行扣除
****                 通过变量：m_TopFourCircles 传递，如果没有该区域，则为Null
*****************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pErosionSize,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	//
	int Radius = (int)pRadius->fltVal;
	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_OutCircle.Id()==H_EMPTY_REGION||m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1|| m_InnerCircleRadius.Num()!=1||m_modelAngle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject PolarTransImage,ImageDomain;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		//set_system("clip_region","false");
		HTuple Angle;
		Angle=HTuple(90).Rad()+m_modelAngle;

		if (Selection==1)  //顶部高亮区域
		{

			polar_trans_image_ext(m_ImageScaleMax, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, "nearest_neighbor");
			Hobject Regions,RegionFillUp2,ConnectedRegions,SelectedRegions;
			threshold(PolarTransImage, &Regions, ThredLower, 255);
			fill_up(Regions, &RegionFillUp2);
			connection(RegionFillUp2, &ConnectedRegions);
			select_shape(ConnectedRegions, &SelectedRegions, "area", "and", AreaLimitLower, 9999999);
			Hobject TopRegsClosing,TopRegs;
			closing_circle(SelectedRegions, &TopRegsClosing, 105);
			m_TopRegsClosing=TopRegsClosing;
			//两端缩放
			Hobject TopRegsErosion;
			polar_trans_region_inv(TopRegsClosing, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, Radius, (Radius*2)*3.14, Radius, m_imgWidth, m_imgHeight, "nearest_neighbor");
			union1(TopRegs,&TopRegs);
			erosion_circle(TopRegs,&TopRegsErosion,ErosionSize);
			//用于生成顶部缺胶检测区域
			m_RubberReg0=TopRegsClosing;
			//
			m_TopRegsDilationXY=TopRegs;
			m_TopRadius=Radius;
			intersection(TopRegsErosion, ImageDomain, &TopRegsErosion);
			
			// 针对润德一种双叉顶部带小圆胶塞，扣除小圆区域,没有小圆则m_TopFourCircles为空
			difference(TopRegsErosion,m_TopFourCircles,&TopRegsErosion);
			
			m_vRgn[rId] = TopRegsErosion ;	
		}
		else if(Selection==2)  //顶部斜坡区域
		{
			Hobject RegionMoved,TopRegsDilation,XYTransTopRegsDilation,RegionDilation2,TopRegsErosion;
			move_region(m_TopRegsClosing, &RegionMoved, 25, 0);
			dilation_circle(RegionMoved, &RegionDilation2, 35);
			erosion_rectangle1(RegionDilation2, &TopRegsErosion, ForkEdge, 1);
			polar_trans_region_inv(TopRegsErosion, &XYTransTopRegsDilation,  m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius,  m_imgWidth, m_imgHeight, "nearest_neighbor");

			if (InnerEdge>OutEdge)
			{
				InnerEdge=OutEdge-(float)2.0;
			}
			Hobject Circle5,Circle6,CircleDiff,TopSlopRegs;   
			shape_trans(m_TopRegsDilationXY, &Circle5, "outer_circle");

			Hobject OutCircle,InnerCircle;
			dilation_circle(Circle5, &OutCircle, OutEdge);
			dilation_circle(Circle5, &InnerCircle,InnerEdge);

			difference(OutCircle, InnerCircle, &CircleDiff);
			intersection(CircleDiff, XYTransTopRegsDilation, &TopSlopRegs);
			union1(TopSlopRegs,&TopSlopRegs);
			intersection(TopSlopRegs, ImageDomain, &TopSlopRegs);
			m_vRgn[rId] = TopSlopRegs ;	
		}
		else if(Selection==3)  //顶部叉口区域,以外圆中心坐标
		{
			//
			Hobject TopRegion,ConnectedRoiB;
			HTuple LongLength,ShortLength,Num1;
			union1(m_TopRegsDilationXY, &TopRegion);
			connection(TopRegion, &ConnectedRoiB);
			count_obj(ConnectedRoiB, &Num1);
			if (Num1!=2)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			Hobject ObjectSelected,RegionTrans;
			HTuple RowL, ColumnL, PhiL, Length1, Length2;
			select_obj(ConnectedRoiB, &ObjectSelected, 1);
			shape_trans(ObjectSelected, &RegionTrans, "rectangle2");
			smallest_rectangle2(RegionTrans, &RowL, &ColumnL, &PhiL, &Length1, &Length2);
			if (0 != (Length1>=Length2))
			{
				LongLength = Length1;
				ShortLength = Length2;
			}
			else if (0 != (Length1<Length2))
			{
				LongLength = Length2;
				ShortLength = Length1;
			}
			Hobject RectangleL,RegionL;
			gen_rectangle2(&RectangleL, RowL, ColumnL, PhiL, LongLength+100, ShortLength+ForkEdge);
			intersection(RectangleL, ImageDomain, &RegionL);

			gen_rectangle2(&m_RectL, RowL, ColumnL, PhiL, LongLength+100, ShortLength);
			Hobject RegionTrans1;
			HTuple RowR, ColumnR, PhiR, Length11, Length21,LongLength1,ShortLength1;
			select_obj(ConnectedRoiB, &ObjectSelected, 2);
			shape_trans(ObjectSelected, &RegionTrans1, "rectangle2");
			smallest_rectangle2(RegionTrans1, &RowR, &ColumnR, &PhiR, &Length11, &Length21);
			if (0 != (Length11>=Length21))
			{
				LongLength1 = Length11;
				ShortLength1 = Length21;
			}
			else if (0 != (Length11<Length21))
			{
				LongLength1 = Length21;
				ShortLength1 = Length11;
			}
			Hobject RectangleR,RegionR,RegionUnion,Circle8;
			gen_rectangle2(&RectangleR, RowR, ColumnR, PhiR, LongLength1+100,ShortLength1+ForkEdge);
			intersection(RectangleR, ImageDomain, &RegionR);
			union2(RegionL, RegionR, &RegionUnion);
			gen_rectangle2(&m_RectR, RowR, ColumnR, PhiR, LongLength1+100,ShortLength1);

			gen_circle(&Circle8, m_InnerCircleRow, m_InnerCircleCol, OutEdge);
			if (InnerEdge+10.0>OutEdge)
			{
				InnerEdge=OutEdge-(float)10.0;
			}
			Hobject Circle7,CircleDiff1,TopLowRegs;
			gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, InnerEdge+1.5);
			difference(Circle8, Circle7, &CircleDiff1);
			difference(CircleDiff1, RegionUnion, &TopLowRegs);
			opening_circle(TopLowRegs, &TopLowRegs, 3);
			union1(TopLowRegs,&TopLowRegs);

			intersection(TopLowRegs, ImageDomain, &TopLowRegs);

			// 针对润德一种双叉顶部带小圆胶塞，扣除小圆区域,没有小圆则m_TopFourCircles为空
			difference(TopLowRegs,m_TopFourCircles,&TopLowRegs);
			m_vRgn[rId] = TopLowRegs ;	
		}
		else if(Selection==4)  //内壁区域,如果存在，则进行开启
		{
			if (OutEdge<=InnerEdge+1.5)
			{
				OutEdge=InnerEdge+(float)1.5;
			}
			//Up边缘
			Hobject RectangleL1Dilation0,RectangleR1Dilation0;
			dilation_circle(m_RectL, &RectangleL1Dilation0, InnerEdge);
			dilation_circle(m_RectR, &RectangleR1Dilation0, InnerEdge);
			//Lower边缘
			Hobject RectangleL1Dilation,RectangleR1Dilation;
			dilation_circle(m_RectL, &RectangleL1Dilation, OutEdge);
			dilation_circle(m_RectR, &RectangleR1Dilation, OutEdge);

			Hobject RegionDiffR1,RegionDiffL1;
			difference(RectangleR1Dilation, RectangleR1Dilation0, &RegionDiffR1);
			difference(RectangleL1Dilation, RectangleL1Dilation0, &RegionDiffL1);
			Hobject OutCircle,InWallRegs;
			Hobject InWallRegsL,ConnectedRegions1;
			gen_circle(&OutCircle, m_InnerCircleRow,  m_InnerCircleCol, ForkEdge);
			intersection(OutCircle, RegionDiffL1, &InWallRegsL);
			connection(InWallRegsL, &ConnectedRegions1);
			select_shape_std(ConnectedRegions1, &InWallRegsL, "max_area", 70);
			Hobject InWallRegsR,ConnectedRegions2,InWallRegsUnion;
			intersection(OutCircle, RegionDiffR1, &InWallRegsR);
			connection(InWallRegsR, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &InWallRegsR, "max_area", 70);
			union2(InWallRegsL, InWallRegsR, &InWallRegsUnion);

			//剔除内孔区域
			Hobject InnerCircle;
			dilation_circle(m_InnerCircleT,&InnerCircle,3.5);
			difference(InWallRegsUnion,InnerCircle,&InWallRegs);
			intersection(InWallRegs, ImageDomain, &InWallRegs);
			m_vRgn[rId] = InWallRegs ;	
		}
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1118;LP;1;4;1;1$\
					 1075;LP;100;250;1;180$\
					 1076;FP;1;250;0.5;125$\
					 1077;LP;1;19000;1;8000$\
					 1082;FP;1;20;0.5;3.5$\
					 1177;LP;1;200;1;1$\
					 1178;FP;1;180;0.5;40$\
					 1179;FP;1;250;0.5;190");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************************************************
****函 数 名：T20_TopForkRegionLocationAlgo
****功    能：双叉胶塞的叉口整体区域定位
****修    改： （一）针对一种双叉裸塞存在顶部小圆，对其进行扣除
****                 通过变量：m_TopFourCircles 传递，如果没有该区域，则为Null
*****************************************************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopForkRegionLocationAlgo(VARIANT* rgnId, VARIANT* pRadius,VARIANT*pRoiWidth, VARIANT* pThredLower,VARIANT*pAreaLimitLower,VARIANT* pThreshUpValue,VARIANT* pForkEdge,VARIANT* pInnerEdge,VARIANT* pOutEdge)
{
	int rId = (int)rgnId->fltVal;
	float Radius =(float)pRadius->fltVal;
	float RoiWidth = (float)pRoiWidth->fltVal;

	float ThredLower = (float)pThredLower->fltVal;
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;

	float ThreshUpValue = (float)pThreshUpValue->fltVal;
	//float ErosionSize = (float)pErosionSize->fltVal;
	//
	int ForkEdge = (int)pForkEdge->fltVal;
	float InnerEdge = (float)pInnerEdge->fltVal;
	float OutEdge = (float)pOutEdge->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 || m_modelAngle.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageDomain;
		Hobject Image=m_crtImg;
		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		HTuple RadiusExt,RadiusInner,AngleS,WithPolar,HeightPolar;
		RadiusExt =(int) Radius;
		if (Radius-RoiWidth>3)
		{
			RadiusInner = RadiusExt-RoiWidth;
		}
		else
		{
			RadiusInner =2;
		}
		HTuple Angle;
		Angle=HTuple(90).Rad()+m_modelAngle;

		Hobject PolarTransImage,ImageScaleMax;
		AngleS = 3.1416*2.3;
		WithPolar = (((RadiusExt+RadiusInner)*AngleS)/2.0).Round();
		HeightPolar = ((RadiusExt-RadiusInner).Abs()).Round();
		polar_trans_image_ext(Image, &PolarTransImage, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, RadiusInner, RadiusExt, WithPolar, HeightPolar, "nearest_neighbor");
		//scale_image_max(PolarTransImage, &ImageScaleMax);

		//顶部高亮区域
		Hobject Regions4,RegionFillUp,ConnectedRegions5,SelectedRegions4;
		threshold(PolarTransImage, &Regions4, ThredLower, 255);
		fill_up(Regions4, &RegionFillUp);
		connection(RegionFillUp, &ConnectedRegions5);
		select_shape(ConnectedRegions5, &SelectedRegions4, "area", "and", AreaLimitLower, 9999999);

		//圆孔区域
		Hobject Regions1,RegionFillUp3,ConnectedRegions4,SelectedRegions1,RegionOpening,RegionBorder1;
		threshold(PolarTransImage, &Regions1, 0, ThreshUpValue);
		fill_up(Regions1, &RegionFillUp3);
		//
		Hobject RegionClosing;
		closing_circle(RegionFillUp3, &RegionClosing, RadiusInner);
		//
		connection(RegionClosing, &ConnectedRegions4);
		select_shape_std(ConnectedRegions4, &SelectedRegions1, "max_area", 70);
		opening_rectangle1(SelectedRegions1, &RegionOpening, 300, 1);
		boundary(RegionOpening, &RegionBorder1, "outer");
		Hobject Domain,RegionClipped,RegionIntersection,Contours1;
		HTuple ContRow, ContCol,RowMean,ColMean,Num1;
		get_domain(PolarTransImage, &Domain);
		clip_region_rel(Domain, &RegionClipped, 1, 1, 10, 10);
		intersection(RegionClipped, RegionBorder1, &RegionIntersection);
		//
		Hobject ConnectedRegions7,SortedRegions,ObjectSelected2;
		HTuple Number3;
		connection(RegionIntersection, &ConnectedRegions7);
		count_obj(ConnectedRegions7, &Number3);
		if (Number3<=0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		sort_region(ConnectedRegions7, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected2, Number3);

		//
		gen_contour_region_xld(ObjectSelected2, &Contours1, "center");
		HTuple Area2, Row4, Column4;
		area_center(ObjectSelected2, &Area2, &Row4, &Column4);
		if ((Area2==0)||(Area2.Num()!=1))
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		get_contour_xld(Contours1, &ContRow, &ContCol);
		if (ContRow.Num()==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}
		tuple_mean(ContRow, &RowMean);
		tuple_mean(ContCol, &ColMean);

		HTuple Number2,Row11, Column11, Row21, Column21,RowDiff;
		Hobject EmptyRegion,ObjectSelected1,RegionMoved1;
		count_obj(SelectedRegions4, &Number2);
		gen_empty_region(&EmptyRegion);
		for (int i=1;i<=Number2;i++)
		{
			select_obj(SelectedRegions4, &ObjectSelected1, i);
			smallest_rectangle1(ObjectSelected1, &Row11, &Column11, &Row21, &Column21);
			RowDiff = (RowMean-Row11).Abs();
			move_region(ObjectSelected1, &RegionMoved1, (-RowDiff)-ForkEdge, 0);
			concat_obj(EmptyRegion, RegionMoved1, &EmptyRegion);
		}
		Hobject RegionUnion3,TopRegs;
		union1(EmptyRegion, &RegionUnion3);
		polar_trans_region_inv(RegionUnion3, &TopRegs, m_InnerCircleRow, m_InnerCircleCol, Angle,6.28319+Angle, RadiusInner, RadiusExt, WithPolar, HeightPolar, m_imgWidth, m_imgHeight, "nearest_neighbor");
		Hobject EmptyRect,ConnectedRegions6,ObjectSelected,RegionTrans,RectangleR;
		HTuple Number1,RowR, ColumnR, PhiR, Length11, Length21,LongLength1,ShortLength1;
		gen_empty_region(&EmptyRect);
		connection(TopRegs, &ConnectedRegions6);
		count_obj(ConnectedRegions6, &Number1);
		for (int i=1;i<=Number1;i++)
		{

			select_obj(ConnectedRegions6, &ObjectSelected, i);
			shape_trans(ObjectSelected, &RegionTrans, "rectangle2");
			smallest_rectangle2(RegionTrans, &RowR, &ColumnR, &PhiR, &Length11, &Length21);
			if (0 != (Length11>=Length21))
			{
				LongLength1 = Length11;
				ShortLength1 = Length21;
			}
			else if (0 != (Length11<Length21))
			{
				LongLength1 = Length21;
				ShortLength1 = Length11;
			}
			gen_rectangle2(&RectangleR, RowR, ColumnR, Angle, LongLength1+100, ShortLength1);
			concat_obj(EmptyRect, RectangleR, &EmptyRect);
		}
		Hobject Circle8;
		union1(EmptyRect,&EmptyRect);
		gen_circle(&Circle8, m_InnerCircleRow, m_InnerCircleCol, OutEdge);
		if (InnerEdge+10.0>OutEdge)
		{
			InnerEdge=OutEdge-(float)10.0;
		}
		Hobject Circle7,CircleDiff1,TopLowRegs,SlectReg;
		gen_circle(&Circle7, m_InnerCircleRow, m_InnerCircleCol, InnerEdge+1.5);
		difference(Circle8, EmptyRect, &CircleDiff1);
		connection(CircleDiff1,&CircleDiff1);
		select_shape_std(CircleDiff1,&SlectReg,"max_area",70);

		difference(SlectReg, Circle7, &TopLowRegs);
		opening_circle(TopLowRegs, &TopLowRegs, 2.5);
		union1(TopLowRegs,&TopLowRegs);
		intersection(TopLowRegs, ImageDomain, &TopLowRegs);
		
		// 针对润德一种双叉顶部带小圆胶塞，扣除小圆区域,没有小圆则m_TopFourCircles为空
		difference(TopLowRegs, m_TopFourCircles,&TopLowRegs);
		
		m_vRgn[rId] = TopLowRegs ;	

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopForkRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1073$\
					 167;B$\
					 1130;FP;80.0;350.0;0.5;230$\
					 413;FP;1.5;260;0.5;180$\
					 1076;FP;1;250;0.5;130$\
					 1077;LP;1;25000;1;6000$\
					 1141;FP;1;250;0.5;52$\
					 1078;LP;0;30;1;5$\
					 1079;FP;1;160;0.5;60$\
					 1080;FP;1;250;0.5;190");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_SideSlopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_AroiTClosing.Id() == H_EMPTY_REGION||m_ConeEllipse.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 250);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//往上平移5个像素，实际情况调整
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1;
		move_region(m_ARegionT, &ARegionTMoved, -0, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		//
		HTuple ARegionTArea, ARegionTRow, ARegionTColumn;
		Hobject SelectedRegions,RegionUnion,RegionMoved;
		area_center(m_ARegionT, &ARegionTArea, &ARegionTRow, &ARegionTColumn);
		select_shape(ConnectedRegions1, &SelectedRegions, "row", "and", 0, ARegionTRow);
		union1(SelectedRegions, &RegionUnion);
		//
		HTuple AroiTRegArea, AroiTRegRow, AroiTRegColumn,ABEllipseArea, ABEllipseRowCenter, ABEllipseColumnCenter;
		area_center(m_AroiTClosing, &AroiTRegArea, &AroiTRegRow, &AroiTRegColumn);
		area_center(m_ABEllipse, &ABEllipseArea, &ABEllipseRowCenter, &ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-AroiTRegRow)+MoveSize), -(ABEllipseColumnCenter-AroiTRegColumn));

		Hobject RegionErosion1,RegionDifference2,ConnectedRegions5,SelectedRegions1,RegionIntersection1;
		erosion_rectangle1(RegionMoved, &RegionErosion1, 15, 1);
		difference(m_ROI, RegionErosion1, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		intersection(SelectedRegions1, RegionUnion, &RegionIntersection1);

		//倒角
		Hobject RegionUnion2,ConePlatformClosing;
		union2(m_ConeEllipse, m_PlatformReg, &RegionUnion2);
		closing_circle(RegionUnion2, &ConePlatformClosing, 60);

		Hobject SideSlopReg;
		difference(RegionIntersection1, ConePlatformClosing, &SideSlopReg);
		HTuple PlatformRegArea, PlatformRegRow,PlatformRegColumn;
		area_center(m_PlatformReg, &PlatformRegArea, &PlatformRegRow, &PlatformRegColumn);

		if (0 != (PlatformRegArea==0))
		{
			Hobject ConnectedRegions2;
			connection(SideSlopReg, &ConnectedRegions2);
			select_shape_std(ConnectedRegions2, &SideSlopReg, "max_area", 70);
		}
		opening_circle(SideSlopReg, &SideSlopReg, 2);
		HTuple ROIRow1,ROIColumn1,ROIRow2,ROIColumn2;
		HTuple InnerRow1, InnerCol1, InnerRow2, InnerCol2;
		inner_rectangle1(m_ARegionT, &InnerRow1, &InnerCol1, &InnerRow2, &InnerCol2);
		HTuple OutRow1, OutCol1, OutRow2, OutCol2;
		smallest_rectangle1(m_ARegionT, &OutRow1, &OutCol1, &OutRow2, &OutCol2);
		smallest_rectangle1(m_ROI, &ROIRow1, &ROIColumn1, &ROIRow2, &ROIColumn2);
		//叉口角度判断,裁剪斜坡区域两端
		HTuple a,b,c;
		tuple_rad(5, &a);
		tuple_rad(175, &b);
		tuple_rad(180, &c);
		if (0 != (((m_Angle>=0)&&(m_Angle<=a))||((m_Angle>b)&&(m_Angle<=c))))
		{
			clip_region(SideSlopReg, &SideSlopReg, ROIRow1, InnerCol1+20, OutRow2, InnerCol2-20);
		}
		//水平缩放
		Hobject SideSlopRegErosion;
		erosion_rectangle1(SideSlopReg,&SideSlopRegErosion,HErosionSize,VErosionSize);
		m_vRgn[rId] = SideSlopRegErosion ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;0;30;1;10$\
					 994;LP;1;35;1;1$\
					 995;LP;1;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_WholeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pABHErosionSize, VARIANT* pABVErosionSize,VARIANT*pDilationSize,VARIANT*pDilationSize0,VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;
	int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	int ABVErosionSize   = (int)pABVErosionSize->fltVal;

	int DilationSize =(int)pDilationSize->fltVal;
	int DilationSize0 =(int)pDilationSize0->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_WholeRoi.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//剔除AB基准线附近的反光干扰区域ABEdge
		Hobject ABEdgeMoved,RegionDilation;
		dilation_rectangle1(m_ABEdge,&RegionDilation, ABHErosionSize, ABVErosionSize);
		move_region(RegionDilation, &ABEdgeMoved, ABVErosionSize/2-3, 0);

		Hobject TotallRoi;
		erosion_circle(m_WholeRoi,&TotallRoi, ErosionSize);
		difference(TotallRoi,ABEdgeMoved,&TotallRoi);
		//剔除三角花纹高亮区域
		Hobject TriangleRoi;
		dilation_circle(m_TriangleRoi,&TriangleRoi,DilationSize);
		difference(TotallRoi,TriangleRoi,&TotallRoi);
		//剔除叉口
		Hobject Platform;
		dilation_circle(m_Platform,&Platform,DilationSize0);
		difference(TotallRoi, Platform, &TotallRoi);
		union1(TotallRoi,&TotallRoi);
		m_vRgn[rId] = TotallRoi ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_WholeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1065$\
					 167;B$\
					 1068;LP;1;35;1;5$\
					 1069;LP;9;35;1;10$\
					 1020;LP;1;35;1;10$\
					 1070;LP;1;35;1;10$\
					 1063;LP;1;45;1;12");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::T20_TopRubberRegionLocationAlgo(VARIANT* rgnId, VARIANT* pInnerEdge,VARIANT* pOutEdge,VARIANT*pForkEdge)
{
	int rId = (int)rgnId->fltVal;
	int ForkEdge = (int)pForkEdge->fltVal;
	int InnerEdge = (int)pInnerEdge->fltVal;
	int OutEdge = (int)pOutEdge->fltVal;

	//int AreaLimitLower=(int)pAreaLimitLower->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if (m_RubberReg0.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	if (m_InnerCircleRow.Num()!=1 || m_InnerCircleCol.Num()!=1 || m_modelAngle.Num()!=1||m_TopRadius.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		HTuple Angle;
		Angle=HTuple(90).Rad()+m_modelAngle;
		Hobject RegionMoved,RegionDilation,RegionDilation1,RegionDiff;
		move_region(m_RubberReg0,&RegionMoved, ForkEdge, 1);
		dilation_rectangle1(RegionMoved, &RegionDilation, InnerEdge, 1);
		//
		if (OutEdge>0)
		{
			dilation_rectangle1(RegionMoved,&RegionDilation1, OutEdge, 20);

		} 
		else if(OutEdge<0)
		{
			erosion_rectangle1(RegionMoved,&RegionDilation1, -OutEdge, 1);
			dilation_rectangle1(RegionDilation1,&RegionDilation1, 1, 20);
		}
		else
		{
			dilation_rectangle1(RegionMoved,&RegionDilation1, 1, 20);
		}
		//dilation_rectangle1(RegionMoved, &RegionDilation1, OutEdge, 20);
		difference(RegionDilation, RegionDilation1, &RegionDiff);
		Hobject RubberRegs;
		polar_trans_region_inv(RegionDiff, &RubberRegs, m_InnerCircleRow, m_InnerCircleCol, Angle, 6.28319+Angle, 0, m_TopRadius, (m_TopRadius*2)*3.14, m_TopRadius, m_imgWidth, m_imgHeight, "nearest_neighbor");
		union1(RubberRegs,&RubberRegs);

		m_vRgn[rId] = RubberRegs;
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopRubberRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1157$\
					 167;B$\
					 1158;LP;1;150;1;80$\
					 1159;LP;-20;20;1;1$\
					 1103;LP;1;50;1;25");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
***函数名：T20_StripePatternRegionLocationAlgo
***功  能：提取花纹整体包括：三角花纹和圆形花纹
***************************************************************************/
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgo(VARIANT* rgnId, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//花纹
		Hobject StripeReg;
		union2(m_LowerReg,m_UpReg,&StripeReg);
		union1(StripeReg,&StripeReg);

		//缩放
		Hobject StripeRegDilation,RegionDetect;
		if (VErosionSize>=1)
		{
			dilation_rectangle1(StripeReg,&StripeRegDilation,VErosionSize,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			erosion_rectangle1(StripeReg,&StripeRegDilation,-VErosionSize,-VErosionSize);
		}
		else
		{
			StripeRegDilation=StripeReg;
		}
		//水平缩放
		clip_region_rel(StripeRegDilation,&RegionDetect,0,0,HErosionSize,HErosionSize);
		Hobject StripRegion,PlatformRegDilated;
		intersection(m_ARegionT,RegionDetect,&StripRegion);
		dilation_rectangle1(m_PlatformReg,&PlatformRegDilated,10,1);
		difference(StripRegion,PlatformRegDilated,&StripRegion);
		opening_circle(StripRegion,&StripRegion,1.5);
		m_vRgn[rId] = StripRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 994;LP;1;35;1;1$\
					 995;LP;-35;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************************
***函数名：T20_StripePatternRegionLocationAlgo1
***功  能：提取花纹：增加了区域开关，可以选择显示三角花纹、圆形花纹、花纹整体、三角花纹高亮区域
**********************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgo1(VARIANT* rgnId, VARIANT*pSelection,VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT*pDilationSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}	
		Hobject StripeReg;
		if (Selection==1)
		{
			//上排花纹
			union1(m_UpReg,&StripeReg);
		} 
		else if(Selection==2)
		{
			union1(m_LowerReg,&StripeReg);
			//扣除三角花纹亮斑
			Hobject Triangle,Strip;
			dilation_circle(m_TriangleRoi,&Triangle,DilationSize);
			difference(StripeReg,Triangle,&Strip);
			closing_rectangle1(Strip,&StripeReg,35,1);
		}
		else if(Selection==3)
		{
			// 全部花纹
			union2(m_LowerReg,m_UpReg,&StripeReg);
			union1(StripeReg,&StripeReg);
		}
		else if(Selection==4)
		{
			// 三角花纹的高亮区域
			Hobject TriangleRoi;
			fill_up(m_TriangleRoi,&TriangleRoi);
			closing_circle(TriangleRoi,&TriangleRoi,2.5);

			Hobject Triangle;
			HTuple EVSize;
			EVSize = DilationSize-4;
			if (EVSize<0)
			{
				dilation_circle(TriangleRoi,&Triangle,-EVSize);
			}
			else if(EVSize >0)
			{
				erosion_circle(TriangleRoi,&Triangle,EVSize);
			}
			else
			{
				Triangle=TriangleRoi;
			}
			union1(Triangle,&StripeReg);
		}

		//缩放
		Hobject StripeRegDilation,RegionDetect;
		if (VErosionSize>=1)
		{
			dilation_rectangle1(StripeReg,&StripeRegDilation,1,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			erosion_rectangle1(StripeReg,&StripeRegDilation,1,-VErosionSize);
		}
		else
		{
			StripeRegDilation=StripeReg;
		}
		//水平缩放
		clip_region_rel(StripeRegDilation,&RegionDetect,0,0,HErosionSize,HErosionSize);
		Hobject StripRegion,PlatformRegDilated;
		intersection(m_ARegionT,RegionDetect,&StripRegion);
		dilation_rectangle1(m_PlatformReg,&PlatformRegDilated,10,1);
		difference(StripRegion,PlatformRegDilated,&StripRegion);

		opening_circle(StripRegion,&StripRegion,1.5);
		m_vRgn[rId] = StripRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 1329;LP;1;4;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;-35;35;1;1$\
					 1330;LP;1;20;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************************
***函数名：T20_StripePatternRegionLocationAlgo2
***功  能：提取花纹：在1算子的基础上增加了对三角花纹下区域的裁剪
***修  改：（一）内  容：加opening_circle 函数；将closing_rectanglec尺寸从35减小至25
**               时  间: 2018年10月26日
**               修改人：吴贻峰
**********************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgo2(VARIANT* rgnId, VARIANT*pSelection,VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT*pDilationSize,VARIANT*pCircleUpRgnPos,VARIANT* pTriangleDownRgnPos)
{
	int rId           = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;
	float TriangleDownRgnPos = (float)pTriangleDownRgnPos->fltVal;
	float CircleUpRgnPos = (float)pCircleUpRgnPos->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id()==H_EMPTY_REGION||m_LowerReg.Id()==H_EMPTY_REGION||m_UpReg.Id()==H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}	
		Hobject StripeReg;
		if (Selection==1)
		{
			//上排花纹
			HTuple iNum;
			Hobject  rgnStripeCon ;
			union1(m_UpReg,&StripeReg);
			connection(StripeReg,&rgnStripeCon);
			count_obj(rgnStripeCon,&iNum);

			if((iNum>3) || (iNum<=0))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			Hobject rgnStripClipAll,rgnStripSel,rgnRectCircle,rgnStripClip;
			HTuple  dRow1Circle,dCol1Circle,dRow2Circle,dCol2Circle ;
			gen_empty_obj(&rgnStripClipAll);
			for (int i=1;i<=iNum;++i)
			{   
				select_obj(rgnStripeCon,&rgnStripSel,i);
				move_region(rgnStripSel,&rgnStripClip,(Hlong)CircleUpRgnPos,0);
				intersection(rgnStripSel,rgnStripClip,&rgnStripClip);
				//smallest_rectangle1(rgnStripSel,&dRow1Circle, &dCol1Circle, &dRow2Circle, &dCol2Circle);
				//gen_rectangle1(&rgnRectCircle,dRow1Circle, dCol1Circle, dRow2Circle, dCol2Circle);
				////clip_region(rgnStripSel, &rgnStripClip, dRow1Triangle.Select(i-1), dCol1Triangle.Select(i-1), dRow2Triangle.Select(i-1)-TriangleDownRgnPos,dCol2Triangle.Select(i-1));
				//clip_region(rgnStripSel, &rgnStripClip, dRow1Circle+CircleUpRgnPos, dCol1Circle, dRow2Circle,dCol2Circle);

				concat_obj(rgnStripClipAll,rgnStripClip,&rgnStripClipAll);
			}

			union1(rgnStripClipAll,&StripeReg);

		} 
		else if(Selection==2)
		{
			//扣除三角花纹亮斑,得到三角花纹的三角区域
			Hobject Triangle,rgnStripe,Strip,rgnStripeCls,rgnTriangleSel,rgnStripCon,rgnStripOpn;
			HTuple dAreaTriangleSel, dRowTriangleSel, dColTriangleSel;
			union1(m_LowerReg,&rgnStripe);
			dilation_circle(m_TriangleRoi,&Triangle,DilationSize);
			difference(rgnStripe,Triangle,&Strip);
			opening_circle(Strip,&rgnStripOpn,2.5);
			closing_rectangle1(rgnStripOpn,&rgnStripeCls,25,1);

			connection(rgnStripeCls,&rgnStripCon);
			select_shape(rgnStripCon, &rgnTriangleSel, "area", "and", 80, 9999999);

			area_center(rgnTriangleSel, &dAreaTriangleSel, &dRowTriangleSel, &dColTriangleSel);
			if (dAreaTriangleSel==0)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			Hobject rgnRecTriangle,rgnStripSel,rgnStripClip,rgnStripClipAll;
			HTuple iNum,dRow1Triangle, dCol1Triangle, dRow2Triangle, dCol2Triangle ;

			count_obj(rgnTriangleSel,&iNum);

			if((iNum>3) || (iNum<=0))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			gen_empty_obj(&rgnStripClipAll);
			for (int i=1;i<=iNum;++i)
			{   
				select_obj(rgnTriangleSel,&rgnStripSel,i);
				smallest_rectangle1(rgnStripSel,&dRow1Triangle, &dCol1Triangle, &dRow2Triangle, &dCol2Triangle);
				gen_rectangle1(&rgnRecTriangle,dRow1Triangle, dCol1Triangle, dRow2Triangle, dCol2Triangle);
				//clip_region(rgnStripSel, &rgnStripClip, dRow1Triangle.Select(i-1), dCol1Triangle.Select(i-1), dRow2Triangle.Select(i-1)-TriangleDownRgnPos,dCol2Triangle.Select(i-1));
				clip_region(rgnStripSel, &rgnStripClip, dRow1Triangle, dCol1Triangle, dRow2Triangle-TriangleDownRgnPos,dCol2Triangle);

				concat_obj(rgnStripClipAll,rgnStripClip,&rgnStripClipAll);
			}

			union1(rgnStripClipAll,&StripeReg);

		}
		else if(Selection==3)
		{
			// 全部花纹
			union2(m_LowerReg,m_UpReg,&StripeReg);
			union1(StripeReg,&StripeReg);
		}
		else if(Selection==4)
		{
			// 三角花纹的高亮区域
			Hobject TriangleRoi;
			fill_up(m_TriangleRoi,&TriangleRoi);
			closing_circle(TriangleRoi,&TriangleRoi,2.5);

			Hobject Triangle;
			HTuple EVSize;
			EVSize = DilationSize-4;
			if (EVSize<0)
			{
				dilation_circle(TriangleRoi,&Triangle,-EVSize);
			}
			else if(EVSize >0)
			{
				erosion_circle(TriangleRoi,&Triangle,EVSize);
			}
			else
			{
				Triangle=TriangleRoi;
			}
			union1(Triangle,&StripeReg);
		}

		//缩放
		Hobject StripeRegDilation,RegionDetect;
		if (VErosionSize>=1)
		{
			dilation_rectangle1(StripeReg,&StripeRegDilation,1,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			erosion_rectangle1(StripeReg,&StripeRegDilation,1,-VErosionSize);
		}
		else
		{
			StripeRegDilation=StripeReg;
		}
		//水平缩放
		clip_region_rel(StripeRegDilation,&RegionDetect,0,0,HErosionSize,HErosionSize);
		Hobject StripRegion,PlatformRegDilated;
		intersection(m_ARegionT,RegionDetect,&StripRegion);
		dilation_rectangle1(m_PlatformReg,&PlatformRegDilated,10,1);
		difference(StripRegion,PlatformRegDilated,&StripRegion);

		opening_circle(StripRegion,&StripRegion,1.5);
		m_vRgn[rId] = StripRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_StripePatternRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 1329;LP;1;4;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;-35;35;1;1$\
					 1330;LP;1;20;1;1$\
					 6014;FP;0;50;0.5;0$\
					 6012;FP;0;50;0.5;0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：AB20_DownEdgeDetectAlgo
***功  能：对AB20圆形胶塞的覆膜的上边缘和下边缘进行提取
***原  理：通过梯度法和measure_pose（极性控制） 两种方法来寻找覆膜的上下边缘；
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_DownEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject DownEdge,DownEdgeDilation,DownEdgeDilationCliped;
		move_region(m_ABEdgeM, &DownEdge, -MoveSize, 0);
		dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		/*Hobject PlatformRegMoved;
		move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);
		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		difference(DownEdgeDilationCliped, PlatformRegMoved, &DownEdgeDiff);*/

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		intersection(DownEdgeDilationCliped, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}
		//HTuple DefinedRow, DefinedCol;
		//R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		////P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		//
		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"positive", "first", &DefinedRow0, &DefinedCol0);

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////      
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_DownEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1106$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;30;1;5$\
					 1105;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_DownEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_DownEdge.Id()== H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject PlatformRegMoved,DownEdgeRegDilation;
		//move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);

		Hobject DownEdgeReg,DownEdgeRegIntersction;
		move_region(m_DownEdge, &DownEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(DownEdgeReg,&DownEdgeRegDilation,1,DialtionSizeV);

		intersection(DownEdgeRegDilation,m_ARegionT,&DownEdgeRegIntersction);
		//水平缩放
		Hobject RegionClip;
		clip_region_rel(DownEdgeRegIntersction, &RegionClip, 0, 0, HErosionSize, HErosionSize);
		Hobject DownEdgeRegion,ImageDomain;
		difference(RegionClip,m_Platform0,&DownEdgeRegion);
		connection(DownEdgeRegion,&DownEdgeRegion);
		select_shape_std(DownEdgeRegion, &DownEdgeRegion, "max_area", 70);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(DownEdgeRegion, ImageDomain, &DownEdgeRegion);

		m_vRgn[rId] = DownEdgeRegion ;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_DownEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1194$\
					 167;B$\
					 1190;LP;-20;20;1;3$\
					 994;LP;1;70;1;10$\
					 995;LP;1;50;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
***函数名：AB20_DownEdgeDetectAlgo1
***功  能：对AB20圆形胶塞的覆膜的上边缘和下边缘进行提取
***修  改：在原来算子的基础上将measure_pose（极性控制） 从first修改为last；
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_DownEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		Hobject DownEdge,DownEdgeDilation,DownEdgeDilationCliped;
		move_region(m_ABEdgeM, &DownEdge, -MoveSize, 0);
		dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		/*Hobject PlatformRegMoved;
		move_region(m_PlatformReg, &PlatformRegMoved, 0, 0);
		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		difference(DownEdgeDilationCliped, PlatformRegMoved, &DownEdgeDiff);*/

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		intersection(DownEdgeDilationCliped, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}
		//HTuple DefinedRow, DefinedCol;
		//R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		////P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow, &DefinedCol);
		//
		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"positive", "last", &DefinedRow0, &DefinedCol0);

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////      
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_DownEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1106$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;30;1;5$\
					 1105;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************************
***函数名：AB32_DownEdgeDetectAlgo
***功  能：对AB32圆形覆膜胶塞的覆膜的上边缘和下边缘进行提取(针对其覆膜边缘和颈部基准线基本上重合)
***说  明：根据AB20_DownEdgeDetectAlgo1 算子进行修改；
***修  改：（1）内容：将上下边缘的阈值参数区分开来
***             时间：2019年6月27日
**********************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pThresholdDown,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	float ThresholdDown = (float)pThresholdDown->fltVal;
	int ValueThred    =(int)pValueThred->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION )
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		//HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HClipSize, HClipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);

		Hobject DownEdge,DownEdgeDilation;
		move_region(ABReg, &DownEdge, -MoveSize, 0);

		Hobject RegionDilation;
		dilation_rectangle1(DownEdge, &RegionDilation, 1, SearchSize);

		Hobject DownEdgeDilationCliped;
		DownEdgeDilationCliped = RegionDilation;

		//dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		//clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		intersection(DownEdgeDilationCliped, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}

		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		// m_ABEdge加入,为拐角区域传递变量
		gen_region_contour_xld(DownEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		/////////////////////////////

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, ThresholdDown,"negative", "first", &DefinedRow0, &DefinedCol0);

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////      
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;
		
		///  基准线相关变量传递 m_ABEdgeReg
		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(DownEdgePoints, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;
		// 传递找到的覆膜边缘
		m_DownEdgeReg = DownEdgeReg;
		m_DownEdgeReg2 = DownEdgeReg2;
	    ///////////////////////////////////////////////////////////////////////////////////////////////////////
		

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5528$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;100;1;5$\
					 6073;FP;0.5;10;0.5;3$\
					 6063;FP;0.5;10;0.5;3$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************************
***函数名：AB32_DownEdgeDetectAlgo1（华强定制算子）
***功  能：对AB32圆形覆膜胶塞的覆膜的上边缘和下边缘进行提取(针对其覆膜边缘和颈部基准线基本上重合)
***说  明：根据AB32_DownEdgeDetectAlgo 算子进行修改；
***修  改：（1）内容：设置了一个新参数：重合点阈值，判断上下边缘的重合点个数，超过阈值则使用新的方法寻找
***             时间：2019年6月27日
**********************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgo1(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pThresholdDown,VARIANT* pSamePointsThred,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	float ThresholdDown = (float)pThresholdDown->fltVal;
	int SamePointsThred    =(int)pSamePointsThred->fltVal; 
	int ValueThred    =(int)pValueThred->fltVal;            

	// 覆膜下边缘二次提取flag
	m_bSecondFlag = false;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION )
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		//HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HClipSize, HClipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);

		Hobject DownEdge,DownEdgeDilation;
		move_region(ABReg, &DownEdge, -MoveSize, 0);

		Hobject RegionDilation;
		dilation_rectangle1(DownEdge, &RegionDilation, 1, SearchSize);

		Hobject DownEdgeDilationCliped;
		DownEdgeDilationCliped = RegionDilation;

		//dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		//clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		intersection(DownEdgeDilationCliped, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}

		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		// 覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "first", &DefinedRow0, &DefinedCol0);

		// 判断重合点个数
		HTuple distPP,distPPLess,indiceS,iSameNum,DefinedRow3,DefinedCol3;
		iSameNum = HTuple();
		distance_pp(DefinedRow1,DefinedCol1,DefinedRow0,DefinedCol0,&distPP);
		tuple_less_elem(distPP,2,&distPPLess);
		tuple_find(distPPLess,1,&indiceS);
		tuple_length(indiceS,&iSameNum);

		if ( iSameNum > SamePointsThred)
		{
			R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, ThresholdDown,"positive", "last", &DefinedRow3, &DefinedCol3);
		}

		
		if ( DefinedRow1.Num()*2/3.0 < DefinedRow3.Num())
		{
			DefinedRow0 = HTuple();
			DefinedRow0 = HTuple();
			DefinedRow0 = DefinedRow3;
			DefinedCol0 = DefinedCol3;
		}

		if ( ( iSameNum > SamePointsThred) && (( DefinedRow1.Num()*2/3.0 > DefinedRow3.Num())))
		{
			 m_bSecondFlag = true;
		}

		////////////////////////////////////////////////////////
		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		// m_ABEdge加入,为拐角区域传递变量
		gen_region_contour_xld(DownEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		/////////////////////////////

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
			//concat_obj(m_vRgn[rId], DownEdgeReg, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点
		
		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		union1(DownEdgePoints,&DownEdgePoints);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		partition_rectangle(DownEdge, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////      
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;

		///  基准线相关变量传递 m_ABEdgeReg
		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(DownEdgePoints, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		// 传递找到的覆膜边缘
		m_DownEdgeReg = DownEdgeReg;
		m_DownEdgeReg2 = DownEdgeReg2;

		///////////////////////////////////////////////////////////////////////////////////////////////////////


		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}

		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6067$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;100;1;5$\
					 6073;FP;0.5;10;0.5;3$\
					 6063;FP;0.5;10;0.5;3$\
					 6064;LP;1;100;1;10$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgo2(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pSearchSize, VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pThresholdDown,VARIANT* pSamePointsThred,VARIANT* pValueThred, VARIANT* pEdgeArea)
{
	//提取覆膜边缘的上下点
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	int HClipSize    =(int)pHClipSize->fltVal;

	float Threshold     =(float)pThreshold->fltVal;
	float ThresholdDown = (float)pThresholdDown->fltVal;
	int SamePointsThred    =(int)pSamePointsThred->fltVal; 
	int ValueThred    =(int)pValueThred->fltVal;            

	// 覆膜下边缘二次提取flag
	m_bSecondFlag = false;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION )
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImg = m_crtImg;

		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		//HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HClipSize, HClipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);

		Hobject DownEdge,DownEdgeDilation;
		move_region(ABReg, &DownEdge, -MoveSize, 0);

		Hobject RegionDilation;
		dilation_rectangle1(DownEdge, &RegionDilation, 1, SearchSize);

		Hobject DownEdgeDilationCliped;
		DownEdgeDilationCliped = RegionDilation;

		//dilation_rectangle1(DownEdge, &DownEdgeDilation, 1, SearchSize);
		//clip_region_rel(DownEdgeDilation,&DownEdgeDilationCliped,0,0,HClipSize,HClipSize);

		Hobject DownEdgeDiff,DownEdgeSearchReg,DownEdgeImageReduced;
		intersection(DownEdgeDilationCliped, m_ROI, &DownEdgeSearchReg);
		reduce_domain(crtImg,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		expand_domain_gray(DownEdgeImageReduced,&DownEdgeImageReduced,5);
		median_image (DownEdgeImageReduced, &DownEdgeImageReduced, "circle", 1.5, "mirrored");
		reduce_domain(DownEdgeImageReduced,DownEdgeSearchReg, &DownEdgeImageReduced);
		//
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgeSearchReg, &m_vRgn[rId]);
		}

		HTuple Area,Row,Col;
		area_center(DownEdgeSearchReg,&Area,&Row,&Col);
		if (Area==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		//覆膜上边缘点
		HTuple DefinedRow1,DefinedCol1,DefinedRow2,DefinedCol2,DefinedRow,DefinedCol;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "last", &DefinedRow1, &DefinedCol1);
		P_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, SearchSize, 1, &DefinedRow2, &DefinedCol2);

		// 覆膜下边缘点
		HTuple DefinedRow0,DefinedCol0;
		R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, Threshold,"negative", "first", &DefinedRow0, &DefinedCol0);

		// 判断重合点个数
		HTuple distPP,distPPLess,indiceS,iSameNum,DefinedRow3,DefinedCol3;
		iSameNum = HTuple();
		distance_pp(DefinedRow1,DefinedCol1,DefinedRow0,DefinedCol0,&distPP);
		tuple_less_elem(distPP,2,&distPPLess);
		tuple_find(distPPLess,1,&indiceS);
		tuple_length(indiceS,&iSameNum);

		if ( iSameNum > SamePointsThred)
		{
			R_EdgePointsFitCurve(DownEdgeSearchReg, DownEdgeImageReduced, 5, 1, ThresholdDown,"positive", "last", &DefinedRow3, &DefinedCol3);
		}


		if ( DefinedRow1.Num()*2/3.0 < DefinedRow3.Num())
		{
			DefinedRow0 = HTuple();
			DefinedRow0 = HTuple();
			DefinedRow0 = DefinedRow3;
			DefinedCol0 = DefinedCol3;
		}

		if ( ( iSameNum > SamePointsThred) && (( DefinedRow1.Num()*2/3.0 > DefinedRow3.Num())))
		{
			m_bSecondFlag = true;
		}

		////////////////////////////////////////////////////////
		if((DefinedRow1.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow1;
			DefinedCol=DefinedCol1;
			m_CutOff=1;
		}
		//
		Hobject DownEdgePoints;
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);

		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;

		HTuple dUpArea,dUpCenRow,dUpCenCol;
		union1(DownEdgePoints,&DownEdgePoints);
		area_center(DownEdgePoints,&dUpArea,&dUpCenRow,&dUpCenCol);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgePartitioned,DownEdgeMovUp;
		HTuple AreaPartitioned, RowPartitioned, ColPartitioned;
		move_region(DownEdge,&DownEdgeMovUp,dUpCenRow -ABRegRow ,0);
		partition_rectangle(DownEdgeMovUp, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		HTuple RowsRound,ColsRound;
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		HTuple PointsNum,Rows,Cols,Indice,RowDiff;
		PointsNum = DefinedCol.Num();

		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints1;
		gen_region_points(&DownEdgePoints1,Rows, Cols);
		//
		HTuple DownEdgeArea, DownEdgeRow, DownEdgeCol;
		area_center(DownEdgePoints1, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		m_DownEdgeArea=DownEdgeArea;

		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		Hobject DownEdgeXld,DownEdgeSmoothed;
		HTuple Rows1, Cols1;
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		// m_ABEdge加入,为拐角区域传递变量
		gen_region_contour_xld(DownEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		/////////////////////////////

		Hobject DownEdgeReg,DownEdgeRegMoved,DownEdgeRegDilation;
		gen_region_polygon(&DownEdgeReg, Rows1, Cols1);
		move_region(DownEdgeReg, &DownEdgeRegMoved, 3, 0);
		dilation_rectangle1(DownEdgeRegMoved, &DownEdgeRegDilation, 10, 5);
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints1, &m_vRgn[rId]);
			//concat_obj(m_vRgn[rId], DownEdgeReg, &m_vRgn[rId]);
		}
		////////////////////////////
		//覆膜下边缘点

		if((DefinedRow0.Num())<((DefinedRow2.Num()*4)/5))
		{
			DefinedRow=DefinedRow2;
			DefinedCol=DefinedCol2;
			m_CutOff=0;
		}
		else
		{
			DefinedRow=DefinedRow0;
			DefinedCol=DefinedCol0;
			m_CutOff=1;
		}
		gen_region_points(&DownEdgePoints, DefinedRow, DefinedCol);
		m_FMrows=DefinedRow;
		m_FMcols=DefinedCol;
		HTuple dDownArea,dDownCenRow,dDownCenCol;
		union1(DownEdgePoints,&DownEdgePoints);
		area_center(DownEdgePoints,&dDownArea,&dDownCenRow,&dDownCenCol);
		m_FMpoints=DownEdgePoints;
		//剔除离群点 m_ABEdgeM
		Hobject DownEdgeMovDown;
		move_region(DownEdge,&DownEdgeMovDown,dDownCenRow-ABRegRow,0);
		partition_rectangle(DownEdgeMovDown, &DownEdgePartitioned, 1, 100);
		area_center(DownEdgePartitioned, &AreaPartitioned, &RowPartitioned, &ColPartitioned);
		tuple_round(RowPartitioned, &RowsRound);
		tuple_round(ColPartitioned, &ColsRound);

		PointsNum = DefinedCol.Num();
		Rows = HTuple();
		Cols = HTuple();
		if (PointsNum<2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}

		for (int i=0;i<=PointsNum-1;i++)
		{
			tuple_find(ColsRound, DefinedCol.Select(i), &Indice);
			if (0 != (Indice==-1))
			{
				continue;
			}
			RowDiff = ((DefinedRow.Select(i))-(RowsRound.Select(Indice[0]))).Abs();
			if (0 != (RowDiff<ValueThred))
			{
				Rows = (DefinedRow.Select(i)).Concat(Rows);
				Cols = (DefinedCol.Select(i)).Concat(Cols);
			}

		}
		Hobject DownEdgePoints2;
		gen_region_points(&DownEdgePoints2,Rows, Cols);
		area_center(DownEdgePoints2, &DownEdgeArea, &DownEdgeRow, &DownEdgeCol);
		if (DownEdgeArea==0||DownEdgeArea.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeArea);
			return S_FALSE;
		}
		gen_contour_polygon_xld(&DownEdgeXld, Rows, Cols);
		smooth_contours_xld(DownEdgeXld, &DownEdgeSmoothed, 15);
		get_contour_xld(DownEdgeSmoothed, &Rows1, &Cols1);

		Hobject DownEdgeReg2,DownEdgeRegMoved2;
		gen_region_polygon(&DownEdgeReg2, Rows1, Cols1);
		move_region(DownEdgeReg2, &DownEdgeRegMoved2, -3, 0);
		Hobject DownEdgeRegDilationX;
		dilation_rectangle1(DownEdgeRegMoved2, &DownEdgeRegDilationX, 10, 5);
		///////////////////////////////////      
		m_DownEdgeX=DownEdgeRegDilationX;
		m_DownEdge=DownEdgeRegDilation;

		///  基准线相关变量传递 m_ABEdgeReg
		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(DownEdgePoints, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		// 传递找到的覆膜边缘
		m_DownEdgeReg = DownEdgeReg;
		m_DownEdgeReg2 = DownEdgeReg2;

		///////////////////////////////////////////////////////////////////////////////////////////////////////


		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], DownEdgePoints2, &m_vRgn[rId]);
		}
		//
		if (DownEdgeArea>0)
		{
			Hobject DownEdgePointsDilation;
			retValue = DownEdgeArea[0].I();
			dilation_circle(DownEdgePoints, &DownEdgePointsDilation, 2);
			m_vErrorRgn[rId] = DownEdgePointsDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}

		retValue.Detach(pEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_DownEdgeDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6067$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 991;LP;0;100;1;35$\
					 1107;LP;1;100;1;45$\
					 1108;LP;1;100;1;5$\
					 6073;FP;0.5;10;0.5;3$\
					 6063;FP;0.5;10;0.5;3$\
					 6064;LP;1;100;1;10$\
					 1109;LP;1;100;1;50");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//Color image process, Algo.
STDMETHODIMP CPlugAlgo::DynThresholdForColorAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int ColorTransType = (int)pColorTransType->fltVal;
	int ChannelSelect = (int)pChannelSelect->fltVal;
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}
		Hobject ImageReduced, ImageReduceMean;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DynThresholdForColorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("660$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************
***算子名：DynThresholdForColorFilmAlgo
***功  能：用于覆膜胶塞彩色图像的动态灰度值，加入覆膜边缘剔除功能
***时  间：2019年8月9日
*******************************************************************************/
STDMETHODIMP CPlugAlgo::DynThresholdForColorFilmAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pWhiteMaskSize, VARIANT* pSeriousWhitePointDynThresh, VARIANT* pSeriousWhitePointSize, VARIANT* pMoveSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int ColorTransType = (int)pColorTransType->fltVal;
	int ChannelSelect = (int)pChannelSelect->fltVal;
	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;  
    int MoveSize = (int) pMoveSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}
		Hobject ImageReduced, ImageReduceMean;
		Hobject BlackUnion, WhiteUnion;
		HTuple blackArea, whiteArea, rowBlack, colBlack, rowWhite, colWhite;
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, BlackMaskSize, BlackMaskSize,1,ImageReduced, ImageReduceMean);
		ImageProcessAlg.ErrorDetect(ImageReduced,ImageReduceMean , SeriousBlackPointDynThresh, SeriousBlackPointSize, BlackUnion,1);
		area_center(BlackUnion, &blackArea, &rowBlack, &colBlack);
		//
		ImageProcessAlg.MeanImageReduced(Image,rgn, WhiteMaskSize, WhiteMaskSize,1,ImageReduced, ImageReduceMean);
		ImageProcessAlg.ErrorDetect(ImageReduced, ImageReduceMean, SeriousWhitePointDynThresh, SeriousWhitePointSize, WhiteUnion,0);
		area_center(WhiteUnion, &whiteArea, &rowWhite, &colWhite);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(SeriousBlackPointDynThresh));
			m_dictSpecialData[rId].push_back(float(SeriousWhitePointDynThresh));
			HTuple Width, Height,AbsoluteHisto, RelativeHisto, Length,rateMax;
			Hobject ImageSub;
			get_image_size (Image,& Width, &Height);
			abs_diff_image (ImageReduced, ImageReduceMean, &ImageSub, 1);
			gray_histo (rgn, ImageSub, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(RelativeHisto,&rateMax);
			int histoLength = Length[0].I();
			double scale=100.0/rateMax[0].D();
			float histoAddAr[256]={0.0};
			float histoAdd=0.0;
			for (int i=histoLength-1; i>=0; i--)
			{
				if(histoAdd* Width* Height<200)
				{	
					histoAdd=histoAdd+(float)(RelativeHisto[i].D());
					histoAddAr[i]=histoAdd;
				}
				else
					histoAddAr[i]=histoAdd;
			}
			for (int i=0; i<histoLength; i++)
			{
				histoAdd=(float)(histoAddAr[i]*(Width[0].D()* Height[0].D()));
				if(histoAdd<=200)
					m_dictSpecialData[rId].push_back(-histoAdd);
				else
					m_dictSpecialData[rId].push_back(-200.0);
			}
		}
		//
		//m_FMpoints  m_ABEdgeM ，剔除覆膜边缘干扰
		HTuple Area7, Row5, Column3,Area8, Row6, Column5;
		Hobject RegionMoved,RegionDilation;
		area_center(m_DownEdge, &Area7, &Row5, &Column3);
		area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
		move_region(m_DownEdge, &RegionMoved, -(Row6-Row5)/2.0, 0);
		dilation_rectangle1(RegionMoved, &RegionDilation, 1, 20);

		Hobject RemovedReg,DefectRegs;
		move_region(RegionDilation,&RemovedReg,MoveSize,0);
		//
		union2(BlackUnion, WhiteUnion, &DefectRegs);
		union1(DefectRegs,&DefectRegs);
		Hobject DefectRegs1;
		difference(DefectRegs,RemovedReg,&DefectRegs1);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs1, &Area, &Row_test, &Column_test);
		
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs1, &DefectRegs1, 2.5);
			m_vErrorRgn[rId] = DefectRegs1;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DynThresholdForColorFilmAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6115$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 417;LP;3;101;2;7$\
					 420;LP;1;250;1;60$\
					 421;LP;1;250;1;10$\
					 1227;LP;-50;50;1;20");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::EdgeForColorAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect, VARIANT* pEdgeThred, VARIANT* pDefectSize, VARIANT* pDetectArea)
{
	//盖面边沿算法
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int ColorTransType = (int)pColorTransType->fltVal;
	int ChannelSelect = (int)pChannelSelect->fltVal;
	int EdgeThred = (int)pEdgeThred->fltVal;
	int DefectSize = (int)pDefectSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}
		Hobject ImageReduced, ExpandedImage, DerivGauss;
		reduce_domain (Image, rgn, &ImageReduced);
		expand_domain_gray(ImageReduced, &ExpandedImage, 2);

		Hobject ImageMean, ImageExpandedReduced;
		HTuple MaskSize;
		MaskSize = 3;
		mean_image(ExpandedImage, &ImageMean, MaskSize, MaskSize);
		reduce_domain(ImageMean, rgn, &ImageExpandedReduced);

		Hobject ImageEdgeRobinson, ThresholdRegion, ConnectedThresholdRegion, SelectedRegion;
		robinson_amp(ImageExpandedReduced, &ImageEdgeRobinson);
		if (m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(EdgeThred));
			m_dictSpecialData[rId].push_back(-999999.0f);
			HTuple AbsoluteHisto, RelativeHisto, Length;
			gray_histo (rgn, ImageEdgeRobinson, &AbsoluteHisto, &RelativeHisto);
			HTuple  maxValue = 0;
			tuple_max (AbsoluteHisto, &maxValue);
			tuple_length (AbsoluteHisto, &Length);
			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i=0; i< histoLength; i++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		threshold(ImageEdgeRobinson, &ThresholdRegion, EdgeThred, 255);
		connection(ThresholdRegion, &ConnectedThresholdRegion);
		select_shape(ConnectedThresholdRegion, &SelectedRegion, "area", "and", DefectSize, 99999);
		Hobject DefectRegs;
		union1(SelectedRegion, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}		
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::EdgeForColorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("661$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 433;LP;1;255;1;30$\
					 434;LP;1;250;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/********************************************************************************************
***函数名：AnnularRotaDynThresholdForColorAlgo
***功  能：将原图旋转一定角度与原图之间进行灰度对比（针对彩色图像）
***思  路：其实与DynThreshold 类似，只是这里可以更加方便的选择通道进行处理，前者是写死的
********************************************************************************************/
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdForColorAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect,VARIANT* pRotaAngle,VARIANT* pDynThresh, VARIANT* pDefectSize, VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int ColorTransType = (int)pColorTransType->fltVal;
	int ChannelSelect = (int)pChannelSelect->fltVal;
	int ThresholdValue = (int)pDynThresh->fltVal;
	int DefectSize = (int) pDefectSize->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}
		Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		Hobject ImageMean;
		mean_image (Image, &ImageMean, 9, 9);
		reduce_domain (ImageMean, rgn, &ImageReduced);
		vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY, fCenterX, HTuple(RotaAngle).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "bilinear", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThresholdValue, "dark");
		opening_circle(RegionDynThresh,&RegionDynThresh,1.5);
		closing_circle(RegionDynThresh,&RegionDynThresh,3.5);
		connection(RegionDynThresh, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions4, "area", "and", DefectSize, 9999999);
		Hobject DefectRegs;
		union1(SelectedRegions4, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AnnularRotaDynThresholdForColorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("662$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1$\
					 610;FP;0.5;60;0.5;3.5$\
					 630;LP;1;250;1;60$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CurlNoCompoundForColorAlgo(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect, VARIANT* pGrayValueMean)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		//为空不报错
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
	int ColorTransType = (int)pColorTransType->fltVal;
	int ChannelSelect = (int)pChannelSelect->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image;// = m_crtImg;
		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,   ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGrayValueMean);
			return S_FALSE;
		}
		HTuple MeanGray, Deviation;
		intensity (rgn, Image, &MeanGray, &Deviation);

		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].push_back(float(MeanGray[0].D()));
			m_dictSpecialData[rId].push_back(-999999.0f);

			HTuple AbsoluteHisto, RelativeHisto, Length, maxValue = 0;
			gray_histo (rgn, Image, &AbsoluteHisto, &RelativeHisto);
			tuple_length (AbsoluteHisto, &Length);
			tuple_max(AbsoluteHisto, &maxValue);

			float YRange = 100;
			float YScaleFactor = float(YRange/maxValue[0].D());

			int histoLength = Length[0].I();
			for (int i = 0; i < histoLength; i ++)
			{
				m_dictSpecialData[rId].push_back(float((-1)*YScaleFactor*AbsoluteHisto[i].D()));
			}
		}
		retValue = MeanGray[0].I();
		m_vErrorRgn[rId] = rgn;
		retValue.Detach(pGrayValueMean);

#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGrayValueMean);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CurlNoCompoundForColorAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("816$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;1$\
					 658;LP;1;3;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//旋转对比算法核心部分，简化
void GetDefectsInPolarImg4AnnualRota(Hobject Image, Hobject PolarTransImageOrigin, Hobject PolarTransImageRotated, Hobject* pDefects, HTuple ThredLow, HTuple DefectSizeLow, HTuple Offset, bool m_bDebugImg, HTuple fCenterY, HTuple fCenterX, HTuple RadiusStart, HTuple RadiusEnd, HTuple RotaAngle, HTuple StartAngle, HTuple EndAngle, HTuple* pDefectPolarArea, HTuple DefectType = "dark")
{
	gen_empty_obj(pDefects);
	*pDefectPolarArea = 0;

	Hobject BlackRegDynLight, BlackRegDynDark, BlackRegDynDarkMoved, BlackRegDyn;
	Hobject BlackRegConnected, BlackDefectsPolar;
	dyn_threshold(PolarTransImageRotated, PolarTransImageOrigin, &BlackRegDynLight, ThredLow, "light");
	dyn_threshold(PolarTransImageRotated, PolarTransImageOrigin, &BlackRegDynDark, ThredLow, "dark");	

	if (DefectType == "dark")
	{
		move_region(BlackRegDynDark, &BlackRegDynDarkMoved, 0, Offset);
		intersection(BlackRegDynDarkMoved, BlackRegDynLight, &BlackRegDyn);
	} 
	else if(DefectType == "white")
	{
		move_region(BlackRegDynLight, &BlackRegDynDarkMoved, 0, Offset);
		intersection(BlackRegDynDarkMoved, BlackRegDynDark, &BlackRegDyn);
	}

	HTuple OriginImgWidth, OriginImgHeight;
	get_image_size(Image, &OriginImgWidth, &OriginImgHeight);

	HTuple AngleEndOrigin = HTuple(EndAngle).Rad();
	HTuple PolarImgHeight = RadiusStart - RadiusEnd;

	//HTuple PolarImgWidth = AngleEndOrigin *0.5*(RadiusStart + RadiusEnd);


	HTuple PolarImgWidth = (AngleEndOrigin- HTuple(StartAngle).Rad())*RadiusStart;

	HTuple InterpolationMethod = "nearest_neighbor";

	closing_circle(BlackRegDyn, &BlackRegDyn, 2.5);
	connection(BlackRegDyn, &BlackRegConnected);
	select_shape(BlackRegConnected, &BlackDefectsPolar, "area", "and", DefectSizeLow, OriginImgWidth * OriginImgHeight);
	union1(BlackDefectsPolar,&BlackDefectsPolar);
	HTuple BlackDefectPolarArea, BlackDefectPolarRow, BlackDefectPolarCol;
	area_center(BlackDefectsPolar, &BlackDefectPolarArea, &BlackDefectPolarRow, &BlackDefectPolarCol);

	Hobject BlackDefects;
	if (BlackDefectPolarArea > 0)
	{
		if (m_bDebugImg)
		{
			polar_trans_region_inv(BlackDefectsPolar, &BlackDefects, fCenterY, fCenterX, HTuple(StartAngle).Rad(), AngleEndOrigin, RadiusStart, RadiusEnd, PolarImgWidth, PolarImgHeight, OriginImgWidth, OriginImgHeight, InterpolationMethod);
			union1(BlackDefects, &BlackDefects);
			concat_obj(*pDefects, BlackDefects, pDefects);
		} 
		else
		{
			//在线检测阶段，只利用错误区域的重心，标记成圆形区域
			HTuple RadiusOrigin = RadiusStart - BlackDefectPolarRow;
			HTuple Theta = 1.0 * BlackDefectPolarCol / PolarImgWidth * HTuple((EndAngle - StartAngle).Abs()).Rad() + HTuple(StartAngle).Rad();

			HTuple sinTheta, cosTheta;
			tuple_sin(Theta, &sinTheta);
			tuple_cos(Theta, &cosTheta);

			HTuple Row_Origin = fCenterY - RadiusOrigin* sinTheta;
			HTuple Col_Origin = fCenterX + RadiusOrigin* cosTheta;

			HTuple Radius_Origin;
			HTuple DefectNum;
			tuple_length(BlackDefectPolarRow, &DefectNum);
			tuple_gen_const(DefectNum, 10, &Radius_Origin);
			gen_circle(&BlackDefects, Row_Origin, Col_Origin, Radius_Origin);
			union1(BlackDefects, &BlackDefects);
			concat_obj(*pDefects, BlackDefects, pDefects);
		}

		*pDefectPolarArea = BlackDefectPolarArea;
	}	
}

STDMETHODIMP CPlugAlgo:: AnnularRotaDynThresholdAlgoBW(VARIANT* rgnId, VARIANT* pRotaAngle, VARIANT* pBlackThredLow, VARIANT* pBlackDefectSize, VARIANT* pWhiteThredLow, VARIANT* pWhiteDefectSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	m_vWhiteErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackThredLow = (int)pBlackThredLow->fltVal;
	int BlackDefectSize = (int) pBlackDefectSize->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
	int WhiteThredLow = (int)pWhiteThredLow->fltVal;
	int WhiteDefectSize = (int) pWhiteDefectSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;

		//get the params for polar trans
		float RoiWidth = m_ringPara[rId].m_RoiWidth;
		float Radius = m_ringPara[rId].m_Radius;

		float StartAngle = m_sectorAngle[rId].m_angleStartAbs;	//逆时针转顺时针
		float EndAngle =  m_sectorAngle[rId].m_angleEndAbs;

		HTuple RadiusStart, RadiusEnd;

		if (Radius - RoiWidth < 1)
		{			
			RadiusEnd = 0;
			RadiusStart = Radius;
		}
		else
		{
			RadiusEnd = Radius - RoiWidth;
			RadiusStart = Radius;
		}

		HTuple AngleEndOrigin = HTuple(EndAngle).Rad();
		HTuple PolarImgHeight = RadiusStart - RadiusEnd;

		HTuple PolarImgWidth = (AngleEndOrigin- HTuple(StartAngle).Rad())*RadiusStart;

		HTuple InterpolationMethod = "nearest_neighbor";

		//As RadiusStart > RadiusEnd, the polar transformation is performed clockwise(顺时针)
		Hobject PolarTransImageOrigin, PolarTransImageRotated;
		polar_trans_image_ext(Image, &PolarTransImageOrigin, fCenterY, fCenterX,  HTuple(StartAngle).Rad(), AngleEndOrigin, RadiusStart, RadiusEnd, PolarImgWidth, PolarImgHeight, InterpolationMethod);
		polar_trans_image_ext(Image, &PolarTransImageRotated, fCenterY, fCenterX, HTuple(StartAngle + RotaAngle).Rad(), AngleEndOrigin + HTuple(RotaAngle).Rad(), RadiusStart, RadiusEnd, PolarImgWidth, PolarImgHeight, InterpolationMethod);

		HTuple MiddleRadius = 0.5*(RadiusStart + RadiusEnd);
		HTuple Offset = RadiusStart * HTuple(RotaAngle).Rad();
		HTuple OriginImgWidth, OriginImgHeight;
		get_image_size(Image, &OriginImgWidth, &OriginImgHeight);

		Hobject DefectRegs;
		gen_empty_obj(&DefectRegs);

		Hobject BlackDefects;
		gen_empty_obj(&BlackDefects);
		HTuple  BlackDefectPolarArea;

		GetDefectsInPolarImg4AnnualRota(Image, PolarTransImageOrigin, PolarTransImageRotated, &BlackDefects, BlackThredLow, BlackDefectSize, Offset, m_bDebugImg, fCenterY, fCenterX, RadiusStart, RadiusEnd, RotaAngle, StartAngle, EndAngle, &BlackDefectPolarArea, "dark");
		union2(DefectRegs, BlackDefects, &DefectRegs);

		Hobject WhiteDefects;
		gen_empty_obj(&WhiteDefects);
		HTuple  WhiteDefectPolarArea;
		GetDefectsInPolarImg4AnnualRota(Image, PolarTransImageOrigin, PolarTransImageRotated, &WhiteDefects, WhiteThredLow, WhiteDefectSize, Offset, m_bDebugImg, fCenterY, fCenterX, RadiusStart, RadiusEnd, RotaAngle, StartAngle, EndAngle, &WhiteDefectPolarArea, "white");

		union2(DefectRegs, WhiteDefects, &DefectRegs);

		HTuple Area, Row_test, Column_test;
		union1(DefectRegs, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
			m_vWhiteErrorRgn[rId] = newRgn;
		}
		else
		{			
			dilation_circle (BlackDefects, &BlackDefects, 2.5);
			dilation_circle (WhiteDefects, &WhiteDefects, 2.5);
			m_vErrorRgn[rId] = BlackDefects;
			m_vWhiteErrorRgn[rId] = WhiteDefects;			

			//			retValue = Area[0].I();

			//输出为极坐标下的缺陷面积，避免前后不一致，2018.05.20
			HTuple PolarDefectArea = 0;

			if (BlackDefectPolarArea[0].I() > 0)
			{
				PolarDefectArea = PolarDefectArea + BlackDefectPolarArea;
			}

			if (WhiteDefectPolarArea[0].I() > 0)
			{
				PolarDefectArea = PolarDefectArea + WhiteDefectPolarArea;
			}

			retValue = PolarDefectArea[0].I();
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		m_vWhiteErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo:: AnnularRotaDynThresholdAlgoBWHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1295$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 610;FP;0.5;60;0.5;3.5$\
					 427;FP;0;255;0.5;23$\
					 428;LP;1;1000;1;10$\
					 430;FP;0;255;0.5;23$\
					 431;LP;1;1000;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/*************************************************************************
** 函数名：AnnularRotaDynThresholdForColorAlgoBW
** 功  能：彩色通道旋转对比分黑白
** 时  间：2019年11月27日
**************************************************************************/
STDMETHODIMP CPlugAlgo:: AnnularRotaDynThresholdForColorAlgoBW(VARIANT* rgnId, VARIANT* pColorTransType, VARIANT* pChannelSelect,VARIANT* pRotaAngle, VARIANT* pBlackThredLow, VARIANT* pBlackDefectSize, VARIANT* pWhiteThredLow, VARIANT* pWhiteDefectSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	m_vWhiteErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int ColorTransType = (int) pColorTransType->fltVal;
	int ChannelSelect = (int) pChannelSelect->fltVal;
	int BlackThredLow = (int)pBlackThredLow->fltVal;
	int BlackDefectSize = (int) pBlackDefectSize->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
	int WhiteThredLow = (int)pWhiteThredLow->fltVal;
	int WhiteDefectSize = (int) pWhiteDefectSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image ;

		//按要求变换彩色空间，并提取单通道图像。
		if(!H_ColorImageTrans(m_crtImgMult,&Image,rgn,ColorTransType, ChannelSelect))
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;

		//get the params for polar trans
		float RoiWidth = m_ringPara[rId].m_RoiWidth;
		float Radius = m_ringPara[rId].m_Radius;

		float StartAngle = m_sectorAngle[rId].m_angleStartAbs;	//逆时针转顺时针
		float EndAngle =  m_sectorAngle[rId].m_angleEndAbs;

		HTuple RadiusStart, RadiusEnd;

		if (Radius - RoiWidth < 1)
		{			
			RadiusEnd = 0;
			RadiusStart = Radius;
		}
		else
		{
			RadiusEnd = Radius - RoiWidth;
			RadiusStart = Radius;
		}

		HTuple AngleEndOrigin = HTuple(EndAngle).Rad();
		HTuple PolarImgHeight = RadiusStart - RadiusEnd;

		HTuple PolarImgWidth = (AngleEndOrigin- HTuple(StartAngle).Rad())*RadiusStart;

		HTuple InterpolationMethod = "nearest_neighbor";

		//Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//As RadiusStart > RadiusEnd, the polar transformation is performed clockwise(顺时针)
		mean_image (Image, &Image, 9, 9);

		Hobject PolarTransImageOrigin, PolarTransImageRotated;
		polar_trans_image_ext(Image, &PolarTransImageOrigin, fCenterY, fCenterX,  HTuple(StartAngle).Rad(), AngleEndOrigin, RadiusStart, RadiusEnd, PolarImgWidth, PolarImgHeight, InterpolationMethod);
		polar_trans_image_ext(Image, &PolarTransImageRotated, fCenterY, fCenterX, HTuple(StartAngle + RotaAngle).Rad(), AngleEndOrigin + HTuple(RotaAngle).Rad(), RadiusStart, RadiusEnd, PolarImgWidth, PolarImgHeight, InterpolationMethod);

		HTuple MiddleRadius = 0.5*(RadiusStart + RadiusEnd);
		HTuple Offset = RadiusStart * HTuple(RotaAngle).Rad();
		HTuple OriginImgWidth, OriginImgHeight;
		get_image_size(Image, &OriginImgWidth, &OriginImgHeight);

		Hobject DefectRegs;
		gen_empty_obj(&DefectRegs);

		Hobject BlackDefects;
		gen_empty_obj(&BlackDefects);
		HTuple  BlackDefectPolarArea;

		GetDefectsInPolarImg4AnnualRota(Image, PolarTransImageOrigin, PolarTransImageRotated, &BlackDefects, BlackThredLow, BlackDefectSize, Offset, m_bDebugImg, fCenterY, fCenterX, RadiusStart, RadiusEnd, RotaAngle, StartAngle, EndAngle, &BlackDefectPolarArea, "dark");
		union2(DefectRegs, BlackDefects, &DefectRegs);

		Hobject WhiteDefects;
		gen_empty_obj(&WhiteDefects);
		HTuple  WhiteDefectPolarArea;
		GetDefectsInPolarImg4AnnualRota(Image, PolarTransImageOrigin, PolarTransImageRotated, &WhiteDefects, WhiteThredLow, WhiteDefectSize, Offset, m_bDebugImg, fCenterY, fCenterX, RadiusStart, RadiusEnd, RotaAngle, StartAngle, EndAngle, &WhiteDefectPolarArea, "white");

		union2(DefectRegs, WhiteDefects, &DefectRegs);

		HTuple Area, Row_test, Column_test;
		union1(DefectRegs, &DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);

		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
			m_vWhiteErrorRgn[rId] = newRgn;
		}
		else
		{			
			dilation_circle (BlackDefects, &BlackDefects, 2.5);
			dilation_circle (WhiteDefects, &WhiteDefects, 2.5);
			m_vErrorRgn[rId] = BlackDefects;
			m_vWhiteErrorRgn[rId] = WhiteDefects;			

			//			retValue = Area[0].I();

			//输出为极坐标下的缺陷面积，避免前后不一致，2018.05.20
			HTuple PolarDefectArea = 0;

			if (BlackDefectPolarArea[0].I() > 0)
			{
				PolarDefectArea = PolarDefectArea + BlackDefectPolarArea;
			}

			if (WhiteDefectPolarArea[0].I() > 0)
			{
				PolarDefectArea = PolarDefectArea + WhiteDefectPolarArea;
			}

			retValue = PolarDefectArea[0].I();
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		m_vWhiteErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo:: AnnularRotaDynThresholdForColorAlgoBWHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6206$\
					 397;R;LP;0;1000;1;<=#20$\
					 381;B$\
					 657;LP;0;6;1;0$\
					 658;LP;1;3;1;3$\
					 610;FP;0.5;60;0.5;3.5$\
					 427;FP;0;255;0.5;23$\
					 428;LP;1;1000;1;10$\
					 430;FP;0;255;0.5;23$\
					 431;LP;1;1000;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::my_disp_obj(const Halcon::Hobject Object)
{
	if (m_bPilotImg)
	{
		return;
	}
	std::string mode("visible");
	std::string strMachine("");
	set_check("~father");
	HTuple Width, Height;

	if(m_WindowFirst)
	{
		//get_image_size (m_crtImg, &Width, &Height);
		open_window(1,1,m_imgWidth/2,m_imgHeight/2,(Hlong)NULL, mode.c_str(),strMachine.c_str(), (Hlong*)&m_CHImgWndID);
		m_WindowFirst=false;
		disp_obj(m_crtImg,m_CHImgWndID);
	}
	set_part(m_CHImgWndID,0, 0, m_imgWidth, m_imgHeight);
	set_check("father");
	set_draw(m_CHImgWndID,"margin"); 
	set_color(m_CHImgWndID, "red");
	set_line_width(m_CHImgWndID,HTuple(1));
	clear_window(m_CHImgWndID);
	disp_obj(Object,m_CHImgWndID);

	write_object(Object, "D:/Region3.hobj");
	write_image(m_crtImg, "tiff", 0,"D:/Image.tiff");
}

STDMETHODIMP CPlugAlgo::DetectSmalCircleAngleHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1361$\
					 381;B$\
					 859;LP;80;350;1;151$\
					 860;LP;25;180;1;80$\
					 763;LP;1;200;1;175$\
					 861;LP;20;3600;1;700");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DetectSmalCircleAngle(VARIANT* rgnId, VARIANT* pRadius,VARIANT* pRoiWidth,VARIANT* pGrayValue,VARIANT* pAreaLimitSize)
{
	int id = (int)rgnId->fltVal;
	int Radius = (int)pRadius->fltVal;
	int RoiWidth = (int)pRoiWidth->fltVal;
	int ThreshUpValue = (int)pGrayValue->fltVal;
	int AreaLowValue = (int)pAreaLimitSize->fltVal;
	//float RoundnessValue =(float) pLowRoundness->fltVal;

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;
	if ((Radius-RoiWidth)<2)
	{
		Radius=RoiWidth+2;
	}
	Hobject newRgn;
	m_vRgn[id] = newRgn;

#ifdef NDEBUG
	try
	{
#endif

		HTuple  hv_iWidth, hv_iHeight,iChannelNumber; 
		Hobject ho_imgSrc,ho_imgDst1,ho_imgDst2,ho_imgDst3;

		if(m_crtImgMult.Id() == H_EMPTY_REGION)
		{
			return S_FALSE;
		}

		copy_image(m_crtImgMult, &ho_imgSrc);

		count_channels(ho_imgSrc,&iChannelNumber);
		if (iChannelNumber[0].D() != 3)
		{
			return S_FALSE;
		}

		decompose3(ho_imgSrc, &ho_imgDst1, &ho_imgDst2, &ho_imgDst3);
		get_image_size(ho_imgSrc, &hv_iWidth, &hv_iHeight);

		Hobject ho_rgnCircleBig,ho_rgnCircleSmal,ho_rgnAnnular,ho_imgAnnular;

		gen_circle(&ho_rgnCircleBig, fCenterY, fCenterX, Radius);
		gen_circle(&ho_rgnCircleSmal, fCenterY, fCenterX, Radius-RoiWidth);
		difference(ho_rgnCircleBig, ho_rgnCircleSmal, &ho_rgnAnnular);


		if (m_bDebugImg)
		{
			concat_obj(ho_rgnAnnular,m_vRgn[id],&m_vRgn[id]);
		}

		reduce_domain(ho_imgDst2, ho_rgnAnnular, &ho_imgAnnular);

		Hobject ho_rgnThr,ho_rgnCon,ho_rgnOpn,ho_rgnFill,ho_rgnCon1,ho_rgnSels;
		Hobject ho_rgnTrans,ho_rgnLine,ho_rgnConcats;
		HTuple hv_iNumber,hv_dArea1,hv_dRow1,hv_dColumn1,hv_Phi,hv_dAngle;

		threshold(ho_imgAnnular, &ho_rgnThr, 0, ThreshUpValue);
		connection(ho_rgnThr, &ho_rgnCon);
		opening_circle(ho_rgnCon, &ho_rgnOpn, 3.5);
		fill_up(ho_rgnOpn, &ho_rgnFill);
		connection(ho_rgnFill, &ho_rgnCon1);
		select_shape(ho_rgnCon1, &ho_rgnSels, (HTuple("area").Append("roundness")), "and", (HTuple(AreaLowValue).Append(0.7)), (HTuple(10000).Append(1)));

		count_obj(ho_rgnSels, &hv_iNumber);
		if (0 != (HTuple(hv_iNumber<1).Or(hv_iNumber>4)))
		{
			return S_FALSE;
		}

		shape_trans(ho_rgnSels, &ho_rgnTrans, "outer_circle");
		area_center(ho_rgnTrans, &hv_dArea1, &hv_dRow1, &hv_dColumn1);

		Hobject CenterCircle,SelectCircle,RegionUnion;
		HTuple Angle;
		//gen_region_line(&ho_rgnLine, fCenterY, fCenterX, hv_dRow1.Select(0), hv_dColumn1.Select(0));
		gen_region_line(&ho_rgnLine, hv_dRow1.Select(0), hv_dColumn1.Select(0), fCenterY, fCenterX);

		gen_circle(&CenterCircle, fCenterY, fCenterX, 5);
		gen_circle(&SelectCircle, hv_dRow1.Select(0), hv_dColumn1.Select(0), 20);
		union2(CenterCircle, SelectCircle, &RegionUnion);
		orientation_region(RegionUnion, &Angle);

		orientation_region(ho_rgnLine, &hv_Phi);
		hv_Phi = hv_Phi - PI;
		if(Angle[0].D()<0)
		{
			Angle=2*PI+Angle;
		}

		concat_obj(ho_rgnLine,ho_rgnTrans,&ho_rgnConcats);
		concat_obj(ho_rgnConcats,m_vRgn[id],&m_vRgn[id]);

		m_modelAngle = Angle;

		m_modelAngleTmp = m_modelAngleTmp.Concat(m_modelAngle);

		//m_vRgn[id] = ho_rgnConcats;

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif  

	return S_OK;


}

//  AB32 内壁区域提取
STDMETHODIMP CPlugAlgo::AB32_InnerWallRegDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pTopRegionArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;
	double ThredLower   = (double)pThredLower->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);
		Hobject ImageScaleMax1;
		scale_image_max(ImageReducedAroi, &ImageScaleMax1);

		Hobject Regions,ConnectedRegions,RegionSelect;
		threshold(ImageScaleMax1, &Regions, ThredLower, 255);

		Hobject RegionFillUp,RegionsConnected,RegionsSelected;
		fill_up(Regions, &RegionFillUp);
		connection(RegionFillUp, &RegionsConnected);
		select_shape_std(RegionsConnected, &RegionsSelected, "max_area", 70);

		m_rgnTopSel =  RegionsSelected;

		// RegionsSelected：内壁区域+高亮区域 + 内底区域
		// Regions: 高亮区域
		Hobject TopInwallRegionFirst,TopInwallRegionFirstFil,TopInwallRegionFirstCon;
		Hobject TopInwallRegionFirstOpn,TopInwallRegionFirstCls,RegionsSelectedSecond;
		difference(RegionsSelected,Regions,&TopInwallRegionFirst);

		fill_up(TopInwallRegionFirst,&TopInwallRegionFirstFil);

		opening_circle(TopInwallRegionFirstFil,&TopInwallRegionFirstOpn,3.5);
		closing_circle(TopInwallRegionFirstOpn,&TopInwallRegionFirstCls,3.5);
		connection(TopInwallRegionFirstCls,&TopInwallRegionFirstCon);
		select_shape_std(TopInwallRegionFirstCon,&RegionsSelectedSecond,"max_area", 70);

		m_TopInwallRegion = RegionsSelectedSecond;

		// 方法二：通过平移截取*******************
		Hobject ho_rgnConnected,ho_rgnSelected ,ho_rgnTrans,ho_rgnFillUp ;
		Hobject  ho_rgnErosion,ho_rgnMoved,ho_rgnDifference, ho_rgnDifference1;
		Hobject  ho_rgnDifference2,ho_rgnRegions1,ho_rgnConnected2;
		connection(Regions, &ho_rgnConnected);
		select_shape(ho_rgnConnected, &ho_rgnSelected, "area", "and", 800, 99999);
		shape_trans(ho_rgnSelected, &ho_rgnTrans, "convex");

		fill_up(ho_rgnTrans, &ho_rgnFillUp);
		erosion_circle(ho_rgnFillUp, &ho_rgnErosion, 35.5);
		move_region(ho_rgnErosion, &ho_rgnMoved, MoveSize-20, 0);

		difference(ho_rgnSelected, ho_rgnMoved, &ho_rgnDifference);

		difference(ho_rgnFillUp, ho_rgnMoved, &ho_rgnDifference1);
		difference(ho_rgnDifference1,ho_rgnDifference,&ho_rgnDifference2);
		connection(ho_rgnDifference2, &ho_rgnConnected2);
		select_shape(ho_rgnConnected2, &ho_rgnRegions1, "area", "and", 800, 99999);
		//m_TopInwallRegion = ho_SelectedRegions1; ********************************


		//开闭运算尺寸，依据实际的图片进行调整
		Hobject TopRegionClosing,TopRegionOpening,TopRegionConnected;
		closing_circle(RegionsSelected, &TopRegionClosing, 20);
		opening_circle(TopRegionClosing, &TopRegionOpening, 20);
		Hobject TopRegion;
		connection(TopRegionOpening, &TopRegionConnected);
		select_shape_std(TopRegionConnected, &TopRegion, "max_area", 70);

		HTuple TopRegionArea, TopRegionRow, TopRegionCol;
		area_center(TopRegion, &TopRegionArea, &TopRegionRow, &TopRegionCol);
		//顶部区域
		m_TopRegion=TopRegion;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], AroiClosing, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], RegionsSelectedSecond, &m_vRgn[rId]);
			//concat_obj(m_vRgn[rId], TopRegion, &m_vRgn[rId]);
		}
		//
		if (TopRegionArea>0)
		{
			retValue = TopRegionArea[0].I();
			m_vErrorRgn[rId] = TopRegion;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}

		retValue.Detach(pTopRegionArea);

#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopRegionArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_InnerWallRegDetectAlgoHelp (BSTR* pHelpStr)
{

	CComBSTR strHelp("1364$\
					 397;R;FP;1;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;500;1;250$\
					 989;FP;1;254;1;100");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/***************************************************************************************************
***算子名：AB32_BottomRegionLocationAlgo
***功  能：针对一种32型胶塞侧面工位的内底区域提取（针对胶塞深度较浅，内壁工位能够看到内底部区域的型号）
***思  路：通过提取到的内壁区域进行缩放与顶部高亮区域缩放，进行区域操作
***时  间：2019年5月15日
***作  者：WuYifeng
*****************************************************************************************************/
STDMETHODIMP CPlugAlgo::AB32_BottomRegionLocationAlgo(VARIANT* rgnId,  VARIANT* pUpPosiotion, VARIANT* pDownPosition,VARIANT* pHorizonEro,VARIANT* pScaleSize)
{
	int rId           = (int)rgnId->fltVal;
	int DownPosition      = (int)pDownPosition->fltVal;
	int UpPosiotion   = (int)pUpPosiotion->fltVal;
	float ScaleSize   = (float)pScaleSize->fltVal;
	float HorizonEro  = (float)pHorizonEro->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if( (m_TopInwallRegion.Id() == H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;

		Hobject rgnTopROISel,rgnInnerWallROI,rgnTopLight,rgnTopLightEro;
		rgnTopROISel = m_rgnTopSel;
		rgnInnerWallROI = m_TopInwallRegion;

		Hobject rgnInnerWallROIDil1,rgnInnerWallROIDil2;
		difference(rgnTopROISel, rgnInnerWallROI, &rgnTopLight);
	    erosion_circle(rgnTopROISel, &rgnTopLightEro, DownPosition);
	    dilation_circle(rgnInnerWallROI, &rgnInnerWallROIDil1, 15);
		move_region(rgnInnerWallROIDil1,&rgnInnerWallROIDil2, -10, 0);
	    //dilation_rectangle1(rgnInnerWallROIDil1, &rgnInnerWallROIDil2, 20, 1);

		Hobject rgnBottomOri,rgnBottomOriCon,rgnBottomOriFil,rgnBottomOriOpn,rgnBottomOriCls,rgnBottomSel;
		difference(rgnTopLightEro, rgnInnerWallROIDil2, &rgnBottomOri);
		connection(rgnBottomOri, &rgnBottomOriCon);
		fill_up(rgnBottomOriCon, &rgnBottomOriFil);
		opening_circle(rgnBottomOriFil, &rgnBottomOriOpn, 3.5);
		closing_circle(rgnBottomOriOpn, &rgnBottomOriCls, 3.5);
		select_shape_std(rgnBottomOriCls, &rgnBottomSel, "max_area", 70);

		//上缩放
		Hobject rgnBottomMovedUp,rgnBottomIntsct,rgnBottomIntsctCon,rgnBottom;
		move_region(rgnBottomSel, &rgnBottomMovedUp, UpPosiotion, 0);
		intersection(rgnBottomMovedUp, rgnBottomSel, &rgnBottomIntsct);
		connection(rgnBottomIntsct, &rgnBottomIntsctCon);
		select_shape_std(rgnBottomIntsctCon, &rgnBottom, "max_area", 70);
		// 水平缩放
		erosion_rectangle1(rgnBottom,&rgnBottom,(Hlong)HorizonEro+1,1);

		// 整体缩放
		if (ScaleSize > 0)
		{
			erosion_circle(rgnBottom, &rgnBottom,ScaleSize);
		}
		else if (ScaleSize  = 0 )
		{
			erosion_circle(rgnBottom, &rgnBottom,ScaleSize + 0.5);
		}
		else if (ScaleSize < 0)
		{
			dilation_circle(rgnBottom, &rgnBottom,-ScaleSize);
		}
		m_rgnBottom = rgnBottom;
		m_vRgn[rId] = rgnBottom;

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_BottomRegionLocationAlgoHelp (BSTR* pHelpStr)
{

	CComBSTR strHelp("5508$\
					 167;B$\
					 5509;LP;-10;50;1;15$\
					 5510;LP;1;100;1;45$\
					 5512;FP;0;50;0.5;0.5$\
					 5511;FP;-10;35;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::AB32_SideSlopRegionLocationAlgo(VARIANT* rgnId, VARIANT*pDilationSize,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	//修改说明：用于32胶塞；在20的基础上加大了基准线的膨胀尺寸，以找到颈部检测区域
	int rId           = (int)rgnId->fltVal;
	float DilationSize   = (float)pDilationSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;
	if(m_ROI.Id() == H_EMPTY_REGION||m_ABEdge.Id() == H_EMPTY_REGION||m_TopInwallRegion.Id() == H_EMPTY_REGION||m_ABEdgeRowS.Num()!=1||m_TopSlopEdgeRow.Num()!=1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject ABEdgeMovedCenter,ARegionT;
		gen_empty_region(&ARegionT);
		HTuple MoveSize;
		MoveSize = m_ABEdgeRowS-m_TopSlopEdgeRow;
		move_region(m_ABEdge, &ABEdgeMovedCenter, (-MoveSize)/2, 0);
		dilation_rectangle1(ABEdgeMovedCenter, &ARegionT, 1, MoveSize);
		intersection(ARegionT, m_ROI, &ARegionT);
		//
		m_ARegionT=ARegionT;
		//ARegionT为20圆形没有截除两端区域
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(ARegionT, &ARegionTDilation, 1, 340);
		intersection(ARegionTDilation, m_ROI, &RegionIntersection);

		//往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,SortedRegions,ObjectSelected1;
		move_region(ARegionT, &ARegionTMoved, -5, 0);
		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);
		sort_region(ConnectedRegions1, &SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &ObjectSelected1, 1);

		//与顶部区域作差
		Hobject TopSlopRegDiff,TopRegion;
		dilation_circle(m_TopRegion,&TopRegion,DilationSize);
		difference(ObjectSelected1,TopRegion,&TopSlopRegDiff);

		Hobject TopSlopRegClosing,RegionConnected,RegionSelect;
		connection(TopSlopRegDiff,&RegionConnected);
		select_shape_std(RegionConnected,&RegionSelect,"max_area",70);
		closing_circle(RegionSelect, &TopSlopRegClosing, 10);
		//水平垂直缩放
		Hobject RegionCliped,TopSlopReg,RegionErosion,RegionConnected1;
		clip_region_rel(TopSlopRegClosing,&RegionCliped,1,1,HErosionSize,HErosionSize);
		erosion_rectangle1(RegionCliped,&RegionErosion,1,VErosionSize);
		connection(RegionErosion,&RegionConnected1);
		select_shape_std(RegionConnected1,&TopSlopReg,"max_area",70);
		m_vRgn[rId] = TopSlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB32_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1365$\
					 167;B$\
					 1019;FP;1;55;0.5;10$\
					 994;LP;1;150;1;1$\
					 995;LP;1;80;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo2(VARIANT* rgnId, VARIANT* pSearchSize, VARIANT* pHclipSize, VARIANT* pABEdgeArea)
{
	//通过提取线性区域的梯度最强点，拟合颈部基准线
	int rId         = (int)rgnId->fltVal;
	int SearchSize  =(int)pSearchSize->fltVal;
	int HclipSize  =(int)pHclipSize->fltVal;
	//int Threshold   = (int)pThreshold->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		//
		Hobject crtImg = m_crtImg;
		//模板工具画AB基准椭圆
		Hobject ABEllipseXld,ABEllipseReg,ABEllipse;
		HTuple Rows, Columns;
		m_ABEllipse=rgn;

		boundary(rgn, &ABEllipse, "outer");
		/*gen_contour_region_xld(rgn, &ABEllipseXld, "border");
		gen_region_contour_xld(ABEllipseXld, &ABEllipseReg, "margin");
		get_region_points(ABEllipseReg, &Rows, &Columns);
		gen_region_points(&ABEllipse, Rows, Columns);*/
		Hobject BaseRegionLine;
		P_GetEllipseLongAxis(rgn,&BaseRegionLine);
		Hobject BaseRegionLineDiation,RegionDiff,RegionDiffConnected;
		dilation_rectangle1(BaseRegionLine, &BaseRegionLineDiation, 5, 2);
		difference(ABEllipse, BaseRegionLineDiation, &RegionDiff);
		connection(RegionDiff, &RegionDiffConnected);
		Hobject SortedRegions,ABReg;
		sort_region(RegionDiffConnected, &SortedRegions, "first_point", "true", "row");
		HTuple Num;
		count_obj(SortedRegions,&Num);
		if (Num!=2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		select_obj(SortedRegions, &ABReg, 2);

		//start
		clip_region_rel(ABReg, &ABReg, 0, 0, HclipSize, HclipSize);

		HTuple ABRegArea, ABRegRow, ABRegColumn;
		area_center(ABReg, &ABRegArea, &ABRegRow, &ABRegColumn);
		Hobject RegionDilation,crtImgReduce;
		dilation_rectangle1(ABReg, &RegionDilation, 1, SearchSize);
		reduce_domain(crtImg,RegionDilation,&crtImgReduce);

		HTuple ABDefinedRow, ABDefinedCol;
		//R_EdgePointsFitCurve(RegionDilation, crtImg, 5, 1, Threshold, "negative", "last",&ABDefinedRow, &ABDefinedCol);
		//PartInterval=5;LineLength:=膨胀尺寸;RemoveSize=2
		//P_EdgePointsFitCurve(TopSlopSearchReg, TopSlopImageReduced, 5, SearchSize, 2, &DefinedRow, &DefinedCol);
		P_EdgePointsFitCurve(RegionDilation, crtImgReduce, 5, SearchSize, 2, &ABDefinedRow, &ABDefinedCol);

		if (ABDefinedRow.Num()==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}
		Hobject Region,ABEdgeXld,ABEdgeSmoothed;
		gen_region_points(&Region, ABDefinedRow, ABDefinedCol);
		gen_contour_polygon_xld(&ABEdgeXld, ABDefinedRow, ABDefinedCol);
		smooth_contours_xld(ABEdgeXld, &ABEdgeSmoothed, 15);
		//my_disp_obj(ABEdgeSmoothed);
		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,ABDefinedRow, ABDefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");

			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], RegionDilation, &m_vRgn[rId]);
		}
		HTuple ABRow,ABCol,ABEdgeArea, ABEdgeRow, ABEdgeCol;
		Hobject ABEdge;
		get_contour_xld(ABEdgeSmoothed, &ABRow, &ABCol);
		//得到基部边缘。
		//gen_region_points(&m_ABEdgeReg,ABRow, ABCol);
		gen_region_contour_xld(ABEdgeSmoothed,&m_ABEdgeReg,"margin");
		Hobject RegionClip;
		move_region(m_ABEdgeReg,&RegionClip,-3,0);
		fill_up(RegionClip,&RegionClip);
		difference(m_ABEdgeReg,RegionClip,&m_ABEdgeReg);
		//
		gen_region_polygon(&ABEdge, ABRow, ABCol);
		area_center(ABEdge, &ABEdgeArea, &ABEdgeRow, &ABEdgeCol);
		if (ABEdgeArea<1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pABEdgeArea);
			return S_FALSE;
		}

		//提取点之后再进行椭圆位置校正，用于条纹提取m_ABEdgeM 
		HTuple ABEdgeArea0, ABEdgeRow0, ABEdgeCol0;
		area_center(Region, &ABEdgeArea0, &ABEdgeRow0, &ABEdgeCol0);
		Hobject ABEdgeM;
		HTuple HomMat2D;
		vector_angle_to_rigid(ABRegRow, ABRegColumn, 0,  ABEdgeRow0, ABEdgeCol0, 0, &HomMat2D);
		affine_trans_region(ABReg, &ABEdgeM, HomMat2D, "nearest_neighbor");
		HTuple ABEdgeAreaM, ABEdgeRowM, ABEdgeColM;
		union1(ABEdgeM,&ABEdgeM);
		area_center(ABEdgeM, &ABEdgeAreaM, &ABEdgeRowM, &ABEdgeColM);

		//
		m_ABEdgeM=ABEdgeM;
		m_ABEdgeRowM=ABEdgeRowM;
		//用于校正m_ABEllipse位置
		m_RowDiff=ABRegRow-ABEdgeRow0;
		m_ColDiff=ABRegColumn-ABEdgeCol0;
		//兼容NeckBaseEdgeDetectAlgo算子公共变量
		m_ABEdge=ABEdgeM;
		m_ABEdgeRowS=ABEdgeRowM;

		if(ABEdgeArea > 1)
		{
			retValue = ABEdgeArea[0].I();
			m_vErrorRgn[rId] = ABEdgeM;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pABEdgeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pABEdgeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::NeckBaseEdgeDetectAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1366$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1100;LP;10;80;1;40$\
					 1101;LP;0;50;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//20单叉覆膜凸点型花纹
STDMETHODIMP CPlugAlgo::G20_EmbossCoordAlgo(VARIANT* rgnId, VARIANT* pEllipseMoveSize,VARIANT* pEdgeMoveSize,VARIANT* pOpeningSize,VARIANT* pSearchSize,VARIANT* pGrayValue,VARIANT* pWidthRadiusSet,VARIANT* pAngleT1,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int EllipseMoveSize    = (int)pEllipseMoveSize->fltVal;
	int OpeningSize    = (int)pOpeningSize->fltVal;

	int EdgeMoveSize    = (int)pEdgeMoveSize->fltVal;
	int SearchSize    =(int)pSearchSize->fltVal;
	float GrayValue    =(float)pGrayValue->fltVal;

	float WidthRadiusSet    =(float)pWidthRadiusSet->fltVal;
	float AngleT1    =(float)pAngleT1->fltVal;
	//float AngleT2    =(float)pAngleT2->fltVal;

	if((int)WidthRadiusSet-WidthRadiusSet==0)
	{
		WidthRadiusSet=WidthRadiusSet+(float)0.5;
	}

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_WholeRoi.Id() == H_EMPTY_REGION||m_ABEdgeM.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//圆形区域
		Hobject crtImg = m_crtImg;
		Hobject crtImgReduced;
		reduce_domain(crtImg, rgn, &crtImgReduced);

		//基准椭圆
		Hobject RegionMoved4,Rectangle,RegionIntersection;
		HTuple Area1, Row1, Column1;
		move_region(m_ABEllipse, &RegionMoved4, -EllipseMoveSize, 0);
		area_center(RegionMoved4, &Area1, &Row1, &Column1);
		gen_rectangle1(&Rectangle, Row1-70, 10, Row1+180, m_imgWidth-10);
		intersection(Rectangle, m_WholeRoi, &RegionIntersection);

		Hobject RegionOpening,Rectangle1;
		HTuple Row11, Column11, Row2, Column2;
		opening_rectangle1(RegionIntersection, &RegionOpening, 3, 31);
		smallest_rectangle1(RegionOpening, &Row11, &Column11, &Row2, &Column2);
		gen_rectangle1(&Rectangle1, Row11, Column11, Row2, Column2);
		//
		m_WholeColumnL=Column11;
		m_WholeColumnR=Column2;
		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionOpening, &m_vRgn[rId]);
		}
		//基准线
		Hobject RegionMoved,RegionDilation1,ImageReduced;
		move_region(m_ABEdgeM, &RegionMoved, -EdgeMoveSize, 0);
		dilation_rectangle1(RegionMoved, &RegionDilation1, 3, SearchSize);
		reduce_domain(crtImgReduced, RegionDilation1, &ImageReduced);

		Hobject Region1,RegionDilation2,RegionOpening2;
		HTuple Row12, Column12, Row21, Column21;
		threshold(ImageReduced, &Region1, GrayValue, 255);
		dilation_rectangle1(Region1, &RegionDilation2, 3, 7);
		opening_rectangle1(RegionDilation2, &RegionOpening2, 3, 21);   
		Hobject ConnectedRegions2,SelectedRegions1;
		connection(RegionOpening2, &ConnectedRegions2);
		select_shape_std(ConnectedRegions2, &SelectedRegions1, "max_area", 70);
		smallest_rectangle1(SelectedRegions1, &Row12, &Column12, &Row21, &Column21);
		//
		m_PlatColumnL=Column12;
		m_PlatColumnR=Column21;
		//空区域也有数值
		Hobject Rectangle2;
		gen_empty_region(&Rectangle2);
		HTuple area,row,col;
		area_center(SelectedRegions1,&area,&row,&col);
		if (area!=0 ||area.Num()!=0)
		{
			gen_rectangle1(&Rectangle2, Row12, Column12, Row21, Column21);
		}

		HTuple Rect1CenterCol,Rect2CenterCol;
		Rect1CenterCol = (Column11+Column2)/2.0;
		Rect2CenterCol = (Column12+Column21)/2.0;

		//开口角度 22.5,边缘到凸点1角度42.5  边缘到凸点2角度91.5.胶塞在图片中的所占比例，以下的三个值需要根据实际情况设定。
		//HTuple WidthRadiusSet;
		//WidthRadiusSet = 170.5;
		//GapAngle = 22.5;
		//EdgePointAngleDiff1 = 42.5;
		//EdgePointAngleDiff2 = 91.5;

		float EdgePointAngleDiff1,GapAngle;
		EdgePointAngleDiff1 = AngleT1;
		GapAngle = 78.5;

		HTuple ColCenterSet,WidthEdgeDist,EdgeAngle,EdgeAngle360,EdgeAngleT1,EdgeAngleT2,ColT1,ColT2,Switch;
		HTuple EdgeAngle1,EdgeAngle360_1,EdgeAngleT3,EdgeAngleT4,ColT3,ColT4,WidthEdgeDist1,ColDiff,offset;
		Hobject RegionLines1,RegionLines2,RegionLines3,RegionLines4;

		//标记m_Switch
		if (0 != ((Column21-Column12)>10))
		{
			//调试显示
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], SelectedRegions1, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], Rectangle2, &m_vRgn[rId]);
			}
			if (0 != (((Rect1CenterCol-Rect2CenterCol).Abs())>65))
			{
				if (0 != (Rect1CenterCol>=Rect2CenterCol))
				{
					m_Switch = 1;
					ColCenterSet = Column2-WidthRadiusSet;
					WidthEdgeDist = Column21-ColCenterSet;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;
					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);

					m_EdgeAngleT1=EdgeAngleT1;

					m_ColT1=ColT1;
					//
					gen_empty_region(&RegionLines3);
				}
				else if (0 != (Rect1CenterCol<Rect2CenterCol))
				{
					m_Switch = 1;
					ColCenterSet = Column11+WidthRadiusSet;
					WidthEdgeDist = Column12-ColCenterSet;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = (180.0*EdgeAngle)/3.14156;
					EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;
					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					//
					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);

					m_EdgeAngleT1=EdgeAngleT1;

					m_ColT1=ColT1;
					//
					gen_empty_region(&RegionLines3);
				}
			}
			else
			{
				ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
				if (0 != (ColDiff<10.0))
				{
					offset = 10.0;
				}
				else if (0 != (ColDiff<20.0))
				{
					offset = 5.0;
				}
				else
				{
					offset = 0.0;
				}
				/////
				m_Switch = 2;
				ColCenterSet = Column2-WidthRadiusSet;
				WidthEdgeDist = (Column21-ColCenterSet);
				if (WidthEdgeDist.Abs()>WidthRadiusSet)
				{
					m_ColT1=m_imgWidth/2.0;
					m_ColT3=m_imgWidth/2.0;
					//
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pStripeArea);
					return S_FALSE;
				}
				EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
				EdgeAngle360 = (180*EdgeAngle)/3.14156;
				EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1+offset;
				if (0 != (EdgeAngleT1>90))
				{
					EdgeAngleT1 = 90;
				}
				if (0 != (EdgeAngleT1<-90))
				{
					EdgeAngleT1 = -90;
				}

				//2
				WidthEdgeDist = (Column12-ColCenterSet);
				if (WidthEdgeDist.Abs()>WidthRadiusSet)
				{
					m_ColT1=m_imgWidth/2.0;
					m_ColT3=m_imgWidth/2.0;
					//
					retValue = -1;
					m_vErrorRgn[rId].Reset();
					retValue.Detach(pStripeArea);
					return S_FALSE;
				}
				EdgeAngle1 = (WidthEdgeDist/WidthRadiusSet).Asin();
				EdgeAngle360_1 = (180*EdgeAngle1)/3.14156;
				EdgeAngleT3 = EdgeAngle360_1-EdgePointAngleDiff1-offset;
				if (0 != (EdgeAngleT3>90))
				{
					EdgeAngleT3 = 90;
				}
				if (0 != (EdgeAngleT3<-90))
				{
					EdgeAngleT3 = -90;
				}

				ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
				ColT3 = (WidthRadiusSet*((EdgeAngleT3.Rad()).Sin()))+ColCenterSet;
				//
				gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
				gen_region_line(&RegionLines3, Row2, ColT3, Row2+130, ColT3);

				m_EdgeAngleT1=EdgeAngleT1;
				m_EdgeAngleT3=EdgeAngleT3;

				m_ColT1=ColT1;
				m_ColT3=ColT3;
			}
		}
		else
		{
			Hobject RegionDifference,RegionOpening3,ConnectedRegions1,SelectedRegions,RegionOpening2;
			HTuple Row13, Column12, Row22, Column21,ColDiff;
			difference(RegionMoved4, m_WholeRoi, &RegionDifference);
			opening_rectangle1(RegionDifference, &RegionOpening3, 3, OpeningSize);
			connection(RegionOpening3, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &SelectedRegions, "width", "and", 60, 99999);
			select_shape_std(SelectedRegions, &RegionOpening2, "max_area", 70);

			smallest_rectangle1(RegionOpening2, &Row13, &Column12, &Row22, &Column21);
			area_center(RegionOpening2,&area,&row,&col);
			if (area!=0 && area.Num()!=0)
			{
				gen_rectangle1(&Rectangle2, Row13, Column12, Row22, Column21);

			}

			Rect2CenterCol = (Column12+Column21)/2.0;
			ColDiff = (Rect1CenterCol-Rect2CenterCol).Abs();
			//*area
			HTuple Area3, Row4, Column6,offset;
			area_center(RegionOpening2, &Area3, &Row4, &Column6);

			//调试显示
			if(m_bDebugImg)
			{
				concat_obj(m_vRgn[rId], RegionOpening2, &m_vRgn[rId]);
				concat_obj(m_vRgn[rId], Rectangle2, &m_vRgn[rId]);
			}
			if (0 != (Area3>2))
			{
				if (0 != (Rect1CenterCol>=Rect2CenterCol))
				{
					m_Switch = 2;
					ColCenterSet = Column2-WidthRadiusSet;
					if (0 != (ColDiff<10.0))
					{
						offset = 30.0;
					}
					else if (0 != (ColDiff<20.0))
					{
						offset = 20.0;
					}
					else if (0 != (ColDiff<30.0))
					{
						offset = 10.0;
					}
					else
					{
						offset = 0.0;
					}
					WidthEdgeDist = (Column21-ColCenterSet)+offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					//右边缘
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156)-GapAngle;
					EdgeAngleT1 = EdgeAngle360-EdgePointAngleDiff1;

					if (0 != (EdgeAngleT1>-90.0))
					{
						EdgeAngleT1 = -90.0;
					}
					if (0 != (EdgeAngleT1<-90.0))
					{
						EdgeAngleT1 = -(180.0+EdgeAngleT1);
					}

					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;
					//2
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156);
					EdgeAngleT3 = EdgeAngle360-GapAngle/2-180;

					if (0 != (EdgeAngleT3>-90.0))
					{
						EdgeAngleT3 = -90.0;
					}
					if (0 != (EdgeAngleT3<-90.0))
					{
						EdgeAngleT3 = -(180.0+EdgeAngleT3);
					}

					ColT3 = (WidthRadiusSet*((EdgeAngleT3.Rad()).Sin()))+ColCenterSet;


					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines3, Row2, ColT3, Row2+130, ColT3);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT3=EdgeAngleT3;

					m_ColT1=ColT1;
					m_ColT3=ColT3;
				}
				else if (0 != (Rect1CenterCol<Rect2CenterCol))
				{
					m_Switch = 2;
					ColCenterSet = Column11+WidthRadiusSet;
					if (0 != (ColDiff<10.0))
					{
						offset = 30.0;
					}
					else if (0 != (ColDiff<20.0))
					{
						offset = 20.0;
					}
					else if (0 != (ColDiff<30.0))
					{
						offset = 10.0;
					}
					else
					{
						offset = 0.0;
					}
					WidthEdgeDist = (Column12-ColCenterSet)-offset;
					if (WidthEdgeDist.Abs()>WidthRadiusSet)
					{
						m_ColT1=m_imgWidth/2.0;
						//
						retValue = -1;
						m_vErrorRgn[rId].Reset();
						retValue.Detach(pStripeArea);
						return S_FALSE;
					}
					EdgeAngle = (WidthEdgeDist/WidthRadiusSet).Asin();
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156)+GapAngle;
					EdgeAngleT1 = EdgeAngle360+EdgePointAngleDiff1;

					if (0 != (EdgeAngleT1<90.0))
					{
						EdgeAngleT1 = 90.0;
					}

					if (0 != (EdgeAngleT1>90.0))
					{
						EdgeAngleT1 = 180.0-EdgeAngleT1;
					}
					ColT1 = (WidthRadiusSet*((EdgeAngleT1.Rad()).Sin()))+ColCenterSet;

					//2
					EdgeAngle360 = ((180.0*EdgeAngle)/3.14156);
					EdgeAngleT3 = EdgeAngle360+GapAngle/2+180;

					if (0 != (EdgeAngleT3<90.0))
					{
						EdgeAngleT3 = 90.0;
					}
					if (0 != (EdgeAngleT3>90.0))
					{
						EdgeAngleT3 = 180.0-EdgeAngleT3;
					}

					ColT3 = (WidthRadiusSet*((EdgeAngleT3.Rad()).Sin()))+ColCenterSet;


					gen_region_line(&RegionLines1, Row2, ColT1, Row2+130, ColT1);
					gen_region_line(&RegionLines3, Row2, ColT3, Row2+130, ColT3);

					m_EdgeAngleT1=EdgeAngleT1;
					m_EdgeAngleT3=EdgeAngleT3;

					m_ColT1=ColT1;
					m_ColT3=ColT3;
				}
			}
			else
			{
				ColT1 = -1;
				m_Switch=0;
			}
		}
		Hobject ConPatternRect;
		if (ColT1==-1)
		{
			gen_empty_region(&ConPatternRect);
			m_ColT1=m_imgWidth/2.0;
			m_ColT3=m_imgWidth/2.0;
		} 
		else
		{
			union2(RegionLines1,RegionLines3,&ConPatternRect);
			union1(ConPatternRect,&ConPatternRect);

		}

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], ConPatternRect, &m_vRgn[rId]);
		}
		//
		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(ConPatternRect, &StripeRegArea, &StripeRegRow, &StripeRegColumn);
		if (StripeRegArea>0)
		{
			retValue = ColT1[0].I();
			m_vErrorRgn[rId] = ConPatternRect;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_EmbossCoordAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1193$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 1186;LP;0;300;1;190$\
					 1187;LP;1;150;1;30$\
					 1206;LP;1;100;1;21$\
					 998;LP;1;80;1;50$\
					 992;FP;1;250;0.5;60$\
					 1191;FP;1.5;300.5;0.5;170.5$\
					 1188;FP;1.5;300.5;0.5;42.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_EmbossSearchRegAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pHDilationSize,VARIANT* pSearchSize,VARIANT*pClipSize)
{
	//上排圆形花纹搜索区域
	int id = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;
	int HDilationSize   = (int)pHDilationSize->fltVal;
	int SearchSize =(int)pSearchSize->fltVal;
	int ClipSize =(int)pClipSize->fltVal;//靠近边缘的搜索区域、进行剔除

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	if (m_ABEdgeM.Id()==H_EMPTY_REGION||m_ROI.Id()==H_EMPTY_REGION||m_Switch==0||m_ColT1.Num()!=1)
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		HTuple area,row,col;
		area_center(m_ROI,&area,&row,&col);
		if (area==0 ||area.Num()==0)
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
		HTuple LeftCol,RightCol;
		HTuple RoiRow1,RoiColumn1,RoiRow2,RoiColumn2;
		smallest_rectangle1(m_ROI,&RoiRow1, &RoiColumn1, &RoiRow2, &RoiColumn2);

		Hobject ABEdgeMoved,SearchReg,SearchRegDiff;
		move_region(m_ABEdgeM, &ABEdgeMoved, -MoveSize, 0);
		//垂向膨胀
		dilation_rectangle1(ABEdgeMoved, &SearchReg, 1, SearchSize);
		intersection(SearchReg, m_ROI, &SearchReg);
		m_PatternEdge=ABEdgeMoved;

		Hobject Rect1,ObjectsConcat;
		gen_rectangle1(&Rect1, RoiRow1, m_ColT1-50, RoiRow2, m_ColT1+50);
		if (HDilationSize>=0)
		{
			dilation_rectangle1(Rect1,&Rect1,HDilationSize+1,1);
		} 
		else
		{
			erosion_rectangle1(Rect1,&Rect1,abs(HDilationSize),1);
		}
		intersection(Rect1, SearchReg, &Rect1);

		if (0 != (m_Switch==1))
		{
			//剔除90、-90度附近的角度
			gen_empty_region(&ObjectsConcat);
			if (0 != (m_EdgeAngleT1<0))
			{
				if (0 != (((m_EdgeAngleT1+90).Abs())>=ClipSize))
				{

					concat_obj(Rect1, ObjectsConcat, &ObjectsConcat);
				}
			}
			else
			{
				if (0 != (((m_EdgeAngleT1-90).Abs())>=ClipSize))
				{

					concat_obj(Rect1, ObjectsConcat, &ObjectsConcat);
				}
			}

		}
		else if (0 != (m_Switch==2))
		{
			//剔除90、-90度及其附近的角度
			HTuple ColT;
			ColT = HTuple();
			if (0 != (HTuple(m_EdgeAngleT1!=90).And(m_EdgeAngleT1!=-90)))
			{
				if (0 != (m_EdgeAngleT1<0))
				{
					if (0 != (((m_EdgeAngleT1+90).Abs())>=ClipSize))
					{
						ColT = m_ColT1.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT1-90).Abs())>=ClipSize))
					{
						ColT = m_ColT1.Concat(ColT);
					}
				}
			}

			if (0 != (HTuple(m_EdgeAngleT3!=90).And(m_EdgeAngleT3!=-90)))
			{
				if (0 != (m_EdgeAngleT3<0))
				{
					if (0 != (((m_EdgeAngleT3+90).Abs())>=ClipSize))
					{
						ColT = m_ColT3.Concat(ColT);
					}
				}
				else
				{
					if (0 != (((m_EdgeAngleT3-90).Abs())>=ClipSize))
					{
						ColT = m_ColT3.Concat(ColT);
					}
				}
			}

			HTuple Num;
			Num = ColT.Num();
			if (0 != (Num<1))
			{
				m_vRgn[id] = newRgn ;
				return S_FALSE;
			}
			Hobject Rect;
			gen_empty_region(&ObjectsConcat);
			for (int i=0; i<=Num-1; i ++)
			{
				gen_rectangle1(&Rect, RoiRow1, (ColT.Select(i))-50, RoiRow2, (ColT.Select(i))+50);
				if (HDilationSize>=0)
				{
					dilation_rectangle1(Rect,&Rect,HDilationSize+1,1);
				} 
				else
				{
					erosion_rectangle1(Rect,&Rect,abs(HDilationSize),1);
				}
				intersection(Rect, SearchReg, &Rect);
				concat_obj(Rect, ObjectsConcat, &ObjectsConcat);
			}
		}
		//m_StripeReg=ConReg;
		m_vRgn[id] = ObjectsConcat;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_EmbossSearchRegAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1269$\
					 167;B$\
					 1190;LP;50;350;1;135$\
					 994;LP;-30;30;1;1$\
					 995;LP;10;160;1;90$\
					 1286;LP;2;15;1;11"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgo2(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize,VARIANT* pDilationSize0,VARIANT* pDilationSize1,VARIANT* pSwitch,VARIANT* pMoveSizeH,VARIANT*pDilationSizeH,VARIANT* pAreaThred,VARIANT* pDilationSize2)
{
	//侧面花纹位于中部区域
	int rId           = (int)rgnId->fltVal;
	int Selection   = (int)pSelection->fltVal;
	int MoveSize   = (int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;

	int DilationSize0   = (int)pDilationSize0->fltVal;
	int DilationSize1   = (int)pDilationSize1->fltVal;

	int Switch   = (int)pSwitch->fltVal;
	int MoveSizeH   = (int)pMoveSizeH->fltVal;
	int DilationSizeH=(int)pDilationSizeH->fltVal;

	int AreaThred   = (int)pAreaThred->fltVal;
	int DilationSize2   = (int)pDilationSize2->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_TopRegion.Id()==H_EMPTY_REGION||m_MiddleEdge.Id()==H_EMPTY_REGION||m_DownEdge.Id()==H_EMPTY_REGION||m_StripeReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//叉口区域缩放
		Hobject RegionUnion,RegionFillUp,RegionClosing,PlatformRegDilation,PlatformRegDilation1;
		dilation_circle(m_PlatformReg,&PlatformRegDilation,DilationSize0);
		dilation_circle(m_Platform0,&PlatformRegDilation1,DilationSize0);
		union2(m_TopRegion,PlatformRegDilation,&RegionUnion);
		fill_up(RegionUnion, &RegionFillUp);
		closing_circle(RegionFillUp, &RegionClosing, 20);

		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject ARegionMoved,ARegionIntersction;
		move_region(m_ARegionT,&ARegionMoved,-MoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1;
		//颈部整体水平缩放
		//clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		//颈部整体垂直缩放
		erosion_rectangle1(ARegionIntersction,&ARegionT1,1,VErosionSize);
		//剔除干扰点
		Hobject ARegionTOpening,ARegionTUnion,ConnectedARegionT;
		opening_circle(ARegionT1, &ARegionTOpening, 3.5);
		union1(ARegionTOpening, &ARegionTUnion);
		connection(ARegionTUnion, &ConnectedARegionT);
		select_shape_std(ConnectedARegionT, &ARegionT1, "max_area", 70);

		//中部边缘缩放
		Hobject MidldleRegDilation,ARegionDiff1;
		dilation_circle(m_MiddleEdge,&MidldleRegDilation,DilationSize1);
		difference(ARegionT1, MidldleRegDilation, &ARegionDiff1);
		//
		Hobject ARegionDiff1Connected,SortedRegions,RegionSelected0;
		connection(ARegionDiff1,&ARegionDiff1Connected);
		HTuple Number;
		count_obj(ARegionDiff1Connected, &Number);
		if (Number[0].I()!=2)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}

		sort_region(ARegionDiff1Connected,&SortedRegions, "first_point", "true", "row");
		select_obj(SortedRegions, &RegionSelected0, 2);

		Hobject DownRegDilation;
		dilation_circle(m_DownEdge,&DownRegDilation,DilationSize2);
		//防止提取的下部边缘小于m_ARegionT水平宽度
		HTuple EdgeRow1, EdgeColumn1, EdgeRow2, EdgeColumn2;
		HTuple ARegionTRow1, ARegionTColumn1, ARegionTRow2, ARegionTColumn2;
		smallest_rectangle1(DownRegDilation, &EdgeRow1, &EdgeColumn1, &EdgeRow2, &EdgeColumn2);
		smallest_rectangle1(RegionSelected0,&ARegionTRow1, &ARegionTColumn1, &ARegionTRow2, &ARegionTColumn2);

		Hobject ARegionDiff2;
		if (m_DownEdgeArea>=AreaThred)
		{
			Hobject RegionClipped;
			clip_region(RegionSelected0,&RegionClipped, ARegionTRow1, EdgeColumn1, ARegionTRow2, EdgeColumn2);
			//下部边缘缩放
			difference(RegionClipped, DownRegDilation, &ARegionDiff2);
		}
		else
		{
			HTuple Area7, Row5, Column3,Area8, Row6, Column5;
			Hobject RegionMoved5;
			area_center(m_FMpoints, &Area7, &Row5, &Column3);
			area_center(m_ABEdgeM, &Area8, &Row6, &Column5);
			move_region(m_ABEdgeM, &RegionMoved5, -(Row6-Row5), 0);
			//下部边缘缩放
			dilation_circle(RegionMoved5,&DownRegDilation,DilationSize2);
			difference(RegionSelected0, DownRegDilation, &ARegionDiff2);
		}
		Hobject ARegionDiff2Connected,SortedRegions1;
		connection(ARegionDiff2,&ARegionDiff2Connected);
		HTuple Number1;
		count_obj(ARegionDiff2Connected, &Number1);
		//if (Number1[0].I()!=2)
		//{
		//	m_vRgn[rId] = newRgn ;
		//	return S_FALSE;
		//}
		sort_region(ARegionDiff2Connected,&SortedRegions1, "first_point", "true", "row");
		//花纹特征
		Hobject ConRegions,ConRegionsDilation;
		gen_empty_region(&ConRegions);
		union2(m_StripeReg,ConRegions,&ConRegions);
		union1(ConRegions,&ConRegions);
		if (Selection==1)
		{
			Hobject ARegionDiff0;
			difference(ARegionT1, RegionClosing, &ARegionDiff0);
			union1(ARegionDiff0,&ARegionDiff0);
			//水平缩放
			clip_region_rel(ARegionDiff0, &ARegionDiff0, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = ARegionDiff0 ;	
		}
		else if(Selection==2)
		{
			Hobject RegionSelected,RegionDiff,RegionDilation,RegionOpening,RegionDiff1;
			select_obj(SortedRegions, &RegionSelected, 1);
			//水平缩放
			clip_region_rel(RegionSelected, &RegionSelected, 0, 0, HErosionSize, HErosionSize);

			difference(RegionSelected,RegionClosing,&RegionDiff);
			//
			opening_circle(m_AroiTClosing,&RegionOpening, 10);
			dilation_circle(RegionOpening,&RegionDilation, 5);
			difference(RegionDiff, RegionDilation, &RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1;
		}
		else if(Selection==3)
		{
			Hobject RegionSelected1,RegionDiff,RegionDiff1,RegionDiff2;
			select_obj(SortedRegions1, &RegionSelected1, 1);
			//水平缩放
			clip_region_rel(RegionSelected1, &RegionSelected1, 0, 0, HErosionSize, HErosionSize);
			difference(RegionSelected1, RegionClosing, &RegionDiff);
			difference(RegionDiff,PlatformRegDilation1,&RegionDiff1);
			union1(RegionDiff1,&RegionDiff1);
			m_vRgn[rId] = RegionDiff1 ;

			m_MiddleNeckRegion=RegionDiff1;

			//花纹扣除开关
			if (Switch)
			{
				//花纹纵向平移
				Hobject ConRegionsDilation;
				dilation_circle(ConRegions,&ConRegionsDilation,DilationSizeH);
				move_region(ConRegionsDilation,&ConRegionsDilation,MoveSizeH,0);
				difference(RegionDiff1,ConRegionsDilation,&RegionDiff2);
				difference(RegionDiff2, RegionClosing, &RegionDiff2);
			}
			else
			{
				difference(RegionDiff1,RegionClosing,&RegionDiff2);
			}
			m_vRgn[rId] = RegionDiff2;
		}
		else if(Selection==4)
		{
			Hobject RegionSelected2,RegionDiff;
			if (Number1[0].I()!=2)
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}
			select_obj(SortedRegions1, &RegionSelected2, 2);
			difference(RegionSelected2, RegionClosing, &RegionDiff);
			union1(RegionDiff,&RegionDiff);
			//水平缩放
			clip_region_rel(RegionDiff, &RegionDiff, 0, 0, HErosionSize, HErosionSize);
			m_vRgn[rId] = RegionDiff ;

		}
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::G20_NeckRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1001$\
					 167;B$\
					 1116;LP;1;4;1;1$\
					 1117;LP;1;20;1;1$\
					 1110;LP;1;50;1;10$\
					 1111;LP;1;50;1;3$\
					 1112;LP;1;30;1;3$\
					 1113;LP;1;30;1;3$\
					 1231;LP;0;1;1;1$\
					 1222;LP;-10;10;1;1$\
					 1020;LP;1;30;1;3$\
					 1199;LP;1;200;1;50$\
					 1114;LP;1;90;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************************
**算子名：T20_TopDefectDetectAlgo
**功  能：针对 双叉 20 覆膜胶塞的顶部高亮区域的缺陷检测
**时  间：2018年8月8日
**作  者：吴贻峰
**隐  患： 针对水平方向的缺陷是否敏感呢？
**************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopDefectDetectAlgo(VARIANT* rgnId, VARIANT* pErosionSize,VARIANT* pCErosionSize,VARIANT* pRectSegmntNum,VARIANT* pThreshAdjust, VARIANT* pDefectAreaThresh, VARIANT* pMeanGrayDiffThresh,VARIANT* pMeanGrayNeighborDiff,VARIANT* pDefectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}

	float fErosionSize = (float)pErosionSize->fltVal;
	float fCErosionSize = (float)pCErosionSize->fltVal;
	int   iRectSegmntNum = (int) pRectSegmntNum->fltVal;
	int   iThreshAdjust = (int) pThreshAdjust->fltVal;
	float fDefectAreaThresh = (float) pDefectAreaThresh->fltVal;
	float fMeanGrayDiffThresh = (float) pMeanGrayDiffThresh->fltVal;
	float fMeanGrayNeighborDiff = (float) pMeanGrayNeighborDiff->fltVal;


#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		HTuple dOutCircleRow,dOutCircleCol,dOutCircleRadius,iTopNum;
		Hobject rgnErosion,rgnErosnUnion,rgnOutCircle,rgnErosnIntsct,rgnErosnIntsctEro;
		Hobject rgnCon,imgRed,objSel,objSelFil,rgnThrCon;

		erosion_circle(rgn,&rgnErosion,fErosionSize);

		union1(rgnErosion,&rgnErosnUnion);
		smallest_circle(rgnErosnUnion,&dOutCircleRow,&dOutCircleCol,&dOutCircleRadius);
		gen_circle(&rgnOutCircle,dOutCircleRow,dOutCircleCol,dOutCircleRadius);
		intersection(rgnOutCircle, rgn, &rgnErosnIntsct);
		erosion_circle(rgnErosnIntsct, &rgnErosnIntsctEro, fCErosionSize);

		connection(rgnErosnIntsctEro, &rgnCon);

		if ( m_crtImg.Id() == H_EMPTY_REGION)
		{
			return S_FALSE;
		}
		reduce_domain(m_crtImg, rgnErosnUnion, &imgRed);

		gen_empty_obj(&objSel);
		gen_empty_obj(&objSelFil);

		count_obj(rgnCon, &iTopNum);

		HTuple end_val1 = iTopNum;
		HTuple step_val1 = 1;
		HTuple hv_i ;
		for ( hv_i = 1;hv_i.Continue(end_val1, step_val1); hv_i += step_val1)
		{
			HTuple dMeanWhole,dDeviationWhole,dRectRow,dRectCol,dPhi,dLen1,dLen2;
			HTuple dMeanValue,dMeanValueTemp,dmeanValue1,dmeanValue,dmeanValue2,imeanLength;
			Hobject rgnRect;

			select_obj(rgnCon, &objSel, hv_i);
			intensity(objSel, imgRed, &dMeanWhole, &dDeviationWhole);
			smallest_rectangle2(objSel, &dRectRow, &dRectCol, &dPhi, &dLen1, &dLen2);
			gen_rectangle2(&rgnRect, dRectRow, dRectCol, dPhi, dLen1, dLen2);


			dMeanValue = HTuple();
			dMeanValueTemp = HTuple();


			if (0 != ((iRectSegmntNum%2)==1))
			{
				iRectSegmntNum += 1;
			}

			if (0 != (iRectSegmntNum==0))
			{
				return S_FALSE;
			}

			HTuple end_val2= (iRectSegmntNum/2)-1;
			HTuple step_val2 = 1;
			HTuple hv_n;

			for ( hv_n = (-iRectSegmntNum)/2 ; hv_n.Continue(end_val2, step_val2); hv_n += step_val2)
			{
				HTuple dcenterRow,dcenterCol,dMeanCurrent,dDeviCurrent;
				Hobject rgnSmalRect,rgnIntersected;

				dcenterRow = dRectRow-(((dLen1/iRectSegmntNum)*((2*hv_n)+1))*(dPhi.Sin()));
				dcenterCol = dRectCol+(((dLen1/iRectSegmntNum)*((2*hv_n)+1))*(dPhi.Cos()));
				gen_rectangle2(&rgnSmalRect,dcenterRow, dcenterCol, dPhi, dLen1/iRectSegmntNum, dLen2);

				intersection(rgnSmalRect, rgnErosnUnion, &rgnIntersected);

				intensity(rgnIntersected, imgRed, &dMeanCurrent, &dDeviCurrent);

				if ( dMeanCurrent <= 0)
				{
					retValue = 0.0;
					Hobject newRgn; 
					m_vErrorRgn[rId] = newRgn;
					retValue.Detach(pDefectArea);
					return S_FALSE;

				}

				dmeanValue = dmeanValue.Concat(dMeanCurrent);
				tuple_length(dmeanValue, &imeanLength);

			}

			//给矩阵的第一个和最后一个各添加一个值，以防止 meanValue[n+6-1] 和 meanValue[n+6+1] 不存在
			dmeanValue1 = dmeanValue.Select(0);
			dmeanValue2 = dmeanValue.Select(iRectSegmntNum-1);
			dmeanValue = dmeanValue1.Concat(dmeanValue);
			dmeanValue = dmeanValue.Concat(dmeanValue2);


			HTuple end_val3 = (iRectSegmntNum/2)-1;
			HTuple step_val3 = 1;

			for (HTuple hv_n=(-iRectSegmntNum)/2; hv_n.Continue(end_val3, step_val3); hv_n += step_val3)
			{

				HTuple hv_centerRow,hv_centerCol,dMeanCurrent,dDeviCurrent,dDiffValueBefore,dDiffValueAfter;
				Hobject rgnSmalRect,rgnIntersected,imgIntsctRed,rgnThr,rgnSel;

				hv_centerRow = dRectRow-(((dLen1/iRectSegmntNum)*((2*hv_n)+1))*(dPhi.Sin()));
				hv_centerCol = dRectCol+(((dLen1/iRectSegmntNum)*((2*hv_n)+1))*(dPhi.Cos()));
				gen_rectangle2(&rgnSmalRect, hv_centerRow, hv_centerCol, dPhi, dLen1/iRectSegmntNum, dLen2);

				intersection(rgnSmalRect, rgnErosnUnion, &rgnIntersected);
				intensity(rgnIntersected, imgRed, &dMeanCurrent, &dDeviCurrent);

				dDiffValueBefore = (dMeanCurrent-(dmeanValue.Select(hv_n+(iRectSegmntNum/2)))).Abs();
				dDiffValueAfter = (dMeanCurrent-(dmeanValue.Select((hv_n+(iRectSegmntNum/2))+2))).Abs();

				if ( dMeanCurrent <= 0)
				{
					retValue = 0.0;
					Hobject newRgn; 
					m_vErrorRgn[rId] = newRgn;
					retValue.Detach(pDefectArea);
					return S_FALSE;
				}

				if (0 != ((dMeanWhole-dMeanCurrent)>fMeanGrayDiffThresh))
				{
					reduce_domain(imgRed, rgnIntersected, &imgIntsctRed);
					threshold(imgIntsctRed, &rgnThr, 0, dMeanCurrent-iThreshAdjust);
					connection(rgnThr,&rgnThrCon);
					select_shape(rgnThrCon, &rgnSel, "area", "and", fDefectAreaThresh, 500);
					if (0 != (HTuple(dDiffValueBefore>fMeanGrayNeighborDiff).Or(dDiffValueAfter>fMeanGrayNeighborDiff)))
					{
						concat_obj(objSelFil, rgnSel, &objSelFil);
					}
				}

			}

		}

		Hobject DefectRegs;
		HTuple Area, Row_test, Column_test;
		union1(objSelFil,&DefectRegs);
		area_center(DefectRegs, &Area, &Row_test, &Column_test);
		if(Area <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDefectArea);


#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDefectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopDefectDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1375$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 1376;FP;0;50;0.5;15.5$\
					 1377;FP;0;50;0.5;7.5$\
					 1378;LP;1;50;1;12$\
					 1381;LP;1;50;1;3$\
					 1379;FP;1;101;0.5;10$\
					 1380;FP;1;50;0.5;2$\
					 1382;FP;1;50;0.5;4");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************************************
**函 数 名：AB20_FilmOrNotDetectAlgo
**功    能：针对20圆形覆膜胶塞，检测胶塞是否覆膜
**思    路：先检测CH3高亮区域是否有缺陷，如果有缺陷，则剔除；
             若没有缺陷则进行方差计算，进行判断
**判断准则：>= 50,该数值可以根据事情情况调整（软件平台上）
**时    间：2018年08月23日
**作    者：吴贻峰
*******************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_FilmOrNotDetectAlgo(VARIANT* rgnId,VARIANT* pRotaAngle,VARIANT* pDynThresh, VARIANT* pDefectSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int ThresholdValue = (int)pDynThresh->fltVal; 
	int DefectSize = (int) pDefectSize->fltVal;
	float RotaAngle = (float)pRotaAngle->fltVal;
	//float DeriationSize = (float)pDeriationSize->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ImageAffinTrans,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//

		float fCenterX = 0.0;
		float fCenterY = 0.0;
		fCenterX = m_vPos[0].m_x;
		fCenterY = m_vPos[0].m_y;
		reduce_domain (Image, rgn, &ImageReduced);
		vector_angle_to_rigid(fCenterY,fCenterX, 0, fCenterY, fCenterX, HTuple(RotaAngle).Rad(), &HomMat2D);
		affine_trans_image(ImageReduced, &ImageAffinTrans, HomMat2D, "bilinear", "false");
		dyn_threshold(ImageReduced, ImageAffinTrans, &RegionDynThresh, ThresholdValue, "not_equal");
		connection(RegionDynThresh, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions4, "area", "and", DefectSize, 9999999);
		Hobject DefectRegs;
		union1(SelectedRegions4, &DefectRegs);
		HTuple Area, Row_test, Column_test;
		area_center(DefectRegs, &Area, &Row_test, &Column_test);

		HTuple dDev;
		if(Area <= 0)
		{
			HTuple dMean,dDeviation;

			intensity(rgn,Image,&dMean,&dDeviation);
			dDev = dDeviation*dDeviation;
			retValue = dDev[0].I();

			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;

		}
		else
		{
			retValue = Area[0].I();
			//retValue = -1;
			dilation_circle (DefectRegs, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_FilmOrNotDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1385$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 610;FP;0.5;350;0.5;3.5$\
					 630;LP;1;250;1;60$\
					 387;LP;1;200;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************************************
**函 数 名：AB20_FilmOrNotDetectAlgo1
**功    能：针对20圆形覆膜胶塞，检测胶塞是否覆膜
**思    路：通过判断CH4侧面工位的覆膜区域是否存在来判断是否为覆膜胶塞（无膜时覆膜边缘很不清晰）
**时    间：2018年11月11日
*******************************************************************************/
STDMETHODIMP CPlugAlgo::AB20_FilmOrNotDetectAlgo1(VARIANT* rgnId,VARIANT* pWhiteMask,VARIANT* pDynThresh, VARIANT* pAreaSize,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	int WhiteMask = (int)pWhiteMask->fltVal; 
	int ThresholdValue = (int)pDynThresh->fltVal; 
	int AreaSize = (int) pAreaSize->fltVal;


#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		HTuple HomMat2D;
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ImageReducedMean,RegionDynThresh,ConnectedRegions4,SelectedRegions4;
		//
		reduce_domain (Image, rgn, &ImageReduced);
		mean_image(ImageReduced,&ImageReducedMean,WhiteMask,WhiteMask/2);

		dyn_threshold(ImageReduced, ImageReducedMean, &RegionDynThresh, ThresholdValue, "light");
		connection(RegionDynThresh, &ConnectedRegions4);
		select_shape(ConnectedRegions4, &SelectedRegions4, "area", "and", AreaSize, 9999999);
		Hobject FilmRegs;
		union1(SelectedRegions4, &FilmRegs);
		HTuple Area, Row_test, Column_test;
		area_center(FilmRegs, &Area, &Row_test, &Column_test);

		HTuple dDev;
		if(Area <= 0)
		{
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = Area[0].I();
			m_vErrorRgn[rId] = FilmRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::AB20_FilmOrNotDetectAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1385$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 417;LP;1;250;1;40$\
					 418;LP;1;250;1;20$\
					 419;LP;1;20000;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

STDMETHODIMP CPlugAlgo::CountValueNumberAlgo(VARIANT* rgnId,VARIANT* pError)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pError);
		return S_FALSE;
	}


#ifdef NDEBUG
	try
	{
#endif
		//
		retValue = m_Value;
		//retValue.ChangeType(VT_R4);
		retValue.Detach(pError);

#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pError);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pError);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::CountValueNumberAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6000$\
					 397;R;FP;-100;300;1;>=#1$\
					 381;B");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************************************
***函数名：FilmEdgeRegionLocationAlgo
***功  能：基于基准线生成的覆膜边缘检测区域，区域的大小不会跟随覆膜的变化而发生改变
********************************************************************************************/
STDMETHODIMP CPlugAlgo::FilmEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHErosionSize,VARIANT* pDialtionSizeV)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize =(int)pMoveSize->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int DialtionSizeV   = (int)pDialtionSizeV->fltVal;

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ABEdgeM.Id()== H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject MiddleEdgeReg,MiddleEdgeRegDilation,PlatformRegDilation,MiddleRegion;
		move_region(m_ABEdgeM, &MiddleEdgeReg, MoveSize, 0);
		//垂直缩放
		dilation_rectangle1(MiddleEdgeReg,&MiddleEdgeRegDilation,1,DialtionSizeV);
		Hobject RegionClip,ImageDomain;
		clip_region_rel(MiddleEdgeRegDilation, &RegionClip, 0, 0, HErosionSize, HErosionSize);

		gen_rectangle1(&ImageDomain,1,1,m_imgHeight-1,m_imgWidth-1);
		intersection(RegionClip, ImageDomain, &RegionClip);
		m_vRgn[rId] = RegionClip;
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::FilmEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1389$\
					 167;B$\
					 1190;LP;-90;160;1;1$\
					 994;LP;1;70;1;10$\
					 995;LP;1;70;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

/********************************************************************************************
***函数名：DerivateDynThresholdAlgo
***功  能：dynThreshold之前，先对原图进行derivate_gauss预处理
********************************************************************************************/
STDMETHODIMP CPlugAlgo::DerivateDynThresholdAlgo(VARIANT* rgnId, VARIANT* pBlackMaskSize, VARIANT* pSeriousBlackPointDynThresh, VARIANT* pSeriousBlackPointSize, VARIANT* pSeriousBlackPointLength,VARIANT*pRowDiffValue,VARIANT*pAreaThred,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	HTuple area,row,col;
	union1(rgn,&rgn);
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue = 0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int BlackMaskSize = (int)pBlackMaskSize->fltVal;
	float SeriousBlackPointDynThresh = (float)pSeriousBlackPointDynThresh->fltVal;
	int SeriousBlackPointSize = (int) pSeriousBlackPointSize->fltVal;
	int SeriousBlackPointLength = (int) pSeriousBlackPointLength->fltVal;

	float RowDiffValue = (float)pRowDiffValue->fltVal;
	int AreaThred   = (int)pAreaThred->fltVal;
	//int WhiteMaskSize = (int) pWhiteMaskSize->fltVal;
	//float SeriousWhitePointDynThresh = (float) pSeriousWhitePointDynThresh->fltVal;
	//int SeriousWhitePointSize = (int) pSeriousWhitePointSize->fltVal;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject Image = m_crtImg;
		Hobject ImageReduced,ExpandedImage,DerivGauss,ImageMean;
		Hobject BlackUnion, WhiteUnion,BlackRegs,BlackRegsSelected,BlackRegsSelected1,DefectRegs;
		HTuple Area, Row_test, Column_test;

		expand_domain_gray(Image,&ExpandedImage,5);
		reduce_domain(ExpandedImage,rgn,&ImageReduced);

		derivate_gauss(ImageReduced,&DerivGauss,1,"y");
		mean_image(DerivGauss,&ImageMean,10,BlackMaskSize);
		dyn_threshold(DerivGauss,ImageMean,&BlackRegs,SeriousBlackPointDynThresh,"dark");
		connection(BlackRegs,&BlackRegs);

		select_shape(BlackRegs,&BlackRegsSelected,"area","and",SeriousBlackPointSize,99999999);
		select_shape(BlackRegsSelected,&BlackRegsSelected1,"contlength","and",1,SeriousBlackPointLength);
		union1(BlackRegsSelected1,&BlackUnion);
		area_center(BlackUnion,  &Area, &Row_test, &Column_test);

		HTuple ErrorRegsArea;
		ErrorRegsArea=0;
		if (Area>0)
		{
			if (m_bDebugImg)
			{
				concat_obj(BlackUnion,m_vRgn[rId],&m_vRgn[rId]);
			}
			HTuple Number;
			Hobject SelectRegion;
			count_obj(BlackRegsSelected1,&Number);
			for (int i=1;i<=Number;i++)	
			{
				select_obj(BlackRegsSelected1,&SelectRegion,i);
				Hobject Rectangle;
				HTuple Row11, Column11, Row21, Column22;
				smallest_rectangle1(SelectRegion, &Row11, &Column11, &Row21, &Column22);
				gen_rectangle1(&Rectangle, Row11-20, Column11, Row21+20, Column22);
				Hobject DownEdgePoints1,DownEdgePoints2;
				intersection(m_DownEdgePoints1,Rectangle,&DownEdgePoints1);
				intersection(m_DownEdgePoints2,Rectangle,&DownEdgePoints2);

				Hobject SubDownEdgePoints1,SubDownEdgePoints2;
				difference(m_DownEdgePoints1,DownEdgePoints1,&SubDownEdgePoints1);
				difference(m_DownEdgePoints2,DownEdgePoints2,&SubDownEdgePoints2);

				HTuple PArea1,PRow1,PCol1,PArea2,PRow2,PCol2;
				area_center(DownEdgePoints1,&PArea1,&PRow1,&PCol1);
				area_center(DownEdgePoints2,&PArea2,&PRow2,&PCol2);
				HTuple RowDiff1;
				RowDiff1=PRow2-PRow1;

				HTuple PSArea1,PSRow1,PSCol1,PSArea2,PSRow2,PSCol2;
				area_center(SubDownEdgePoints1,&PSArea1,&PSRow1,&PSCol1);
				area_center(SubDownEdgePoints2,&PSArea2,&PSRow2,&PSCol2);
				HTuple RowDiff2;
				RowDiff2=PSRow2-PSRow1;

				if ((RowDiff1-RowDiff2).Abs()>=RowDiffValue)
				{
					area_center(BlackUnion,  &Area, &Row_test, &Column_test);

				}
				else
				{
					Area=0;

				}
				ErrorRegsArea=ErrorRegsArea+Area;
			}

		}
		//
		HTuple PDArea1,PDRow1,PDCol1,PDArea2,PDRow2,PDCol2;
		area_center(m_DownEdgePoints1,&PDArea1,&PDRow1,&PDCol1);
		area_center(m_DownEdgePoints2,&PDArea2,&PDRow2,&PDCol2);
		if ((PDArea1-PDArea2).Abs()>AreaThred)
		{
			ErrorRegsArea=0;
		}
		//
		if(ErrorRegsArea <= 0)
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}
		else
		{
			retValue = ErrorRegsArea[0].I();
			dilation_circle (BlackUnion, &DefectRegs, 2.5);
			m_vErrorRgn[rId] = DefectRegs;
		}
		retValue.Detach(pDetectArea);
#ifdef NDEBUG
	}
	catch (HException &except)  
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue=-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DerivateDynThresholdAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("411$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 412;LP;3;101;2;7$\
					 415;LP;1;250;1;60$\
					 416;LP;1;200;1;10$\
					 5011;LP;3;500;1;200$\
					 1185;FP;1;10;0.1;1$\
					 1390;LP;1;100;1;6");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/********************************************************************************************
***函数名：TopLessRubberDetectAlgo
***功  能：双叉覆膜顶部缺胶检测
********************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopLessRubberDetectAlgo(VARIANT* rgnId,VARIANT* pAreaLimit,VARIANT* pLongLengthLimit,VARIANT* pDetectArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}

	int AreaLimit = (int)pAreaLimit->fltVal;
	float LongLengthLimit = (float)pLongLengthLimit->fltVal;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject Image = m_crtImg;

		Hobject rgnCon,rgnSel,objSel;
		HTuple  iNumber,LongLengthAll,LongLengthAllSorted;

		connection(rgn, &rgnCon);

		select_shape(rgnCon, &rgnSel, "area", "and", AreaLimit,9999999);
		count_obj(rgnSel, &iNumber);

		if ((iNumber<=0) ||(iNumber>2) )
		{
			retValue=0.0;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pDetectArea);
			return S_FALSE;
		}

		LongLengthAll = HTuple();

		for (int i=1; i<=iNumber; ++i)
		{
			HTuple dRow1, dColumn1, dPhi, dLength1, dLength2,LongLength;
			Hobject rgnRectangle;
			select_obj(rgnSel, &objSel, i);
			smallest_rectangle2(objSel, &dRow1, &dColumn1, &dPhi, &dLength1, &dLength2);
			gen_rectangle2(&rgnRectangle, dRow1, dColumn1, dPhi, dLength1, dLength2);

			if (dLength1>dLength2)
			{
				LongLength = dLength1;
			}
			else
			{
				LongLength = dLength2;
			}

			LongLengthAll = LongLengthAll.Concat(LongLength);
		}

		tuple_sort(LongLengthAll, &LongLengthAllSorted);

		if(LongLengthAllSorted[0].D()<LongLengthLimit)
		{
			HTuple MinLength,Indices,dArea,dCenRow,dCenCol;
			Hobject objSel2,objSel2Ero;
			MinLength = LongLengthAllSorted.Select(0);
			tuple_find(LongLengthAll, MinLength, &Indices);
			select_obj(rgnSel, &objSel2, Indices+1);
			erosion_circle(objSel2,&objSel2Ero,3.5);

			area_center(objSel2Ero,&dArea,&dCenRow,&dCenCol);

			retValue = dArea[0].I();
			m_vErrorRgn[rId] = objSel2Ero;

		}
		else
		{
			retValue = 0.0;
			Hobject newRgn; 
			m_vErrorRgn[rId] = newRgn;
		}

		retValue.Detach(pDetectArea);

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pDetectArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopLessRubberDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6015$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6005;LP;1;30000;100;4000$\
					 6016;FP;1;250;0.5;140");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

//================注射器胶塞==================================

/*******************************************************
*算子名：SideCenterLocationAlgo1
*功  能：侧面区域定位，针对一种螺旋状的胶塞
********************************************************/
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgo1(VARIANT* rgnId, VARIANT* pThresholdLow,VARIANT* pOutlierRemoverSize,VARIANT* pErosionSize)
{
	/*异形胶塞侧面工位中心定位*/
	int id = (int)rgnId->fltVal;
	int ThresholdLow = (int)pThresholdLow->fltVal;
	int OutlierRemoverSize = (int)pOutlierRemoverSize->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	Hlong Width, Height;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject Image = m_crtImg;
		Hobject Ellipse,ImageReduced;
		get_image_size (Image, &Width, &Height);
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/1.6, Height/2.0);   //默认图片的大小有要求(/0.1)
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		reduce_domain (Image, Ellipse, &ImageReduced);
		Hobject ImageReducedScaleMax;
		scale_image_max(ImageReduced,&ImageReducedScaleMax);

		//*提取整个ROI
		Hobject Regions,ConnectedRegions,RegionFillUp,RegionOpening,RegionSelect,RegionClosing;
		threshold(ImageReducedScaleMax, &Regions, ThresholdLow, 255);

		fill_up(Regions, &RegionFillUp);
		opening_circle(RegionFillUp, &RegionOpening, OutlierRemoverSize+0.5);
		
		Hobject rgnClosing;
		closing_circle(RegionOpening,&rgnClosing,5.5);

		connection(rgnClosing, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);
		closing_circle(RegionSelect, &RegionClosing, 20.5);

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(RegionClosing,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(RegionClosing, &ROI, ErosionSize);
			m_vPos[0].m_x =(float)ROIcol[0].D();
			m_vPos[0].m_y =(float)ROIrow[0].D();
			m_vRgn[id] = ROI;
			m_ROI=ROI;
			m_WholeRoi=ROI;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vPos[0].m_x = (float)(m_imgWidth/2.0);
			m_vPos[0].m_y = (float)(m_imgHeight/2.0);
			m_vRgn[id] = Circle;
			m_ROI=newRgn;
			m_WholeRoi=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideCenterLocationAlgo1Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("1013$\
					 381;B$\
					 640;LP;1;255;1;23$\
					 641;LP;1;800;1;3$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*******************************************************
*算子名：TopBaseLineDetectAlgo
*功  能：基准线提取(底部和顶部基准线)
*说  明：pSelecttion控制提取的基准线：1--顶部基准线；2--底部基准线
********************************************************/
STDMETHODIMP CPlugAlgo::TopBaseLineDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6022$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6023;LP;1;2;1;1$\
					 6021;LP;5;100;1;18$\
					 1100;LP;5;80;1;15$\
					 1101;LP;0;50;1;10$\
					 1099;LP;1;60;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopBaseLineDetectAlgo(VARIANT* rgnId, VARIANT* pSelecttion,VARIANT* pMoveSize,VARIANT* pDilSize,VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pTopBaseLineArea)
{
	//得到矩形条状区域区域
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}

	int MoveSize = (int)pMoveSize->fltVal;     // 18
	int DilSize = (int)pDilSize->fltVal;       //15
	int Threshold = (int)pThreshold->fltVal;   //8
	int HClipSize = (int)pHClipSize->fltVal; // 10
	int Selecttion = (int)pSelecttion->fltVal; // 1-2

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnTopMoved,rgnTopDif ;
		Hobject Image = m_crtImg;

		move_region(rgn, &rgnTopMoved, MoveSize, 0);
		if (MoveSize>0)
		{
			difference(rgnTopMoved, rgn, &rgnTopDif);
		}
		else if(MoveSize < 0 )
		{
			difference(rgn, rgnTopMoved, &rgnTopDif);
		}
		else
		{
			move_region(rgn, &rgnTopMoved, 1, 0);
			difference(rgnTopMoved, rgn, &rgnTopDif);
		}
		connection(rgnTopDif,&rgnTopDif);
		select_shape_std(rgnTopDif, &rgnTopDif, "max_area", 70);

		Hobject rgnTopMovedUp,rgnTopMovedUpDil;
		move_region(rgnTopDif, &rgnTopMovedUp,(-MoveSize)/2 , 0);    // 
		dilation_rectangle1(rgnTopMovedUp, &rgnTopMovedUpDil, 1, DilSize);

		clip_region_rel(rgnTopMovedUpDil,&rgnTopMovedUpDil,0,0,HClipSize,HClipSize);

		HTuple DefinedRow,DefinedCol;
		
		R_EdgePointsFitCurve(rgnTopMovedUpDil, Image, 5, 2, Threshold,"positive", "first", &DefinedRow, &DefinedCol);

		if (DefinedRow.Num()< 5)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopBaseLineArea);
			return S_FALSE;
		}

		Hobject Region,Contour,SmoothedContours,rgnTopEdge,TopEdge;
		HTuple dRow,dCol;
		gen_region_points(&Region, DefinedRow, DefinedCol);
		gen_contour_nurbs_xld(&Contour, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(Contour, &SmoothedContours, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,DefinedRow, DefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], rgnTopMovedUpDil, &m_vRgn[rId]);
		}
		get_contour_xld(SmoothedContours, &dRow, &dCol);
		gen_region_polygon(&rgnTopEdge, dRow, dCol);

		clip_region_rel(rgnTopEdge, &TopEdge, 0, 0, 10, 10);

		HTuple TopEdgeArea, TopEdgeRow, TopEdgeCol;
		area_center(TopEdge, &TopEdgeArea, &TopEdgeRow, &TopEdgeCol);

		if(TopEdgeArea > 1)
		{
			retValue = TopEdgeArea[0].I();
			m_vErrorRgn[rId] = TopEdge;
			if (Selecttion == 1)
			{
				// Top Baseline
				m_TopBaseLine = TopEdge;
				m_TopEdgeRow  = TopEdgeRow;
			}
			else if (Selecttion == 2)
			{
				// Bottom Baseline
				m_BottomBaseLine = TopEdge;
				m_BottomEdgeRow = TopEdgeRow;

				// 使用拐角区域算子
				m_ABEdgeReg = TopEdge;
			}
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopBaseLineArea);


#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/****************************************************************************************
*算子名：LineDetectFromBaseTopAlgo
*功  能：根据顶部基准线提取其它边缘
*说  明：pSelecttion控制提取的基准线：1--顶部下边缘线；2--中部上边缘；3--中部中心边缘
****************************************************************************************/
STDMETHODIMP CPlugAlgo::LineDetectFromBaseTopAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6024$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6025;LP;1;3;1;1$\
					 6026;LP;10;180;1;18$\
					 1100;LP;10;80;1;15$\
					 1101;LP;0;50;1;10$\
					 1099;LP;1;60;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::LineDetectFromBaseTopAlgo(VARIANT* rgnId, VARIANT* pSelecttion,VARIANT* pMoveSize,VARIANT* pDilSize,VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pTopBaseLineArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0)
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}

	int MoveSize = (int)pMoveSize->fltVal;     // 18
	int DilSize = (int)pDilSize->fltVal;       //15
	int Threshold = (int)pThreshold->fltVal;   //8
	int HClipSize = (int)pHClipSize->fltVal; // 10
	int Selecttion = (int)pSelecttion->fltVal; // 1-3

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopBaseLine = m_TopBaseLine;
		Hobject Image = m_crtImg;
		Hobject rgnTopBaseLineMoved,rgnTopBaseLineDil;

		move_region(TopBaseLine, &rgnTopBaseLineMoved, MoveSize, 0);
		dilation_rectangle1(rgnTopBaseLineMoved, &rgnTopBaseLineDil, 1, DilSize);

		clip_region_rel(rgnTopBaseLineDil,&rgnTopBaseLineDil,0,0,HClipSize,HClipSize);
		intersection(rgnTopBaseLineDil,m_ROI,&rgnTopBaseLineDil);

		HTuple DefinedRow,DefinedCol;
		if ( Selecttion == 1 )
		{
			// 顶部下边缘
			R_EdgePointsFitCurve(rgnTopBaseLineDil, Image, 5, 2, Threshold,"positive", "first", &DefinedRow, &DefinedCol);
		}
		else if(Selecttion == 2 )
		{
			// 中部上边缘
			P_EdgePointsFitCurve(rgnTopBaseLineDil, Image, 5, DilSize, 2, &DefinedRow, &DefinedCol);
		}
		else if(Selecttion == 3 )
		{
			// 中部中心边缘
			R_EdgePointsFitCurve(rgnTopBaseLineDil, Image, 5, 2, Threshold,"positive", "last", &DefinedRow, &DefinedCol);
		}
		
		if (DefinedRow.Num()< 10)
		{
			P_EdgePointsFitCurve(rgnTopBaseLineDil, Image, 5, 30, 2, &DefinedRow, &DefinedCol);
		}
	
		if (DefinedRow.Num()< 5)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pTopBaseLineArea);
			return S_FALSE;
		}

		Hobject Region,Contour,SmoothedContours,rgnTopEdge,TopEdge;
		HTuple dRow,dCol;
		gen_region_points(&Region, DefinedRow, DefinedCol);
		gen_contour_nurbs_xld(&Contour, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(Contour, &SmoothedContours, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,DefinedRow, DefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], rgnTopBaseLineDil, &m_vRgn[rId]);
		}
		get_contour_xld(SmoothedContours, &dRow, &dCol);
		gen_region_polygon(&rgnTopEdge, dRow, dCol);

		clip_region_rel(rgnTopEdge, &TopEdge, 0, 0, 10, 10);

		HTuple TopEdgeArea, TopEdgeRow, TopEdgeCol;
		area_center(TopEdge, &TopEdgeArea, &TopEdgeRow, &TopEdgeCol);

		if(TopEdgeArea > 1)
		{
			retValue = TopEdgeArea[0].I();
			m_vErrorRgn[rId] = TopEdge;
			if (Selecttion == 1)
			{
				// 顶部下边缘
				m_rgnTopDownEdge = TopEdge;
				m_TopDownEdgeRow  = TopEdgeRow;
			}
			else if (Selecttion == 2)
			{
				// 中部上边缘
				m_dRowMidUp = TopEdgeRow;
			}
			else if (Selecttion == 3)
			{
				// 中部中心边缘
				m_dRowMidMM = TopEdgeRow;
			}
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pTopBaseLineArea);


#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pTopBaseLineArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/********************************************************************************
*算子名：TopRegionLocationAlgo
*功  能：ROI 区域提取（整体区域或者顶部高亮区域）
*说  明：通过设定不同的阈值,提取不同位置（1-整体;2-高亮区域）
********************************************************************************/
STDMETHODIMP CPlugAlgo::TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelecttion,VARIANT* pThresholdLow,VARIANT* pOutlierRemoverSize,VARIANT* pErosionSize)
{
	/*异形胶塞顶部区域定位*/
	int id = (int)rgnId->fltVal;
	int Selecttion = (int)pSelecttion->fltVal;         
	int ThresholdLow = (int)pThresholdLow->fltVal;
	int OutlierRemoverSize = (int)pOutlierRemoverSize->fltVal;
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	Hlong Width, Height;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject Image = m_crtImg;
		Hobject Ellipse,ImageReduced;
		get_image_size (Image, &Width, &Height);
		gen_ellipse (&Ellipse, Height/2.0, Width/2.0, 0.0, Width/1.6, Height/2.0);   //默认图片的大小有要求(/0.1)
	
		reduce_domain (Image, Ellipse, &ImageReduced);
		Hobject ImageReducedScaleMax;
		scale_image_max(ImageReduced,&ImageReducedScaleMax);

		//*提取整个ROI
		Hobject Regions,ConnectedRegions,RegionFillUp,RegionOpening,RegionSelect,RegionClosing;
		threshold(ImageReducedScaleMax, &Regions, ThresholdLow, 255);

		fill_up(Regions, &RegionFillUp);
		opening_circle(RegionFillUp, &RegionOpening, OutlierRemoverSize+0.5);

		Hobject rgnClosing;
		closing_circle(RegionOpening,&rgnClosing,5.5);

		connection(rgnClosing, &ConnectedRegions);
		select_shape_std(ConnectedRegions, &RegionSelect, "max_area", 70);
		closing_circle(RegionSelect, &RegionClosing, 20.5);

		if ( Selecttion == 2 )
		{
			// 将顶部高亮区域传递出来
			gen_empty_region(&m_rgnSideTop);
			concat_obj(m_rgnSideTop,RegionClosing,&m_rgnSideTop); 
		}
		
		HTuple ROIarea,ROIrow,ROIcol;
		area_center(RegionClosing,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(RegionClosing, &ROI, ErosionSize);
			m_vRgn[id] = ROI;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6027$\
					 381;B$\
					 6104;LP;1;2;1;1$\
					 640;LP;1;255;1;23$\
					 641;LP;1;800;1;3$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************************
*算子名：SideTopSectorRegionLocationAlgo
*功  能：提取侧面顶部高亮区域中的非反光区域
****************************************************************************************/
STDMETHODIMP CPlugAlgo::SideTopSectorRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6101$\
					 381;B$\
					 6108;LP;1;3;1;1$\
					 6010;LP;1;70;1;10$\
					 6012;LP;1;350;1;10$\
					 6102;FP;0;360;0.5;230$\
					 6103;FP;0;360;0.5;310$\
					 5543;FP;1;20.5;0.5;1.5$\
					 5544;FP;1;20.5;0.5;1.5");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SideTopSectorRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pdUpPos,VARIANT* pdDownPos,VARIANT* pAngleStart,VARIANT* pAngleEnd,VARIANT* pOuterSize,VARIANT* pInnerSize)
{
	int id = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;       // 1--，，2--
	int dUpPos = (int)pdUpPos->fltVal;             // 10
	int dDownPos = (int)pdDownPos->fltVal;         // 10
	float AngleStart = (float)pAngleStart->fltVal; // 210
	float AngleEnd = (float)pAngleEnd->fltVal;     // 310  
	float OuterSize = (float)pOuterSize->fltVal;   // 3.5
	float InnerSize = (float)pInnerSize->fltVal;    // 3.5

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	Hobject rgnTop = m_rgnSideTop;
	union1(rgnTop,&rgnTop);
	
	if ((m_rgnSideTop.Id() == H_EMPTY_REGION) )
	{
		Hobject newRgn;
		m_vRgn[id] = newRgn;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		Hobject Image = m_crtImg;
		Hobject xldTop;
		HTuple dTopRow,dTopCol,dTopRowMin,dTopRowIndices,dTopColSel,dTopRowSel ;
		opening_circle(rgnTop, &rgnTop, 10.5);
		union1(rgnTop,&rgnTop);

		HTuple  dArea,dRow,dCol;
		area_center(rgnTop,&dArea,&dRow,&dCol );
		if ( dArea <= 0)
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		
		gen_contour_region_xld(rgnTop, &xldTop, "border");

		HTuple  iNum;
		count_obj(xldTop,&iNum);
		if ( iNum > 1)
		{
			Hobject newRgn;
			m_vRgn[id] = newRgn;
			return S_FALSE;
		}
		get_contour_xld(xldTop, &dTopRow, &dTopCol);

		if ( dTopRow.Num() < 3)
		{
			Hobject newRgn;
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}
		tuple_min(dTopRow, &dTopRowMin);
		tuple_find(dTopRow, dTopRowMin, &dTopRowIndices);
		tuple_select(dTopCol, dTopRowIndices, &dTopColSel);
		tuple_select(dTopRow, dTopRowIndices, &dTopRowSel);
		//gen_cross_contour_xld(&Cross, dTopRowSel, dTopColSel, 6, 0.785398);

		HTuple  dTopColSelMean;
		tuple_mean(dTopColSel, &dTopColSelMean);

		//gen_cross_contour_xld(&xldCrossTop, dTopRowMin, dTopColSelMean, 6, 0.785398);
		HTuple DistanceMin,DistanceMax  ;
		Hobject rgnCircSector ;
		distance_pc(xldTop, dTopRowMin, dTopColSelMean, &DistanceMin, &DistanceMax);
		gen_circle_sector(&rgnCircSector, dTopRowMin-5, dTopColSelMean, DistanceMax, ((HTuple)AngleStart).Rad(), ((HTuple)AngleEnd).Rad());

		Hobject rgnTopMovDown,rgnTopMovUp,rgnTopClip,rgnTopSector,rgnROI,rgnTopBorder ;
		move_region(rgnTop, &rgnTopMovDown, dUpPos, 0);
		move_region(rgnTop, &rgnTopMovUp, -dDownPos, 0);
		intersection(rgnTopMovDown, rgnTopMovUp, &rgnTopClip);

		intersection(rgnCircSector, rgnTopClip, &rgnTopSector);
		
		if ( Selection == 1)
		{
			// 中间区域
			rgnROI = rgnTopSector;
		}
		else if ( Selection == 2)
		{
			difference(rgnTopClip,rgnTopSector,& rgnTopBorder);
			rgnROI = rgnTopBorder ;
			m_rgnSideTopBorder = rgnTopBorder;
		}
		else if( Selection == 3)
		{
			// 侧面顶部高亮区域
			Hobject rgnTopSectorDil,rgnTopBorderDil,rgnDiff1,rgnTopHighLigt ;
			dilation_circle(rgnTopSector,&rgnTopSectorDil,InnerSize ) ;
			dilation_circle(m_rgnSideTopBorder,&rgnTopBorderDil,OuterSize );
			difference(rgnTopClip,rgnTopSectorDil,&rgnDiff1 );
			difference(rgnDiff1,rgnTopBorderDil,& rgnTopHighLigt);
			opening_circle(rgnTopHighLigt,&rgnTopHighLigt,1.5 );
			rgnROI = rgnTopHighLigt;
		}
		else
		{
			gen_empty_obj(&rgnROI);
		}

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(rgnROI,&ROIarea,&ROIrow,&ROIcol);
		if ( ROIarea > 0)
		{	
			m_vRgn[id] = rgnROI;
		}
		else
		{
			Hobject newRgn;
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
// 顶部下边缘区域定位
STDMETHODIMP CPlugAlgo::TopEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6028$\
					 381;B$\
					 6026;LP;-30;50;1;1$\
					 1100;LP;10;80;1;20$\
					 1101;LP;0;50;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::TopEdgeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pDilSiz,VARIANT* pHClipSize,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;      // 0
	int DilSiz = (int)pDilSiz->fltVal;          // 20
	int HClipSize = (int)pHClipSize->fltVal;    // 10
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	
	if ((m_TopDownEdgeRow.Num() != 1) || ( m_TopEdgeRow.Num() != 1))
	{
		Hobject newRgn;
	    m_vRgn[id] = newRgn;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		
		HTuple MoveSizeOri;
		Hobject TopBaseLine = m_TopBaseLine;
		Hobject rgnTopBaseLineMoved,rgnTopBaseLineDil,TopEdgeROI;

		MoveSizeOri = (m_TopDownEdgeRow - m_TopEdgeRow)/2;
        move_region(TopBaseLine, &rgnTopBaseLineMoved, MoveSizeOri + MoveSize, 0);
        dilation_rectangle1(rgnTopBaseLineMoved, &rgnTopBaseLineDil, 1, DilSiz);
        clip_region_rel(rgnTopBaseLineDil, &TopEdgeROI, 0, 0, HClipSize, HClipSize);


		HTuple ROIarea,ROIrow,ROIcol;
		area_center(TopEdgeROI,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(TopEdgeROI, &TopEdgeROI, ErosionSize);
			m_vRgn[id] = TopEdgeROI;
			m_TopEdgeROI = TopEdgeROI;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

// 中部边缘上下区域
STDMETHODIMP CPlugAlgo::MiddleEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6030$\
					 381;B$\
					 6029;LP;1;3;1;1$\
					 6026;LP;-30;50;1;1$\
					 1100;LP;10;80;1;20$\
					 1101;LP;0;50;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::MiddleEdgeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize,VARIANT* pDilSiz,VARIANT* pHClipSize,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;      // 0
	int DilSiz = (int)pDilSiz->fltVal;          // 20
	int HClipSize = (int)pHClipSize->fltVal;    // 10
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;
	
	if ((m_BottomBaseLine.Id() == H_EMPTY_REGION)||(m_BottomEdgeRow.Num() != 1) || ( m_dRowMidMM.Num() != 1)|| ( m_dRowMidUp.Num() != 1))
	{
		Hobject newRgn;
	    m_vRgn[id] = newRgn;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		
		HTuple  MoveSizeOri;
		Hobject BottomBaseLine = m_BottomBaseLine;
		HTuple  BottomEdgeRow = m_BottomEdgeRow;
		HTuple  dRowMidMM = m_dRowMidMM;
		HTuple  dRowMidUp = m_dRowMidUp;

		Hobject rgnBaseDownEdgeMU,rgnBaseDownEdgeMUDil,MidEdgeUpROI;

		MoveSizeOri = BottomEdgeRow - dRowMidMM + (dRowMidMM - dRowMidUp)/2;

		if (Selection == 1)
		{
			// 中部边缘上区域
			move_region(BottomBaseLine, &rgnBaseDownEdgeMU, -MoveSizeOri+MoveSize, 0);
		}
		else if(Selection == 2)
		{
			// 中部边缘下区域
			move_region(BottomBaseLine, &rgnBaseDownEdgeMU, -MoveSizeOri+MoveSize+17, 0);
		}
		else if (Selection == 3)
		{
			// 中部上边缘拐角区域
			move_region(BottomBaseLine, &rgnBaseDownEdgeMU, -MoveSizeOri+MoveSize-8, 0);
		}
        dilation_rectangle1(rgnBaseDownEdgeMU, &rgnBaseDownEdgeMUDil, 1, DilSiz);
        clip_region_rel(rgnBaseDownEdgeMUDil, &MidEdgeUpROI, 0, 0, HClipSize, HClipSize);

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(MidEdgeUpROI,&ROIarea, &ROIrow, &ROIcol);
		if (0 != (ROIarea!=0))
		{	
			erosion_circle(MidEdgeUpROI, &MidEdgeUpROI, ErosionSize);
			m_vRgn[id] = MidEdgeUpROI;
			if (Selection == 1)
			{
				m_MidEdgeUpROI = MidEdgeUpROI;
			}
			else if (Selection == 2)
			{
				m_MidEdgeDownROI = MidEdgeUpROI;
			}
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

// 颈部上下区域定位
STDMETHODIMP CPlugAlgo::MiddleRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6031$\
					 381;B$\
					 6099;LP;1;2;1;1$\
					 6026;LP;-30;50;1;1$\
					 1100;LP;10;80;1;20$\
					 1101;LP;0;50;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::MiddleRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize,VARIANT* pDilSiz,VARIANT* pHClipSize,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;      // 0
	int DilSiz = (int)pDilSiz->fltVal;          // 20
	int HClipSize = (int)pHClipSize->fltVal;    // 10
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;  
	
	if ((m_TopEdgeROI.Id() == H_EMPTY_REGION)||(m_TopBaseLine.Id() == H_EMPTY_REGION)||(m_BottomBaseLine.Id() == H_EMPTY_REGION)||(m_BottomEdgeRow.Num() != 1) || ( m_TopEdgeRow.Num() != 1)|| ( m_dRowMidUp.Num() != 1))
		//||(m_MidEdgeUpROI.Id() == H_EMPTY_REGION)||(m_MidEdgeDownROI == H_EMPTY_REGION))
	{
		Hobject newRgn;
	    m_vRgn[id] = newRgn;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		
		Hobject BottomBaseLine = m_BottomBaseLine;
		Hobject TopBaseLine = m_TopBaseLine;
		HTuple  BottomEdgeRow = m_BottomEdgeRow;
		HTuple  TopEdgeRow = m_TopEdgeRow;
		HTuple  dRowMidUp = m_dRowMidUp;
		HTuple  dRowCenterDM = m_dRowCenterDM;  
		HTuple  dRowCenterDU = m_dRowCenterDU;

		Hobject rgnBaseDownEdgeMU,rgnBaseDownEdgeMUDil,MidUpROI;

		if (Selection == 1)
		{
			// 颈部上区域
		   HTuple  MoveSizeOri;
		   MoveSizeOri = (dRowMidUp -TopEdgeRow)/2;
		   move_region(TopBaseLine, &rgnBaseDownEdgeMU,MoveSizeOri+MoveSize, 0);
		   dilation_rectangle1(rgnBaseDownEdgeMU, &rgnBaseDownEdgeMUDil, 1, DilSiz+MoveSizeOri);
           clip_region_rel(rgnBaseDownEdgeMUDil, &MidUpROI, 0, 0, HClipSize, HClipSize);
		 
		   Hobject TopEdgeROIDil,MidEdgeUPROIDil;
		   dilation_rectangle1(m_TopEdgeROI, &TopEdgeROIDil, 1, 1);
		   difference(MidUpROI, TopEdgeROIDil,& MidUpROI);
		   dilation_rectangle1(m_MidEdgeUpROI, &MidEdgeUPROIDil, 1, 1);
		   difference(MidUpROI, MidEdgeUPROIDil, &MidUpROI);
		   connection(MidUpROI,&MidUpROI);

		   select_shape_std(MidUpROI,&MidUpROI,"max_area",70);

		}
		else if(Selection == 2)
		{
			// 颈部下区域
			HTuple  MoveSizeOri;
			MoveSizeOri = (dRowCenterDU -BottomEdgeRow);
			move_region(BottomBaseLine, &rgnBaseDownEdgeMU, MoveSizeOri+MoveSize-20, 0);
			dilation_rectangle1(rgnBaseDownEdgeMU, &rgnBaseDownEdgeMUDil, 1, DilSiz+20);
			clip_region_rel(rgnBaseDownEdgeMUDil, &MidUpROI, 0, 0, HClipSize, HClipSize);

			Hobject DownROIUpDil,MidEdgeDownROIDil;
			dilation_rectangle1(m_DownEdgeUpROI, &DownROIUpDil, 2, 2);
			dilation_rectangle1(m_MidEdgeDownROI, &MidEdgeDownROIDil,4, 2);
			difference(MidUpROI, DownROIUpDil, &MidUpROI);
			difference(MidUpROI, MidEdgeDownROIDil, &MidUpROI) ;  
			connection(MidUpROI,&MidUpROI);

			select_shape_std(MidUpROI,&MidUpROI,"max_area",70);
		}

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(MidUpROI,&ROIarea, &ROIrow, &ROIcol);
		if (0 != (ROIarea!=0))
		{	
			erosion_circle(MidUpROI, &MidUpROI, ErosionSize);
			m_vRgn[id] = MidUpROI;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
/****************************************************************************************
*算子名：LineDetectFromBaseDownAlgo
*功  能：根据底部基准线提取其它边缘
*说  明：pSelecttion控制提取的基准线：1：下部上边缘线提取；2：下部中心边缘提取
****************************************************************************************/
STDMETHODIMP CPlugAlgo::LineDetectFromBaseDownAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6032$\
					 397;R;LP;0;1000;1$\
					 381;B$\
					 6033;LP;1;2;1;1$\
					 6026;LP;10;180;1;45$\
					 1100;LP;10;80;1;15$\
					 1101;LP;0;50;1;10$\
					 1099;LP;1;60;1;10");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::LineDetectFromBaseDownAlgo(VARIANT* rgnId, VARIANT* pSelecttion,VARIANT* pMoveSize,VARIANT* pDilSize,VARIANT* pHClipSize,VARIANT* pThreshold,VARIANT* pEdgeLineArea)
{
	int rId = (int)rgnId->fltVal;
	m_vErrorRgn[rId].Reset();
	Hobject rgn = m_vRgn[rId];
	CComVariant retValue;

	union1(rgn,&rgn);
	HTuple area,row,col;
	area_center(rgn,&area,&row,&col);
	if(rgn.Id() == H_EMPTY_REGION||area.Num()==0||area==0||(m_BottomBaseLine.Id() == H_EMPTY_REGION))
	{
		retValue=0.0;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeLineArea);
		return S_FALSE;
	}

	int MoveSize = (int)pMoveSize->fltVal;     // 60
	int DilSize = (int)pDilSize->fltVal;       //15
	int Threshold = (int)pThreshold->fltVal;   //8
	int HClipSize = (int)pHClipSize->fltVal; // 10
	int Selecttion = (int)pSelecttion->fltVal; // 1-2

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject BottomBaseLine = m_BottomBaseLine;
		Hobject Image = m_crtImg;
		Hobject rgnBottomBaseLineMoved,rgnBottomBaseLineDil;

		move_region(BottomBaseLine, &rgnBottomBaseLineMoved, -MoveSize, 0);
		dilation_rectangle1(rgnBottomBaseLineMoved, &rgnBottomBaseLineDil, 1, DilSize);

		clip_region_rel(rgnBottomBaseLineDil,&rgnBottomBaseLineDil,0,0,HClipSize,HClipSize);

		intersection(rgnBottomBaseLineDil,m_ROI,&rgnBottomBaseLineDil);

		HTuple DefinedRow,DefinedCol;
		if ( Selecttion == 1 )
		{
			// 下部上边缘
			R_EdgePointsFitCurve(rgnBottomBaseLineDil, Image, 5, 2, Threshold,"negative", "last", &DefinedRow, &DefinedCol);
		}
		else if(Selecttion == 2 )
		{
			// 下部中心边缘
		    R_EdgePointsFitCurve(rgnBottomBaseLineDil, Image, 5, 2, Threshold,"positive", "last", &DefinedRow, &DefinedCol);
		}
		
		if (DefinedRow.Num()< 10)
		{
			P_EdgePointsFitCurve(rgnBottomBaseLineDil, Image, 5, 30, 2, &DefinedRow, &DefinedCol);
		}
	
		if (DefinedRow.Num()< 5)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pEdgeLineArea);
			return S_FALSE;
		}

		Hobject Region,Contour,SmoothedContours,rgnEdge,EdgeClipped;
		HTuple dRow,dCol;
		gen_region_points(&Region, DefinedRow, DefinedCol);
		gen_contour_nurbs_xld(&Contour, DefinedRow, DefinedCol, "auto", "auto", 3, 1, 5);
		smooth_contours_xld(Contour, &SmoothedContours, 15);

		if(m_bDebugImg)
		{
			Hobject cross;
			gen_cross_contour_xld(&cross,DefinedRow, DefinedCol,2, 0.785398);
			gen_region_contour_xld(cross,&cross,"margin");
			concat_obj (m_vRgn[rId], cross, &m_vRgn[rId]);
			concat_obj (m_vRgn[rId], rgnBottomBaseLineDil, &m_vRgn[rId]);
		}
		get_contour_xld(SmoothedContours, &dRow, &dCol);
		gen_region_polygon(&rgnEdge, dRow, dCol);

		clip_region_rel(rgnEdge, &EdgeClipped, 0, 0, 10, 10);

		HTuple EdgeArea, EdgeRow, EdgeCol;
		area_center(EdgeClipped, &EdgeArea, &EdgeRow, &EdgeCol);

		if(EdgeArea > 1)
		{
			retValue = EdgeArea[0].I();
			m_vErrorRgn[rId] = EdgeClipped;
			if (Selecttion == 1)
			{
				// 下部上边缘
				m_dRowCenterDU  = EdgeRow;
			}
			else if (Selecttion == 2)
			{
				// 下部中心边缘
				m_dRowCenterDM = EdgeRow;
			}
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pEdgeLineArea);


#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue =-1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeLineArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pEdgeLineArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}

// 下部边缘上下区域
STDMETHODIMP CPlugAlgo::DownEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6035$\
					 381;B$\
					 6036;LP;1;3;1;1$\
					 6026;LP;-30;50;1;1$\
					 1100;LP;10;80;1;20$\
					 1101;LP;0;50;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::DownEdgeRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pMoveSize,VARIANT* pDilSiz,VARIANT* pHClipSize,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;      // 0
	int DilSiz = (int)pDilSiz->fltVal;          // 20
	int HClipSize = (int)pHClipSize->fltVal;    // 10
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if ((m_BottomBaseLine.Id() == H_EMPTY_REGION)||(m_BottomEdgeRow.Num() != 1) || ( m_dRowCenterDU.Num() != 1)|| ( m_dRowCenterDM.Num() != 1))
	{
		Hobject newRgn;
		m_vRgn[id] = newRgn;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		HTuple  MoveSizeOri;
		Hobject BottomBaseLine = m_BottomBaseLine;
		HTuple  BottomEdgeRow = m_BottomEdgeRow;
		HTuple  dRowCenterDU = m_dRowCenterDU;
		HTuple  dRowCenterDM = m_dRowCenterDM;

		Hobject rgnBaseDownEdgeDU,rgnBaseDownEdgeDUDil,DownEdgeUpROI;

		MoveSizeOri =dRowCenterDM - BottomEdgeRow + (dRowCenterDU - dRowCenterDM)/2;

		if (Selection == 1)
		{
			// 下部边缘上区域
			move_region(BottomBaseLine, &rgnBaseDownEdgeDU, MoveSizeOri+MoveSize, 0);
		}
		else if(Selection == 2)
		{
			// 下部边缘下区域
			move_region(BottomBaseLine, &rgnBaseDownEdgeDU, MoveSizeOri+MoveSize+17, 0);
		}
		else if (Selection == 3)
		{
			// 下部边缘上拐角区域
            move_region(BottomBaseLine, &rgnBaseDownEdgeDU, MoveSizeOri+MoveSize-8, 0);
		}

		dilation_rectangle1(rgnBaseDownEdgeDU, &rgnBaseDownEdgeDUDil, 1, DilSiz);
		clip_region_rel(rgnBaseDownEdgeDUDil, &DownEdgeUpROI, 0, 0, HClipSize, HClipSize);

		HTuple ROIarea,ROIrow,ROIcol;
		area_center(DownEdgeUpROI,&ROIarea, &ROIrow, &ROIcol);
		if (0 != (ROIarea!=0))
		{	
			erosion_circle(DownEdgeUpROI, &DownEdgeUpROI, ErosionSize);
			m_vRgn[id] = DownEdgeUpROI;
			if (Selection == 1)
			{
				m_DownEdgeUpROI = DownEdgeUpROI;
			}
			else if (Selection == 2)
			{
				m_DownEdgeDownROI = DownEdgeUpROI;
			}
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

// 底部区域定位
STDMETHODIMP CPlugAlgo::BottomRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6037$\
					 381;B$\
					 6021;LP;-30;50;1;25$\
					 1101;LP;0;50;1;10$\
					 443;FP;1;20.5;0.5;2.0");

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::BottomRegionLocationAlgo(VARIANT* rgnId, VARIANT* pMoveSize,VARIANT* pHClipSize,VARIANT* pErosionSize)
{
	int id = (int)rgnId->fltVal;
	int MoveSize = (int)pMoveSize->fltVal;      // 0
	int HClipSize = (int)pHClipSize->fltVal;    // 10
	float ErosionSize = (float)pErosionSize->fltVal;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	if ((m_TopDownEdgeRow.Num() != 1) || ( m_ROI.Id() == H_EMPTY_REGION))
	{
		Hobject newRgn;
		m_vRgn[id] = newRgn;
	}

	Hobject ROI = m_ROI;
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}

		HTuple MoveSizeOri;
		Hobject ROIMoved,ROIMovedDil,DownROI;

		Hobject ROIDif,ROIDifOpn,ROIDifCon;
		move_region(ROI,&ROIMoved,-MoveSize,0);
		difference(ROI, ROIMoved, &ROIDif);
		opening_circle(ROIDif, &ROIDifOpn, 1.5);
		connection(ROIDifOpn, &ROIDifCon);
		select_shape_std(ROIDifCon, &DownROI, "max_area", 70);
		clip_region_rel(DownROI, &DownROI, 0, 0, HClipSize, HClipSize);


		HTuple ROIarea,ROIrow,ROIcol;
		area_center(DownROI,&ROIarea,&ROIrow,&ROIcol);
		if (0 != (ROIarea!=0))
		{	
			Hobject ROI;
			erosion_circle(DownROI, &DownROI, ErosionSize);
			m_vRgn[id] = DownROI;
		}
		else
		{
			Hobject Circle,newRgn;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			m_vRgn[id]=newRgn;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

//整体区域（针对螺旋状胶塞）
STDMETHODIMP CPlugAlgo::WholeRegionLocationForHelixAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6038$\
					 167;B$\
					 6105;LP;1;2;1;1$\
					 1063;LP;1;45;1;12");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::WholeRegionLocationForHelixAlgo(VARIANT* rgnId,VARIANT* pSelection, VARIANT* pErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Selection     = (int)pSelection->fltVal;
	int ErosionSize   = (int)pErosionSize->fltVal;

	//int ABHErosionSize   = (int)pABHErosionSize->fltVal;
	//int ABVErosionSize   = (int)pABVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_WholeRoi.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TotallRoi,WholeRoiCls,WholeRoiDif,WholeRoiCon;
		closing_circle(m_WholeRoi,&WholeRoiCls,5);

		Hobject rgnTop,WholeRoiOpn;
		gen_empty_obj(&rgnTop);
		if ( Selection == 2)
		{
			concat_obj(rgnTop,m_rgnSideTop,&rgnTop);
			//rgnTop = m_rgnSideTop;
			union1(rgnTop,&rgnTop);
		}
		else
			gen_empty_obj(&rgnTop);

		difference(WholeRoiCls,rgnTop,&WholeRoiDif);
		opening_circle(WholeRoiDif,&WholeRoiOpn,3.5);
		connection(WholeRoiOpn,&WholeRoiCon );

		//union1(WholeRoiCls,&TotallRoi);
		select_shape_std(WholeRoiCon,&TotallRoi,"max_area",70);
		erosion_circle(TotallRoi,&TotallRoi, ErosionSize);
		union1(TotallRoi,&TotallRoi);
		m_vRgn[rId] = TotallRoi ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
// =========================== end ================================================================================================

/**********************************************************************************
** 函 数 名：T20_TopCircleLocationAlgo
** 功    能：针对瑞德一种双叉裸塞在顶部和叉口区域存在小圆，对此圆定位（4个）
** 注意事项：（1）该算子主要给顶部高亮区域、叉口区域、叉口整体区域传递定位的小圆区域
**                定义的传参变量为：m_rgnTopFourCircle
************************************************************************************/
STDMETHODIMP CPlugAlgo::T20_TopCircleLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5500$\
					 167;B$\
					 5501;LP;1;350;1;145$\
					 5502;LP;1;350;1;35$\
					 5503;LP;1;70;1;15$\
					 5504;FP;-10;10;0.5;0$\
					 5505;FP;1;50;0.5;3.5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::T20_TopCircleLocationAlgo(VARIANT* rgnId, VARIANT* pCircleOuter, VARIANT* pCircleWidth,VARIANT*pSmalCircleR,VARIANT*pAngleAdjust,VARIANT* pScaleSize)
{
	int rId           = (int)rgnId->fltVal;
	int dCircleOuter   = (int)pCircleOuter->fltVal;
	int dCircleWidth   = (int)pCircleWidth->fltVal;
	int dSmalCircleR   = (int)pSmalCircleR->fltVal;
	HTuple  dCircleInner;
	dCircleInner = abs(dCircleOuter - dCircleWidth) ;               // 35
	float dAngleAdjust =(float)pAngleAdjust->fltVal;
	float dScaleSize =(float)pScaleSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	HTuple dCenterRow,dCenterCol;
	dCenterRow = m_vPos[0].m_y;
	dCenterCol = m_vPos[0].m_x;

	if(dCenterRow.Num() != 1 || dCenterCol.Num() != 1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject rgnCircleOuter,rgnCircleInner,rgnToSearch;
		if ( dCircleWidth > dCircleOuter)
		{
			gen_circle(&rgnCircleOuter, dCenterRow, dCenterCol, dCircleOuter);
			//gen_circle(&rgnCircleOuter, dCenterRow, dCenterCol, dCircleInner);
			gen_empty_region(&rgnCircleInner);
		}
		else if(dCircleOuter > dCircleWidth )
		{
			gen_circle(&rgnCircleOuter, dCenterRow, dCenterCol, dCircleOuter);
			gen_circle(&rgnCircleInner, dCenterRow, dCenterCol, dCircleInner);
		}
		else
		{
			gen_circle(&rgnCircleOuter, dCenterRow, dCenterCol, dCircleOuter);
			gen_circle(&rgnCircleInner, dCenterRow, dCenterCol, 0.5);
		}
		
		difference(rgnCircleOuter, rgnCircleInner, &rgnToSearch);

		HTuple Angle;
		Angle = m_modelAngle ; 
		Hobject rgnRectH,rgnRectV,rgnUnion,rgnCircleOri;
		gen_rectangle2(&rgnRectH, dCenterRow, dCenterCol, Angle + ((HTuple)dAngleAdjust).Rad(), 210+10, dSmalCircleR);
		gen_rectangle2(&rgnRectV, dCenterRow, dCenterCol, Angle + ((HTuple)dAngleAdjust).Rad() + HTuple(90).Rad(), 210+10, dSmalCircleR);
		union2(rgnRectV, rgnRectH, &rgnUnion);
		intersection(rgnToSearch, rgnUnion, &rgnCircleOri);

		Hobject rgnCircleOriCon,rgnCircleTrans,rgnCircles;
		connection(rgnCircleOri, &rgnCircleOriCon);
		shape_trans(rgnCircleOriCon, &rgnCircleTrans, "inner_circle");
		union1(rgnCircleTrans, &rgnCircles);

		if (0 != (dScaleSize>0))
		{
			dilation_circle(rgnCircles, &rgnCircles, dScaleSize);
		}
		else if (0 != (dScaleSize==0))
		{
			dilation_circle(rgnCircles, &rgnCircles, 0.5);
		}
		else if (0 != (dScaleSize<0))
		{
			erosion_circle(rgnCircles, &rgnCircles, dScaleSize);
		}

		m_TopFourCircles = rgnCircles;
		m_vRgn[rId] = rgnCircles ;

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}

/*============================================================================================================
*************************************一种新三叉胶塞定位算法***************************************************
*=============================================================================================================/

/*****************************************************************************************************
** 函数名：D20N_SideTopRegAngleDetectAlgo
** 功  能：针对一种新三叉胶塞的顶部叉口角度进行定位
** 时  间：2019年12月4日
******************************************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_SideTopRegAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6212$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 988;LP;0;360;1;175$\
					 5531;FP;-100;250;0.5;20.0$\
					 5533;LP;1;5000;1;700");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_SideTopRegAngleDetectAlgo(VARIANT* rgnId, VARIANT* pMoveSize, VARIANT* pThredLower, VARIANT* pAreaLimitLower,VARIANT* pLineAngle)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize      = (int)pMoveSize->fltVal;        // 260
	double ThredLower   = (double)pThredLower->fltVal; // 20
	int AreaLimitLower=(int)pAreaLimitLower->fltVal;          // 700

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//
		Hobject crtImg = m_crtImg;
		Hobject ABsearchImage;
		reduce_domain(crtImg, rgn, &ABsearchImage);
		//
		HTuple Area, ContEllipseTransRow, ContEllipseTransCol;
		Hobject TopEllipse;
		area_center(rgn, &Area, &ContEllipseTransRow, &ContEllipseTransCol);
		//基准椭圆
		m_ContEllipse=rgn;
		move_region(rgn, &TopEllipse, -MoveSize, 0);
		Hobject Aroi,AroiClosing,ImageReducedAroi;
		intersection(TopEllipse, m_ROI, &Aroi);
		closing_circle(Aroi, &AroiClosing, 3.5);
		reduce_domain(crtImg, AroiClosing, &ImageReducedAroi);

		//get the whole top region （顶部整体区域）
		Hobject ImageReducedAroiScaled;
		scale_image_max(ImageReducedAroi,&ImageReducedAroiScaled);
		HTuple Mean,Deviation;
		intensity(AroiClosing,ImageReducedAroiScaled,&Mean,&Deviation);
		if (Mean.Num()!=1)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}	
		if(Mean[0].D()+ThredLower>=255.0)
		{
			ThredLower=254.0-Mean[0].D();
		}
		if ( Mean[0].D()+ThredLower<= 0)
		{
			ThredLower = 0;
		}

		Hobject TopWholeRgnThr,TopWholeRgnFil;
		threshold(ImageReducedAroiScaled, &TopWholeRgnThr, Mean+ThredLower, 255);
		fill_up(TopWholeRgnThr,&TopWholeRgnFil);
		Hobject TopWholeRgnOpn,TopWholeRgnCls,TopWholeRgnCon,TopWholeRgn;
		opening_circle(TopWholeRgnFil, &TopWholeRgnOpn, 3.5);
		//closing_circle(TopWholeRgnOpn, &TopWholeRgnCls, 10);
		connection(TopWholeRgnOpn, &TopWholeRgnCon);
		select_shape_std(TopWholeRgnCon, &TopWholeRgn, "max_area", 70);

		//* get the top region（顶部高亮区域）
		HTuple Thred;
		Thred = Mean + ThredLower + 80;

		if(Thred >=255.0)
		{
			Thred=254.0-Mean[0].D();
		}
		if ( Thred <= 0)
		{
			Thred = 0;
		}
		Hobject TopRegions,TopRegionsFillUp,TopRegionOpening,TopRegionClosing,TopRegionConnected;
		threshold(ImageReducedAroiScaled, &TopRegions, Thred, 255);
		fill_up(TopRegions, &TopRegionsFillUp);
		opening_circle(TopRegionsFillUp, &TopRegionOpening, 3.5);
		closing_circle(TopRegionOpening, &TopRegionClosing, 10);
		connection(TopRegionClosing, &TopRegionConnected);

		Hobject  TopRegionSelected,TopRegionGravity;
		HTuple TopCenTerArea, TopCenTerRow, TopCenTerCol;
		select_shape_std(TopRegionConnected, &TopRegionSelected, "max_area", 70);
		shape_trans(TopRegionSelected, &TopRegionGravity, "inner_center");
		area_center(TopRegionGravity, &TopCenTerArea, &TopCenTerRow, &TopCenTerCol);
		if ( TopCenTerArea[0].D() <= 0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;

		}

		//* get the middle part center
		//* firstly,select the second and third row sorted region
		//* Secondly,sort the selected region in column to get left and right region
		Hobject  rgnTopTrans,rgnTopBlackOri,rgnTopBlackOriOpn,rgnTopBlackOriCon,rgnTopBlackOriSel ;
		HTuple  NumTopBlack;
		shape_trans(TopRegionSelected, &rgnTopTrans, "convex");
		difference(rgnTopTrans, TopRegionSelected, &rgnTopBlackOri);
		opening_circle(rgnTopBlackOri, &rgnTopBlackOriOpn, 1.5);
		connection(rgnTopBlackOriOpn, &rgnTopBlackOriCon);
		select_shape(rgnTopBlackOriCon, &rgnTopBlackOriSel, "area", "and", AreaLimitLower, 9999999);
		count_obj(rgnTopBlackOriSel, &NumTopBlack);
		if (NumTopBlack!=3)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}
		HTuple dAreaTopBlack, dRowTopBlack,dColTopBlack,IndexTopSort;
		Hobject  objSel1,objSel2,rgnTopBlackSel,rgnTopBlackSelCon,rgnTopBlackSelSort ;
		area_center(rgnTopBlackOriSel, &dAreaTopBlack, &dRowTopBlack, &dColTopBlack);
		tuple_sort_index(dRowTopBlack, &IndexTopSort);
		select_obj(rgnTopBlackOriSel, &objSel1, (IndexTopSort.Select(1))+1);
		select_obj(rgnTopBlackOriSel, &objSel2, (IndexTopSort.Select(2))+1);
		union2(objSel2, objSel1, &rgnTopBlackSel);

		 //* thirdly,get the points whose row is biggest of the two region in each other
		HTuple dLowPointRowL,dLowPointColL,dLowPointRowR,dLowPointColR ;
		Hobject rgnTopBlackL,rgnTopBlackR ;
		dLowPointRowL = HTuple();
		dLowPointColL = HTuple();
		dLowPointRowR = HTuple();
		dLowPointColR = HTuple();
		gen_empty_obj(&rgnTopBlackL);
		gen_empty_obj(&rgnTopBlackR);
		concat_obj(rgnTopBlackL, objSel1, &rgnTopBlackL);
		concat_obj(rgnTopBlackR, objSel2, &rgnTopBlackR);

		Hobject xldTopBlackL ;
		HTuple dRowSL,dColSL,dRowMaxL,IndicesL,iLengthL  ;
		gen_contour_region_xld(rgnTopBlackL, &xldTopBlackL, "border");
		get_contour_xld(xldTopBlackL, &dRowSL, &dColSL);
		tuple_max(dRowSL, &dRowMaxL);
		tuple_find(dRowSL, dRowMaxL, &IndicesL);
		tuple_length(IndicesL, &iLengthL);
		dLowPointRowL = dRowSL.Select(IndicesL.Select(0));
		dLowPointColL = dColSL.Select(IndicesL.Select(0));

		HTuple dAreaMid,dRowMid,dColMid ;
		area_center(objSel1, &dAreaMid, &dRowMid, &dColMid);
		if (dColMid > TopCenTerCol )
		{
			// 选择的第一个黑色区域在顶部中心右边
			Hobject xldTopBlackR;
			HTuple dRowSR,dColSR,dRowMaxR,IndicesR,iLengthR,dColMaxR ;
			gen_contour_region_xld(rgnTopBlackR, &xldTopBlackR, "border");
			get_contour_xld(xldTopBlackR, &dRowSR, &dColSR);
			tuple_max(dColSR, &dColMaxR);
			tuple_find(dColSR, dColMaxR, &IndicesR);
			tuple_length(IndicesR, &iLengthR);
			dLowPointRowR = dRowSR.Select(IndicesR.Select(iLengthR-1));
			dLowPointColR = dColSR.Select(IndicesR.Select(iLengthR-1));

		}
		else if (dColMid < TopCenTerCol )
		{
			//在顶部中心左边
			Hobject xldTopBlackR;
			HTuple dRowSR,dColSR,dRowMaxR,IndicesR,iLengthR,dColMinR ;
			gen_contour_region_xld(rgnTopBlackR, &xldTopBlackR, "border");
			get_contour_xld(xldTopBlackR, &dRowSR, &dColSR);
			tuple_min(dColSR, &dColMinR);
			tuple_find(dColSR, dColMinR, &IndicesR);
			tuple_length(IndicesR, &iLengthR);
			dLowPointRowR = dRowSR.Select(IndicesR.Select(iLengthR-1));
			dLowPointColR = dColSR.Select(IndicesR.Select(iLengthR-1));

		}
		else
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pLineAngle);
			return S_FALSE;
		}

		//* gen angle line
		HTuple dTopBarRow,dTopBarCol ;
		dTopBarRow = (dLowPointRowL+dLowPointRowR)/2.0;
		dTopBarCol = (dLowPointColL+dLowPointColR)/2.0;

		Hobject rgnAngleLine;
		HTuple  dAngle,dAngleDeg;
		gen_region_line(&rgnAngleLine, dTopBarRow, dTopBarCol, TopCenTerRow, TopCenTerCol);
		orientation_region(rgnAngleLine, &dAngle);
		if( dAngle < 0 )
			dAngle = dAngle + PI;

		m_Angle=dAngle;
		tuple_deg(dAngle, &dAngleDeg);  

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], rgnAngleLine, &m_vRgn[rId]);  
			concat_obj(m_vRgn[rId], TopRegionSelected, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], TopWholeRgn, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], Aroi, &m_vRgn[rId]);
		}

		m_TopRow=TopCenTerRow;     // 顶部区域中心
		m_TopCol=TopCenTerCol;
		m_TopRegions = TopRegionSelected; // 顶部高亮区域
		m_TopWholeRgn = TopWholeRgn;      // 顶部整体区域

		//m_FirstRow     = FirstRow;      // 选取的顶部高亮下区域中心
		//m_FirstCol     = FirstCol;
		//m_rgnTopBlack = rgnTopBlack;     // 部瓤^域
		
		// display and the parameters transfermation
		HTuple AngleLineArea,AngleLineRow,AngleLineCol;
		area_center(rgnAngleLine,&AngleLineArea,&AngleLineRow,&AngleLineCol);

		if (AngleLineArea>0)
		{
			Hobject TopAngleLineDilation;
			retValue = dAngleDeg[0].D();
			dilation_circle(rgnAngleLine, &TopAngleLineDilation, 2);
			m_vErrorRgn[rId] = TopAngleLineDilation;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
			//
			m_TopRow=0;
			m_TopCol=0;
		}
		retValue.Detach(pLineAngle);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pLineAngle);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/*****************************************************************************************************
** 函数名：SidePlatformRegionLocationAlgo2
** 功  能：对带叉口胶塞的叉口平台区域进行定位
** 时  间：2019年12月4日
******************************************************************************************************/
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgo2(VARIANT* rgnId,VARIANT* pUpEdgeSize,VARIANT* pABEdgeMov,VARIANT* pThredLow,VARIANT* pClosingSize,VARIANT* pAreaSize, VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId            = (int)rgnId->fltVal;
	int UpEdgeSize     = (int)pUpEdgeSize->fltVal;              // 20
	int ABEdgeMov      = (int)pABEdgeMov->fltVal;                // 60
	int ThredLow       =  (int)pThredLow->fltVal;                // 10
	float ClosingSize  = (float)pClosingSize->fltVal;
	int AreaSize       = (int)pAreaSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if((m_Platform.Id()== H_EMPTY_REGION))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		//二次提取
		Hobject rgnPlatformDil,GrayImage,imgPlatformDil,rgnPlatFormOri,rgnPlatFormOriFil,rgnPlatFormOriOpn;
		Hobject rgnPlatFormOriCon,rgnMoved ;
		HTuple Mean, Deviation,iNum ;
		GrayImage = m_crtImg;

		move_region(m_Platform,&rgnMoved, -UpEdgeSize,0);
		//move_region(m_Platform,&rgnMoved,-20,0 );

		dilation_rectangle1(rgnMoved, &rgnPlatformDil, 30, 60);
		reduce_domain(GrayImage, rgnPlatformDil, &imgPlatformDil);
		intensity(rgnPlatformDil, GrayImage, &Mean, &Deviation);
		threshold(imgPlatformDil, &rgnPlatFormOri, Mean-ThredLow, 255);
		fill_up(rgnPlatFormOri, &rgnPlatFormOriFil);
		opening_circle(rgnPlatFormOriFil, &rgnPlatFormOriOpn, ClosingSize);
		/*connection(rgnPlatFormOriOpn, &rgnPlatFormOriCon);
		count_obj(rgnPlatFormOriCon, &iNum);*/

		//基准线限制筛选
		Hobject rgnPlatForm,rgnABEdgeMove,rgnABEdgeDil;
		HTuple dDilSize;
		gen_empty_obj(&rgnPlatForm);
		dDilSize =ABEdgeMov/2.0;
		move_region(m_ABEdge, &rgnABEdgeMove, -dDilSize, 0);
		dilation_rectangle1(rgnABEdgeMove,&rgnABEdgeDil,1,ABEdgeMov);
		difference(rgnPlatFormOriOpn,rgnABEdgeDil,&rgnPlatForm);

		HTuple dRow1,dCol1,dRow2,dCol2;
		Hobject rgnRect,rgnRectMov;
		smallest_rectangle1(rgnABEdgeDil, &dRow1,&dCol1,&dRow2,&dCol2);
		gen_rectangle1(&rgnRect,dRow1,dCol1,dRow2,dCol2);
		move_region(rgnRect,&rgnRectMov,-ABEdgeMov,0);
		intersection(rgnPlatForm,rgnRectMov,&rgnPlatForm);
		
		Hobject rgnPlatFormCon,rgnPlatFormSel;
		connection(rgnPlatForm,&rgnPlatFormCon);
		select_shape(rgnPlatFormCon,&rgnPlatFormSel,"area","and",AreaSize,9999999 );

		union1(rgnPlatFormSel, &rgnPlatForm);

		m_rgnPlatForm = rgnPlatForm;

		Hobject PlatformDetectReg,PlatformDetectRegClosing;
		closing_circle(rgnPlatForm,&PlatformDetectRegClosing, ClosingSize);
		//水平垂直缩放
		erosion_rectangle1(PlatformDetectRegClosing,&PlatformDetectReg,HErosionSize,VErosionSize);
		
		m_vRgn[rId] = PlatformDetectReg ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SidePlatformRegionLocationAlgo2Help(BSTR* pHelpStr)
{
	CComBSTR strHelp("6229$\
					 167;B$\
					 6215;LP;1;80;1;20$\
					 6082;LP;1;150;1;60$\
					 6083;LP;-50;50;1;10$\
					 1061;FP;1;20;0.5;10$\
					 6005;LP;1;20000;1;500$\
					 994;LP;1;35;1;5$\
					 995;LP;1;35;1;5");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*****************************************************************************************************
** 函数名：SidePlatformTopEdgeRegionLocationAlgo
** 功  能：叉口上边缘区域定位
** 时  间：2019年12月12日
******************************************************************************************************/
STDMETHODIMP CPlugAlgo::SidePlatformTopEdgeRegionLocationAlgo(VARIANT* rgnId,VARIANT* pLengthSel, VARIANT* pOuterSize,VARIANT* pMoveSize,VARIANT* pHClipSize, VARIANT* pVDilSize)
{
	int rId           = (int)rgnId->fltVal;
	int LengthSel     = (int)pLengthSel->fltVal;        // 120
	float OuterSize   = (float)pOuterSize->fltVal;   // 5.5
	int MoveSize      = (int)pMoveSize->fltVal;        // 0
	int HClipSize     = (int)pHClipSize->fltVal;      // 5
	int VDilSize      = (int)pVDilSize->fltVal;        // 10
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	HTuple dArea1;
	region_features(m_rgnPlatForm,"area",&dArea1);
	if(dArea1 < 1)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	Hobject rgnPlatForm = m_rgnPlatForm;

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject  rgnPlatformCon,rgnPlatforMax;
		HTuple dAreaPlatform,dRowPlatform,dColPlatform ,Ratio ;
		connection(rgnPlatForm, &rgnPlatformCon);
		area_center(rgnPlatformCon, &dAreaPlatform, &dRowPlatform, &dColPlatform);
		gen_empty_obj(&rgnPlatforMax);
		if ((dRowPlatform.Num())==2)
		{

			if ( (dAreaPlatform.Select(0))==(dAreaPlatform.Select(1)))
			{
				Ratio = 1;
			}
			else
			{
				HTuple  dAreaPlatformMax,dAreaPlatformMin;
				tuple_max(dAreaPlatform, &dAreaPlatformMax);
				tuple_min(dAreaPlatform, &dAreaPlatformMin);

				Ratio = dAreaPlatformMin/(dAreaPlatformMax*1.0);
			}

			if (0 != (Ratio<0.6))
			{
				select_shape_std(rgnPlatformCon, &rgnPlatforMax, "max_area", 70);
			}
			else
			{
				concat_obj(rgnPlatformCon, rgnPlatforMax, &rgnPlatforMax);
			}
		}
		else
		{
			select_shape_std(rgnPlatformCon, &rgnPlatforMax, "max_area", 70);
		}

		Hobject rgnPlatforMaxUp,rgnPlatforMaxDown,rgnUpEdgeOri,rgnRoiEro ;
		move_region(rgnPlatforMax, &rgnPlatforMaxUp, -1, 0);
		move_region(rgnPlatforMax, &rgnPlatforMaxDown, 1, 0);
		difference(rgnPlatforMaxUp, rgnPlatforMaxDown, &rgnUpEdgeOri);

		erosion_circle(m_ROI, &rgnRoiEro, OuterSize);
		intersection(rgnRoiEro, rgnUpEdgeOri, &rgnUpEdgeOri);

		Hobject  rgnUpEdgeOriCon,rgnUpEdge;
		connection(rgnUpEdgeOri, &rgnUpEdgeOriCon);
		select_shape(rgnUpEdgeOriCon, &rgnUpEdge, "contlength", "and", LengthSel, 9999999);
		clip_region_rel(rgnUpEdge, &rgnUpEdge, 0, 0, HClipSize, HClipSize);
		dilation_rectangle1(rgnUpEdge, &rgnUpEdge, 1, VDilSize);
		move_region(rgnUpEdge,&rgnUpEdge,MoveSize,0 );
		
		m_vRgn[rId] = rgnUpEdge ;	

#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::SidePlatformTopEdgeRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6230$\
					 167;B$\
					 6232;LP;10;1000;1;120$\
					 5515;FP;1;30;0.5;5.5$\
					 5008;LP;-20;35;1;0$\
					 5512;LP;1;50;1;5$\
					 6231;LP;1;50;1;10");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}

void CPlugAlgo::RemoveSpecialAngleRegion (Hobject rgnInput, Hobject *rgnOutPut,HTuple dAngleStart, HTuple dAngleEnd)
{

	  // Local iconic variables 
	  Hobject  rgnInputCon, objSel;

	  // Local control variables 
	  HTuple  NumRgn, i, Ra, Rb, Phi;
	  HTuple  dDeg;

	  //*筛除区域中的某些特定角度区域

	  connection(rgnInput, &rgnInputCon);
	  count_obj(rgnInputCon, &NumRgn);
	  gen_empty_obj(&(*rgnOutPut));

	  if (NumRgn<=0)
	  {
		return;
	  }

	  HTuple end_val12 = NumRgn;
	  HTuple step_val12 = 1;
	  for (int i=1; i <= NumRgn; i ++)
	  {
		select_obj(rgnInputCon, &objSel, i);
		elliptic_axis(objSel, &Ra, &Rb, &Phi);
		dDeg = (Phi.Deg()).Abs();
		if (0 != (HTuple(dDeg<dAngleStart).Or(dDeg>dAngleEnd)))
		{
		  concat_obj((*rgnOutPut), objSel, &(*rgnOutPut));
		}

	  }


	  return;
}
void CPlugAlgo::GetSpecialAngleRegion (Hobject rgnInput, Hobject *rgnOutPut,HTuple dAngleStart, HTuple dAngleEnd)
{

	  // Local iconic variables 
	  Hobject  rgnInputCon, objSel;

	  // Local control variables 
	  HTuple  NumRgn, i, Ra, Rb, Phi;
	  HTuple  dDeg;

	  //*筛除区域中的某些特定角度区域

	  connection(rgnInput, &rgnInputCon);
	  count_obj(rgnInputCon, &NumRgn);
	  gen_empty_obj(&(*rgnOutPut));

	  if (NumRgn<=0)
	  {
		return;
	  }

	  HTuple end_val12 = NumRgn;
	  HTuple step_val12 = 1;
	  for (int i=1; i <= NumRgn; i ++)
	  {
		select_obj(rgnInputCon, &objSel, i);
		elliptic_axis(objSel, &Ra, &Rb, &Phi);
		dDeg = (Phi.Deg()).Abs();
		if ( (dDeg>dAngleStart) && (dDeg < dAngleEnd))
		{
		  concat_obj((*rgnOutPut), objSel, &(*rgnOutPut));
		}

	  }


	  return;
}
/*********************************************************************************
** 函数名 ： D20N_StripePatternDetectAlgo
** 功  能 ： 新三叉胶塞花纹提取
** 时  间 ：2019年12月5日
**********************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_StripePatternDetectAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pHSearchSize,VARIANT* pVSearchSize,VARIANT* pWhiteThred,VARIANT* pDilationSize,VARIANT* pStripeArea)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	int SearchSize    =(int)pVSearchSize->fltVal;
	int HSearchSize    =(int)pHSearchSize->fltVal;
	double WhiteThred   = (double)pWhiteThred->fltVal;
	int DilationSize   = (int)pDilationSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if((rgn.Id() == H_EMPTY_REGION)||m_ROI.Id() == H_EMPTY_REGION||m_PlatformReg.Id()==H_EMPTY_REGION||m_ARegionT.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject crtImgReduced = m_crtImg;
		//条形花纹提取
		Hobject ABStripeReg;
		HTuple ABStripeArea, ABStripeRow, ABStripeColumn;
		move_region(m_ABEdge, &ABStripeReg, -MoveSize, 0);
		clip_region_rel(ABStripeReg,&ABStripeReg,0,0,HSearchSize,HSearchSize);

		intersection(ABStripeReg, m_ROI, &ABStripeReg);
		area_center(ABStripeReg, &ABStripeArea, &ABStripeRow, &ABStripeColumn);

		Hobject ABStripeRegDilation,ABStripeRegIntersection;
		dilation_rectangle1(ABStripeReg, &ABStripeRegDilation, 1, SearchSize);
		intersection(ABStripeRegDilation, m_ROI, &ABStripeRegIntersection);

		Hobject RegionDiffH2,StripeRegOpening,StripeSearchReg,rgnPlatform0Dil;
		dilation_rectangle1(m_Platform0,&rgnPlatform0Dil, DilationSize,DilationSize);
		difference(ABStripeRegIntersection, rgnPlatform0Dil, &RegionDiffH2);
		opening_circle(RegionDiffH2, &StripeRegOpening, 3);
		union1(StripeRegOpening, &StripeSearchReg);

		Hobject StripeRegImage;
		reduce_domain(crtImgReduced, StripeSearchReg, &StripeRegImage);
		emphasize(StripeRegImage, &StripeRegImage, 7, 7, 1);
		Hobject WhiteStripeRoi0,WhiteStripeRoi;
		threshold(StripeRegImage, &WhiteStripeRoi0, WhiteThred, 255);

		Hobject WhiteStripeRoiFillUp,WhiteRegionErosion;
		fill_up(WhiteStripeRoi0, &WhiteStripeRoiFillUp);
		Hobject WhiteStripeRoiOpening;

		//剔除小的干扰点
		Hobject ConnectedRegions2;
		connection(WhiteStripeRoiFillUp, &ConnectedRegions2);
		select_shape(ConnectedRegions2, &WhiteStripeRoi, "area", "and", 20, 999999);

		Hobject StripeRoiUnion,StripeRoiConnected,PlatformRegConnected;
		union1(WhiteStripeRoi, &StripeRoiUnion);

		if(m_bDebugImg)
		{
			Hobject ABStripeRegInterscted;
			intersection(ABStripeReg,StripeSearchReg,&ABStripeRegInterscted);
			concat_obj(m_vRgn[rId], ABStripeRegInterscted, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], StripeSearchReg, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], WhiteStripeRoi0, &m_vRgn[rId]); //用于显示阈值分割情况

			// 基准线平移之后的位置
			m_PatternEdge = ABStripeReg;

		}
		//
		HTuple Area8, Row8, Column8;
		area_center(StripeRoiUnion, &Area8, &Row8, &Column8);
		if(Area8==0)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		connection(StripeRoiUnion, &StripeRoiConnected);
		connection(m_PlatformReg, &PlatformRegConnected);
		HTuple Number1,SelectSzie;
		count_obj(PlatformRegConnected, &Number1);

		//根据平台边缘坐标剔除叉口边缘的干扰亮斑,由于存在变形，适当改小了
		SelectSzie=10;
		Hobject SortedRegions,ObjectSelected,TriangleRoiCliped,ConnectedRegions1,RegionUnion2,RegionUnionDiff;
		HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
		if (0 != (Number1==2))
		{
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected, 1);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			select_shape(StripeRoiConnected, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiUnion, RegionUnion2, &RegionUnionDiff);

			select_obj(SortedRegions, &ObjectSelected, 2);
			smallest_rectangle1(ObjectSelected, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(RegionUnionDiff, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);

			union1(TriangleRoiCliped, &RegionUnion2);
			difference(RegionUnionDiff, RegionUnion2, &WhiteStripeRoi);
		}
		else
		{
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			connection(StripeRoiConnected, &ConnectedRegions1);
			select_shape(ConnectedRegions1, &TriangleRoiCliped, "column", "and", PlatformColL-SelectSzie, PlatformColR+SelectSzie);
			union1(TriangleRoiCliped, &RegionUnion2);
			difference(StripeRoiConnected, RegionUnion2, &WhiteStripeRoi);
		}

		//排除白条下面的白点干扰,只选择基准线以上的白条区域
		Hobject ABStripePartitioned;
		HTuple ABStripePartitionedArea, ABStripeRegRows, ABStripeRegCols;
		partition_rectangle(ABStripeReg, &ABStripePartitioned, 1, 100);
		area_center(ABStripePartitioned, &ABStripePartitionedArea, &ABStripeRegRows, &ABStripeRegCols);

		HTuple ABrowsRound,ABcolsRound,WhiteStripeNumber;
		Hobject WhiteStripeRoiConnected;
		tuple_round(ABStripeRegRows, &ABrowsRound);
		tuple_round(ABStripeRegCols, &ABcolsRound);
		union1(WhiteStripeRoi, &WhiteStripeRoi);
		connection(WhiteStripeRoi, &WhiteStripeRoiConnected);
		count_obj(WhiteStripeRoiConnected, &WhiteStripeNumber);

		Hobject WhiteStripeUp,WhiteStripeSelected;
		HTuple StripeArea, StripeRow, StripeCol,StripeColRound,ColIndice;
		gen_empty_region(&WhiteStripeUp);
		for(int i=1;i<=WhiteStripeNumber;i++)
		{
			select_obj(WhiteStripeRoiConnected, &WhiteStripeSelected, i);
			area_center(WhiteStripeSelected, &StripeArea, &StripeRow, &StripeCol);
			tuple_round(StripeCol, &StripeColRound);
			tuple_find(ABcolsRound, StripeColRound, &ColIndice);
			//
			if (0 != (ColIndice==-1))
			{
				continue;
			}

			if (0 != (StripeRow<=(ABrowsRound.Select(ColIndice.Select(0)))))
			{
				concat_obj(WhiteStripeUp, WhiteStripeSelected, &WhiteStripeUp);

			}

		}
		Hobject WhiteStripeUpUnion;
		union1(WhiteStripeUp, &WhiteStripeUpUnion);
		Hobject WhiteStripeRgnUnion,WhiteStripeRegConnected,ObjectUnion,StripeRoiError;
		connection(WhiteStripeUpUnion, &WhiteStripeRegConnected);

		 //防止叉口上的区域被提取到时，进行筛除（区域角度为70-120度是筛除）
		Hobject rgnVertical,WhiteStripeRegEro ;
		HTuple dArea;
		erosion_rectangle1(WhiteStripeRegConnected, &WhiteStripeRegEro, 1, 5);
		GetSpecialAngleRegion(WhiteStripeRegEro,&rgnVertical,70,90 );
	 	region_features(rgnVertical,"area",&dArea);
		if (dArea > 0 )
		{
			Hobject rgnVerticalDil,WhiteStripeRegDif,WhiteStripeRegCon,WhiteStripeRegSel ;
			dilation_rectangle1(rgnVertical, &rgnVerticalDil, 1, 30);
			difference(WhiteStripeRegConnected,rgnVerticalDil,&WhiteStripeRegDif);
			connection(WhiteStripeRegDif,&WhiteStripeRegCon);
			select_shape(WhiteStripeRegCon,&WhiteStripeRegSel,"area","and",15,9999999);
			WhiteStripeRegConnected = WhiteStripeRegSel;
			connection(WhiteStripeRegConnected,&WhiteStripeRegConnected );
		}

		//根据白条之间的距离进行判断筛选
		HTuple TriangleRegNum;
		count_obj(WhiteStripeRegConnected, &TriangleRegNum);

		HTuple ObjectSelectedArea, ObjectSelectedRow, ObjectSelectedCol;
		Hobject TriangleRegL,TriangleRegR,WhiteStripeReg;
		Hobject TriangleRegLConnected,TriangleRegLeft;
		HTuple NumberL;
		Hobject TriangleRegRConnected,TriangleRegRight;
		HTuple NumberR;

		gen_empty_region(&TriangleRegL);
		gen_empty_region(&TriangleRegR);
		gen_empty_region(&TriangleRegLeft);
		gen_empty_region(&TriangleRegRight);
		gen_empty_region(&WhiteStripeReg);
		if (0 != (Number1==2))
		{
			Hobject SortedRegions,ObjectSelected1,ObjectSelected2;
			HTuple Area1, Row1, Column1;
			sort_region(PlatformRegConnected, &SortedRegions, "first_point", "true", "column");
			select_obj(SortedRegions, &ObjectSelected1, 1);
			area_center(ObjectSelected1, &Area1, &Row1, &Column1);
			HTuple PlatformRowL1, PlatformColL1, PlatformRowR1, PlatformColR1;
			smallest_rectangle1(ObjectSelected1, &PlatformRowL1, &PlatformColL1, &PlatformRowR1, &PlatformColR1);

			HTuple Area2, Row2, Column2,PlatformRowL2, PlatformColL2, PlatformRowR2, PlatformColR2;
			select_obj(SortedRegions, &ObjectSelected2, 2);
			area_center(ObjectSelected2, &Area2, &Row2, &Column2);
			smallest_rectangle1(ObjectSelected2, &PlatformRowL2, &PlatformColL2, &PlatformRowR2, &PlatformColR2);

			if (0 != (Area1>Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL1))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR1))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}
			}
			else if (0 != (Area1<Area2))
			{

				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
					else if (0 != (ObjectSelectedCol>PlatformColR2))
					{
						concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
					}
				}

			}
			else
			{
				for (int i=1; i<=TriangleRegNum; i++)
				{
					select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
					area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
					if (0 != (ObjectSelectedCol<PlatformColL2))
					{
						concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
					}
				}

			}	
			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}

			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}
		else
		{
			HTuple PlatformRowL, PlatformColL, PlatformRowR, PlatformColR;
			smallest_rectangle1(m_PlatformReg, &PlatformRowL, &PlatformColL, &PlatformRowR, &PlatformColR);
			for (int i=1; i<=TriangleRegNum; i++)
			{
				select_obj(WhiteStripeRegConnected, &ObjectSelected, i);
				area_center(ObjectSelected, &ObjectSelectedArea, &ObjectSelectedRow, &ObjectSelectedCol);
				if (0 != (ObjectSelectedCol<PlatformColL))
				{
					concat_obj(TriangleRegL, ObjectSelected, &TriangleRegL);
				}
				else if (0 != (ObjectSelectedCol>PlatformColR))
				{
					concat_obj(TriangleRegR, ObjectSelected, &TriangleRegR);
				}
			}

			union1(TriangleRegL, &TriangleRegL);
			connection(TriangleRegL, &TriangleRegLConnected);
			count_obj(TriangleRegLConnected, &NumberL);
			if (0 != (NumberL>=1))
			{
				select_shape_std(TriangleRegLConnected, &TriangleRegLeft, "max_area", 70);
			}

			union1(TriangleRegR, &TriangleRegR);
			connection(TriangleRegR, &TriangleRegRConnected);
			count_obj(TriangleRegRConnected, &NumberR);
			if (0 != (NumberR>=1))
			{
				select_shape_std(TriangleRegRConnected, &TriangleRegRight, "max_area", 70);
			}
			union2(TriangleRegLeft, TriangleRegRight, &WhiteStripeReg);
		}

		// 移除特定角度白条（70-120）
		
		//RemoveSpecialAngleRegion(WhiteStripeReg, &WhiteStripeReg, 70, 120);

		

		Hobject StripeRegs;
		union1(WhiteStripeReg, &StripeRegs);

		Hobject StripeConnected;
		connection(StripeRegs, &StripeConnected);
		HTuple StripeNumber,StripeRegArea, StripeRegRow, StripeRegColumn;
		count_obj(StripeConnected, &StripeNumber);
		area_center(StripeRegs, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		Hobject StripeReg;
		m_WhiteStripeReg = StripeRegs;
		m_StripeReg1=StripeRegs;
		m_StripeReg2=StripeRegs;

		if(m_bDebugImg)
		{
			Hobject StripeRegInterscted;
			intersection(StripeRegs,StripeSearchReg,&StripeRegInterscted);
			concat_obj(m_vRgn[rId], StripeRegInterscted, &m_vRgn[rId]);
		}

		if (StripeNumber>2)
		{
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pStripeArea);
			return S_FALSE;
		}
		//
		if (StripeRegArea>0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = StripeRegs;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_StripePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#1$\
					 381;B$\
					 991;LP;0;250;1;90$\
					 5556;LP;1;50;1;3$\
					 998;LP;1;100;1;60$\
					 999;FP;0;250;0.5;80$\
					 6094;LP;1;30;1;3");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*********************************************************************************
** 函数名 ： D20N_StripePatternDetectAlgo
** 功  能 ： 新三叉胶塞三角花纹提取
** 时  间 ：2019年12月5日
******************************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_TrianglePatternDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1007$\
					 397;R;FP;0;10000;1;>=#0$\
					 381;B$\
					 6213;FP;0.5;20;0.5;1.5$\
					 1018;LP;5;80;1;55");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_TrianglePatternDetectAlgo(VARIANT* rgnId,VARIANT* pWhiteBarSize,VARIANT* pTriangleSize,VARIANT* pStripeArea)
{
	//三角花纹提取
	int rId           = (int)rgnId->fltVal;
	float WhiteBarSize = (float) pWhiteBarSize->fltVal;
	int TriangleSize = (int) pTriangleSize->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION||m_WhiteStripeReg.Id()==H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	//
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_crtImg;
	//	Hobject ImageScaleMax,Ellipse,ImageReduced;
		//gen_ellipse (&Ellipse, m_imgHeight/2.0, m_imgWidth/2.0, 0.0, m_imgWidth/2.0, m_imgHeight/2.0);   //默认图片的大小有要求
		//reduce_domain(crtImg,Ellipse,&ImageReduced);
		//scale_image_max(ImageReduced, &ImageScaleMax);
		//
		Hobject RectSelected,ImageReduced5,Regions1,ConnectedRegions1,ABEdgePartitioned,TriangleObject,WhiteTriangleRegSelected,TriangleObjectConnected;
		Hobject TriangleRoi,TReg,TriangleConcat,TriangleReg,TriangleRoi1;
		HTuple Number,RectArea, RectRow, RectColumn,Number1,PartitionedArea, PartitionedRow, PartitionedCol,WhiteTriangleArea, WhiteTriangleRow,WhiteTriangleCol,RowRound,ColRound,Indice;
		HTuple TriangleArea, TriangleRow, TriangleColumn,MidRow, MidCol, phi, Length1, Length2,LengthLong,LengthShort;
		HTuple Row1,Col1,Row2,Col2,RowDiff;

		// 使用的F20_StripePatternDetectAlgo中提取的花纹高亮区域
		// 然后生成三角花纹
		Hobject WhiteStripeReg,rgnTregS;
		WhiteStripeReg = m_WhiteStripeReg;
		connection(WhiteStripeReg,&WhiteStripeReg );
		//my_disp_obj(WhiteStripeReg );

		gen_empty_region(&TriangleReg);
		gen_empty_region(&rgnTregS);
		count_obj(WhiteStripeReg, &Number);
		for (int x=1; x<=Number; x++)
		{
			select_obj(WhiteStripeReg, &RectSelected, x);
			area_center(RectSelected, &RectArea, &RectRow, &RectColumn);
			if ( RectArea > 0)
			{		
				TriangleObject = RectSelected;
				dilation_rectangle1(TriangleObject,&TriangleObject,(Hlong)WhiteBarSize,(Hlong)(WhiteBarSize/2.0) );
				union1(TriangleObject, &TriangleObject);
				connection(TriangleObject, &TriangleObjectConnected);
				select_shape_std(TriangleObjectConnected, &TriangleRoi, "max_area", 70);
				area_center(TriangleRoi, &TriangleArea, &TriangleRow, &TriangleColumn);
				smallest_rectangle2(TriangleRoi, &MidRow, &MidCol, &phi, &Length1, &Length2);
				if (0 != (Length1>Length2))
				{
					LengthLong = Length1;
					LengthShort = Length2;
				}
				else
				{
					LengthLong = Length2;
					LengthShort = Length1;
				}
				Row1 = MidRow+(LengthLong*(phi.Sin()));
				Col1 = MidCol-(LengthLong*(phi.Cos()));

				Row2 = MidRow-(LengthLong*(phi.Sin()));
				Col2 = MidCol+(LengthLong*(phi.Cos()));

				gen_region_polygon(&TReg, ((Row1.Concat(Row2)).Concat(MidRow+TriangleSize)).Concat(Row1),((Col1.Concat(Col2)).Concat(MidCol)).Concat(Col1));
				fill_up(TReg, &TReg);
				//m_TriangleRoi  用于整体区域
				concat_obj(TriangleRoi, TReg, &TriangleConcat);
				// rgnTregS 三角花纹区域
				concat_obj(rgnTregS,TReg,&rgnTregS );
			}
			concat_obj(TriangleReg, TriangleConcat, &TriangleReg);
			concat_obj(TriangleRoi,TriangleRoi1,&TriangleRoi1);
		}
		Hobject TriangleRegFillUp,TriangleRegUnion,TriangleRoiFillUp,TriangleRoi1Union;
		gen_empty_region(&TriangleRegFillUp);
		union1(TriangleReg, &TriangleRegUnion);
		fill_up(TriangleRegUnion, &TriangleRegFillUp);         // 花纹整体

		gen_empty_region(&TriangleRoiFillUp);
		union1(TriangleRoi1, &TriangleRoi1Union);
		fill_up(TriangleRoi1Union,&TriangleRoiFillUp);        // 花纹高亮

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], TriangleReg, &m_vRgn[rId]); 
		}
		m_LowerReg=TriangleRegFillUp;
		m_StripeReg=TriangleRegFillUp;    //用于单叉覆膜胶塞花纹扣除
		m_StripeReg1=TriangleRegFillUp;    //用于新三叉胶塞花纹扣除
		m_TriangleRoi=TriangleRoiFillUp;    // 花纹高亮区域
		m_WhiteStripeReg = TriangleRoiFillUp;
		m_TReg          = rgnTregS ;        // 三角花纹区域

		HTuple StripeRegArea, StripeRegRow, StripeRegColumn;
		area_center(TriangleRegFillUp, &StripeRegArea, &StripeRegRow, &StripeRegColumn);

		if (StripeRegArea>=0)
		{
			retValue = StripeRegArea[0].I();
			m_vErrorRgn[rId] = TriangleRegFillUp;
		}
		else
		{
			Hobject Circle;
			gen_circle(&Circle, m_imgHeight/2.0, m_imgWidth/2.0, 100);
			retValue = -1;
			m_vErrorRgn[rId] = Circle;
		}
		retValue.Detach(pStripeArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pStripeArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
/******************************************************************************************
**函 数 名：D20N_StripePatternRegionLocationAlgo
**功    能：新三叉胶塞颈部花纹区域（1-花纹整体区域；2-花纹高亮区域；3--三角花纹区域）
**时    间 ：2019年12月5日
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_StripePatternRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelect,VARIANT* pHErosionSize, VARIANT* pVErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int Select         = (int)pSelect->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VErosionSize   = (int)pVErosionSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id()==H_EMPTY_REGION||m_WhiteStripeReg.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

	HTuple dArea1,dArea2,dArea3;
	region_features(m_TriangleRoi,"area",&dArea1 );
	region_features(m_StripeReg1,"area",&dArea2 );
	region_features(m_TReg,"area",&dArea3 );
	if ( (dArea2 <= 0) || (dArea1 <= 0) || (dArea3 <= 0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		Hobject  rgnStripe;
		if (Select == 1)
		{
			// 花纹整体区域
			rgnStripe = m_StripeRegD;
		} 
		else if (Select == 2)
		{
			// 高亮区域
			rgnStripe = m_WhiteStripeReg;
		} 
		else
		{
			// 三角花纹区域
			rgnStripe = m_TReg;
			difference(rgnStripe,m_WhiteStripeReg,&rgnStripe );
			opening_circle(rgnStripe,&rgnStripe,1.5 );
		}

		//垂直缩放
		Hobject StripeRegDilation,RegionDetect;
		if (VErosionSize>=1)
		{
			dilation_rectangle1(rgnStripe,&StripeRegDilation,1,VErosionSize);
		}
		else if (VErosionSize<=-1)
		{
			erosion_rectangle1(rgnStripe,&StripeRegDilation,1,-VErosionSize);
		}
		else
		{
			StripeRegDilation=rgnStripe;
		}
		//水平缩放
		clip_region_rel(StripeRegDilation,&RegionDetect,0,0,HErosionSize,HErosionSize);

		Hobject StripRegion;
		intersection(m_ROI,RegionDetect,&StripRegion);
		opening_circle(StripRegion,&StripRegion,3.5);
		m_vRgn[rId] = StripRegion ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId]=newRgn;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_StripePatternRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1071$\
					 167;B$\
					 6214;LP;1;3;1;1$\
					 994;LP;1;35;1;1$\
					 995;LP;-35;35;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/******************************************************************************************
**函 数 名：D20N_NeckRegionLocationAlgo1
**功    能：计算新三叉胶塞的颈部区域（剔除平台，下花纹区域）
**时    间 ：2019年12月5日
*******************************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_NeckRegionLocationAlgo(VARIANT* rgnId,VARIANT* pLowerEdgeMoveSize, VARIANT* pUpEdgeMoveSize,VARIANT* pHErosionSize,VARIANT* pDilationSizeH1,VARIANT* pDilationSizeT)
{
	int rId           = (int)rgnId->fltVal;
	int LowerEdgeMoveSize   = (int)pLowerEdgeMoveSize->fltVal;
	int HErosionSize   = (int)pHErosionSize->fltVal;
	int UpEdgeMoveSize   = (int)pUpEdgeMoveSize->fltVal;

	int DilationSizeH1   = (int)pDilationSizeH1->fltVal;

	int DilationSizeT   = (int)pDilationSizeT->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ARegionT.Id() == H_EMPTY_REGION||m_PlatformReg.Id() == H_EMPTY_REGION||m_StripeReg1.Id()==H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}
		//针对颈部拐角反光的情况，下边缘往上平移
		Hobject rgnABEdgeMoved,rgnABEdgeMoveDil,ARegionMoved,ARegionIntersction;

		//move_region(m_ABEdge,&rgnABEdgeMoved,5,0);
		dilation_rectangle1(m_ABEdge,&rgnABEdgeMoveDil,1,LowerEdgeMoveSize );

		difference(m_ARegionT, rgnABEdgeMoveDil,&ARegionMoved);
		connection(ARegionMoved,&ARegionMoved );
		select_shape_std(ARegionMoved,&ARegionMoved,"max_area",70 );
		//move_region(m_ARegionT,&ARegionMoved,-LowerEdgeMoveSize,0);
		intersection(ARegionMoved,m_ARegionT,&ARegionIntersction);

		Hobject ARegionT0,ARegionT1,RegionMoved1;
		//水平缩放
		clip_region_rel(ARegionIntersction, &ARegionT0, 0, 0, HErosionSize, HErosionSize);
		
		//上边缘
		move_region(ARegionT0, &RegionMoved1, UpEdgeMoveSize, 0);
		intersection(RegionMoved1, ARegionT0, &ARegionT1);

		//剔除平台
		Hobject PlatformReg;
		dilation_circle(m_PlatformReg,&PlatformReg,DilationSizeT);
		Hobject ARegionPlatDiff,ARegionDiff;
		difference(ARegionT1, PlatformReg, &ARegionPlatDiff);
		//剔除花纹
		Hobject StripeReg1;
		//下花纹缩放
		dilation_circle(m_StripeReg1,&StripeReg1,DilationSizeH1);

		Hobject StripeReg;
		union1(StripeReg1,&StripeReg);
		difference(ARegionPlatDiff, StripeReg, &ARegionDiff);

		m_StripeRegD=StripeReg;
		m_vRgn[rId] = ARegionDiff ;	
#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_NeckRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("1169$\
					 167;B$\
					 1117;LP;1;30;1;11$\
					 1126;LP;1;50;1;5$\
					 994;LP;1;50;1;20$\
					 6089;LP;1;45;1;5$\
					 1021;LP;1;45;1;8");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/**************************************************************************
**函 数 名：D20N_OutInWallRegionLocationAlgo
**功    能：D20_侧面之20新三叉侧面外内壁区域定位
**说    明：该算子根据叉口平台区域与顶部叉口黑色区域提取
**时    间：2019年12月05日
***************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_OutInWallRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("5537$\
					 167;B$\
					 5515;FP;1;30;0.5;1.5$\
					 5538;FP;1;100;0.5;5.0$\
					 5539;FP;1;100;0.5;5.0$\
					 5540;LP;1;3000;1;500$\
					 5557;LP;1;3000;1;1000$\
					 6058;FP;1;50;0.5;12.0$\
					 994;FP;1;50;0.5;1.0");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_OutInWallRegionLocationAlgo(VARIANT* rgnId, VARIANT* pOuterSize,VARIANT* pUpSizeOuterWall,VARIANT* pDownSizeOuterWall,VARIANT* pAreaSize,VARIANT* pWholeAreaSize,VARIANT* pHPlatEroSize,VARIANT* pHEroSize)
{
	int rId           = (int)rgnId->fltVal;
	float OuterSize   = (float)pOuterSize->fltVal;       // 5
	float UpSizeOuterWall   = (float)pUpSizeOuterWall->fltVal;       // 5
	float DownSizeOuterWall   = (float)pDownSizeOuterWall->fltVal;   //5
	float HEroSize   = (float)pHEroSize->fltVal;                     // 3.5
	float HPlatEroSize = (float)pHPlatEroSize->fltVal;              // 15
	int   AreaSize  = (int) pAreaSize->fltVal;                       //   500
	int   WholeAreaSize  = (int) pWholeAreaSize->fltVal;             //   500

	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	HTuple dArea1,dArea2;
	region_features(m_rgnPlatForm,"area",&dArea1 );
	region_features(m_TopWholeRgn,"area",&dArea2 );

	if((dArea1<= 0)||(dArea2 <= 0))
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject TopRegions;
		TopRegions = m_TopWholeRgn;

		// get the initial outer inwall region  
		Hobject rgnPlatformDil,rgnTopRegionsDil,rgnDiffPlatform1,rgnOuterWallSearch,rgnOuterWallOri;
		dilation_circle(m_rgnPlatForm, &rgnPlatformDil,  3.5);
		dilation_circle(TopRegions,&rgnTopRegionsDil, 3.5);
		
		difference(m_PlatformReg, rgnPlatformDil, &rgnDiffPlatform1);
		difference(rgnDiffPlatform1, rgnTopRegionsDil, &rgnOuterWallSearch);

		intersection(rgnOuterWallSearch, m_ROI, &rgnOuterWallOri);

		// horizontal erosion as pre-process
		Hobject rgnOuterWall1,rgnOuterWall1Con,rgnOuterWallSel;
		union1(rgnOuterWallOri,&rgnOuterWallOri);
		erosion_rectangle1(rgnOuterWallOri, &rgnOuterWall1, (Hlong)HPlatEroSize, 1);
		clip_region_rel(rgnOuterWall1,&rgnOuterWall1,0,0,(Hlong)(HPlatEroSize/3.0),(Hlong)(HPlatEroSize/3.0));

		connection(rgnOuterWall1, &rgnOuterWall1Con);
		select_shape(rgnOuterWall1Con, &rgnOuterWallSel, "area", "and", 200, 99999999);

		// get the top fork black region
		Hobject rgnTopConvex,rgnTopConvexDiff,rgnTopConvexOpn,rgnTopConvexCls,rgnTopForksOri;
		shape_trans(TopRegions, &rgnTopConvex, "convex");
		difference(rgnTopConvex, TopRegions, &rgnTopConvexDiff);
		opening_circle(rgnTopConvexDiff, &rgnTopConvexOpn, 3.5);
		closing_circle(rgnTopConvexOpn, &rgnTopConvexCls, 3.5);
		connection(rgnTopConvexCls, &rgnTopForksOri);
		HTuple dAreargnTopForks, dRowrgnTopForks, dColrgnTopForks;
		area_center(rgnTopForksOri, &dAreargnTopForks, &dRowrgnTopForks, &dColrgnTopForks);

		// get the top region center and the top black region center
		HTuple dRectTopCol1, dRectTopRow1, dRectTopRow2,dRectTopCol2;
		smallest_rectangle1(TopRegions, &dRectTopCol1, &dRectTopRow1, &dRectTopRow2,&dRectTopCol2 );
		HTuple dRectTopBlackRow1, dRectTopBlackRowCol1, dRectTopBlackRow2, dRectTopBlackRowCol2;
		smallest_rectangle1(m_rgnTopBlack, &dRectTopBlackRow1, &dRectTopBlackRowCol1, &dRectTopBlackRow2, &dRectTopBlackRowCol2);

		//根据叉口朝向，提取平台区域
		HTuple a,b,c;
		tuple_rad(m_AngleP, &a);
		tuple_rad(180-m_AngleP, &b);
		tuple_rad(180, &c);

		Hobject rgnTopForkL,rgnTopForkR ;
		gen_empty_obj(&rgnTopForkR);
		gen_empty_obj(&rgnTopForkL);

		if ((0 < m_Angle ) && (m_Angle < a))
		{
			// left
			Hobject rgnTopForksSelL,rgnTopForksSelL1,rgnTopForksSelL2;
			select_shape(rgnTopForksOri, &rgnTopForksSelL, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelL, &rgnTopForksSelL1, "column", "and", dRectTopCol1, m_TopCol);
			select_shape(rgnTopForksSelL1, &rgnTopForksSelL2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelL2, &rgnTopForkL, "max_area", 70);
		} 
		else if(( a < m_Angle) && ( m_Angle < b)  )
		{
			// left
			Hobject rgnTopForksSelL,rgnTopForksSelL1,rgnTopForksSelL2;
			select_shape(rgnTopForksOri, &rgnTopForksSelL, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelL, &rgnTopForksSelL1, "column", "and", dRectTopCol1, m_TopCol);
			select_shape(rgnTopForksSelL1, &rgnTopForksSelL2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelL2, &rgnTopForkL, "max_area", 70);

			// right
			Hobject rgnTopForksSelR,rgnTopForksSelR1,rgnTopForksSelR2;
			select_shape(rgnTopForksOri, &rgnTopForksSelR, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelR, &rgnTopForksSelR1, "column", "and", m_TopCol, dRectTopCol2);
			select_shape(rgnTopForksSelR1, &rgnTopForksSelR2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelR2, &rgnTopForkR, "max_area", 70);

		}
		else if( (b < m_Angle) && ( m_Angle < c))
		{
			// right
			Hobject rgnTopForksSelR,rgnTopForksSelR1,rgnTopForksSelR2;
			select_shape(rgnTopForksOri, &rgnTopForksSelR, "row", "and", m_dRowTopBlack-50,dRectTopRow2);
			select_shape(rgnTopForksSelR, &rgnTopForksSelR1, "column", "and", m_TopCol, dRectTopCol2);
			select_shape(rgnTopForksSelR1, &rgnTopForksSelR2, "area", "and", AreaSize, 9999999);
			select_shape_std(rgnTopForksSelR2, &rgnTopForkR, "max_area", 70);

		}

		Hobject rgnTopFork,rgnOuterWallUni,rgnOuterWallOpn,rgnOuterWallOri2;
		union2(rgnTopForkL, rgnTopForkR, &rgnTopFork);
		union2(rgnTopFork, rgnOuterWallSel, &rgnOuterWallUni);

		union1(rgnOuterWallUni, &rgnOuterWallUni);
		opening_circle(rgnOuterWallUni, &rgnOuterWallOpn, 3.5);
		closing_circle(rgnOuterWallOpn, &rgnOuterWallOri2, 35);

		// 上下位置缩放
		Hobject rgnPlatFormMov,rgnPlatformDilation,rgnTopRegionsDilation,rgnDiffPlatform2,rgnOuterWallFinal;
		
		move_region(m_rgnPlatForm,&rgnPlatFormMov,15,0 );
		union2(rgnPlatFormMov,m_rgnPlatForm,&rgnPlatFormMov );

		dilation_circle(rgnPlatFormMov, &rgnPlatformDilation,  DownSizeOuterWall);
		dilation_circle(TopRegions,&rgnTopRegionsDilation, UpSizeOuterWall);

		difference(rgnOuterWallOri2, rgnPlatformDilation, &rgnDiffPlatform2);
		difference(rgnDiffPlatform2, rgnTopRegionsDilation, &rgnOuterWallFinal);

		Hobject rgnOuterWall;
		intersection(rgnOuterWallFinal, m_ROI, &rgnOuterWall);

		// 水平缩放
		erosion_rectangle1(rgnOuterWall, &rgnOuterWall, (Hlong)HEroSize, 1);
		opening_circle(rgnOuterWall,&rgnOuterWall,2);

		// 外边缘缩放
		Hobject rgnROIEro ;
		erosion_circle(m_ROI,&rgnROIEro,OuterSize );
		intersection(rgnOuterWall,rgnROIEro,&rgnOuterWall );

		// 防止经过缩放处理之后产生比较小的区域
		connection(rgnOuterWall,&rgnOuterWall);
		select_shape(rgnOuterWall, &rgnOuterWall, "area", "and", WholeAreaSize, 9999999);
		union1(rgnOuterWall,&rgnOuterWall);

		HTuple dArea,dRow,dCol;
		area_center(rgnOuterWall,&dArea,&dRow,&dCol);

		if ( dArea > 0)
		{
			m_vRgn[rId] = rgnOuterWall;
		} 
		else
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}


#ifdef NDEBUG 
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
/***************************************************************************
**函 数 名：D20N_SideSlopRegionLocationAlgo
**功    能：计算新三叉胶塞的顶部斜坡区域
**时    间：2019年12月07日
****************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_SideSlopRegionLocationAlgo(VARIANT* rgnId,VARIANT* pMoveSize,VARIANT* pVEroSizeDown, VARIANT* pOuterEdgeSize,VARIANT* pBlackThred,VARIANT* pHErosionSize)
{
	int rId           = (int)rgnId->fltVal;
	int MoveSize    = (int)pMoveSize->fltVal;
	float BlackThred    = (float)pBlackThred->fltVal;

	int HErosionSize   = (int)pHErosionSize->fltVal;
	int VEroSizeDown   = (int)pVEroSizeDown->fltVal;
	int OuterEdgeSize   = (int)pOuterEdgeSize->fltVal;
	//
	Hobject newRgn;
	m_vRgn[rId] = newRgn;

	if(m_ROI.Id() == H_EMPTY_REGION||m_ARegionT.Id() == H_EMPTY_REGION||m_ABEllipse.Id() == H_EMPTY_REGION||m_TopRegions.Id() == H_EMPTY_REGION||m_TopSlopEdgePoints.Id() == H_EMPTY_REGION)
	{
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bPilotImg)
		{
			return S_OK;
		}
		if(m_bDebugImg)
		{
			m_dictSpecialData[rId].clear();
		}

		Hobject crtImg = m_ImageScaleMax;
		//scale_image_max(crtImg,&crtImg);
		Hobject ARegionTDilation,RegionIntersection;
		dilation_rectangle1(m_ARegionT, &ARegionTDilation, 1, 350);
		Hobject ROIClosing;
		closing_rectangle1(m_ROI, &ROIClosing, 100, 1);
		intersection(ARegionTDilation, ROIClosing, &RegionIntersection);
		erosion_circle(RegionIntersection, &RegionIntersection, 5);

		//*往上平移5个像素
		Hobject ARegionTMoved,RegionDifference,ConnectedRegions1,ObjectSelected1;
		move_region(m_ARegionT, &ARegionTMoved, -5, 0);
		HTuple ARegionTMovedArea, ARegionTMovedRow, ARegionTMovedCol;
		area_center(ARegionTMoved, &ARegionTMovedArea, &ARegionTMovedRow, &ARegionTMovedCol);

		difference(RegionIntersection, ARegionTMoved, &RegionDifference);
		connection(RegionDifference, &ConnectedRegions1);

		select_shape(ConnectedRegions1, &ObjectSelected1, "row", "and", 0, ARegionTMovedRow);
		union1(ObjectSelected1, &ObjectSelected1);

		Hobject TopRegionsOpening,TopRegionsClosing;
		opening_circle(m_TopRegions, &TopRegionsOpening, 3.5);
		closing_circle(TopRegionsOpening, &TopRegionsClosing, 60);
		//
		Hobject TopRegTrans;
		shape_trans(TopRegionsClosing, &TopRegTrans, "convex");
		HTuple TopRegTransArea, TopRegTransRow, TopRegTransColumn;
		area_center(TopRegTrans, &TopRegTransArea, &TopRegTransRow, &TopRegTransColumn);

		Hobject RegionMoved;
		HTuple ABEllipseArea,ABEllipseRowCenter,ABEllipseColumnCenter;
		area_center(m_ABEllipse,&ABEllipseArea,&ABEllipseRowCenter,&ABEllipseColumnCenter);
		move_region(m_ABEllipse, &RegionMoved, -((ABEllipseRowCenter-TopRegTransRow)+MoveSize), -(ABEllipseColumnCenter-TopRegTransColumn));

		Hobject RegionErosion1,RegionDifference2,SelectedRegions1,ConnectedRegions5,RegionIntersection1;
		erosion_rectangle1(RegionMoved, &RegionErosion1, 20, 1);
		difference(ROIClosing, RegionErosion1, &RegionDifference2);
		connection(RegionDifference2, &ConnectedRegions5);
		select_shape_std(ConnectedRegions5, &SelectedRegions1, "max_area", 70);
		intersection(SelectedRegions1, ObjectSelected1, &RegionIntersection1);

		Hobject SlopRegSearch;
		connection(RegionIntersection1, &SlopRegSearch);
		select_shape_std(SlopRegSearch, &SlopRegSearch, "max_area", 70);
		Hobject SlopRegSearchMoved,SlopRegSearchDiff;
		move_region(SlopRegSearch, &SlopRegSearchMoved, -1, 0);
		difference(SlopRegSearchMoved, RegionErosion1, &SlopRegSearchDiff);

		// 搜索区域下位置调整
		Hobject SlopRegSearchDiffUp,SlopRegSearchDiffDown ;
		move_region(SlopRegSearchDiff,&SlopRegSearchDiffDown,-VEroSizeDown,0 );
		intersection(SlopRegSearchDiff, SlopRegSearchDiffDown,&SlopRegSearchDiff );

		Hobject SlopImageReduced,DynthredRegs,DynthredRegsFillUp,DynthredRegsOpening;
		HTuple Mean, Deviation;
		reduce_domain(crtImg, SlopRegSearchDiff, &SlopImageReduced);
		intensity(SlopRegSearch, SlopImageReduced, &Mean, &Deviation);

		//my_disp_obj(SlopRegSearch );


		if (Mean.Num()!=1)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;
		}	
		if(Mean[0].D()-BlackThred<=0)
		{
			BlackThred=(float)Mean[0].D();
		}
		threshold(SlopImageReduced, &DynthredRegs, 0, Mean-BlackThred);
		intersection(DynthredRegs, m_ROI, &DynthredRegs);
		fill_up(DynthredRegs, &DynthredRegsFillUp);
		opening_circle(DynthredRegsFillUp, &DynthredRegsOpening, 5.5);

		HTuple BlackRegsNumber;
		Hobject DynthredRegsClosing,BlackRegsConnected;
		closing_circle(DynthredRegsOpening, &DynthredRegsClosing, 15);
		connection(DynthredRegsClosing, &BlackRegsConnected);
		count_obj(BlackRegsConnected, &BlackRegsNumber);
		HTuple Area3, Row3, Column3;
		area_center(DynthredRegsClosing, &Area3, &Row3, &Column3);
		if (Area3==0)
		{
			m_vRgn[rId] = newRgn ;
			return S_FALSE;

		}
	
		//根据叉口朝向，提取斜坡叉口
		HTuple a,b,c;
		tuple_rad(m_AngleP, &a);
		tuple_rad(180-m_AngleP, &b);
		tuple_rad(180, &c);

		Hobject BlackRegL,BlackRegR;
		gen_empty_region(&BlackRegL);
		gen_empty_region(&BlackRegR);

		if (0 != (HTuple(m_Angle>=0).And(m_Angle<=a)))
		{
			//右边单叉
			//P_20D_BlackRegRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowR, m_SymProngColR, &BlackRegR);
			select_shape_std(BlackRegsConnected,&BlackRegR,"max_area",70 );

		}
		else if (0 != (HTuple(m_Angle>a).And(m_Angle<b)))
		{
			//两个叉口
			//P_20D_BlackRegLRSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, m_SymProngRowR, m_SymProngColR, &BlackRegL, &BlackRegR);
			HTuple  iNumBlack;
			count_obj(BlackRegsConnected,& iNumBlack);
			if ( (iNumBlack < 1) || (iNumBlack > 2))
			{
				m_vRgn[rId] = newRgn ;
				return S_FALSE;
			}

			if ( iNumBlack == 1)
			{
				BlackRegL = BlackRegsConnected;
				BlackRegR = BlackRegsConnected;
			}
			if ( iNumBlack == 2)
			{
				HTuple dArea,dRow,dCol ;
             	Hobject objSel2,objSel1;
				select_obj(BlackRegsConnected,&objSel1,1 );
				select_obj(BlackRegsConnected,&objSel2,2 );
				area_center(objSel1,&dArea,&dRow,&dCol );

				if (dCol < m_TopCol )
				{
					BlackRegL = objSel1;
					BlackRegR = objSel2;
				}
				else
				{
					BlackRegL = objSel2;
					BlackRegR = objSel1;
				}

			}
		}
		else if (0 != (HTuple(m_Angle>=b).And(m_Angle<=c)))
		{
			//左边单叉
			//P_20D_BlackRegLSelectAlgo(BlackRegsConnected, BlackRegsNumber, m_TopCol, m_SymProngRowL, m_SymProngColL, &BlackRegL);
			BlackRegL = BlackRegsConnected;
			BlackRegR = BlackRegsConnected;
		}
		Hobject BlackReg,BlackRegDilation,SlopRegDiff;
		union2(BlackRegL, BlackRegR, &BlackReg);

		//外边缘缩放、水平缩放  SlopRegSearchDiff  HErosionSize
		Hobject rgnROIEro1,SlopIntesct,BlackRegLDil,BlackRegRDil,SlopDiff1,SlopDiff2;
		erosion_circle(m_ROI,&rgnROIEro1,OuterEdgeSize );
		intersection(SlopRegSearchDiff,rgnROIEro1,&SlopIntesct );
		
		dilation_circle(BlackRegL, &BlackRegLDil,HErosionSize);
		dilation_circle(BlackRegR, &BlackRegRDil,HErosionSize);

		difference( SlopIntesct,BlackRegLDil,&SlopDiff1);
		difference( SlopDiff1,BlackRegRDil,&SlopDiff2);
		opening_circle(SlopDiff2,&SlopRegDiff,2.5 );

		Hobject SlopRegDiffCon,SlopReg;
		connection(SlopRegDiff, &SlopRegDiffCon);
        select_shape(SlopRegDiffCon, &SlopReg, "area", "and", 100, 99999999);

		// 未进行缩放的斜坡区域
		m_SlopRegDiff = SlopRegDiff;
		m_BlackReg    =   BlackReg;

		m_vRgn[rId] = SlopReg ;	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		m_vRgn[rId] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_SideSlopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("996$\
					 167;B$\
					 1019;LP;1;30;1;10$\
					 6216;LP;1;20;1;5$\
					 1046;LP;1;20;1;5$\
					 1022;FP;-40;70;0.5;-15$\
					 994;LP;1;20;1;1");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/*************************************************************************
**函 数 名：D20N_TopAngleDetectAlgo
**功    能：新三叉胶塞顶部高亮区域角度定位
**时    间：2019年12月07日
*************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_TopAngleDetectAlgo(VARIANT* rgnId,VARIANT* pRadius, VARIANT* pThreshLowerValue,VARIANT* pGapArea)
{
	int rId = (int)rgnId->fltVal;
	float Radius = (float)pRadius->fltVal;
	float ThreshLowerValue = (float)pThreshLowerValue->fltVal;

	m_vErrorRgn[rId].Reset();
	CComVariant retValue;
	Hobject rgn = m_vRgn[rId];
	if(rgn.Id() == H_EMPTY_REGION)
	{
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		if(m_bPilotImg)
		{
			return S_OK;
		}
		Hobject ImageReduced,ImageScaleMax;
		Hobject Image=m_ImageScaleMax;
		Hlong Width, Height,Pt_y,Pt_x;
		get_image_size (Image, &Width, &Height);
		m_imgWidth  = (long)Width;
		m_imgHeight = (long)Height;

		Pt_x = (Hlong)(m_vPos[0].m_x);
		Pt_y = (Hlong)(m_vPos[0].m_y);
		
		Hobject rgnCircleAngle,imgCircleAngle ;
		//reduce_domain(Image, rgn, &ImageScaleMax);
		gen_circle(&rgnCircleAngle,(double)Pt_y,(double)Pt_x,Radius);
		reduce_domain(Image, rgnCircleAngle, &imgCircleAngle);
		scale_image_max(imgCircleAngle, &imgCircleAngle);

		Hobject rgnThrTop,rgnFilTop,rgnOpnTop,rgnConTop,rgnTopSel,rgnTopCls ;
		threshold(imgCircleAngle, &rgnThrTop,ThreshLowerValue, 255);
		fill_up(rgnThrTop, &rgnFilTop);
		opening_circle(rgnFilTop, &rgnOpnTop, 5.5);
		connection(rgnOpnTop, &rgnConTop);
		select_shape(rgnConTop, &rgnTopSel, "area", "and", 500, 9999999);

		closing_circle(rgnTopSel, &rgnTopCls, 10.5);
		select_shape_std(rgnTopCls, &rgnTopSel, "max_area", 70);
		closing_circle(rgnTopSel, &rgnTopSel, 100.5);

		Hobject rgnTopUni,rgnTrans  ;
		HTuple  dRowCir,dColCir,dRCir;
		union1(rgnTopSel, &rgnTopUni);
		shape_trans(rgnTopUni, &rgnTrans, "outer_circle");
		smallest_circle(rgnTrans, &dRowCir, &dColCir, &dRCir);
		if (dRCir < 2 )
		{
			m_InnerCircleRow1=m_imgHeight/2;
			m_InnerCircleCol1=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId].Reset();
			retValue.Detach(pGapArea);
			return S_FALSE;
		}
		Hobject rgnDiffCon,rgnEro,rgnDiff ;
		HTuple iBarNum ;
		erosion_circle(rgnTrans, &rgnEro,dRCir/2.0);
		difference(rgnTopUni, rgnEro, &rgnDiff);
		connection(rgnDiff, &rgnDiffCon);
		count_obj(rgnDiffCon, &iBarNum);
		if ( (iBarNum > 3) || (iBarNum < 1))
		{
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			m_InnerCircleRow1=m_imgHeight/2;
			m_InnerCircleCol1=m_imgWidth/2;
			retValue = -1;
			m_vErrorRgn[rId] = Line;
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		Hobject rgnBarSel,RegionLines ;
		HTuple dAreaBar, dRowAngle,dColAngle;
		select_obj(rgnDiffCon, &rgnBarSel, 1);
        area_center(rgnBarSel, &dAreaBar, &dRowAngle, &dColAngle);

        //**Angle line
		Hobject  rgnCircleIn,rgnCircleOut,rgnCircleInOut;
		HTuple  Angle;
        gen_region_line(&RegionLines,dRowCir,dColCir,dRowAngle,dColAngle);
		gen_circle(&rgnCircleIn,dRowCir,dColCir, 10);
		gen_circle(&rgnCircleOut,dRowAngle,dColAngle, 5);
		union2(rgnCircleOut, rgnCircleIn, &rgnCircleInOut);
		orientation_region(rgnCircleInOut, &Angle);

		HTuple GapLineArea,GapLineRow,GapLineCol;
		area_center(RegionLines,&GapLineArea,&GapLineRow,&GapLineCol);

		// 顶部高亮区域
		m_rgnTop = rgnTopSel;

		if(m_bDebugImg)
		{
			concat_obj(m_vRgn[rId], RegionLines, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], rgnCircleAngle, &m_vRgn[rId]);
			concat_obj(m_vRgn[rId], rgnTopSel, &m_vRgn[rId]);
		}

		if (GapLineArea>0)
		{
			m_vPos[0].m_x = (float)dColCir[0].D();
			m_vPos[0].m_y = (float)dRowCir[0].D();

			m_InnerCircleRow1=dRowCir;
			m_InnerCircleCol1=dColCir;
			//m_InnerCircleRadius1=InnerCircleRadius;

			m_modelAngle=Angle;
			retValue = GapLineArea[0].I();
			m_vErrorRgn[rId] = RegionLines;
		}
		else
		{
			m_InnerCircleRow1=m_imgHeight/2;
			m_InnerCircleCol1=m_imgWidth/2;
			Hobject Line;
			gen_region_line(&Line, m_imgHeight/2, m_imgWidth/2, m_imgHeight/2, m_imgWidth/2+70);
			retValue = -1;
			m_vErrorRgn[rId] = Line;
			retValue.Detach(pGapArea);
			return S_FALSE;
		}

		m_modelAngleTmp=m_modelAngleTmp.Concat(m_modelAngle);
		retValue.Detach(pGapArea);
#ifdef NDEBUG
	}
	catch (HException &except)
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
	catch (...) 
	{
		m_algoSpy.QueueUpLogMsg(__FUNCTION__, m_crtImg);
		retValue = -1;
		m_vErrorRgn[rId].Reset();
		retValue.Detach(pGapArea);
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_TopAngleDetectAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6217$\
					 397;R;FP;-2;10000;1;>=#0$\
					 381;B$\
					 1024;FP;1;400;0.5;200$\
					 1011;FP;1;250;0.5;145");
	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************
** 函数名：D20N_TopForkRegionLocationIniAlgo
** 功  能：一种新三叉胶塞顶部叉口初始定位
** 时  间：2019年12月7日
*****************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_TopForkRegionLocationIniAlgo(VARIANT* rgnId, VARIANT* pRadius, VARIANT* pTopDilSize1,VARIANT* pTopDilSize2)
{
	//得到环形区域
	int id = (int)rgnId->fltVal;
	float TopDilSize1 = (float)pTopDilSize1->fltVal;
	float TopDilSize2 = (float)pTopDilSize2->fltVal;

	float RadiusSize =(float)pRadius->fltVal;
	
	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	HTuple dRowCir,dColCir;
	dRowCir = fCenterY;
	dColCir = fCenterX;

	Hobject newRgn;
	m_vRgn[id] = newRgn;

	HTuple dArea1;
	region_features(m_rgnTop,"area",&dArea1 );

	if((fCenterX<2.0)||(fCenterY<2.0) || (dArea1<1))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	
#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}
		
		//first
		Hobject  rgnTop;
		rgnTop = m_rgnTop;

		Hobject  rgnTopUni,rgnTrans;
		union1(rgnTop, &rgnTopUni);
		shape_trans(rgnTopUni, &rgnTrans, "outer_circle");
		
		Hobject rgnTransEro,rgnTopDil1,rgnForkOri1,rgnForkOri1Opn,rgnForkOri1Cls ;
		erosion_circle(rgnTrans, &rgnTransEro, 3.5);
		dilation_circle(m_rgnTop, &rgnTopDil1,TopDilSize1);
		difference(rgnTransEro, rgnTopDil1, &rgnForkOri1);
		opening_circle(rgnForkOri1, &rgnForkOri1Opn, 10.5);
		closing_circle(rgnForkOri1Opn, &rgnForkOri1Cls, 10.5);

		//second
        Hobject rgnCircleOuter,rgnTopDil2,rgnForkOri2,rgnForkOri2Opn,rgnForkOri2Cls,rgnForkOri ,rgnUni;
		gen_circle(&rgnCircleOuter,dRowCir,dColCir,RadiusSize);
		dilation_circle(m_rgnTop, &rgnTopDil2,TopDilSize2);
		difference(rgnCircleOuter, rgnTopDil2, &rgnForkOri2);
		opening_circle(rgnForkOri2, &rgnForkOri2Opn, 10.5);
		closing_circle(rgnForkOri2Opn, &rgnForkOri2Cls, 10.5);

		union2(rgnForkOri2Cls, rgnForkOri1Cls, &rgnUni);
		closing_circle(rgnUni, &rgnForkOri, 30.5);

		difference(rgnForkOri, rgnTopDil1, &rgnForkOri);

		m_rgnForkOri = rgnForkOri;

		HTuple dArea2,dRow2,dCol2;
		area_center(rgnForkOri,&dArea2,&dRow2,&dCol2 );
		if ( dArea2 > 0)
		{
			m_vRgn[id] = rgnForkOri ;
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}
	
#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_TopForkRegionLocationIniAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6220$\
					 167;B$\
					 194;FP;1.0;2000.0;0.5;220$\
					 6218;FP;1.5;100;0.5;10.5$\
					 6219;FP;1.5;100;0.5;25.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}
/****************************************************************************
** 函数名：D20N_TopRegionLocationAlgo
** 功  能：一种新三叉胶塞顶部区域定位：顶部高亮区域、斜坡区域、叉口区域
** 时  间：2019年12月7日
*****************************************************************************/
STDMETHODIMP CPlugAlgo::D20N_TopRegionLocationAlgo(VARIANT* rgnId, VARIANT* pSelection,VARIANT* pRadius, VARIANT* pTopDilSize,VARIANT* pTopForkSize,VARIANT* pSlopDilSize,VARIANT* pAreaSize,VARIANT* pScaleSize)
{
	//得到环形区域
	int id = (int)rgnId->fltVal;
	int Selection = (int)pSelection->fltVal;
	float Radius  = (float)pRadius->fltVal;           // 220
	float TopDilSize = (float)pTopDilSize->fltVal;    // 3.5
	float SlopDilSize = (float)pSlopDilSize->fltVal;  // 8.5
	float TopForkSize = (float)pTopForkSize->fltVal;  // 5.5 
	int AreaSize = (int)pAreaSize->fltVal; 

	float ScaleSize =(float)pScaleSize->fltVal;       // 1.5

	float fCenterX = 0.0;
	float fCenterY = 0.0;
	fCenterX = m_vPos[0].m_x;
	fCenterY = m_vPos[0].m_y;

	HTuple dRowCir,dColCir;
	dRowCir = fCenterY;
	dColCir = fCenterX;

	Hobject newRgn;
	m_vRgn[id] = newRgn; 

	HTuple dArea1,dArea2,dArea3;  
	region_features(m_rgnTop,"area",&dArea1 );
	region_features(m_rgnForkOri,"area",&dArea2 );
	region_features(m_rgnTopSlop,"area",&dArea3 );

	if((fCenterX<2.0)||(fCenterY<2.0) || (dArea1<1) || (dArea2 < 1))
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
	if ((Selection == 3)&&(dArea3<1) )
	{
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}

#ifdef NDEBUG
	try
	{
#endif
		//
		if(m_bDebugImg)
		{
			m_dictSpecialData[id].clear();
		}

		//first
		Hobject  rgnTop,rgnForkOri,rgnCircleOuter,rgnTopSlop;
		rgnTop = m_rgnTop;
		rgnForkOri = m_rgnForkOri;
		rgnTopSlop = m_rgnTopSlop;

		gen_circle(&rgnCircleOuter,dRowCir,dColCir,Radius);

		Hobject rgnDetect;
		if ( Selection == 1)
		{
			// 顶部区域
			Hobject  rgnForkOriDil,rgnDetectOri,rgnDetectOpn,rgnDetectCon;
			dilation_circle(rgnForkOri,&rgnForkOriDil,TopForkSize );
			difference(rgnTop,rgnForkOriDil,&rgnDetectOri);
			intersection(rgnDetectOri,rgnCircleOuter,& rgnDetectOri);
			opening_circle(rgnDetectOri,&rgnDetectOpn,2.5 );
			connection( rgnDetectOpn,&rgnDetectCon);
			select_shape_std(rgnDetectCon,&rgnDetect,"max_area",70 );

			erosion_circle(rgnDetect,&rgnDetect,ScaleSize );

		}
		else if ( Selection == 2)
		{
			// 顶部斜坡区域
			Hobject rgnForkCls,rgnTopFork,rgnTopForkCls,rgnTopSlopOri ;
			closing_circle(rgnForkOri, &rgnForkCls, 60.5);

			union2(rgnForkOri, m_rgnTop, &rgnTopFork);
			closing_circle(rgnTopFork, &rgnTopForkCls, 10.5);
			difference(rgnCircleOuter, rgnForkCls, &rgnTopSlopOri);

			Hobject rgnTopDil,rgnTopSlopOriDif ,rgnForkOriDil,rgnTopSlop;
			dilation_circle(m_rgnTop, &rgnTopDil,TopDilSize);
			difference(rgnTopSlopOri, rgnTopDil, &rgnTopSlopOriDif);

			dilation_circle(rgnForkOri, &rgnForkOriDil,TopForkSize);
			difference(rgnTopSlopOriDif, rgnForkOriDil, &rgnTopSlop);
			opening_circle(rgnTopSlop, &rgnTopSlop, 3.5);
			connection(rgnTopSlop,&rgnTopSlop );
			select_shape(rgnTopSlop,&rgnTopSlop,"area","and",AreaSize,9999999 );

			m_rgnTopSlop = rgnTopSlop;

			erosion_circle(rgnTopSlop,&rgnDetect,ScaleSize );
		
		}
		else if (Selection = 3)
		{
			// 叉口区域
			Hobject rgnForkOriTrans,rgnTopSlopDil,rgnUniToDif,rgnTopFork,rgnTopDil ;
			union1(rgnForkOri,&rgnForkOri);
			shape_trans(rgnForkOri, &rgnForkOriTrans, "outer_circle");

			dilation_circle(m_rgnTop, &rgnTopDil,TopDilSize);
			dilation_circle(rgnTopSlop, &rgnTopSlopDil,SlopDilSize);
			union2(rgnTopSlopDil, rgnTopDil, &rgnUniToDif);
			closing_circle(rgnUniToDif, &rgnUniToDif, 60.5);

			difference(rgnForkOriTrans, rgnUniToDif, &rgnTopFork);
			intersection(rgnTopFork,rgnCircleOuter,& rgnTopFork);

			connection(rgnTopFork,&rgnTopFork );
			select_shape(rgnTopFork,&rgnTopFork,"area","and",AreaSize,9999999 );
			opening_circle(rgnTopFork,&rgnTopFork,2.5 );

			erosion_circle(rgnTopFork,&rgnDetect,ScaleSize );

		}
		else
		{
			// 顶部区域
			rgnDetect = rgnTop;

		}
		
		HTuple dArea,dRow,dCol;
		area_center(rgnDetect,&dArea,&dRow,&dCol );
		if ( dArea > 0)
		{
			m_vRgn[id] = rgnDetect ;
		}
		else
		{
			m_vRgn[id] = newRgn ;
			return S_FALSE;
		}

#ifdef NDEBUG
	}
	catch (HException &except) 
	{
		m_algoSpy.QueueUpLogMsg(except, m_crtImg);
		m_vRgn[id] = newRgn ;
		return S_FALSE;
	}
#endif
	return S_OK;
}
STDMETHODIMP CPlugAlgo::D20N_TopRegionLocationAlgoHelp(BSTR* pHelpStr)
{
	CComBSTR strHelp("6223$\
					 167;B$\
					 6221;LP;1;3;1;1$\
					 194;FP;1.0;2000.0;0.5;220$\
					 6222;FP;1.5;100;0.5;5.5$\
					 6094;FP;1.5;100;0.5;8.5$\
					 6130;FP;1.5;100;0.5;8.5$\
					 6162;LP;1;2000;1;500$\
					 5511;FP;1.5;20;0.5;1.5"); 

	HRESULT hr = strHelp.CopyTo(pHelpStr);
	if(FAILED(hr))
		return S_FALSE;
	return S_OK;
}




















